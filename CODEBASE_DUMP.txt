# Codebase Dump
Generated: 2025-10-26T21:57:46.969Z
Root Directory: /Users/salscrudato/Projects/plzfixthx
Total Files: 56

================================================================================


────────────────────────────────────────────────────────────────────────────────
FILE: .github/pull_request_template.md
SIZE: 1.53 KB
────────────────────────────────────────────────────────────────────────────────

## Description

<!-- Provide a brief description of the changes in this PR -->

## Type of Change

- [ ] Bug fix (non-breaking change which fixes an issue)
- [ ] New feature (non-breaking change which adds functionality)
- [ ] Breaking change (fix or feature that would cause existing functionality to change)
- [ ] Documentation update
- [ ] Performance improvement
- [ ] Security improvement

## Related Issues

<!-- Link to related issues using #issue_number -->
Closes #

## Changes Made

<!-- List the specific changes made in this PR -->

- 
- 
- 

## Testing

<!-- Describe the testing you've done -->

- [ ] Unit tests added/updated
- [ ] Manual testing completed
- [ ] E2E tests added/updated

## Checklist

- [ ] My code follows the style guidelines of this project
- [ ] I have performed a self-review of my own code
- [ ] I have commented my code, particularly in hard-to-understand areas
- [ ] I have made corresponding changes to the documentation
- [ ] My changes generate no new warnings
- [ ] I have added tests that prove my fix is effective or that my feature works
- [ ] New and existing unit tests passed locally with my changes
- [ ] Any dependent changes have been merged and published

## Screenshots (if applicable)

<!-- Add screenshots or GIFs demonstrating the changes -->

## Performance Impact

<!-- Describe any performance implications of these changes -->

## Security Considerations

<!-- Describe any security implications of these changes -->

## Deployment Notes

<!-- Any special deployment instructions or considerations -->




────────────────────────────────────────────────────────────────────────────────
FILE: .github/workflows/ci.yml
SIZE: 3.57 KB
────────────────────────────────────────────────────────────────────────────────

name: CI

on:
  push:
    branches: [main, master, develop]
  pull_request:
    branches: [main, master, develop]

jobs:
  lint-and-typecheck:
    name: Lint & TypeCheck
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Install functions dependencies
        run: npm ci --prefix functions

      - name: Install web dependencies
        run: npm ci --prefix web

      - name: Lint functions
        run: npm run lint --prefix functions

      - name: Lint web
        run: npm run lint --prefix web

      - name: TypeCheck functions
        run: npm run build --prefix functions

      - name: TypeCheck web
        run: npm run build --prefix web

  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Install functions dependencies
        run: npm ci --prefix functions

      - name: Install web dependencies
        run: npm ci --prefix web

      - name: Run functions tests
        run: npm test --prefix functions

      - name: Run web tests
        run: npm test --prefix web

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./functions/coverage/coverage-final.json,./web/coverage/coverage-final.json
          flags: unittests
          fail_ci_if_error: false

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [lint-and-typecheck, unit-tests]
    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Install functions dependencies
        run: npm ci --prefix functions

      - name: Install web dependencies
        run: npm ci --prefix web

      - name: Build functions
        run: npm run build:functions

      - name: Build web
        run: npm run build:web

      - name: Check bundle size
        run: |
          WEB_SIZE=$(du -sh web/dist | cut -f1)
          echo "Web bundle size: $WEB_SIZE"
          FUNCTIONS_SIZE=$(du -sh functions/lib | cut -f1)
          echo "Functions bundle size: $FUNCTIONS_SIZE"

  security-audit:
    name: Security Audit
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Install functions dependencies
        run: npm ci --prefix functions

      - name: Install web dependencies
        run: npm ci --prefix web

      - name: Audit functions
        run: npm audit --prefix functions --audit-level=moderate || true

      - name: Audit web
        run: npm audit --prefix web --audit-level=moderate || true




────────────────────────────────────────────────────────────────────────────────
FILE: .github/workflows/deploy.yml
SIZE: 2.11 KB
────────────────────────────────────────────────────────────────────────────────

name: Deploy

on:
  push:
    branches: [main, master]
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Install functions dependencies
        run: npm ci --prefix functions

      - name: Install web dependencies
        run: npm ci --prefix web

      - name: Lint
        run: |
          npm run lint --prefix functions
          npm run lint --prefix web

      - name: TypeCheck
        run: |
          npm run build --prefix functions
          npm run build --prefix web

      - name: Run tests
        run: |
          npm test --prefix functions
          npm test --prefix web

      - name: Build functions
        run: npm run build:functions

      - name: Build web
        run: npm run build:web

      - name: Setup Firebase CLI
        run: npm install -g firebase-tools

      - name: Deploy to Firebase
        env:
          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}
          FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
        run: |
          firebase deploy --token "$FIREBASE_TOKEN" --project "$FIREBASE_PROJECT_ID"

      - name: Create deployment notification
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.ref,
              environment: 'production',
              description: 'Production deployment',
              auto_merge: false,
              required_contexts: []
            });

      - name: Archive build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: production-build-${{ github.sha }}
          path: |
            web/dist
            functions/lib
          retention-days: 30




────────────────────────────────────────────────────────────────────────────────
FILE: .github/workflows/preview-deploy.yml
SIZE: 1.96 KB
────────────────────────────────────────────────────────────────────────────────

name: Preview Deploy

on:
  pull_request:
    branches: [main, master, develop]
    types: [opened, synchronize, reopened]

jobs:
  preview-deploy:
    name: Deploy Preview
    runs-on: ubuntu-latest
    if: github.event.pull_request.head.repo.full_name == github.repository
    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Install functions dependencies
        run: npm ci --prefix functions

      - name: Install web dependencies
        run: npm ci --prefix web

      - name: Build functions
        run: npm run build:functions

      - name: Build web
        run: npm run build:web

      - name: Generate preview URL
        id: preview
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          PREVIEW_URL="https://preview-pr-${PR_NUMBER}.plzfixthx.dev"
          echo "preview_url=${PREVIEW_URL}" >> $GITHUB_OUTPUT
          echo "Preview URL: ${PREVIEW_URL}"

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const previewUrl = '${{ steps.preview.outputs.preview_url }}';
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `🚀 Preview deployment ready!\n\n[View Preview](${previewUrl})\n\n**Build Info:**\n- Commit: ${context.sha.substring(0, 7)}\n- Branch: ${context.ref}`
            });

      - name: Archive build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: preview-build-${{ github.event.pull_request.number }}
          path: |
            web/dist
            functions/lib
          retention-days: 7




────────────────────────────────────────────────────────────────────────────────
FILE: dump-codebase.js
SIZE: 3.80 KB
────────────────────────────────────────────────────────────────────────────────

#!/usr/bin/env node

/**
 * Codebase Dump Script
 * Collects all source code files and their contents into a single text file
 * Excludes: node_modules, dist, build, .git, and other non-essential directories
 */

const fs = require('fs');
const path = require('path');

const EXCLUDE_DIRS = new Set([
  'node_modules',
  'dist',
  'build',
  '.git',
  '.next',
  'coverage',
  '.venv',
  'venv',
  '__pycache__',
  '.pytest_cache',
  '.turbo',
  'lib',
  '.firebase',
  'public',
  '.vscode',
  '.idea',
]);

const EXCLUDE_FILES = new Set([
  '.DS_Store',
  'package-lock.json',
  'yarn.lock',
  'pnpm-lock.yaml',
  '.env',
  '.env.local',
  '.env.*.local',
]);

const SOURCE_EXTENSIONS = new Set([
  '.ts',
  '.tsx',
  '.js',
  '.jsx',
  '.json',
  '.css',
  '.scss',
  '.html',
  '.md',
  '.yml',
  '.yaml',
  '.xml',
  '.sql',
  '.py',
  '.go',
  '.rs',
  '.java',
  '.cpp',
  '.c',
  '.h',
  '.sh',
  '.bash',
  '.zsh',
]);

function shouldIncludeFile(filePath) {
  const fileName = path.basename(filePath);
  
  // Exclude specific files
  if (EXCLUDE_FILES.has(fileName)) return false;
  
  // Exclude hidden files except .env.example
  if (fileName.startsWith('.') && fileName !== '.env.example') return false;
  
  // Include only source files
  const ext = path.extname(filePath);
  return SOURCE_EXTENSIONS.has(ext);
}

function shouldIncludeDir(dirPath) {
  const dirName = path.basename(dirPath);
  return !EXCLUDE_DIRS.has(dirName);
}

function walkDir(dir, fileList = []) {
  try {
    const files = fs.readdirSync(dir);
    
    for (const file of files) {
      const filePath = path.join(dir, file);
      const stat = fs.statSync(filePath);
      
      if (stat.isDirectory()) {
        if (shouldIncludeDir(filePath)) {
          walkDir(filePath, fileList);
        }
      } else if (stat.isFile()) {
        if (shouldIncludeFile(filePath)) {
          fileList.push(filePath);
        }
      }
    }
  } catch (e) {
    console.warn(`Warning: Could not read directory ${dir}: ${e.message}`);
  }
  
  return fileList;
}

function main() {
  const rootDir = process.cwd();
  console.log(`📁 Scanning codebase in: ${rootDir}`);
  
  const files = walkDir(rootDir);
  console.log(`📄 Found ${files.length} source files`);
  
  let output = `# Codebase Dump\n`;
  output += `Generated: ${new Date().toISOString()}\n`;
  output += `Root Directory: ${rootDir}\n`;
  output += `Total Files: ${files.length}\n`;
  output += `\n${'='.repeat(80)}\n\n`;
  
  let fileCount = 0;
  let totalSize = 0;
  
  for (const filePath of files) {
    try {
      const relPath = path.relative(rootDir, filePath);
      const content = fs.readFileSync(filePath, 'utf-8');
      const size = Buffer.byteLength(content, 'utf-8');
      
      totalSize += size;
      fileCount++;
      
      output += `\n${'─'.repeat(80)}\n`;
      output += `FILE: ${relPath}\n`;
      output += `SIZE: ${(size / 1024).toFixed(2)} KB\n`;
      output += `${'─'.repeat(80)}\n\n`;
      output += content;
      output += `\n\n`;
      
      if (fileCount % 10 === 0) {
        console.log(`  ✓ Processed ${fileCount} files...`);
      }
    } catch (e) {
      console.warn(`Warning: Could not read file ${filePath}: ${e.message}`);
    }
  }
  
  output += `\n${'='.repeat(80)}\n`;
  output += `SUMMARY\n`;
  output += `${'='.repeat(80)}\n`;
  output += `Total Files: ${fileCount}\n`;
  output += `Total Size: ${(totalSize / 1024 / 1024).toFixed(2)} MB\n`;
  output += `Generated: ${new Date().toISOString()}\n`;
  
  const outputPath = path.join(rootDir, 'CODEBASE_DUMP.txt');
  fs.writeFileSync(outputPath, output, 'utf-8');
  
  console.log(`\n✅ Codebase dump complete!`);
  console.log(`📝 Output file: ${outputPath}`);
  console.log(`📊 Statistics:`);
  console.log(`   - Files: ${fileCount}`);
  console.log(`   - Total Size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);
}

main();




────────────────────────────────────────────────────────────────────────────────
FILE: firebase.json
SIZE: 1.64 KB
────────────────────────────────────────────────────────────────────────────────

{
  "firestore": {
    "database": "(default)",
    "location": "nam5",
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "functions": {
    "source": "functions",
    "predeploy": ["npm --prefix functions run build"]
  },
  "hosting": {
    "public": "web/dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "headers": [
      {
        "source": "**/*.@(html|js|css)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "no-cache, no-store, must-revalidate"
          }
        ]
      },
      {
        "source": "/index.html",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "no-cache, no-store, must-revalidate"
          }
        ]
      },
      {
        "source": "/sw.js",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "no-cache, no-store, must-revalidate"
          },
          {
            "key": "Service-Worker-Allowed",
            "value": "/"
          }
        ]
      },
      {
        "source": "**/*.@(jpg|jpeg|gif|png|svg|webp|ico)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=31536000, immutable"
          }
        ]
      }
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  },
  "emulators": {
    "functions": {
      "port": 5001
    },
    "firestore": {
      "port": 8080
    },
    "hosting": {
      "port": 5002
    },
    "ui": {
      "enabled": true,
      "port": 4000
    },
    "singleProjectMode": true
  }
}



────────────────────────────────────────────────────────────────────────────────
FILE: firestore.indexes.json
SIZE: 1.21 KB
────────────────────────────────────────────────────────────────────────────────

{
  // Example (Standard Edition):
  //
  // "indexes": [
  //   {
  //     "collectionGroup": "widgets",
  //     "queryScope": "COLLECTION",
  //     "fields": [
  //       { "fieldPath": "foo", "arrayConfig": "CONTAINS" },
  //       { "fieldPath": "bar", "mode": "DESCENDING" }
  //     ]
  //   },
  //
  //  "fieldOverrides": [
  //    {
  //      "collectionGroup": "widgets",
  //      "fieldPath": "baz",
  //      "indexes": [
  //        { "order": "ASCENDING", "queryScope": "COLLECTION" }
  //      ]
  //    },
  //   ]
  // ]
  //
  // Example (Enterprise Edition):
  //
  // "indexes": [
  //   {
  //     "collectionGroup": "reviews",
  //     "queryScope": "COLLECTION_GROUP",
  //     "apiScope": "MONGODB_COMPATIBLE_API",
  //     "density": "DENSE",
  //     "multikey": false,
  //     "fields": [
  //       { "fieldPath": "baz", "mode": "ASCENDING" }
  //     ]
  //   },
  //   {
  //     "collectionGroup": "items",
  //     "queryScope": "COLLECTION_GROUP",
  //     "apiScope": "MONGODB_COMPATIBLE_API",
  //     "density": "SPARSE_ANY",
  //     "multikey": true,
  //     "fields": [
  //       { "fieldPath": "baz", "mode": "ASCENDING" }
  //     ]
  //   },
  // ]
  "indexes": [],
  "fieldOverrides": []
}


────────────────────────────────────────────────────────────────────────────────
FILE: functions/package.json
SIZE: 1.19 KB
────────────────────────────────────────────────────────────────────────────────

{
  "name": "functions",
  "type": "module",
  "scripts": {
    "build": "npm --prefix ../shared/slideSpec run build && tsc && node scripts/fix-esm-imports.js && node scripts/copy-shared-package.js",
    "serve": "npm run build && firebase emulators:start --only functions",
    "deploy": "npm run build && firebase deploy --only functions",
    "lint": "eslint --ext .ts src",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  },
  "engines": {
    "node": "20"
  },
  "main": "lib/index.js",
  "dependencies": {
    "@plzfixthx/slide-spec": "file:../shared/slideSpec",
    "@types/sharp": "^0.31.1",
    "cors": "^2.8.5",
    "firebase-admin": "^12.6.0",
    "firebase-functions": "^6.0.1",
    "pptxgenjs": "^4.0.1",
    "sharp": "^0.34.4",
    "undici": "^7.16.0",
    "zod": "^4.1.12",
    "zod-to-json-schema": "^3.24.6"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^5.12.0",
    "@typescript-eslint/parser": "^5.12.0",
    "eslint": "^8.9.0",
    "eslint-config-google": "^0.14.0",
    "eslint-plugin-import": "^2.25.4",
    "firebase-functions-test": "^3.1.0",
    "typescript": "^5.7.3",
    "vitest": "^1.0.0"
  },
  "private": true
}



────────────────────────────────────────────────────────────────────────────────
FILE: functions/scripts/copy-shared-package.js
SIZE: 1.19 KB
────────────────────────────────────────────────────────────────────────────────

#!/usr/bin/env node
/**
 * Copy the built shared/slideSpec package into functions/lib for runtime access.
 * This ensures the @plzfixthx/slide-spec package is available at runtime.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const sourceDir = path.join(__dirname, '../../shared/slideSpec/dist');
const targetDir = path.join(__dirname, '../lib/slide-spec');

function copyRecursive(src, dest) {
  if (!fs.existsSync(src)) {
    console.error(`❌ Source directory not found: ${src}`);
    process.exit(1);
  }
  
  if (!fs.existsSync(dest)) {
    fs.mkdirSync(dest, { recursive: true });
  }
  
  const entries = fs.readdirSync(src, { withFileTypes: true });
  
  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);
    
    if (entry.isDirectory()) {
      copyRecursive(srcPath, destPath);
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }
}

console.log('Copying shared package...');
copyRecursive(sourceDir, targetDir);
console.log('✅ Shared package copied to lib/slide-spec');




────────────────────────────────────────────────────────────────────────────────
FILE: functions/scripts/fix-esm-imports.js
SIZE: 3.13 KB
────────────────────────────────────────────────────────────────────────────────

#!/usr/bin/env node
/**
 * Fix ESM import paths for the slide-spec package.
 * Ensures deep imports use the correct .js extension for ESM compatibility.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const libDir = path.join(__dirname, '../lib');
let filesFixed = 0;

function fixImports(dir) {
  const files = fs.readdirSync(dir);

  for (const file of files) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      fixImports(filePath);
    } else if (file.endsWith('.js')) {
      let content = fs.readFileSync(filePath, 'utf8');
      const originalContent = content;

      // Fix all relative imports to add .js extension
      // Match: from "./something" or from '../something'
      const lines = content.split('\n');
      const fixedLines = lines.map(line => {
        // Match import statements with relative paths
        if (line.includes('from "') || line.includes("from '")) {
          return line.replace(
            /from\s+["'](\.\.?\/[^"']+)["']/g,
            (match, importPath) => {
              // Skip if already has .js or .json extension
              if (importPath.endsWith('.js') || importPath.endsWith('.json')) {
                return match;
              }
              // Check if this is a directory import (no extension and directory exists)
              const resolvedPath = path.join(path.dirname(filePath), importPath);
              try {
                if (fs.existsSync(resolvedPath) && fs.statSync(resolvedPath).isDirectory()) {
                  return `from "${importPath}/index.js"`;
                }
              } catch (e) {
                // Ignore errors, fall through to .js extension
              }
              return `from "${importPath}.js"`;
            }
          );
        }
        // Match dynamic imports
        if (line.includes('import(')) {
          return line.replace(
            /import\s*\(\s*["'](\.\.?\/[^"']+)["']\s*\)/g,
            (match, importPath) => {
              if (importPath.endsWith('.js') || importPath.endsWith('.json')) {
                return match;
              }
              // Check if this is a directory import
              const resolvedPath = path.join(path.dirname(filePath), importPath);
              try {
                if (fs.existsSync(resolvedPath) && fs.statSync(resolvedPath).isDirectory()) {
                  return `import("${importPath}/index.js")`;
                }
              } catch (e) {
                // Ignore errors, fall through to .js extension
              }
              return `import("${importPath}.js")`;
            }
          );
        }
        return line;
      });

      content = fixedLines.join('\n');

      if (content !== originalContent) {
        console.log(`  Fixed: ${path.relative(libDir, filePath)}`);
        fs.writeFileSync(filePath, content, 'utf8');
        filesFixed++;
      }
    }
  }
}

console.log('Fixing ESM imports...');
fixImports(libDir);
console.log(`✅ ESM imports fixed (${filesFixed} files modified)`);




────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/__tests__/aiHelpers.test.ts
SIZE: 7.19 KB
────────────────────────────────────────────────────────────────────────────────

import { describe, it, expect } from "vitest";
import { enhanceSlideSpec, sanitizePrompt, moderateContent } from "../aiHelpers";

describe("aiHelpers", () => {
  describe("sanitizePrompt", () => {
    it("should accept valid prompts", () => {
      const result = sanitizePrompt("Create a professional slide about Q1 results");
      expect(result).toBe("Create a professional slide about Q1 results");
    });

    it("should trim whitespace", () => {
      const result = sanitizePrompt("  Hello World  ");
      expect(result).toBe("Hello World");
    });

    it("should reject empty prompts", () => {
      expect(() => sanitizePrompt("")).toThrow();
      expect(() => sanitizePrompt("   ")).toThrow();
    });

    it("should truncate long prompts", () => {
      const longPrompt = "a".repeat(5000);
      const result = sanitizePrompt(longPrompt, 2000);
      expect(result.length).toBeLessThanOrEqual(2000);
    });
  });

  describe("moderateContent", () => {
    it("should allow safe content", () => {
      const result = moderateContent("Create a professional presentation");
      expect(result.safe).toBe(true);
    });

    it("should flag inappropriate content", () => {
      const result = moderateContent("hack the system");
      expect(result.safe).toBe(false);
      expect(result.reason).toBeDefined();
    });

    it("should be case-insensitive", () => {
      const result = moderateContent("HACK THE SYSTEM");
      expect(result.safe).toBe(false);
    });
  });

  describe("enhanceSlideSpec", () => {
    it("should add default meta if missing", () => {
      const spec = { content: { title: { text: "Test" } } };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.meta).toBeDefined();
      expect(enhanced.meta.version).toBe("1.0");
      expect(enhanced.meta.aspectRatio).toBe("16:9");
    });

    it("should add default title if missing", () => {
      const spec = { meta: {}, content: {} };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.title).toBeDefined();
      expect(enhanced.content.title.text).toBe("Untitled Slide");
    });

    it("should add IDs to content elements", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Title" },
          subtitle: { text: "Subtitle" },
          bullets: [{ items: ["Item 1"] }]
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.title.id).toBe("title");
      expect(enhanced.content.subtitle.id).toBe("subtitle");
      expect(enhanced.content.bullets[0].id).toBeDefined();
    });

    it("should limit bullets to 6 items", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Title" },
          bullets: [
            { items: Array(10).fill("Item") }
          ]
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.bullets[0].items.length).toBeLessThanOrEqual(6);
    });

    it("should validate and fix dataViz series", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Title" },
          dataViz: {
            labels: ["Q1", "Q2", "Q3"],
            series: [
              { name: "Series 1", values: [10, 20] } // Only 2 values
            ]
          }
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.dataViz.series[0].values.length).toBe(3);
    });

    it("should ensure valid color palette", () => {
      const spec = {
        meta: {},
        content: { title: { text: "Title" } },
        styleTokens: {
          palette: {
            primary: "invalid-color",
            accent: "also-invalid"
          }
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      // Should have valid hex colors (context-aware generation may vary)
      expect(enhanced.styleTokens.palette.primary).toMatch(/^#[0-9A-F]{6}$/i);
      expect(enhanced.styleTokens.palette.accent).toMatch(/^#[0-9A-F]{6}$/i);
    });

    it("should ensure neutral palette exists", () => {
      const spec = {
        meta: {},
        content: { title: { text: "Title" } },
        styleTokens: { palette: {} }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.styleTokens.palette.neutral).toBeDefined();
      expect(enhanced.styleTokens.palette.neutral.length).toBeGreaterThanOrEqual(5);
    });

    it("should validate contrast compliance", () => {
      const spec = {
        meta: {},
        content: { title: { text: "Title" } },
        styleTokens: {
          palette: {
            primary: "#6366F1",
            accent: "#EC4899",
            neutral: ["#CCCCCC", "#DDDDDD"] // Low contrast
          }
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      // Should have adjusted colors for compliance
      expect(enhanced.styleTokens.palette.neutral).toBeDefined();
    });

    it("should handle multiple bullet groups", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Title" },
          bullets: [
            { items: ["Item 1", "Item 2"] },
            { items: ["Item 3", "Item 4", "Item 5"] }
          ]
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.bullets.length).toBe(2);
      expect(enhanced.content.bullets[0].id).toBeDefined();
      expect(enhanced.content.bullets[1].id).toBeDefined();
    });

    it("should fix layout issues", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Title" },
          subtitle: { text: "Subtitle" }
        },
        layout: {
          regions: [
            { name: "header", rowSpan: 1 },
            { name: "body", rowStart: 2 }
          ],
          anchors: [
            { refId: "title", region: "header" },
            { refId: "subtitle", region: "header" }
          ]
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.layout).toBeDefined();
    });

    it("should split concatenated timeline bullet points", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Timeline" },
          bullets: [{
            items: [
              { text: "1776 Declared independence1783 Won war1789 Became president", level: 1 }
            ]
          }]
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.bullets[0].items.length).toBeGreaterThan(1);
      expect(enhanced.content.bullets[0].items[0].text).toContain("1776");
      expect(enhanced.content.bullets[0].items[1].text).toContain("1783");
      expect(enhanced.content.bullets[0].items[2].text).toContain("1789");
    });

    it("should preserve properly formatted bullet points", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Title" },
          bullets: [{
            items: [
              { text: "First point", level: 1 },
              { text: "Second point", level: 1 },
              { text: "Third point", level: 1 }
            ]
          }]
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.bullets[0].items.length).toBe(3);
      expect(enhanced.content.bullets[0].items[0].text).toBe("First point");
    });
  });
});




────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/__tests__/security.test.ts
SIZE: 4.37 KB
────────────────────────────────────────────────────────────────────────────────

import { describe, it, expect, beforeEach } from "vitest";
import { sanitizePrompt, detectAbuse, getClientId } from "../security";
import { Request } from "express";

describe("security", () => {
  describe("sanitizePrompt", () => {
    it("should accept valid prompts", () => {
      const result = sanitizePrompt("Create a professional slide about Q1 results");
      expect(result).toBe("Create a professional slide about Q1 results");
    });

    it("should trim whitespace", () => {
      const result = sanitizePrompt("  Hello World  ");
      expect(result).toBe("Hello World");
    });

    it("should reject empty prompts", () => {
      expect(() => sanitizePrompt("")).toThrow("Prompt must be a non-empty string");
      expect(() => sanitizePrompt("   ")).toThrow();
    });

    it("should reject prompts shorter than 3 characters", () => {
      expect(() => sanitizePrompt("ab")).toThrow("Prompt must be at least 3 characters");
    });

    it("should truncate long prompts to 2000 characters", () => {
      const longPrompt = "a".repeat(5000);
      const result = sanitizePrompt(longPrompt);
      expect(result.length).toBe(2000);
    });

    it("should reject non-string input", () => {
      expect(() => sanitizePrompt(null as unknown as string)).toThrow();
      expect(() => sanitizePrompt(undefined as unknown as string)).toThrow();
    });
  });

  describe("detectAbuse", () => {
    it("should allow safe content", () => {
      const result = detectAbuse("Create a professional presentation about sales");
      expect(result.isAbusive).toBe(false);
    });

    it("should detect excessive character repetition", () => {
      const result = detectAbuse("aaaaaaaaaaaaaaaaaaaaaa");
      expect(result.isAbusive).toBe(true);
      expect(result.reason).toContain("repetition");
    });

    it("should detect too many URLs", () => {
      const prompt = "Check these: https://a.com https://b.com https://c.com https://d.com https://e.com https://f.com";
      const result = detectAbuse(prompt);
      expect(result.isAbusive).toBe(true);
      expect(result.reason).toContain("URLs");
    });

    it("should detect spam patterns", () => {
      const spamPrompts = [
        "Buy viagra now",
        "Click here for free money",
        "Limited offer casino",
      ];

      for (const prompt of spamPrompts) {
        const result = detectAbuse(prompt);
        expect(result.isAbusive).toBe(true);
        expect(result.reason).toContain("Spam");
      }
    });

    it("should be case-insensitive for spam detection", () => {
      const result = detectAbuse("BUY VIAGRA NOW");
      expect(result.isAbusive).toBe(true);
    });

    it("should allow legitimate URLs", () => {
      const result = detectAbuse("Check https://example.com for more info");
      expect(result.isAbusive).toBe(false);
    });
  });

  describe("getClientId", () => {
    it("should generate consistent IDs for same client", () => {
      const mockReq = {
        ip: "192.168.1.1",
        socket: { remoteAddress: "192.168.1.1" },
        get: (header: string) => {
          if (header === "user-agent") return "Mozilla/5.0";
          return undefined;
        },
      } as unknown as Request;

      const id1 = getClientId(mockReq);
      const id2 = getClientId(mockReq);

      expect(id1).toBe(id2);
      expect(id1.length).toBe(16); // SHA256 slice to 16 chars
    });

    it("should generate different IDs for different clients", () => {
      const mockReq1 = {
        ip: "192.168.1.1",
        socket: { remoteAddress: "192.168.1.1" },
        get: (header: string) => {
          if (header === "user-agent") return "Mozilla/5.0";
          return undefined;
        },
      } as unknown as Request;

      const mockReq2 = {
        ip: "192.168.1.2",
        socket: { remoteAddress: "192.168.1.2" },
        get: (header: string) => {
          if (header === "user-agent") return "Mozilla/5.0";
          return undefined;
        },
      } as unknown as Request;

      const id1 = getClientId(mockReq1);
      const id2 = getClientId(mockReq2);

      expect(id1).not.toBe(id2);
    });

    it("should handle missing IP gracefully", () => {
      const mockReq = {
        ip: undefined,
        socket: { remoteAddress: undefined },
        get: () => "Mozilla/5.0",
      } as unknown as Request;

      const id = getClientId(mockReq);
      expect(id).toBeDefined();
      expect(id.length).toBe(16);
    });
  });
});




────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/__tests__/slideGenerationIntegration.test.ts
SIZE: 9.32 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * Slide Generation Integration Tests
 * Validates end-to-end slide generation with professional design
 */

import { describe, it, expect } from "vitest";
import type { SlideSpecV1 } from "@plzfixthx/slide-spec";

describe("Slide Generation Integration", () => {
  const createProfessionalSlideSpec = (): SlideSpecV1 => ({
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Premium Business",
      aspectRatio: "16:9"
    },
    content: {
      title: { id: "title", text: "Accelerate Growth" },
      subtitle: { id: "subtitle", text: "Transform your business with innovative solutions" },
      bullets: [{
        id: "b1",
        items: [
          { text: "Increase revenue by 40% in 12 months", level: 1 },
          { text: "Reduce operational costs by 25%", level: 1 },
          { text: "Improve customer satisfaction to 95%", level: 1 },
          { text: "Scale operations without adding headcount", level: 1 }
        ]
      }],
      callouts: [{
        id: "c1",
        title: "Key Insight",
        text: "Companies that implement these strategies see 3x faster growth",
        variant: "success"
      }]
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 32, r: 32, b: 32, l: 32 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 5, colSpan: 12 }
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "subtitle", region: "header", order: 1 },
        { refId: "b1", region: "body", order: 0 },
        { refId: "c1", region: "body", order: 1 }
      ]
    },
    styleTokens: {
      palette: {
        primary: "#1E40AF",
        accent: "#06B6D4",
        neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#F8FAFC"]
      },
      typography: {
        fonts: { sans: "Aptos, Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 28, step_3: 44 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.5 }
      },
      spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: { sm: "0 2px 4px rgba(0,0,0,.08)", md: "0 4px 12px rgba(0,0,0,.12)", lg: "0 12px 32px rgba(0,0,0,.16)" },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 }
    }
  });

  describe("Professional Slide Specification", () => {
    it("should generate valid slide spec", () => {
      const spec = createProfessionalSlideSpec();

      expect(spec.meta.version).toBe("1.0");
      expect(spec.meta.aspectRatio).toBe("16:9");
      expect(spec.content.title).toBeDefined();
      expect(spec.styleTokens.palette).toBeDefined();
    });

    it("should have compelling content", () => {
      const spec = createProfessionalSlideSpec();

      // Title should be action-oriented
      expect(spec.content.title.text).toMatch(/Accelerate|Transform|Unlock|Maximize/);

      // Subtitle should provide context
      expect(spec.content.subtitle?.text).toBeTruthy();
      expect(spec.content.subtitle!.text.length).toBeGreaterThan(10);

      // Bullets should be specific and measurable
      const bullets = spec.content.bullets?.[0]?.items || [];
      expect(bullets.length).toBeGreaterThan(0);
      expect(bullets.length).toBeLessThanOrEqual(5);

      // Each bullet should have specific metrics
      const hasMetrics = bullets.some(b => /\d+%|\d+x|[0-9]+/.test(b.text));
      expect(hasMetrics).toBe(true);
    });

    it("should have professional color palette", () => {
      const spec = createProfessionalSlideSpec();
      const palette = spec.styleTokens.palette;

      // Primary and accent colors should be different
      expect(palette.primary).not.toBe(palette.accent);

      // All colors should be valid hex
      const hexRegex = /^#[0-9A-F]{6}$/i;
      expect(hexRegex.test(palette.primary)).toBe(true);
      expect(hexRegex.test(palette.accent)).toBe(true);

      // Neutral palette should have 7 colors
      expect(palette.neutral).toHaveLength(7);
      palette.neutral.forEach(color => {
        expect(hexRegex.test(color)).toBe(true);
      });
    });

    it("should have proper typography hierarchy", () => {
      const spec = createProfessionalSlideSpec();
      const sizes = spec.styleTokens.typography.sizes;

      // Verify size hierarchy
      expect(sizes.step_3).toBeGreaterThan(sizes.step_2);
      expect(sizes.step_2).toBeGreaterThan(sizes.step_1);
      expect(sizes.step_1).toBeGreaterThan(sizes.step_0);

      // Title should be large
      expect(sizes.step_3).toBeGreaterThanOrEqual(40);

      // Body text should be readable
      expect(sizes.step_0).toBeGreaterThanOrEqual(14);
    });

    it("should have WCAG AAA accessibility", () => {
      const spec = createProfessionalSlideSpec();
      const contrast = spec.styleTokens.contrast;

      // WCAG AAA requires 7:1 for text
      expect(contrast.minTextContrast).toBeGreaterThanOrEqual(7);

      // UI elements require 4.5:1
      expect(contrast.minUiContrast).toBeGreaterThanOrEqual(4.5);
    });

    it("should have proper spacing system", () => {
      const spec = createProfessionalSlideSpec();
      const spacing = spec.styleTokens.spacing;

      expect(spacing.base).toBe(4);
      expect(spacing.steps).toContain(0);
      expect(spacing.steps).toContain(4);
      expect(spacing.steps).toContain(8);
      expect(spacing.steps).toContain(32);

      // Verify spacing is in ascending order
      for (let i = 1; i < spacing.steps.length; i++) {
        expect(spacing.steps[i]).toBeGreaterThanOrEqual(spacing.steps[i - 1]);
      }
    });
  });

  describe("Layout System", () => {
    it("should have valid grid system", () => {
      const spec = createProfessionalSlideSpec();
      const grid = spec.layout.grid;

      expect(grid.rows).toBeGreaterThanOrEqual(3);
      expect(grid.cols).toBeGreaterThanOrEqual(3);
      expect(grid.gutter).toBeGreaterThanOrEqual(0);

      // Margins should be professional (minimum 32px = 0.44in)
      expect(grid.margin.t).toBeGreaterThanOrEqual(32);
      expect(grid.margin.r).toBeGreaterThanOrEqual(32);
      expect(grid.margin.b).toBeGreaterThanOrEqual(32);
      expect(grid.margin.l).toBeGreaterThanOrEqual(32);
    });

    it("should have valid regions", () => {
      const spec = createProfessionalSlideSpec();
      const regions = spec.layout.regions;

      expect(regions.length).toBeGreaterThan(0);

      regions.forEach(region => {
        expect(["header", "body", "footer", "aside"]).toContain(region.name);
        expect(region.rowStart).toBeGreaterThan(0);
        expect(region.colStart).toBeGreaterThan(0);
        expect(region.rowSpan).toBeGreaterThan(0);
        expect(region.colSpan).toBeGreaterThan(0);
      });
    });

    it("should have valid anchors", () => {
      const spec = createProfessionalSlideSpec();
      const anchors = spec.layout.anchors;

      expect(anchors.length).toBeGreaterThan(0);

      anchors.forEach(anchor => {
        expect(["header", "body", "footer", "aside"]).toContain(anchor.region);
        expect(anchor.order).toBeGreaterThanOrEqual(0);
      });
    });
  });

  describe("Design Quality Metrics", () => {
    it("should meet professional design standards", () => {
      const spec = createProfessionalSlideSpec();

      // Check for professional theme
      expect(spec.meta.theme).toBeTruthy();

      // Check for proper aspect ratio
      expect(["16:9", "4:3"]).toContain(spec.meta.aspectRatio);

      // Check for complete style tokens
      expect(spec.styleTokens.palette).toBeDefined();
      expect(spec.styleTokens.typography).toBeDefined();
      expect(spec.styleTokens.spacing).toBeDefined();
      expect(spec.styleTokens.contrast).toBeDefined();
    });

    it("should have balanced content distribution", () => {
      const spec = createProfessionalSlideSpec();

      // Should have title
      expect(spec.content.title).toBeDefined();

      // Should have subtitle for context
      expect(spec.content.subtitle).toBeDefined();

      // Should have bullets for key points
      expect(spec.content.bullets).toBeDefined();
      expect(spec.content.bullets!.length).toBeGreaterThan(0);

      // Should have callouts for emphasis
      expect(spec.content.callouts).toBeDefined();
      expect(spec.content.callouts!.length).toBeGreaterThan(0);
    });

    it("should follow content best practices", () => {
      const spec = createProfessionalSlideSpec();

      // Title should be concise (4-8 words ideal)
      const titleWords = spec.content.title.text.split(" ").length;
      expect(titleWords).toBeGreaterThanOrEqual(2);
      expect(titleWords).toBeLessThanOrEqual(10);

      // Bullets should be concise
      const bullets = spec.content.bullets?.[0]?.items || [];
      bullets.forEach(bullet => {
        const words = bullet.text.split(" ").length;
        expect(words).toBeGreaterThanOrEqual(3);
        expect(words).toBeLessThanOrEqual(20);
      });

      // Total content should be under 100 words
      const allText = [
        spec.content.title.text,
        spec.content.subtitle?.text || "",
        ...bullets.map(b => b.text),
        ...((spec.content.callouts || []).map(c => c.text))
      ].join(" ");

      const totalWords = allText.split(" ").length;
      expect(totalWords).toBeLessThan(150);
    });
  });
});




────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/aiHelpers.ts
SIZE: 31.41 KB
────────────────────────────────────────────────────────────────────────────────

import * as logger from "firebase-functions/logger";
import { fetch as undiciFetch } from "undici";
import { z } from "zod";
import { ENHANCED_SYSTEM_PROMPT } from "./prompts";
import { generatePalette } from "./colorPaletteGenerator";
import { randomUUID } from "crypto";

/* eslint-disable @typescript-eslint/no-explicit-any */
import { zodToJsonSchema } from "zod-to-json-schema";

/* -------------------------------------------------------------------------- */
/*                            Structured Error Types                          */
/* -------------------------------------------------------------------------- */

export class AIError extends Error {
  constructor(
    message: string,
    public code: string,
    public requestId: string,
    public details?: Record<string, any>
  ) {
    super(message);
    this.name = "AIError";
  }
}

export class ValidationError extends AIError {
  constructor(message: string, requestId: string, details?: Record<string, any>) {
    super(message, "VALIDATION_ERROR", requestId, details);
    this.name = "ValidationError";
  }
}

/* -------------------------------------------------------------------------- */
/*                               Color & Contrast                             */
/* -------------------------------------------------------------------------- */

/**
 * WCAG 2.2 relative luminance + contrast.
 * Parses #RRGGBB (alpha ignored). Returns ratio and compliance.
 */
function ensureContrast(textHex: string, bgHex: string, minRatio: number) {
  const toRGB = (hex: string): [number, number, number] => {
    const clean = hex.replace("#", "").slice(0, 6);
    const r = parseInt(clean.slice(0, 2), 16) / 255;
    const g = parseInt(clean.slice(2, 4), 16) / 255;
    const b = parseInt(clean.slice(4, 6), 16) / 255;
    return [r, g, b];
  };

  const lin = (c: number) => (c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4));

  const luminance = (hex: string) => {
    const [r, g, b] = toRGB(hex);
    const R = lin(r);
    const G = lin(g);
    const B = lin(b);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  };

  const L1 = luminance(textHex);
  const L2 = luminance(bgHex);
  const ratio = (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);

  return { compliant: ratio >= minRatio, ratio };
}

/* -------------------------------------------------------------------------- */
/*                               Light validators                              */
/* -------------------------------------------------------------------------- */

function validateBulletCount(bullets: any[], maxPerGroup: number) {
  const valid = bullets.every((b) => !b.items || b.items.length <= maxPerGroup);
  return { valid, maxPerGroup };
}

/* -------------------------------------------------------------------------- */
/*                         Retry with exponential backoff                      */
/* -------------------------------------------------------------------------- */

export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries = 3,
  baseDelay = 800
): Promise<T> {
  let lastError: Error | undefined;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;

      if (attempt < maxRetries - 1) {
        const jitter = Math.floor(Math.random() * 150);
        const delay = Math.min(8000, baseDelay * Math.pow(2, attempt)) + jitter;
        logger.warn(`Attempt ${attempt + 1} failed; retrying in ${delay}ms`, {
          error: (lastError as any)?.message || String(lastError),
        });
        await new Promise((r) => setTimeout(r, delay));
      }
    }
  }

  throw lastError || new Error("Max retries exceeded");
}

/* -------------------------------------------------------------------------- */
/*                      OpenAI‑compatible structured outputs                   */
/* -------------------------------------------------------------------------- */

/**
 * Convert Zod schema to JSON Schema for structured output.
 * Always available now that zod-to-json-schema is a dependency.
 */
function toJsonSchema(schema: z.ZodTypeAny): any {
  const json = zodToJsonSchema(schema, { name: "SlideSpec" });
  // Add draft for providers that expect a $schema field
  if (json && typeof json === "object" && !("$schema" in json)) {
    (json as any).$schema = "http://json-schema.org/draft-07/schema#";
  }
  return json;
}

/**
 * Clean unknown keys from parsed spec to prevent silent drift.
 */
function cleanSpec(parsed: any, schema: z.ZodTypeAny): any {
  // Use Zod's parse to strip unknown keys
  const validation = schema.safeParse(parsed);
  if (validation.success) {
    return validation.data;
  }
  // If validation fails, return original (will be caught by caller)
  return parsed;
}

type AIResp = {
  choices?: Array<{ message?: { content?: string } }>;
  usage?: {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
  };
};

/**
 * Call OpenAI-compatible /chat/completions with robust structured-output handling.
 * 1) Use response_format: json_schema with Zod-generated schema
 * 2) Fallback to response_format: json_object on 400/unsupported
 * 3) Validate with provided Zod schema and clean unknown keys
 * 4) Track request/response IDs and token usage
 * 5) Enforce content-length guard (max 200KB)
 */
export async function callAIWithRetry(
  prompt: string,
  apiKey: string,
  baseUrl: string,
  model: string,
  schema: z.ZodTypeAny,
  requestId: string = randomUUID()
): Promise<unknown> {
  return retryWithBackoff(async () => {
    const start = Date.now();
    let usedMode: "json_schema" | "json_object" = "json_schema";
    let responseId: string | undefined;

    // Generate JSON Schema from Zod
    const jsonSchema = toJsonSchema(schema);

    const attempt = async (mode: "json_schema" | "json_object") => {
      usedMode = mode;

      const body: any = {
        model,
        temperature: 0.2,
        top_p: 0.95,
        seed: requestId.split("-")[0], // Use first segment of UUID for reproducibility
        max_tokens: 4096, // Reasonable limit for slide content
        response_format:
          mode === "json_schema"
            ? { type: "json_schema", json_schema: { name: "SlideSpec", schema: jsonSchema, strict: true } }
            : { type: "json_object" },
        stop: ["```"], // Prevent fence leaks
        messages: [
          {
            role: "system",
            content:
              ENHANCED_SYSTEM_PROMPT +
              (mode === "json_object"
                ? `\n\nThe following JSON Schema is authoritative. Return ONLY a JSON object that validates against it:\n${JSON.stringify(
                    jsonSchema
                  )}`
                : ""),
          },
          { role: "user", content: `User prompt:\n<<<${prompt}>>>` },
        ],
      };

      const response = await undiciFetch(`${baseUrl}/chat/completions`, {
        method: "POST",
        headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
        body: JSON.stringify(body),
      });

      const duration = Date.now() - start;

      if (!response.ok) {
        const errorText = await response.text();
        logger.error("AI API request failed", {
          requestId,
          status: response.status,
          error: errorText?.slice(0, 500),
          model,
          promptLength: prompt.length,
          durationMs: duration,
          responseFormat: usedMode,
        });

        // If provider rejects json_schema, fall back once to json_object in-place
        const maybeUnsupported =
          usedMode === "json_schema" &&
          response.status === 400 &&
          /schema|response_format|unsupported/i.test(errorText || "");
        if (maybeUnsupported) {
          return attempt("json_object");
        }

        throw new AIError(
          `AI API error ${response.status}: ${errorText?.slice(0, 200)}`,
          "API_ERROR",
          requestId,
          { status: response.status, model, durationMs: duration }
        );
      }

      let data: AIResp;
      try {
        data = (await response.json()) as AIResp;
        responseId = (data as any)?.id || randomUUID();
      } catch (e) {
        logger.error("Failed to parse AI response as JSON", {
          requestId,
          error: String(e),
          durationMs: duration,
        });
        throw new AIError(
          `Failed to parse AI response: ${e}`,
          "PARSE_ERROR",
          requestId,
          { durationMs: duration }
        );
      }

      const content = data?.choices?.[0]?.message?.content;
      if (!content) {
        logger.error("No content in AI response", {
          requestId,
          responseId,
          data: JSON.stringify(data)?.slice(0, 500),
          durationMs: duration,
          responseFormat: usedMode,
        });
        throw new AIError(
          "No content in AI response",
          "NO_CONTENT",
          requestId,
          { responseId, durationMs: duration }
        );
      }

      // Content-length guard: reject responses > 200KB
      const contentLength = Buffer.byteLength(content, "utf8");
      if (contentLength > 200 * 1024) {
        logger.error("AI response too large", {
          requestId,
          responseId,
          contentLength,
          maxAllowed: 200 * 1024,
          durationMs: duration,
        });
        throw new AIError(
          `AI response too large: ${contentLength} bytes (max 200KB)`,
          "RESPONSE_TOO_LARGE",
          requestId,
          { responseId, durationMs: duration, contentLength }
        );
      }

      let parsed: unknown;
      try {
        parsed = JSON.parse(content);
      } catch (e) {
        logger.error("Failed to parse AI response content as JSON", {
          requestId,
          responseId,
          content: content.slice(0, 500),
          error: String(e),
          durationMs: duration,
          responseFormat: usedMode,
        });
        throw new AIError(
          `Failed to parse AI response as JSON: ${e}`,
          "JSON_PARSE_ERROR",
          requestId,
          { responseId, durationMs: duration }
        );
      }

      const validation = schema.safeParse(parsed);
      if (!validation.success) {
        const detail = validation.error.issues
          .map((issue: any) => `${issue.path.join(".")}: ${issue.message}`)
          .join(", ");
        logger.error("Schema validation failed", {
          requestId,
          responseId,
          topIssues: validation.error.issues.slice(0, 5),
          errorDetails: detail.slice(0, 500),
          aiResponse: JSON.stringify(parsed, null, 2).slice(0, 1000),
          durationMs: duration,
          responseFormat: usedMode,
        });
        throw new ValidationError(
          `Schema validation failed: ${detail.slice(0, 200)}`,
          requestId,
          { responseId, durationMs: duration, issues: validation.error.issues.slice(0, 5) }
        );
      }

      // Clean unknown keys from validated data
      const cleanedData = cleanSpec(validation.data, schema);

      // Log token usage if available
      if (data.usage) {
        logger.info("AI token usage", {
          requestId,
          responseId,
          promptTokens: data.usage.prompt_tokens,
          completionTokens: data.usage.completion_tokens,
          totalTokens: data.usage.total_tokens,
          durationMs: duration,
        });
      }

      logger.info("✅ AI response validated", {
        requestId,
        responseId,
        hasTitle: !!(cleanedData as any)?.content?.title,
        hasBullets: !!(cleanedData as any)?.content?.bullets,
        hasChart: !!(cleanedData as any)?.content?.dataViz,
        durationMs: duration,
        responseFormat: usedMode,
        promptTokens: data.usage?.prompt_tokens,
        completionTokens: data.usage?.completion_tokens,
        contentLength,
      });

      return cleanedData;
    };

    // First try json_schema; fallback to json_object on 400/unsupported
    return attempt("json_schema");
  }, 3, 1000);
}

/* -------------------------------------------------------------------------- */
/*                              Prompt sanitation                              */
/* -------------------------------------------------------------------------- */

export function sanitizePrompt(prompt: string, maxLength = 800): string {
  if (!prompt || typeof prompt !== "string") throw new Error("Prompt must be a non-empty string");
  let p = prompt.trim();

  // Remove code fences and obvious wrappers
  p = p.replace(/^```[a-z0-9]*\n?/i, "").replace(/```$/i, "").trim();

  if (p.length < 3) throw new Error("Prompt must be at least 3 characters long");

  if (p.length > maxLength) {
    logger.info("Prompt truncated to max length", { original: p.length, max: maxLength });
    return p.slice(0, maxLength);
  }

  return p;
}

/* -------------------------------------------------------------------------- */
/*                                  Moderation                                 */
/* -------------------------------------------------------------------------- */

export function moderateContent(
  prompt: string
): { safe: boolean; reason?: string; categories?: string[] } {
  const lower = prompt.toLowerCase();

  // Business context keywords allow benign usage (esp. crypto/finance/security topics)
  const benignBusiness = /\b(strategy|market|roadmap|policy|regulation|regulatory|compliance|report|analysis|architecture|infrastructure|risk|controls|governance|kpi|presentation|slide|deck|test|testing|assessment)\b/i;

  // High-risk categories
  const categories: Array<{ name: string; rx: RegExp; severity: number }> = [
    // Explicit wrongdoing / instructions
    { name: "violent wrongdoing", rx: /\b(build|make|how\s*to|instructions?|guide)\b.*\b(bomb|weapon|explosive|molotov|knife|gun)\b/i, severity: 5 },
    { name: "cyber wrongdoing", rx: /\b(hack|zero[-\s]?day|exploit|ransomware|botnet|ddos|bypass|backdoor)\b.*\b(guide|how|tutorial|steps?|system)\b/i, severity: 5 },
    // Extremist violence or threats
    { name: "incitement", rx: /\b(kill|murder|assault|shoot|stab)\b.*\b(how|plan|guide|tips?)\b/i, severity: 5 },
    // Sexual content explicit
    { name: "sexual content", rx: /\b(porn|xxx|nsfw|explicit|nude|sexual)\b/i, severity: 4 },
    // Drugs illegal
    { name: "illegal drugs", rx: /\b(cocaine|heroin|meth|mdma|lsd|fentanyl)\b/i, severity: 4 },
    // Fraud / scams
    { name: "scams", rx: /\b(get\s*rich\s*quick|double\s*your\s*(money|btc)|seed\s*phrase|giveaway|airdrop\s*claim)\b/i, severity: 4 },
    // Hate / harassment
    { name: "hate speech", rx: /\b(racist|white\s*power|kkk|nazi|kill\s*\w+|gas\s*\w+)\b/i, severity: 5 },
  ];

  // **Allow** benign business contexts for crypto/security words
  if (/\b(crypto|bitcoin|nft|blockchain|penetration\s*test|security)\b/i.test(prompt) && benignBusiness.test(prompt)) {
    // do nothing — allowed
  } else {
    // Add softer generic matches (these alone shouldn't block)
    categories.push(
      { name: "generic violence", rx: /\b(violence|weapon|bomb|terror)\b/i, severity: 1 },
      { name: "generic cyber", rx: /\b(hack|exploit|vulnerability|xss|sql\s*injection|malware)\b/i, severity: 2 },
      { name: "generic spam", rx: /\b(spam|scam|phishing|fraud)\b/i, severity: 2 }
    );
  }

  let score = 0;
  const hits: string[] = [];

  for (const c of categories) {
    if (c.rx.test(lower)) {
      score += c.severity;
      hits.push(c.name);
    }
  }

  // Length abuse
  if (prompt.length > 4000) {
    return { safe: false, reason: "Prompt too long (max 4000 chars)", categories: ["abuse"] };
  }

  // Repetition abuse
  const words = prompt.split(/\s+/).filter(Boolean);
  if (words.length > 0) {
    const freq = new Map<string, number>();
    for (const w of words) freq.set(w, (freq.get(w) || 0) + 1);
    const maxFreq = Math.max(...freq.values());
    if (maxFreq > words.length * 0.5) {
      return { safe: false, reason: "Excessive repetition", categories: ["abuse"] };
    }
  }

  if (score >= 2) {
    logger.warn("Content moderation blocked prompt", { categories: hits });
    return { safe: false, reason: "Content may be unsafe or disallowed", categories: hits };
  }

  return { safe: true };
}

/* -------------------------------------------------------------------------- */
/*                         Fallback Spec Generation                            */
/* -------------------------------------------------------------------------- */

/**
 * Generate a minimal but valid fallback spec when AI generation fails.
 * Ensures the slide is still renderable with sensible defaults.
 */
export function generateFallbackSpec(prompt: string, requestId: string): any {
  logger.warn("Generating fallback spec", { requestId, prompt: prompt.slice(0, 100) });

  return {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Professional",
      aspectRatio: "16:9",
    },
    content: {
      title: {
        id: "title",
        text: prompt.slice(0, 60).trim() || "Untitled Slide",
      },
      subtitle: {
        id: "subtitle",
        text: "Generated with fallback due to AI service unavailability",
      },
    },
    layout: {
      grid: {
        rows: 6,
        cols: 6,
        gutter: 16,
        margin: { t: 32, r: 32, b: 32, l: 32 },
      },
      regions: [
        {
          name: "header",
          rowStart: 1,
          colStart: 1,
          rowSpan: 2,
          colSpan: 6,
        },
        {
          name: "body",
          rowStart: 3,
          colStart: 1,
          rowSpan: 4,
          colSpan: 6,
        },
      ],
      anchors: [
        {
          refId: "title",
          region: "header",
          order: 0,
        },
        {
          refId: "subtitle",
          region: "header",
          order: 1,
        },
      ],
    },
    styleTokens: {
      palette: {
        primary: "#1E40AF",
        accent: "#F59E0B",
        neutral: [
          "#0F172A",
          "#1E293B",
          "#334155",
          "#475569",
          "#64748B",
          "#94A3B8",
          "#CBD5E1",
          "#E2E8F0",
          "#F8FAFC",
        ],
      },
      typography: {
        fonts: { sans: "Inter, Arial, sans-serif" },
        sizes: {
          "step_-2": 12,
          "step_-1": 14,
          step_0: 16,
          step_1: 20,
          step_2: 24,
          step_3: 44,
        },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.5 },
      },
      spacing: { base: 16, steps: [4, 8, 12, 16, 24, 32, 48, 64] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: {
        sm: "0 1px 2px rgba(0,0,0,0.05)",
        md: "0 4px 6px rgba(0,0,0,0.1)",
        lg: "0 10px 15px rgba(0,0,0,0.1)",
      },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 },
    },
  };
}

/* -------------------------------------------------------------------------- */
/*                           Enhancement (idempotent)                          */
/* -------------------------------------------------------------------------- */

/**
 * Action verbs for professional slide titles
 */
const ACTION_VERBS = [
  "Transform", "Accelerate", "Unlock", "Optimize", "Drive", "Elevate", "Maximize",
  "Enhance", "Streamline", "Innovate", "Deliver", "Enable", "Build", "Scale",
  "Achieve", "Create", "Develop", "Implement", "Launch", "Execute"
];

/**
 * Ensure title starts with an action verb for professional impact
 */
function ensureActionVerb(title: string): string {
  const trimmed = title.trim();
  // Check if already starts with an action verb
  const startsWithAction = ACTION_VERBS.some(verb =>
    trimmed.toLowerCase().startsWith(verb.toLowerCase())
  );

  if (startsWithAction) return trimmed;

  // If title is a noun phrase, prepend appropriate verb
  // Simple heuristic: if starts with "The/A/An", it's likely a noun phrase
  if (/^(the|a|an)\s+/i.test(trimmed)) {
    return `Unlock ${trimmed}`;
  }

  // Otherwise, return as-is (might already be imperative)
  return trimmed;
}

/**
 * Normalize bullet grammar to parallel voice
 */
function normalizeBulletGrammar(text: string): string {
  let normalized = text.trim();

  // Remove trailing punctuation (periods, commas)
  normalized = normalized.replace(/[.,;:]$/, "");

  // Ensure starts with capital letter
  if (normalized.length > 0) {
    normalized = normalized.charAt(0).toUpperCase() + normalized.slice(1);
  }

  return normalized;
}

/**
 * Split concatenated bullets like "1776 A 1783 B 1789 C" -> separate items.
 * Extended to handle year ranges, quarters, and date patterns.
 */
function splitConcatenatedBullets(bulletGroup: any): any {
  if (!bulletGroup.items || bulletGroup.items.length === 0) return bulletGroup;

  const newItems: any[] = [];
  for (const item of bulletGroup.items) {
    const text = String(item.text || "");

    // Pattern 1: Year events (1776 Event A 1783 Event B)
    const yearEventPattern = /(\d{4}\s+[^0-9]+?)(?=\d{4}\s+|$)/g;
    const yearMatches = text.match(yearEventPattern);

    // Pattern 2: Year ranges (1999–2001 Event A 2002–2004 Event B)
    const yearRangePattern = /(\d{4}[–-]\d{4}\s+[^0-9]+?)(?=\d{4}[–-]\d{4}\s+|$)/g;
    const rangeMatches = text.match(yearRangePattern);

    // Pattern 3: Quarters (Q1 Event A Q2 Event B)
    const quarterPattern = /(Q[1-4]\s+\d{4}\s+[^Q]+?)(?=Q[1-4]\s+\d{4}\s+|$)/gi;
    const quarterMatches = text.match(quarterPattern);

    // Pattern 4: Month-year dates (Jan 2024 Event A Feb 2024 Event B)
    const monthYearPattern = /((?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}\s+[^A-Z]+?)(?=(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}\s+|$)/gi;
    const monthMatches = text.match(monthYearPattern);

    if ((yearMatches && yearMatches.length > 1) ||
        (rangeMatches && rangeMatches.length > 1) ||
        (quarterMatches && quarterMatches.length > 1) ||
        (monthMatches && monthMatches.length > 1)) {
      const matches = yearMatches || rangeMatches || quarterMatches || monthMatches || [];
      logger.info("Splitting concatenated timeline bullets", {
        original: text.slice(0, 100),
        count: matches.length,
        pattern: yearMatches ? "year" : rangeMatches ? "range" : quarterMatches ? "quarter" : "month"
      });
      for (const m of matches) {
        newItems.push({ text: m.trim(), level: item.level || 1 });
      }
    } else {
      newItems.push(item);
    }
  }
  return { ...bulletGroup, items: newItems };
}

/**
 * Post-process and enhance AI-generated slide spec.
 * - Ensures required fields
 * - Trims bullets to policy (<=3 groups, <=5 items each, <=80 chars)
 * - Normalizes chart series to labels length
 * - Validates palette, enforces 9 neutrals & contrast AA/AAA
 * - Heuristically fixes header layout when title+subtitle present
 */
export function enhanceSlideSpec(spec: any): any {
  const warnings: string[] = [];
  logger.info("🔍 Enhancing slide spec for world-class quality");

  // --- Required scaffolding --------------------------------------------------
  spec.meta = spec.meta || { version: "1.0", locale: "en-US", theme: "Professional", aspectRatio: "16:9" };
  spec.content = spec.content || {};
  if (!spec.content.title?.text) spec.content.title = { id: "title", text: "Untitled Slide" };

  // --- Title & subtitle hygiene ---------------------------------------------
  if (spec.content.title?.text) {
    let t = String(spec.content.title.text).trim().replace(/\s+/g, " ");

    // Enforce action-verb start for professional impact
    const original = t;
    t = ensureActionVerb(t);
    if (t !== original) {
      warnings.push("Title enhanced with action verb");
    }

    if (t.length > 60) {
      warnings.push("Title truncated to 60 chars");
      t = t.slice(0, 57).trim() + "...";
    }
    spec.content.title.text = t;
    spec.content.title.id = spec.content.title.id || "title";
  }

  if (spec.content.subtitle?.text) {
    let st = String(spec.content.subtitle.text).trim().replace(/\s+/g, " ");
    if (st.length > 100) {
      warnings.push("Subtitle truncated to 100 chars");
      st = st.slice(0, 97).trim() + "...";
    }
    spec.content.subtitle.text = st;
    spec.content.subtitle.id = spec.content.subtitle.id || "subtitle";
  }

  // --- Bullets normalization -------------------------------------------------
  if (Array.isArray(spec.content.bullets)) {
    // Cap groups to 3
    if (spec.content.bullets.length > 3) {
      warnings.push("Bullet groups capped at 3");
      spec.content.bullets = spec.content.bullets.slice(0, 3);
    }

    // Ensure IDs and split concatenations
    spec.content.bullets = spec.content.bullets.map((b: any, i: number) => ({
      id: b.id || `bullets_${i}`,
      items: b.items || [],
    }));
    spec.content.bullets = spec.content.bullets.map(splitConcatenatedBullets);

    // Per-item hygiene
    const bulletValidation = validateBulletCount(spec.content.bullets, 5);
    if (!bulletValidation.valid) warnings.push("Bullet items per group limited to 5");

    for (const group of spec.content.bullets) {
      if (!Array.isArray(group.items)) group.items = [];
      if (group.items.length > 5) group.items = group.items.slice(0, 5);

      for (let i = 0; i < group.items.length; i++) {
        let item = group.items[i];
        if (!item) continue;

        // Convert string items to objects
        if (typeof item === "string") {
          item = { text: item, level: 1 };
          group.items[i] = item;
        }

        item.level = Math.min(3, Math.max(1, Number(item.level || 1)));
        if (typeof item.text === "string") {
          let tx = item.text.trim().replace(/\s+/g, " ");

          // Normalize grammar for parallel voice
          tx = normalizeBulletGrammar(tx);

          if (tx.length > 80) {
            warnings.push("Bullet text truncated to 80 chars");
            tx = tx.slice(0, 77).trim() + "...";
          }
          item.text = tx;
        }
      }
    }
  }

  // --- Callouts & IDs --------------------------------------------------------
  if (Array.isArray(spec.content.callouts)) {
    spec.content.callouts = spec.content.callouts.slice(0, 2);
    spec.content.callouts.forEach((c: any, i: number) => (c.id = c.id || `callout_${i}`));
  }

  // --- Charts: series length == labels length + format sanity ---------------
  if (spec.content?.dataViz?.labels && spec.content?.dataViz?.series) {
    const viz = spec.content.dataViz;
    viz.id = viz.id || "dataviz";
    const labelCount = Math.max(0, Math.min(10, viz.labels.length));
    viz.labels = viz.labels.slice(0, labelCount);

    // Chart label sanity: if labels look numeric but valueFormat is "percent", normalize
    if (viz.valueFormat === "percent") {
      const allNumeric = viz.labels.every((l: any) => !isNaN(Number(l)));
      if (allNumeric) {
        warnings.push("Chart labels appear numeric with percent format - treating as categories");
      }

      // Normalize series values to 0..100 range if they appear to be 0..1
      for (const s of viz.series) {
        if (Array.isArray(s.values)) {
          const maxVal = Math.max(...s.values.filter((v: any) => typeof v === "number"));
          if (maxVal > 0 && maxVal <= 1) {
            s.values = s.values.map((v: any) => typeof v === "number" ? v * 100 : v);
            warnings.push(`Series "${s.name}" normalized to 0-100 for percent format`);
          }
        }
      }
    }

    for (const s of viz.series) {
      const diff = labelCount - (Array.isArray(s.values) ? s.values.length : 0);
      if (diff > 0) {
        warnings.push("Series padded with zeros to match labels length");
        s.values = [...(s.values || []), ...Array(diff).fill(0)];
      } else if (diff < 0) {
        warnings.push("Series trimmed to labels length");
        s.values = (s.values || []).slice(0, labelCount);
      }
    }
  }

  // --- Palette & accessibility with context-aware generation ------------------
  const hex = /^#[0-9A-Fa-f]{6}$/;

  spec.styleTokens = spec.styleTokens || {};
  spec.styleTokens.palette = spec.styleTokens.palette || {};
  const p = spec.styleTokens.palette;

  // Generate context-aware palette if colors are missing
  if (!p.primary || !hex.test(p.primary) || !p.accent || !hex.test(p.accent)) {
    const prompt = spec.content?.title?.text || "";
    const generatedPalette = generatePalette(prompt);

    if (!p.primary || !hex.test(p.primary)) {
      p.primary = generatedPalette.primary;
      warnings.push("Primary color generated from context");
    }
    if (!p.accent || !hex.test(p.accent)) {
      p.accent = generatedPalette.accent;
      warnings.push("Accent color generated from context");
    }
  }

  // Guarantee exactly 9 neutrals, dark → light
  const defaultNeutrals = [
    "#0F172A",
    "#1E293B",
    "#334155",
    "#475569",
    "#64748B",
    "#94A3B8",
    "#CBD5E1",
    "#E2E8F0",
    "#F8FAFC",
  ];

  if (!Array.isArray(p.neutral)) {
    p.neutral = defaultNeutrals;
    warnings.push("Neutral palette defaulted");
  } else {
    const filtered = p.neutral.filter((c: any) => typeof c === "string" && hex.test(c)).slice(0, 9);
    p.neutral = filtered.length === 9 ? filtered : defaultNeutrals;
    if (filtered.length !== 9) warnings.push("Neutral palette corrected to 9 colors");
  }

  // Enforce contrast AAA for text (7:1); AA (4.5:1) for UI accents
  const textColor = p.neutral[0];
  const bgColor = p.neutral[8];
  const textContrast = ensureContrast(textColor, bgColor, 7);
  if (!textContrast.compliant) {
    p.neutral[0] = "#000000";
    p.neutral[8] = "#FFFFFF";
    warnings.push("Contrast adjusted to meet WCAG AAA (7:1)");
  }

  // Primary vs accent separation (4.5:1 for consistent legibility)
  const primAcc = ensureContrast(p.primary, p.accent, 4.5);
  if (!primAcc.compliant) {
    // Pick a compliant accent from curated ramp
    const accentRamp = ["#F59E0B", "#EC4899", "#8B5CF6", "#10B981", "#3B82F6", "#EF4444"];
    let foundCompliant = false;
    for (const candidate of accentRamp) {
      const test = ensureContrast(p.primary, candidate, 4.5);
      if (test.compliant) {
        p.accent = candidate;
        foundCompliant = true;
        warnings.push(`Accent color adjusted for 4.5:1 contrast (${test.ratio.toFixed(2)}:1)`);
        break;
      }
    }
    if (!foundCompliant) {
      p.accent = "#F59E0B"; // Fallback
      warnings.push("Accent color set to fallback (contrast may be suboptimal)");
    }
  }

  // --- Layout heuristics: expand header if title+subtitle --------------------
  spec = fixLayoutIssues(spec);

  if (warnings.length) {
    logger.info("Spec enhancement warnings", { warnings });
  }

  return spec;
}

/* -------------------------------------------------------------------------- */
/*                              Layout heuristics                              */
/* -------------------------------------------------------------------------- */

function fixLayoutIssues(spec: any): any {
  if (!spec.layout?.regions || !spec.layout?.anchors) return spec;

  const hasSubtitle = !!spec.content?.subtitle?.text;
  const hasTitle = !!spec.content?.title?.text;

  const header = spec.layout.regions.find((r: any) => r.name === "header");
  if (header && hasTitle && hasSubtitle && header.rowSpan === 1) {
    header.rowSpan = 2;

    const body = spec.layout.regions.find((r: any) => r.name === "body");
    if (body && body.rowStart === 2) {
      body.rowStart = 3;
      body.rowSpan = Math.max(1, body.rowSpan - 1);
    }
    const aside = spec.layout.regions.find((r: any) => r.name === "aside");
    if (aside && aside.rowStart === 2) {
      aside.rowStart = 3;
      aside.rowSpan = Math.max(1, aside.rowSpan - 1);
    }
  }

  // Drop anchors pointing to missing regions
  const regionNames = new Set(spec.layout.regions.map((r: any) => r.name));
  spec.layout.anchors = spec.layout.anchors.filter((a: any) => regionNames.has(a.region));

  return spec;
}


────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/colorPaletteGenerator.ts
SIZE: 5.06 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * Advanced Color Palette Generator
 * Generates context-aware, accessible color palettes based on prompt analysis
 */

/* -------------------------------------------------------------------------- */
/*                          Color Utilities                                   */
/* -------------------------------------------------------------------------- */

/** Convert hex to RGB */
function hexToRgb(hex: string): [number, number, number] {
  const clean = hex.replace("#", "").slice(0, 6);
  const r = parseInt(clean.slice(0, 2), 16);
  const g = parseInt(clean.slice(2, 4), 16);
  const b = parseInt(clean.slice(4, 6), 16);
  return [r, g, b];
}

/** Convert RGB to hex */
function rgbToHex(r: number, g: number, b: number): string {
  return `#${[r, g, b].map((x) => x.toString(16).padStart(2, "0")).join("").toUpperCase()}`;
}

/** Calculate relative luminance (WCAG) */
function getLuminance(hex: string): number {
  const [r, g, b] = hexToRgb(hex).map((x) => x / 255);
  const lin = (c: number) => (c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4));
  return 0.2126 * lin(r) + 0.7152 * lin(g) + 0.0722 * lin(b);
}

/** Calculate contrast ratio (WCAG) */
function getContrastRatio(hex1: string, hex2: string): number {
  const l1 = getLuminance(hex1);
  const l2 = getLuminance(hex2);
  return (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
}

/** Generate neutral ramp (9 colors from dark to light) */
function generateNeutralRamp(): string[] {
  const ramp: string[] = [];

  // Generate 9 steps from dark (#0F172A) to light (#F8FAFC)
  const darkBase = [15, 23, 42];
  const lightBase = [248, 250, 252];

  for (let i = 0; i < 9; i++) {
    const t = i / 8;
    const nr = Math.round(darkBase[0] + (lightBase[0] - darkBase[0]) * t);
    const ng = Math.round(darkBase[1] + (lightBase[1] - darkBase[1]) * t);
    const nb = Math.round(darkBase[2] + (lightBase[2] - darkBase[2]) * t);
    ramp.push(rgbToHex(nr, ng, nb));
  }

  return ramp;
}

/* -------------------------------------------------------------------------- */
/*                      Context-Aware Palette Selection                       */
/* -------------------------------------------------------------------------- */

interface PaletteOption {
  primary: string;
  accent: string;
  name: string;
}

const PALETTE_PRESETS: Record<string, PaletteOption> = {
  tech: { primary: "#1E40AF", accent: "#F59E0B", name: "Tech Blue" },
  finance: { primary: "#0F172A", accent: "#10B981", name: "Finance Navy" },
  creative: { primary: "#7C3AED", accent: "#EC4899", name: "Creative Purple" },
  energy: { primary: "#EA580C", accent: "#F97316", name: "Energy Orange" },
  healthcare: { primary: "#0891B2", accent: "#06B6D4", name: "Healthcare Cyan" },
  sustainability: { primary: "#15803D", accent: "#84CC16", name: "Sustainability Green" },
  corporate: { primary: "#1F2937", accent: "#6366F1", name: "Corporate Gray" },
  luxury: { primary: "#1E1B4B", accent: "#D4AF37", name: "Luxury Gold" },
};

/** Detect context from prompt and select appropriate palette */
export function selectPaletteByContext(prompt: string): PaletteOption {
  const lower = prompt.toLowerCase();
  
  // Tech keywords
  if (/\b(tech|software|ai|data|digital|cloud|api|platform)\b/i.test(lower)) {
    return PALETTE_PRESETS.tech;
  }
  
  // Finance keywords
  if (/\b(finance|revenue|profit|investment|market|trading|banking)\b/i.test(lower)) {
    return PALETTE_PRESETS.finance;
  }
  
  // Creative keywords
  if (/\b(creative|design|brand|marketing|campaign|content|media)\b/i.test(lower)) {
    return PALETTE_PRESETS.creative;
  }
  
  // Energy keywords
  if (/\b(energy|power|growth|momentum|accelerate|drive|transform)\b/i.test(lower)) {
    return PALETTE_PRESETS.energy;
  }
  
  // Healthcare keywords
  if (/\b(health|medical|patient|care|wellness|pharma|biotech)\b/i.test(lower)) {
    return PALETTE_PRESETS.healthcare;
  }
  
  // Sustainability keywords
  if (/\b(sustain|green|eco|environment|carbon|renewable|climate)\b/i.test(lower)) {
    return PALETTE_PRESETS.sustainability;
  }
  
  // Default to corporate
  return PALETTE_PRESETS.corporate;
}

/* -------------------------------------------------------------------------- */
/*                      Palette Generation & Validation                       */
/* -------------------------------------------------------------------------- */

export interface GeneratedPalette {
  primary: string;
  accent: string;
  neutral: string[];
  contrastRatio: number;
  accessible: boolean;
}

/**
 * Generate a complete, accessible color palette
 * - Selects primary/accent based on context
 * - Validates 7:1 contrast ratio
 * - Generates neutral ramp
 */
export function generatePalette(prompt: string): GeneratedPalette {
  const preset = selectPaletteByContext(prompt);
  const neutral = generateNeutralRamp();
  const contrastRatio = getContrastRatio(preset.primary, neutral[8]); // primary vs. white

  return {
    primary: preset.primary,
    accent: preset.accent,
    neutral,
    contrastRatio,
    accessible: contrastRatio >= 7,
  };
}

export default {
  generatePalette,
  selectPaletteByContext,
  getContrastRatio,
};




────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/colorUtils.ts
SIZE: 3.24 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * Color Utility Functions
 * - Contrast ratio calculation (WCAG)
 * - Color manipulation and validation
 * - Nearest compliant color finding
 */

/** Convert hex to RGB */
export function hexToRgb(hex: string): [number, number, number] {
  const clean = hex.replace("#", "").slice(0, 6);
  const r = parseInt(clean.slice(0, 2), 16);
  const g = parseInt(clean.slice(2, 4), 16);
  const b = parseInt(clean.slice(4, 6), 16);
  return [r, g, b];
}

/** Convert RGB to hex */
export function rgbToHex(r: number, g: number, b: number): string {
  return `#${[r, g, b].map((x) => x.toString(16).padStart(2, "0")).join("").toUpperCase()}`;
}

/** Calculate relative luminance (WCAG) */
export function getLuminance(hex: string): number {
  const [r, g, b] = hexToRgb(hex).map((x) => x / 255);
  const lin = (c: number) => (c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4));
  return 0.2126 * lin(r) + 0.7152 * lin(g) + 0.0722 * lin(b);
}

/** Calculate contrast ratio (WCAG) */
export function contrastRatio(hex1: string, hex2: string): number {
  const l1 = getLuminance(hex1);
  const l2 = getLuminance(hex2);
  return (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
}

/** Validate hex color format */
export function isValidHex(color: string): boolean {
  return /^#[0-9A-Fa-f]{6}$/.test(color);
}

/**
 * Find nearest compliant color from a palette
 * Ensures the color has sufficient contrast with white background
 */
export function nearestCompliantColor(
  targetColor: string,
  palette: string[],
  minContrast: number = 4.5
): string {
  if (!isValidHex(targetColor)) {
    return palette[0] || "#1E40AF";
  }

  // Check if target color is already compliant
  const targetContrast = contrastRatio(targetColor, "#FFFFFF");
  if (targetContrast >= minContrast) {
    return targetColor;
  }

  // Find best compliant color from palette
  let bestColor = palette[0] || "#1E40AF";
  let bestContrast = contrastRatio(bestColor, "#FFFFFF");

  for (const color of palette) {
    if (!isValidHex(color)) continue;
    const contrast = contrastRatio(color, "#FFFFFF");
    if (contrast >= minContrast && contrast > bestContrast) {
      bestColor = color;
      bestContrast = contrast;
    }
  }

  return bestColor;
}

/**
 * Lighten a color by a percentage (0-100)
 */
export function lighten(hex: string, percent: number): string {
  const [r, g, b] = hexToRgb(hex);
  const factor = 1 + percent / 100;
  return rgbToHex(
    Math.min(255, Math.round(r * factor)),
    Math.min(255, Math.round(g * factor)),
    Math.min(255, Math.round(b * factor))
  );
}

/**
 * Darken a color by a percentage (0-100)
 */
export function darken(hex: string, percent: number): string {
  const [r, g, b] = hexToRgb(hex);
  const factor = 1 - percent / 100;
  return rgbToHex(
    Math.max(0, Math.round(r * factor)),
    Math.max(0, Math.round(g * factor)),
    Math.max(0, Math.round(b * factor))
  );
}

/**
 * Mix two colors by percentage
 */
export function mix(hex1: string, hex2: string, percent: number): string {
  const [r1, g1, b1] = hexToRgb(hex1);
  const [r2, g2, b2] = hexToRgb(hex2);
  const factor = percent / 100;
  return rgbToHex(
    Math.round(r1 * (1 - factor) + r2 * factor),
    Math.round(g1 * (1 - factor) + g2 * factor),
    Math.round(b1 * (1 - factor) + b2 * factor)
  );
}




────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/errorHandler.ts
SIZE: 5.16 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * Error Handler Module
 * - Normalize errors to consistent format
 * - Map errors to appropriate HTTP status codes
 * - Provide user-friendly error messages
 * - Track error metrics
 */

import { Response } from "express";
import * as logger from "firebase-functions/logger";

export enum ErrorCode {
  // Client errors (4xx)
  BAD_REQUEST = "BAD_REQUEST",
  INVALID_PAYLOAD = "INVALID_PAYLOAD",
  PAYLOAD_TOO_LARGE = "PAYLOAD_TOO_LARGE",
  RATE_LIMITED = "RATE_LIMITED",
  MODERATION_REJECTED = "MODERATION_REJECTED",
  ABUSE_DETECTED = "ABUSE_DETECTED",

  // Server errors (5xx)
  AI_SERVICE_ERROR = "AI_SERVICE_ERROR",
  AI_TIMEOUT = "AI_TIMEOUT",
  AI_VALIDATION_ERROR = "AI_VALIDATION_ERROR",
  PPTX_GENERATION_ERROR = "PPTX_GENERATION_ERROR",
  IMAGE_FETCH_ERROR = "IMAGE_FETCH_ERROR",
  INTERNAL_ERROR = "INTERNAL_ERROR",
}

export interface ErrorResponse {
  error: {
    code: ErrorCode;
    message: string;
    details?: Record<string, unknown>;
  };
  requestId?: string;
  retryAfter?: number;
}

export class AppError extends Error {
  constructor(
    public code: ErrorCode,
    message: string,
    public statusCode: number = 500,
    public details?: Record<string, unknown>
  ) {
    super(message);
    this.name = "AppError";
  }
}

/**
 * Map error code to HTTP status code
 */
export function getStatusCode(code: ErrorCode): number {
  const statusMap: Record<ErrorCode, number> = {
    [ErrorCode.BAD_REQUEST]: 400,
    [ErrorCode.INVALID_PAYLOAD]: 400,
    [ErrorCode.PAYLOAD_TOO_LARGE]: 413,
    [ErrorCode.RATE_LIMITED]: 429,
    [ErrorCode.MODERATION_REJECTED]: 400,
    [ErrorCode.ABUSE_DETECTED]: 400,
    [ErrorCode.AI_SERVICE_ERROR]: 502,
    [ErrorCode.AI_TIMEOUT]: 504,
    [ErrorCode.AI_VALIDATION_ERROR]: 400,
    [ErrorCode.PPTX_GENERATION_ERROR]: 500,
    [ErrorCode.IMAGE_FETCH_ERROR]: 500,
    [ErrorCode.INTERNAL_ERROR]: 500,
  };
  return statusMap[code] || 500;
}

/**
 * Get user-friendly error message
 */
export function getUserMessage(code: ErrorCode): string {
  const messages: Record<ErrorCode, string> = {
    [ErrorCode.BAD_REQUEST]: "Invalid request",
    [ErrorCode.INVALID_PAYLOAD]: "Request payload is invalid",
    [ErrorCode.PAYLOAD_TOO_LARGE]: "Request is too large",
    [ErrorCode.RATE_LIMITED]: "Too many requests, please try again later",
    [ErrorCode.MODERATION_REJECTED]: "Content does not meet safety guidelines",
    [ErrorCode.ABUSE_DETECTED]: "Request flagged as abusive",
    [ErrorCode.AI_SERVICE_ERROR]: "AI service temporarily unavailable",
    [ErrorCode.AI_TIMEOUT]: "Request took too long, please try again",
    [ErrorCode.AI_VALIDATION_ERROR]: "Generated content failed validation",
    [ErrorCode.PPTX_GENERATION_ERROR]: "Failed to generate PowerPoint",
    [ErrorCode.IMAGE_FETCH_ERROR]: "Failed to fetch image",
    [ErrorCode.INTERNAL_ERROR]: "Internal server error",
  };
  return messages[code] || "An error occurred";
}

/**
 * Normalize any error to AppError
 */
export function normalizeError(error: unknown, _requestId?: string): AppError {
  if (error instanceof AppError) {
    return error;
  }

  if (error instanceof Error) {
    // Timeout errors
    if (error.message.includes("timeout") || error.message.includes("TIMEOUT")) {
      return new AppError(
        ErrorCode.AI_TIMEOUT,
        "Request timeout",
        504,
        { originalMessage: error.message }
      );
    }

    // Validation errors
    if (error.message.includes("validation") || error.message.includes("Validation")) {
      return new AppError(
        ErrorCode.AI_VALIDATION_ERROR,
        "Validation failed",
        400,
        { originalMessage: error.message }
      );
    }

    // Network/service errors
    if (
      error.message.includes("ECONNREFUSED") ||
      error.message.includes("ENOTFOUND") ||
      error.message.includes("service")
    ) {
      return new AppError(
        ErrorCode.AI_SERVICE_ERROR,
        "Service unavailable",
        502,
        { originalMessage: error.message }
      );
    }

    // Generic error
    return new AppError(
      ErrorCode.INTERNAL_ERROR,
      error.message || "Unknown error",
      500,
      { originalMessage: error.message }
    );
  }

  return new AppError(
    ErrorCode.INTERNAL_ERROR,
    "Unknown error occurred",
    500,
    { originalError: String(error) }
  );
}

/**
 * Send normalized error response
 */
export function sendErrorResponse(
  res: Response,
  error: unknown,
  requestId?: string,
  retryAfter?: number
): void {
  const appError = normalizeError(error, requestId);
  const statusCode = getStatusCode(appError.code);

  logger.error("Error response", {
    requestId,
    code: appError.code,
    message: appError.message,
    statusCode,
    details: appError.details,
  });

  const response: ErrorResponse = {
    error: {
      code: appError.code,
      message: getUserMessage(appError.code),
      details: appError.details,
    },
    requestId,
  };

  if (retryAfter) {
    response.retryAfter = retryAfter;
    res.set("Retry-After", String(retryAfter));
  }

  res.status(statusCode).json(response);
}

/**
 * Track error metrics
 */
export function trackError(code: ErrorCode, context?: Record<string, unknown>): void {
  logger.warn("Error tracked", {
    code,
    ...context,
  });
}




────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/imageOptimizer.ts
SIZE: 3.08 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * Image Optimization Module
 * - Downscale images to 96dpi (web standard)
 * - Convert to JPEG quality 82 unless PNG transparency needed
 * - Cache by URL hash to avoid re-processing
 */

import sharp from "sharp";
import crypto from "crypto";

/** In-memory cache for optimized images (URL hash → Buffer) */
const imageCache = new Map<string, Buffer>();

/** Maximum cache size (100 images × ~50KB avg = ~5MB) */
const MAX_CACHE_SIZE = 100;

/**
 * Get cache key from URL
 */
function getCacheKey(url: string): string {
  return crypto.createHash("sha256").update(url).digest("hex");
}

/**
 * Optimize image: downscale to 96dpi, convert to JPEG (quality 82) unless PNG transparency needed.
 * Returns optimized buffer or original if optimization fails.
 * Uses in-memory cache to avoid re-processing same URL.
 */
export async function optimizeImage(buffer: Buffer, url?: string): Promise<Buffer> {
  // Check cache first
  if (url) {
    const cacheKey = getCacheKey(url);
    const cached = imageCache.get(cacheKey);
    if (cached) {
      return cached;
    }
  }

  try {
    // Detect image format and metadata
    const metadata = await sharp(buffer).metadata();
    const { format, hasAlpha, width, height } = metadata;

    if (!width || !height) {
      return buffer; // Can't process, return original
    }

    // Calculate target dimensions for 96dpi (web standard)
    // Assume original is at 72dpi, scale to 96dpi = 1.33x
    // But we'll downscale to reasonable web size: max 1920px width
    const maxWidth = 1920;
    const scale = Math.min(1, maxWidth / width);
    const targetWidth = Math.round(width * scale);
    const targetHeight = Math.round(height * scale);

    let pipeline = sharp(buffer)
      .resize(targetWidth, targetHeight, {
        fit: "inside",
        withoutEnlargement: true,
      });

    // Decide output format
    if (hasAlpha && format === "png") {
      // Keep PNG for transparency
      pipeline = pipeline.png({ quality: 80, progressive: true });
    } else {
      // Convert to JPEG for better compression
      pipeline = pipeline.jpeg({ quality: 82, progressive: true });
    }

    const optimized = await pipeline.toBuffer();

    // Cache the result
    if (url) {
      const cacheKey = getCacheKey(url);
      imageCache.set(cacheKey, optimized);

      // Evict oldest entries if cache is too large
      if (imageCache.size > MAX_CACHE_SIZE) {
        const firstKey = imageCache.keys().next().value;
        if (firstKey) imageCache.delete(firstKey);
      }
    }

    return optimized;
  } catch (e) {
    // If optimization fails, return original buffer
    console.warn("Image optimization failed, using original:", e);
    return buffer;
  }
}

/**
 * Clear image cache (useful for testing or memory management)
 */
export function clearImageCache(): void {
  imageCache.clear();
}

/**
 * Get cache statistics (for monitoring)
 */
export function getImageCacheStats(): { size: number; entries: number } {
  let totalSize = 0;
  for (const buffer of imageCache.values()) {
    totalSize += buffer.length;
  }
  return { size: totalSize, entries: imageCache.size };
}




────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/index.ts
SIZE: 15.79 KB
────────────────────────────────────────────────────────────────────────────────

import * as logger from "firebase-functions/logger";
import { setGlobalOptions } from "firebase-functions/v2";
import { onRequest } from "firebase-functions/v2/https";
import { defineSecret } from "firebase-functions/params";
import { getApp } from "firebase-admin/app";
import { initializeApp } from "firebase-admin/app";
import { z } from "zod";
import PptxGenJS from "pptxgenjs";

// Import AI helpers
import {
  callAIWithRetry,
  sanitizePrompt,
  moderateContent,
  enhanceSlideSpec,
} from "./aiHelpers";

// Import PPTX builders (now includes universal builder)
import { buildSlideFromSpec } from "./pptxBuilder";

// Define secrets
const AI_API_KEY = defineSecret("AI_API_KEY");
const AI_BASE_URL = defineSecret("AI_BASE_URL");
const AI_MODEL = defineSecret("AI_MODEL");

setGlobalOptions({
  region: "us-central1",
  memory: "512MiB",
  cpu: 1,
  timeoutSeconds: 60,
});

// Admin init (idempotent)
try {
  getApp();
} catch {
  initializeApp();
}

// Firebase Cloud Functions v2 handles CORS automatically when cors: true is set in onRequest options

/** SlideSpec schema (lean, aligned with exporter) */
const SlideSpecZ = z.object({
  meta: z.object({
    version: z.literal("1.0"),
    locale: z.string().default("en-US"),
    theme: z.string(),
    aspectRatio: z.enum(["16:9", "4:3"]).default("16:9"),
  }),
  content: z.object({
    title: z.object({ id: z.string(), text: z.string().min(1) }),
    subtitle: z
      .object({ id: z.string(), text: z.string().min(1) })
      .optional(),
    bullets: z
      .array(
        z.object({
          id: z.string(),
          items: z
            .array(
              z.object({
                text: z.string(),
                level: z.number().int().min(1).max(3),
              })
            )
            .min(1)
            .max(8),
        })
      )
      .max(3)
      .optional(),
    callouts: z
      .array(
        z.object({
          id: z.string(),
          title: z.string().optional(),
          text: z.string(),
          variant: z.enum(["note", "success", "warning", "danger"]),
        })
      )
      .max(2)
      .optional(),
    dataViz: z
      .object({
        id: z.string(),
        // Expanded kinds to match universal builder support
        kind: z.enum(["bar", "line", "pie", "doughnut", "area", "scatter"]),
        title: z.string().optional(),
        labels: z.array(z.string()).min(2).max(10),
        series: z
          .array(
            z.object({ name: z.string(), values: z.array(z.number()) })
          )
          .min(1)
          .max(3),
      })
      .optional(),
    imagePlaceholders: z
      .array(
        z.object({
          id: z.string(),
          role: z.enum(["hero", "logo", "illustration", "icon"]),
          alt: z.string(),
        })
      )
      .max(2)
      .optional(),
  }),
  layout: z.object({
    grid: z.object({
      rows: z.number().int().min(3).max(12),
      cols: z.number().int().min(3).max(12),
      gutter: z.number().min(0),
      margin: z.object({
        t: z.number(),
        r: z.number(),
        b: z.number(),
        l: z.number(),
      }),
    }),
    regions: z
      .array(
        z.object({
          name: z.enum(["header", "body", "footer", "aside"]),
          rowStart: z.number().int().positive(),
          colStart: z.number().int().positive(),
          rowSpan: z.number().int().positive(),
          colSpan: z.number().int().positive(),
        })
      )
      .min(1)
      .max(4),
    anchors: z
      .array(
        z.object({
          refId: z.string(),
          region: z.enum(["header", "body", "footer", "aside"]),
          order: z.number().int().min(0),
          span: z
            .object({
              rows: z.number().int().positive(),
              cols: z.number().int().positive(),
            })
            .optional(),
        })
      )
      .min(1)
      .max(8),
  }),
  styleTokens: z.object({
    palette: z.object({
      primary: z.string(),
      accent: z.string(),
      neutral: z.array(z.string()).min(5).max(9),
    }),
    typography: z.object({
      fonts: z.object({
        sans: z.string(),
        serif: z.string().optional(),
        mono: z.string().optional(),
      }),
      sizes: z.object({
        "step_-2": z.number(),
        "step_-1": z.number(),
        step_0: z.number(),
        step_1: z.number(),
        step_2: z.number(),
        step_3: z.number(),
      }),
      weights: z.object({
        regular: z.number(),
        medium: z.number(),
        semibold: z.number(),
        bold: z.number(),
      }),
      lineHeights: z.object({ compact: z.number(), standard: z.number() }),
    }),
    spacing: z.object({ base: z.number(), steps: z.array(z.number()).min(5).max(10) }),
    radii: z.object({ sm: z.number(), md: z.number(), lg: z.number() }),
    shadows: z.object({ sm: z.string(), md: z.string(), lg: z.string() }),
    contrast: z.object({ minTextContrast: z.number(), minUiContrast: z.number() }),
  }),
  components: z
    .object({
      bulletList: z
        .object({ variant: z.enum(["compact", "spacious"]).optional() })
        .optional(),
      callout: z.object({ variant: z.enum(["flat", "elevated"]).optional() }).optional(),
      chart: z
        .object({
          legend: z.enum(["none", "right", "bottom"]).optional(),
          gridlines: z.boolean().optional(),
        })
        .optional(),
      image: z.object({ fit: z.enum(["cover", "contain"]).optional() }).optional(),
      title: z.object({ align: z.enum(["left", "center", "right"]).optional() }).optional(),
    })
    .optional(),
});
type SlideSpec = z.infer<typeof SlideSpecZ>;

/** Offline fallback SlideSpec (no AI) */
function fallbackSpec(prompt: string): SlideSpec {
  return {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Clean",
      aspectRatio: "16:9",
    },
    content: {
      title: { id: "title", text: prompt?.trim() ? prompt : "AI-Powered Slide in Seconds" },
      subtitle: { id: "subtitle", text: "plzfixthx — preview & export" },
      bullets: [
        {
          id: "b1",
          items: [
            { text: "Type a prompt; get a polished slide", level: 1 },
            { text: "Live preview in browser", level: 1 },
            { text: "Download a .pptx", level: 1 },
          ],
        },
      ],
      callouts: [{ id: "c1", text: "Preview ≤ 3s, Export ≤ 10s", variant: "success" }],
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 24, r: 24, b: 24, l: 24 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 5, colSpan: 8 },
        { name: "aside", rowStart: 3, colStart: 9, rowSpan: 5, colSpan: 4 },
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "subtitle", region: "header", order: 1 },
        { refId: "b1", region: "body", order: 0 },
        { refId: "c1", region: "aside", order: 0 },
      ],
    },
    styleTokens: {
      palette: {
        primary: "#2563EB",
        accent: "#F59E0B",
        neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
      },
      typography: {
        fonts: { sans: "Inter, Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 32 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.5 },
      },
      spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32] },
      radii: { sm: 2, md: 6, lg: 12 },
      shadows: {
        sm: "0 1px 2px rgba(0,0,0,.06)",
        md: "0 4px 8px rgba(0,0,0,.12)",
        lg: "0 12px 24px rgba(0,0,0,.18)",
      },
      contrast: { minTextContrast: 4.5, minUiContrast: 3 },
    },
  };
}

/** AI adapter (OpenAI-compatible HTTP). Returns SlideSpec or throws. */
async function callVendor(prompt: string): Promise<SlideSpec> {
  const key = AI_API_KEY.value() ?? "";
  const base = AI_BASE_URL.value() || "https://api.openai.com/v1";
  const model = AI_MODEL.value() || "gpt-4o-mini"; // any JSON-capable chat model

  if (!key) {
    logger.warn("AI_API_KEY not set — using fallback");
    return fallbackSpec(prompt);
  }

  // Use enhanced AI calling with retry logic (json-schema aware inside helper)
  const result = await callAIWithRetry(prompt, key, base, model, SlideSpecZ);

  // Post-process and enhance the result
  const enhanced = enhanceSlideSpec(result);

  return enhanced as SlideSpec;
}

/** POST /generateSlideSpec {prompt} -> {spec} */
export const generateSlideSpec = onRequest(
  { cors: true, secrets: [AI_API_KEY, AI_BASE_URL, AI_MODEL] },
  async (req, res) => {
    if (req.method !== "POST") {
      res.status(405).send("Method Not Allowed");
      return;
    }

    const startTime = Date.now();
    const memoryBefore = process.memoryUsage().heapUsed / 1024 / 1024;

    try {
      // Sanitize and validate prompt
      const rawPrompt = (req.body?.prompt ?? "").toString();
      const prompt = sanitizePrompt(rawPrompt, 800);

      logger.info("📝 Spec generation started", {
        promptLength: prompt.length,
        timestamp: new Date().toISOString(),
      });

      // Content moderation
      const moderation = moderateContent(prompt);
      if (!moderation.safe) {
        logger.warn("⚠️ Content moderation rejected", {
          reason: moderation.reason,
          timestamp: new Date().toISOString(),
        });
        res.status(400).json({
          error: moderation.reason || "Content not allowed",
          spec: fallbackSpec("Content moderation failed"),
        });
        return;
      }

      // Generate slide spec
      const spec = await callVendor(prompt);

      const endTime = Date.now();
      const duration = endTime - startTime;
      const memoryAfter = process.memoryUsage().heapUsed / 1024 / 1024;

      logger.info("✅ Spec generation completed", {
        durationMs: duration,
        memoryUsedMB: (memoryAfter - memoryBefore).toFixed(2),
        hasTitle: !!spec.content.title,
        hasSubtitle: !!spec.content.subtitle,
        hasBullets: !!spec.content.bullets,
        hasDataViz: !!spec.content.dataViz,
        aspectRatio: spec.meta.aspectRatio,
        timestamp: new Date().toISOString(),
      });

      res.status(200).json({ spec });
    } catch (e: any) {
      const endTime = Date.now();
      const duration = endTime - startTime;
      const memoryAfter = process.memoryUsage().heapUsed / 1024 / 1024;

      logger.error("❌ Spec generation failed", {
        error: e.message || String(e),
        stack: e.stack,
        durationMs: duration,
        memoryUsedMB: (memoryAfter - memoryBefore).toFixed(2),
        timestamp: new Date().toISOString(),
      });

      // Return fallback spec on error
      const fallback = fallbackSpec(req.body?.prompt || "");
      res.status(200).json({
        spec: fallback,
        warning: "Using fallback due to error: " + e.message,
      });
    }
  }
);

/** POST /exportPPTX {spec} or {specs: []} -> .pptx binary */
export const exportPPTX = onRequest({ cors: true }, async (req, res) => {
  if (req.method !== "POST") {
    res.status(405).send("Method Not Allowed");
    return;
  }

  const startTime = Date.now();
  const memoryBefore = process.memoryUsage().heapUsed / 1024 / 1024;

  try {
    // Support both single spec and array of specs
    const body = req.body;
    let specs: any[];

    if (body?.specs && Array.isArray(body.specs)) {
      // Multiple slides - sanitize before parsing
      specs = body.specs.map((s: any) => {
        // Sanitize palette before validation
        if (s?.styleTokens?.palette?.neutral) {
          const hexPattern = /^#[0-9A-Fa-f]{6}$/;
          s.styleTokens.palette.neutral = (s.styleTokens.palette.neutral as (string | null | undefined)[])
            .filter((color: any): color is string => color != null && typeof color === 'string' && hexPattern.test(color))
            .slice(0, 9);
          if (s.styleTokens.palette.neutral.length < 5) {
            s.styleTokens.palette.neutral = [
              "#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8",
              "#CBD5E1", "#E2E8F0", "#F1F5F9", "#F8FAFC"
            ];
          }
        }
        return SlideSpecZ.parse(s);
      });
    } else if (body?.spec) {
      // Single slide (backward compatibility) - sanitize before parsing
      const spec = body.spec;
      if (spec?.styleTokens?.palette?.neutral) {
        const hexPattern = /^#[0-9A-Fa-f]{6}$/;
        spec.styleTokens.palette.neutral = (spec.styleTokens.palette.neutral as (string | null | undefined)[])
          .filter((color: any): color is string => color != null && typeof color === 'string' && hexPattern.test(color))
          .slice(0, 9);
        if (spec.styleTokens.palette.neutral.length < 5) {
          spec.styleTokens.palette.neutral = [
            "#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8",
            "#CBD5E1", "#E2E8F0", "#F1F5F9", "#F8FAFC"
          ];
        }
      }
      specs = [SlideSpecZ.parse(spec)];
    } else {
      throw new Error("Missing spec or specs in request body");
    }

    logger.info("📊 Export started", {
      slideCount: specs.length,
      timestamp: new Date().toISOString(),
    });

    const buf = await buildPptx(specs);

    const endTime = Date.now();
    const memoryAfter = process.memoryUsage().heapUsed / 1024 / 1024;
    const duration = endTime - startTime;
    const bufferSize = buf.byteLength / 1024 / 1024;

    logger.info("✅ Export completed successfully", {
      slideCount: specs.length,
      durationMs: duration,
      bufferSizeMB: bufferSize.toFixed(2),
      memoryUsedMB: (memoryAfter - memoryBefore).toFixed(2),
      withinBudget: duration <= 1500 && memoryAfter <= 300,
      timestamp: new Date().toISOString(),
    });

    res.setHeader(
      "Content-Type",
      "application/vnd.openxmlformats-officedocument.presentationml.presentation"
    );
    res.setHeader(
      "Content-Disposition",
      `attachment; filename="plzfixthx-presentation.pptx"`
    );
    res.status(200).send(Buffer.from(buf));
  } catch (e: any) {
    const endTime = Date.now();
    const duration = endTime - startTime;
    const memoryAfter = process.memoryUsage().heapUsed / 1024 / 1024;

    logger.error("❌ Export failed", {
      error: e.message || String(e),
      stack: e.stack,
      durationMs: duration,
      memoryUsedMB: (memoryAfter - memoryBefore).toFixed(2),
      timestamp: new Date().toISOString(),
    });

    res.status(400).send(`Export error: ${e.message || String(e)}`);
  }
});

/** PPTX builder - supports single or multiple slides */
async function buildPptx(
  specs: SlideSpec | SlideSpec[]
): Promise<ArrayBuffer> {
  const specsArray = Array.isArray(specs) ? specs : [specs];
  if (specsArray.length === 0) {
    throw new Error("No slides to export");
  }

  const pptx = new PptxGenJS();
  const firstSpec = specsArray[0];
  pptx.layout = firstSpec.meta.aspectRatio === "4:3" ? "LAYOUT_4x3" : "LAYOUT_16x9";

  // Build each slide
  for (const spec of specsArray) {
    await buildSlide(pptx, spec);
  }

  return pptx.write({ outputType: "arraybuffer" }) as Promise<ArrayBuffer>;
}

/** Build a single slide using the universal builder */
async function buildSlide(pptx: PptxGenJS, spec: SlideSpec): Promise<void> {
  logger.info("🏗️ Building slide", {
    hasTitle: !!spec.content.title,
    hasSubtitle: !!spec.content.subtitle,
    aspectRatio: spec.meta.aspectRatio,
  });

  try {
    // Universal builder renders title, subtitle, bullets, callouts, charts, images per grid
    await buildSlideFromSpec(pptx, spec as any);

    logger.info("✅ Slide built successfully", {
      title: spec.content.title?.text?.substring(0, 60) || "Untitled",
    });
  } catch (error) {
    logger.error("❌ Slide build failed", {
      error: String(error),
      spec: {
        title: spec.content.title?.text?.substring(0, 50),
        aspectRatio: spec.meta.aspectRatio,
      },
    });
    throw error;
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/layoutBuilders.ts
SIZE: 8.91 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * Modular Layout Builders for Professional PPTX Generation
 * Status: Optional helpers for bespoke layouts (legacy/experimental).
 *
 * All functions accept a LayoutBuilderContext and use consistent typography,
 * rich-text highlighting, and spacing. These are additive to the universal
 * grid-based renderer, and may be used for custom templates.
 */

import PptxGenJS from "pptxgenjs";

/* --------------------------------- Types ---------------------------------- */

export type Theme = {
  bg: string;
  fg: string;
  accent: string;
  muted: string;
  fontFace?: string;
};

export interface LayoutBuilderContext<Spec = Record<string, unknown>> {
  slide: PptxGenJS.Slide;
  spec: Spec;
  theme: Theme;
  topY: number;
}

/** Paragraph/Bullets/Columns/Metrics/Quote/Chart lightweight specs */
export type ParagraphLayoutSpec = { bullets?: string[]; accentWords?: string[] };
export type BulletsLayoutSpec = { bullets?: string[]; accentWords?: string[] };
export type ComparisonLayoutSpec = {
  columns?: { heading?: string; bullets?: string[] }[];
  accentWords?: string[];
};
export type MetricsLayoutSpec = {
  bullets?: string[];
  callouts?: { label: string; value: string }[];
  accentWords?: string[];
};
export type QuoteLayoutSpec = { bullets?: [string, ...string[]]; accentWords?: string[] };
export type ChartLayoutSpec = { bullets?: string[]; accentWords?: string[] };

/* --------------------------- Rich-text Utilities --------------------------- */

function escapeRe(s: string) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

/**
 * Convert a plain string into a rich text run array, bolding and tinting the
 * listed accent words. Returns PptxGenJS IText[] compatible objects.
 */
export function highlightAccentWords(
  text: string,
  accentWords?: string[],
  accentColor?: string
): Array<{ text: string; options?: PptxGenJS.TextPropsOptions }> {
  if (!accentWords || accentWords.length === 0 || !text) {
    return [{ text }];
  }

  const pattern = new RegExp(
    `\\b(${accentWords.map(escapeRe).join("|")})\\b`,
    "gi"
  );

  const runs: Array<{ text: string; options?: PptxGenJS.TextPropsOptions }> = [];
  let lastIndex = 0;
  let match: RegExpExecArray | null;

  while ((match = pattern.exec(text)) !== null) {
    const [found] = match;
    const start = match.index;

    if (start > lastIndex) {
      runs.push({ text: text.slice(lastIndex, start) });
    }
    runs.push({
      text: found,
      options: { bold: true, color: accentColor },
    });
    lastIndex = pattern.lastIndex;
  }

  if (lastIndex < text.length) {
    runs.push({ text: text.slice(lastIndex) });
  }

  return runs.length > 0 ? runs : [{ text }];
}

/* --------------------------------- Layouts --------------------------------- */

/**
 * PARAGRAPH Layout: Narrative content with professional typography.
 */
export function buildParagraphLayout(
  ctx: LayoutBuilderContext<ParagraphLayoutSpec>
) {
  const { slide, spec, theme, topY } = ctx;
  const fontFace = theme.fontFace || "Aptos, Calibri, Arial";
  const content = (spec.bullets || []).join("\n\n");
  if (!content) return;

  const runs = highlightAccentWords(content, spec.accentWords, theme.accent);
  slide.addText(runs as any, {
    x: 0.7,
    y: topY,
    w: 8.6,
    h: 4.8,
    fontSize: 14,
    color: theme.fg,
    fontFace,
    lineSpacing: 22,
    wrap: true,
  } as PptxGenJS.TextPropsOptions);
}

/**
 * BULLETS Layout: Key points with professional emphasis.
 */
export function buildBulletsLayout(ctx: LayoutBuilderContext<BulletsLayoutSpec>) {
  const { slide, spec, theme, topY } = ctx;
  const fontFace = theme.fontFace || "Aptos, Calibri, Arial";
  const items = spec.bullets || [];
  if (items.length === 0) return;

  // Build a single run array with newline separators to keep bullets aligned
  const newline = { text: "\n" };
  const runs = items.flatMap((b, i) => {
    const parts = highlightAccentWords(b, spec.accentWords, theme.accent);
    return i < items.length - 1 ? [...parts, newline] : parts;
  });

  slide.addText(runs as any, {
    x: 0.7,
    y: topY,
    w: 8.6,
    h: 4.8,
    bullet: true,
    fontSize: 12,
    color: theme.fg,
    fontFace,
    lineSpacing: 20,
    wrap: true,
  } as PptxGenJS.TextPropsOptions);
}

/**
 * COMPARISON Layout: Two-column comparison with visual balance.
 */
export function buildComparisonLayout(
  ctx: LayoutBuilderContext<ComparisonLayoutSpec>
) {
  const { slide, spec, theme, topY } = ctx;
  const cols = spec.columns || [];
  if (cols.length < 2) return;

  const colW = 4.3;
  const gap = 0.4;
  const x1 = 0.5;
  const x2 = x1 + colW + gap;
  const y = topY;
  const h = 4.5;
  const fontFace = theme.fontFace || "Aptos, Calibri, Arial";

  cols.forEach((col, idx) => {
    const x = idx ? x2 : x1;

    if (col.heading) {
      slide.addText(col.heading, {
        x,
        y,
        w: colW,
        fontSize: 16,
        bold: true,
        color: theme.accent,
        fontFace,
      });
    }

    if (col.bullets && col.bullets.length > 0) {
      const newline = { text: "\n" };
      const runs = col.bullets.flatMap((b, i) => {
        const parts = highlightAccentWords(b, spec.accentWords, theme.accent);
        return i < col.bullets!.length - 1 ? [...parts, newline] : parts;
      });

      slide.addText(runs as any, {
        x,
        y: col.heading ? y + 0.4 : y,
        w: colW,
        h,
        bullet: true,
        fontSize: 11,
        color: theme.fg,
        fontFace,
        lineSpacing: 18,
        wrap: true,
      } as PptxGenJS.TextPropsOptions);
    }
  });
}

/**
 * METRICS Layout: KPIs with visual emphasis and callouts.
 */
export function buildMetricsLayout(ctx: LayoutBuilderContext<MetricsLayoutSpec>) {
  const { slide, spec, theme, topY } = ctx;
  const fontFace = theme.fontFace || "Aptos, Calibri, Arial";

  if (spec.bullets && spec.bullets.length > 0) {
    const newline = { text: "\n" };
    const runs = spec.bullets.flatMap((b, i) => {
      const parts = highlightAccentWords(b, spec.accentWords, theme.accent);
      return i < spec.bullets!.length - 1 ? [...parts, newline] : parts;
    });

    slide.addText(runs as any, {
      x: 0.7,
      y: topY,
      w: 8.6,
      h: 3.2,
      bullet: true,
      fontSize: 12,
      color: theme.fg,
      fontFace,
      lineSpacing: 18,
      wrap: true,
    } as PptxGenJS.TextPropsOptions);
  }

  if (spec.callouts && spec.callouts.length > 0) {
    const calloutY = 5.2;
    let calloutX = 0.5;

    spec.callouts.forEach((c) => {
      const label = `${c.label}: ${c.value}`;
      slide.addText(label, {
        x: calloutX,
        y: calloutY,
        w: 2.5,
        h: 0.5,
        fontSize: 11,
        color: theme.accent,
        bold: true,
        fontFace,
        align: "left",
      });
      calloutX += 2.8;
    });
  }
}

/**
 * QUOTE Layout: Powerful statements with professional typography.
 */
export function buildQuoteLayout(ctx: LayoutBuilderContext<QuoteLayoutSpec>) {
  const { slide, spec, theme, topY } = ctx;
  const quoteText = spec.bullets?.[0];
  if (!quoteText) return;
  const fontFace = theme.fontFace || "Aptos, Calibri, Arial";

  // Leading decorative quote
  slide.addText('"', {
    x: 0.5,
    y: topY - 0.3,
    w: 0.5,
    fontSize: 48,
    color: theme.accent,
    fontFace,
    // Note: opacity not supported in PptxGenJS; use lighter color instead
  });

  // Quote body
  const runs = highlightAccentWords(quoteText, spec.accentWords, theme.accent);
  slide.addText(runs as any, {
    x: 0.9,
    y: topY,
    w: 8.2,
    h: 3.5,
    fontSize: 26,
    italic: true,
    color: theme.accent,
    fontFace,
    lineSpacing: 32,
    wrap: true,
  } as PptxGenJS.TextPropsOptions);

  // Trailing decorative quote
  slide.addText('"', {
    x: 8.5,
    y: topY + 2.8,
    w: 0.5,
    fontSize: 48,
    color: theme.accent,
    fontFace,
    // Note: opacity not supported in PptxGenJS; use lighter color instead
  });
}

/**
 * CHART Layout: Data visualization placeholder with professional styling.
 * (Use the universal grid builder for real charts; this is a visual scaffold.)
 */
export function buildChartLayout(ctx: LayoutBuilderContext<ChartLayoutSpec>) {
  const { slide, spec, theme, topY } = ctx;
  const fontFace = theme.fontFace || "Aptos, Calibri, Arial";

  // Placeholder frame
  slide.addText("[Chart/Visualization Area]", {
    x: 0.7,
    y: topY + 1.5,
    w: 8.6,
    h: 0.8,
    fontSize: 14,
    color: theme.muted,
    fontFace,
    align: "center",
    valign: "middle",
  });

  // Supporting bullets below chart
  if (spec.bullets && spec.bullets.length > 0) {
    const newline = { text: "\n" };
    const runs = spec.bullets.flatMap((b, i) => {
      const parts = highlightAccentWords(b, spec.accentWords, theme.accent);
      return i < spec.bullets!.length - 1 ? [...parts, newline] : parts;
    });

    slide.addText(runs as any, {
      x: 0.7,
      y: 4.2,
      w: 8.6,
      h: 1.8,
      bullet: true,
      fontSize: 11,
      color: theme.fg,
      fontFace,
      lineSpacing: 16,
      wrap: true,
    } as PptxGenJS.TextPropsOptions);
  }
}


────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/metrics.ts
SIZE: 6.82 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * Metrics collection and reporting for plzfixthx functions.
 * Tracks counters, latencies, and errors for observability.
 */

import * as logger from "firebase-functions/logger";

/* -------------------------------------------------------------------------- */
/*                            Metrics Store                                   */
/* -------------------------------------------------------------------------- */

interface MetricCounter {
  count: number;
  lastUpdated: number;
}

interface MetricHistogram {
  values: number[];
  count: number;
  sum: number;
  min: number;
  max: number;
}

const counters = new Map<string, MetricCounter>();
const histograms = new Map<string, MetricHistogram>();

// Cleanup old metrics every 1 hour
setInterval(() => {
  const now = Date.now();
  const oneHourAgo = now - 60 * 60 * 1000;

  for (const [key, counter] of counters.entries()) {
    if (counter.lastUpdated < oneHourAgo) {
      counters.delete(key);
    }
  }

  for (const [, histogram] of histograms.entries()) {
    // Keep histograms for analysis
    if (histogram.values.length > 1000) {
      histogram.values = histogram.values.slice(-500);
    }
  }
}, 60 * 60 * 1000);

/* -------------------------------------------------------------------------- */
/*                            Counter Metrics                                 */
/* -------------------------------------------------------------------------- */

/**
 * Increment a counter metric
 */
export function incrementCounter(name: string, value: number = 1, labels?: Record<string, string>): void {
  const key = labels ? `${name}:${JSON.stringify(labels)}` : name;
  const counter = counters.get(key) || { count: 0, lastUpdated: Date.now() };
  counter.count += value;
  counter.lastUpdated = Date.now();
  counters.set(key, counter);
}

/**
 * Get counter value
 */
export function getCounter(name: string, labels?: Record<string, string>): number {
  const key = labels ? `${name}:${JSON.stringify(labels)}` : name;
  return counters.get(key)?.count ?? 0;
}

/**
 * Reset counter
 */
export function resetCounter(name: string, labels?: Record<string, string>): void {
  const key = labels ? `${name}:${JSON.stringify(labels)}` : name;
  counters.delete(key);
}

/* -------------------------------------------------------------------------- */
/*                            Histogram Metrics                               */
/* -------------------------------------------------------------------------- */

/**
 * Record a histogram value (for latencies, sizes, etc.)
 */
export function recordHistogram(name: string, value: number, labels?: Record<string, string>): void {
  const key = labels ? `${name}:${JSON.stringify(labels)}` : name;
  let histogram = histograms.get(key);

  if (!histogram) {
    histogram = { values: [], count: 0, sum: 0, min: value, max: value };
  }

  histogram.values.push(value);
  histogram.count++;
  histogram.sum += value;
  histogram.min = Math.min(histogram.min, value);
  histogram.max = Math.max(histogram.max, value);

  histograms.set(key, histogram);
}

/**
 * Get histogram statistics
 */
export function getHistogramStats(name: string, labels?: Record<string, string>): {
  count: number;
  sum: number;
  min: number;
  max: number;
  avg: number;
  p50: number;
  p95: number;
  p99: number;
} | null {
  const key = labels ? `${name}:${JSON.stringify(labels)}` : name;
  const histogram = histograms.get(key);

  if (!histogram || histogram.count === 0) {
    return null;
  }

  const sorted = [...histogram.values].sort((a, b) => a - b);
  const p50 = sorted[Math.floor(sorted.length * 0.5)];
  const p95 = sorted[Math.floor(sorted.length * 0.95)];
  const p99 = sorted[Math.floor(sorted.length * 0.99)];

  return {
    count: histogram.count,
    sum: histogram.sum,
    min: histogram.min,
    max: histogram.max,
    avg: histogram.sum / histogram.count,
    p50,
    p95,
    p99,
  };
}

/* -------------------------------------------------------------------------- */
/*                            Metric Reporting                                */
/* -------------------------------------------------------------------------- */

/**
 * Report all metrics to logs (for Cloud Logging)
 */
export function reportMetrics(): void {
  const metricsData: Record<string, any> = {
    timestamp: new Date().toISOString(),
    counters: {},
    histograms: {},
  };

  // Collect counters
  for (const [key, counter] of counters.entries()) {
    metricsData.counters[key] = counter.count;
  }

  // Collect histogram stats
  for (const [key] of histograms.entries()) {
    const stats = getHistogramStats(key);
    if (stats) {
      metricsData.histograms[key] = stats;
    }
  }

  logger.info("📊 Metrics Report", metricsData);
}

/**
 * Common metric names
 */
export const MetricNames = {
  // Counters
  REQUESTS_TOTAL: "requests_total",
  REQUESTS_SUCCESS: "requests_success",
  REQUESTS_ERROR: "requests_error",
  REQUESTS_MODERATION_REJECTED: "requests_moderation_rejected",
  REQUESTS_ABUSE_DETECTED: "requests_abuse_detected",
  REQUESTS_RATE_LIMITED: "requests_rate_limited",

  // Histograms
  REQUEST_DURATION_MS: "request_duration_ms",
  AI_GENERATION_DURATION_MS: "ai_generation_duration_ms",
  PPTX_EXPORT_DURATION_MS: "pptx_export_duration_ms",
  IMAGE_FETCH_DURATION_MS: "image_fetch_duration_ms",
  MEMORY_USED_MB: "memory_used_mb",
  PPTX_SIZE_MB: "pptx_size_mb",
} as const;

/**
 * Track request metrics
 */
export function trackRequest(
  endpoint: string,
  durationMs: number,
  success: boolean,
  error?: string
): void {
  const labels = { endpoint };

  incrementCounter(MetricNames.REQUESTS_TOTAL, 1, labels);

  if (success) {
    incrementCounter(MetricNames.REQUESTS_SUCCESS, 1, labels);
  } else {
    incrementCounter(MetricNames.REQUESTS_ERROR, 1, labels);
    if (error) {
      logger.error(`❌ Request failed: ${error}`, { endpoint, error });
    }
  }

  recordHistogram(MetricNames.REQUEST_DURATION_MS, durationMs, labels);
}

/**
 * Track AI generation metrics
 */
export function trackAIGeneration(durationMs: number, success: boolean, error?: string): void {
  if (success) {
    recordHistogram(MetricNames.AI_GENERATION_DURATION_MS, durationMs);
  } else {
    incrementCounter(MetricNames.REQUESTS_ERROR, 1, { endpoint: "generateSlideSpec" });
    if (error) {
      logger.error(`❌ AI generation failed: ${error}`, { error });
    }
  }
}

/**
 * Track PPTX export metrics
 */
export function trackPPTXExport(durationMs: number, sizeMB: number, slideCount: number): void {
  recordHistogram(MetricNames.PPTX_EXPORT_DURATION_MS, durationMs);
  recordHistogram(MetricNames.PPTX_SIZE_MB, sizeMB, { slideCount: String(slideCount) });
}

/**
 * Track image fetch metrics
 */
export function trackImageFetch(durationMs: number, success: boolean): void {
  recordHistogram(MetricNames.IMAGE_FETCH_DURATION_MS, durationMs);
  if (!success) {
    incrementCounter("image_fetch_failures");
  }
}




────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/pptxBuilder/headerOnlyBuilder.ts
SIZE: 24.66 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * Professional PPTX Builders
 * - Back-compat: buildHeaderOnlySlide()
 * - Universal: buildSlideFromSpec() renders a full SlideSpecV1 using a grid engine
 *
 * Notes:
 * - Uses 72dpi px→in conversion (32px ≈ 0.44in)
 * - Honors layout.grid (rows/cols/gutter/margin) and layout.anchors (order/region)
 * - Supports charts: bar | line | pie | doughnut | area | scatter
 *   (Other kinds fall back to a styled placeholder)
 * - Premium accents with proper PPTX transparency (0..100) instead of 8-digit hex
 * - Optional image blocks (content.images) with URL loading
 */

import PptxGenJS from "pptxgenjs";
import { fetch as undiciFetch } from "undici";
import type { SlideSpecV1, ChartKind } from "@plzfixthx/slide-spec";
import { calculateOptimalFontSize, truncateWithEllipsis } from "../typographyEnhancer";
import { optimizeImage } from "../imageOptimizer";

/* -------------------------------------------------------------------------- */
/*                        Back-compat: simple header slide                     */
/* -------------------------------------------------------------------------- */

export interface HeaderOnlySlideSpec {
  header: string;
  subtitle: string;
  color: string;
}

/**
 * Legacy title/subtitle slide (clean, professional)
 */
export async function buildHeaderOnlySlide(
  pptx: PptxGenJS,
  spec: HeaderOnlySlideSpec
): Promise<void> {
  const slide = pptx.addSlide();
  const primaryColor = spec.color || "#6366F1";
  const subtitleColor = "#64748B";
  const backgroundColor = "#FFFFFF";

  slide.background = { color: backgroundColor };

  // Left accent bar ~0.12in
  slide.addShape(pptx.ShapeType.rect, {
    x: 0,
    y: 0,
    w: 0.17,
    h: getSlideDims(pptx).h,
    fill: { color: primaryColor },
    line: { type: "none" },
  });

  // Header
  slide.addText(
    spec.header,
    {
      x: 0.5,
      y: 1.8,
      w: 9.0,
      h: 1.2,
      fontSize: 26,
      bold: true,
      fontFace: "Aptos, Calibri, Arial",
      color: primaryColor,
      align: "left",
      valign: "top",
      wrap: true,
    } as any
  );

  // Subtitle
  slide.addText(
    spec.subtitle,
    {
      x: 0.5,
      y: 3.1,
      w: 9.0,
      h: 1.5,
      fontSize: 16,
      fontFace: "Aptos, Calibri, Arial",
      color: subtitleColor,
      align: "left",
      valign: "top",
      wrap: true,
    } as any
  );
}

/* -------------------------------------------------------------------------- */
/*                      Universal slide builder for V1 spec                    */
/* -------------------------------------------------------------------------- */

export async function buildSlideFromSpec(
  pptx: PptxGenJS,
  spec: SlideSpecV1
): Promise<void> {
  const slide = pptx.addSlide();
  const dims = getSlideDims(pptx);
  const grid = computeGrid(spec, dims);

  // --- Background & premium accents -----------------------------------------
  const palette = spec.styleTokens?.palette ?? {
    primary: "#6366F1",
    accent: "#EC4899",
    neutral: [
      "#0F172A",
      "#1E293B",
      "#334155",
      "#475569",
      "#64748B",
      "#94A3B8",
      "#CBD5E1",
      "#E2E8F0",
      "#FFFFFF",
    ],
  };
  const bg = palette.neutral?.[palette.neutral.length - 1] ?? "#FFFFFF";
  slide.background = { color: bg };

  // Left accent bar (0.12in)
  slide.addShape(pptx.ShapeType.rect, {
    x: 0,
    y: 0,
    w: 0.12,
    h: dims.h,
    fill: { color: palette.primary || "#6366F1" },
    line: { type: "none" },
  });

  // Subtle top-right glaze (10% opacity)
  slide.addShape(pptx.ShapeType.rect, {
    x: dims.w - 3.2,
    y: 0.2,
    w: 3.0,
    h: 1.0,
    fill: { color: palette.accent || "#EC4899", transparency: opacityToTransparency(0.10) },
    line: { type: "none" },
    rectRadius: 12,
  });

  // Premium vertical accent line (very faint)
  slide.addShape(pptx.ShapeType.rect, {
    x: 0.22,
    y: 0.08,
    w: 0.04,
    h: Math.max(0, dims.h - 0.16),
    fill: { color: palette.accent || "#EC4899", transparency: opacityToTransparency(0.88) },
    line: { type: "none" },
    rectRadius: 2,
  });

  // --- Render by regions/anchors --------------------------------------------
  const anchorsByRegion = groupAnchorsByRegion(spec);
  const fontSans = safeFont(spec.styleTokens?.typography?.fonts?.sans);

  for (const region of spec.layout.regions) {
    const regionRect = gridRect(region, grid);

    // simple flow within region
    let cursorY = regionRect.y + 0.08;
    const innerX = regionRect.x + 0.08;
    const innerW = Math.max(0, regionRect.w - 0.16);
    const flowGap = 0.12;

    const anchors = (anchorsByRegion.get(region.name) || []).sort(
      (a, b) => a.order - b.order
    );

    for (const anchor of anchors) {
      const type = resolveAnchorType(spec, anchor.refId);
      if (!type) continue;

      const remaining = regionRect.y + regionRect.h - cursorY;
      const H = preferredHeight(type, remaining);

      switch (type) {
        case "title": {
          const title = spec.content.title!;
          const base = clampNum(
            spec.styleTokens?.typography?.sizes?.step_3 ?? 44,
            24,
            44
          );
          // Use enhanced typography calculation with binary search
          const titleSize = calculateOptimalFontSize(title.text, innerW, H, base, 22, 1.2);

          // Apply ellipsis if text still doesn't fit
          const titleText = truncateWithEllipsis(title.text, innerW, H, titleSize, 1.2);

          slide.addText(
            titleText,
            {
              x: innerX,
              y: cursorY,
              w: innerW,
              h: H,
              fontFace: fontSans,
              fontSize: titleSize,
              bold: true,
              color: palette.primary || "#1E40AF",
              align: spec.components?.title?.align ?? "left",
              valign: "top",
              paraSpaceAfter: 8,
              lineSpacingMultiple: 1.2,
              letterSpacing: -0.02,
              wrap: true,
            } as any
          );

          // Divider + accent dot
          const dividerWidth = Math.min(2.8, innerW * 0.45);
          slide.addShape(pptx.ShapeType.rect, {
            x: innerX,
            y: cursorY + Math.min(H, 0.6),
            w: dividerWidth,
            h: 0.06,
            fill: { color: palette.primary || "#1E40AF" },
            line: { type: "none" },
          });
          slide.addShape(pptx.ShapeType.ellipse, {
            x: innerX + dividerWidth + 0.18,
            y: cursorY + Math.min(H, 0.62),
            w: 0.09,
            h: 0.09,
            fill: { color: palette.accent || "#F59E0B" },
            line: { type: "none" },
          });
          break;
        }

        case "subtitle": {
          const subtitle = spec.content.subtitle!;
          const base = clampNum(
            spec.styleTokens?.typography?.sizes?.step_1 ?? 20,
            14,
            24
          );
          // Use enhanced typography calculation with binary search
          const subtitleSize = calculateOptimalFontSize(
            subtitle.text,
            innerW,
            H,
            base,
            14,
            1.3
          );

          // Apply ellipsis if text still doesn't fit
          const subtitleText = truncateWithEllipsis(subtitle.text, innerW, H, subtitleSize, 1.3);

          const subtitleColor =
            (palette.neutral && palette.neutral[3]) || "#64748B";

          slide.addText(
            subtitleText,
            {
              x: innerX,
              y: cursorY,
              w: innerW,
              h: H,
              fontFace: fontSans,
              fontSize: subtitleSize,
              color: subtitleColor,
              align: "left",
              valign: "top",
              paraSpaceAfter: 6,
              lineSpacingMultiple: 1.3,
              letterSpacing: -0.01,
              wrap: true,
            } as any
          );
          break;
        }

        case "bullets": {
          const group = spec.content.bullets!.find((b) => b.id === anchor.refId)!;
          const bulletParas = (group.items || []).map((it) => ({
            text: it.text,
            options: {
              indentLevel: Math.max(0, (it.level || 1) - 1), // pptxgenjs: 0-based
              color:
                it.level === 1
                  ? palette.primary || "#1E40AF"
                  : it.level === 2
                  ? (palette.neutral && palette.neutral[2]) || "#334155"
                  : (palette.neutral && palette.neutral[3]) || "#475569",
              bold: it.level === 1,
              fontSize: it.level === 1 ? 14 : it.level === 2 ? 12 : 11,
            },
          }));

          const bodySize = clampNum(
            spec.styleTokens?.typography?.sizes?.step_0 ?? 16,
            12,
            14
          );

          slide.addText(
            bulletParas as any,
            {
              x: innerX,
              y: cursorY,
              w: innerW,
              h: H,
              fontFace: fontSans,
              fontSize: bodySize,
              color: (palette.neutral && palette.neutral[0]) || "#0F172A",
              bullet: true,
              paraSpaceAfter: 14, // Improved spacing for better readability
              lineSpacingMultiple: 1.5,
              wrap: true,
            } as any
          );
          break;
        }

        case "callout": {
          const callout = spec.content.callouts!.find(
            (c) => c.id === anchor.refId
          )!;
          const { bg, border, textColor } = calloutColors(
            callout.variant,
            palette
          );

          // Card background with subtle shadow effect
          slide.addShape(pptx.ShapeType.rect, {
            x: innerX,
            y: cursorY,
            w: innerW,
            h: H,
            fill: { color: bg },
            line: { color: border, width: 2 },
            rectRadius: 12,
            shadow: {
              type: "outer",
              blur: 8,
              offset: 2,
              angle: 45,
              color: "#000000",
              opacity: 0.1,
            },
          });

          // Left accent stripe (thicker for better visibility)
          slide.addShape(pptx.ShapeType.rect, {
            x: innerX,
            y: cursorY,
            w: 0.12,
            h: H,
            fill: { color: border },
            line: { type: "none" },
            rectRadius: 12,
          });

          const calloutSize = clampNum(
            spec.styleTokens?.typography?.sizes?.step_0 ?? 16,
            14,
            18
          );
          const calloutText = callout.title
            ? `${callout.title} — ${callout.text}`
            : callout.text;

          slide.addText(
            calloutText,
            {
              x: innerX + 0.32,
              y: cursorY + 0.2,
              w: Math.max(0, innerW - 0.56),
              h: Math.max(0, H - 0.4),
              fontFace: fontSans,
              fontSize: calloutSize,
              color: textColor,
              bold: !!callout.title,
              align: "left",
              valign: "top",
              lineSpacingMultiple: 1.4,
              wrap: true,
            } as any
          );
          break;
        }

        case "chart": {
          const viz = spec.content.dataViz!;
          const supported = mapChartKind(pptx, viz.kind);
          if (!supported) {
            // Graceful placeholder
            slide.addShape(pptx.ShapeType.rect, {
              x: innerX,
              y: cursorY,
              w: innerW,
              h: H,
              fill: {
                color: (palette.neutral && palette.neutral[6]) || "#E2E8F0",
              },
              line: { type: "none" },
              rectRadius: 8,
            });
            slide.addText(
              `[${viz.kind}] chart not supported in exporter yet`,
              {
                x: innerX,
                y: cursorY + H / 2 - 0.15,
                w: innerW,
                h: 0.3,
                fontFace: fontSans,
                fontSize: 12,
                color:
                  (palette.neutral && palette.neutral[3]) || "#64748B",
                align: "center",
                valign: "middle",
              } as any
            );
          } else {
            const chartData = (viz.series || []).map((s) => ({
              name: s.name,
              labels: viz.labels,
              values: s.values,
            }));
            const { valAxisFormatCode, dataLabelFormatCode } = mapFormatCodes(
              viz.valueFormat
            );

            slide.addChart(
              supported,
              chartData as any,
              {
                x: innerX,
                y: cursorY,
                w: innerW,
                h: H,
                showLegend: (spec.components?.chart?.legend ?? "top") !== "none",
                legendPos: toLegendPos(spec.components?.chart?.legend),
                catAxisLabelColor:
                  (palette.neutral && palette.neutral[3]) || "#64748B",
                valAxisLabelColor:
                  (palette.neutral && palette.neutral[3]) || "#64748B",
                dataLabelColor:
                  (palette.neutral && palette.neutral[3]) || "#64748B",
                barDir: "col",
                chartColors: chartSeriesColors(palette),
                catAxisMajorGridline:
                  spec.components?.chart?.gridlines ?? false,
                valAxisMajorGridline:
                  spec.components?.chart?.gridlines ?? false,
                valAxisFormatCode,
                dataLabelFormatCode,
                // Enable data labels if specified
                showValue: spec.components?.chart?.dataLabels ?? false,
                dataLabelPosition: spec.components?.chart?.dataLabels ? "bestFit" : undefined,
              } as any
            );
          }
          break;
        }

        case "image": {
          const img = spec.content.images!.find((i) => i.id === anchor.refId)!;
          const target = { x: innerX, y: cursorY, w: innerW, h: H };

          const buffer = await fetchImageBuffer(
            img.source?.type === "url" ? img.source.url : undefined
          );

          if (!buffer) {
            // Placeholder if fetch fails
            slide.addShape(pptx.ShapeType.rect, {
              x: target.x,
              y: target.y,
              w: target.w,
              h: target.h,
              fill: {
                color: (palette.neutral && palette.neutral[5]) || "#94A3B8",
                transparency: opacityToTransparency(0.26),
              },
              line: {
                color: (palette.neutral && palette.neutral[5]) || "#94A3B8",
                width: 1,
              },
              rectRadius: 8,
            });
            slide.addText(
              img.alt || "Image",
              {
                x: target.x,
                y: target.y + target.h / 2 - 0.2,
                w: target.w,
                h: 0.4,
                fontFace: fontSans,
                fontSize: 12,
                color:
                  (palette.neutral && palette.neutral[2]) || "#334155",
                align: "center",
                valign: "middle",
              } as any
            );
          } else {
            slide.addImage({
              data: buffer,
              x: target.x,
              y: target.y,
              w: target.w,
              h: target.h,
              sizing: {
                type: (img.fit || "cover") as any,
                w: target.w,
                h: target.h,
              },
            } as any);
          }
          break;
        }

        case "imagePlaceholder": {
          // Accessible placeholder (use transparency field, not 8-digit hex)
          const ph = spec.content.imagePlaceholders!.find(
            (p) => p.id === anchor.refId
          )!;
          slide.addShape(pptx.ShapeType.rect, {
            x: innerX,
            y: cursorY,
            w: innerW,
            h: H,
            fill: {
              color: (palette.neutral && palette.neutral[5]) || "#94A3B8",
              transparency: opacityToTransparency(0.26),
            },
            line: {
              color: (palette.neutral && palette.neutral[5]) || "#94A3B8",
              width: 1,
            },
            rectRadius: 8,
          });
          slide.addText(
            ph.alt,
            {
              x: innerX,
              y: cursorY + H / 2 - 0.2,
              w: innerW,
              h: 0.4,
              fontFace: fontSans,
              fontSize: 12,
              color: (palette.neutral && palette.neutral[2]) || "#334155",
              align: "center",
              valign: "middle",
            } as any
          );
          break;
        }
      }

      cursorY += H + flowGap;
      if (cursorY > regionRect.y + regionRect.h - 0.1) break; // avoid overflow
    }
  }
}

/* -------------------------------------------------------------------------- */
/*                                   Helpers                                   */
/* -------------------------------------------------------------------------- */

type Dims = { w: number; h: number };

function getSlideDims(pptx: PptxGenJS): Dims {
  // PptxGenJS uses 10x5.625 (16:9) and 10x7.5 (4:3)
  const layout = (pptx.layout || "LAYOUT_16x9") as string;
  if (layout === "LAYOUT_4x3") return { w: 10, h: 7.5 };
  return { w: 10, h: 5.625 };
}

function pxToIn(px: number): number {
  return Math.round((px / 72) * 1000) / 1000;
}

function clampNum(n: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, n));
}

function safeFont(value?: string): string {
  return value?.trim() || "Aptos, Calibri, Arial, sans-serif";
}

/** Convert CSS-like opacity [0..1] to PPTX transparency [0..100] */
function opacityToTransparency(opacity: number): number {
  const o = clampNum(opacity, 0, 1);
  return Math.round((1 - o) * 100);
}



/** Compute grid geometry (inches) */
function computeGrid(spec: SlideSpecV1, dims: Dims) {
  const g = spec.layout.grid;
  const margins = {
    t: pxToIn(g.margin.t ?? 32),
    r: pxToIn(g.margin.r ?? 32),
    b: pxToIn(g.margin.b ?? 32),
    l: pxToIn(g.margin.l ?? 32),
  };
  const gutterIn = pxToIn(g.gutter ?? 8);

  const innerW = Math.max(0, dims.w - margins.l - margins.r);
  const innerH = Math.max(0, dims.h - margins.t - margins.b);

  const colW = (innerW - gutterIn * (g.cols - 1)) / g.cols;
  const rowH = (innerH - gutterIn * (g.rows - 1)) / g.rows;

  return {
    originX: margins.l,
    originY: margins.t,
    gutterIn,
    colW,
    rowH,
  };
}

function gridRect(
  region: { rowStart: number; colStart: number; rowSpan: number; colSpan: number },
  grid: { originX: number; originY: number; gutterIn: number; colW: number; rowH: number }
) {
  const x = grid.originX + (region.colStart - 1) * (grid.colW + grid.gutterIn);
  const y = grid.originY + (region.rowStart - 1) * (grid.rowH + grid.gutterIn);
  const w = region.colSpan * grid.colW + (region.colSpan - 1) * grid.gutterIn;
  const h = region.rowSpan * grid.rowH + (region.rowSpan - 1) * grid.gutterIn;
  return { x, y, w, h };
}

type RegionKey = SlideSpecV1["layout"]["regions"][number]["name"];
type Anchor = SlideSpecV1["layout"]["anchors"][number];

function groupAnchorsByRegion(spec: SlideSpecV1) {
  const map = new Map<RegionKey, Anchor[]>();
  for (const a of spec.layout.anchors) {
    map.set(a.region, [...(map.get(a.region) || []), a]);
  }
  return map;
}

type AnchorType =
  | "title"
  | "subtitle"
  | "bullets"
  | "callout"
  | "chart"
  | "image"
  | "imagePlaceholder";

function resolveAnchorType(spec: SlideSpecV1, refId: string): AnchorType | null {
  if (spec.content.title?.id === refId) return "title";
  if (spec.content.subtitle?.id === refId) return "subtitle";
  if (spec.content.bullets?.some((b) => b.id === refId)) return "bullets";
  if (spec.content.callouts?.some((c) => c.id === refId)) return "callout";
  if (spec.content.dataViz?.id === refId) return "chart";
  if (spec.content.images?.some((i) => i.id === refId)) return "image";
  if (spec.content.imagePlaceholders?.some((p) => p.id === refId))
    return "imagePlaceholder";
  return null;
}

function preferredHeight(type: AnchorType, remaining: number): number {
  switch (type) {
    case "title":
      return clampNum(0.65, 0.55, Math.min(0.85, remaining));
    case "subtitle":
      return clampNum(0.45, 0.35, Math.min(0.65, remaining));
    case "bullets":
      return Math.max(remaining - 0.2, 2.0);
    case "callout":
      return clampNum(0.9, 0.6, Math.min(1.1, remaining));
    case "chart":
      return Math.max(1.6, remaining);
    case "image":
    case "imagePlaceholder":
      return clampNum(Math.min(remaining, 3.0), 1.2, 3.0);
  }
}

/* ---------------------------- Charts & formatting --------------------------- */

function mapChartKind(pptx: PptxGenJS, kind?: ChartKind | string | null) {
  const k = (kind || "bar").toString().toLowerCase();
  const T = pptx.ChartType;
  switch (k) {
    case "bar":
      return T.bar;
    case "line":
      return T.line;
    case "pie":
      return T.pie;
    case "doughnut":
      return T.doughnut;
    case "area":
      return T.area;
    case "scatter":
      return T.scatter;
    case "combo":
      // Combo chart: first series as column, second as line
      return T.bar; // Use bar as base, will be enhanced with line overlay
    case "waterfall":
      // Waterfall chart (if supported by pptxgenjs)
      return T.bar; // Fallback to bar
    case "funnel":
      // Funnel chart (if supported by pptxgenjs)
      return T.bar; // Fallback to bar
    default:
      return null;
  }
}

function toLegendPos(pos?: "none" | "right" | "bottom") {
  if (pos === "right") return "r";
  if (pos === "bottom") return "b";
  return "t";
}

function chartSeriesColors(palette: SlideSpecV1["styleTokens"]["palette"]): string[] {
  const neutral = palette.neutral || [];
  const base = [
    palette.primary,
    palette.accent,
    neutral[2],
    neutral[3],
    neutral[4],
    neutral[5],
  ].filter(Boolean) as string[];
  return base;
}

type ValueFormat = NonNullable<SlideSpecV1["content"]["dataViz"]>["valueFormat"];
function mapFormatCodes(fmt: ValueFormat | undefined): {
  valAxisFormatCode?: string;
  dataLabelFormatCode?: string;
} {
  switch (fmt) {
    case "percent":
      return { valAxisFormatCode: "0%", dataLabelFormatCode: "0%" };
    case "currency":
      return { valAxisFormatCode: "$#,##0", dataLabelFormatCode: "$#,##0" };
    case "number":
      return { valAxisFormatCode: "0", dataLabelFormatCode: "0" };
    case "auto":
    default:
      return {};
  }
}

/* ------------------------------ Callout colors ------------------------------ */

function calloutColors(
  variant: "note" | "success" | "warning" | "danger",
  palette: SlideSpecV1["styleTokens"]["palette"]
) {
  switch (variant) {
    case "success":
      return {
        bg: "#D1FAE5",
        border: palette.accent || "#10B981",
        textColor: "#065F46",
      };
    case "warning":
      return { bg: "#FEF3C7", border: "#F59E0B", textColor: "#78350F" };
    case "danger":
      return { bg: "#FEE2E2", border: "#EF4444", textColor: "#7F1D1D" };
    case "note":
    default:
      return {
        bg: "#F3F4F6",
        border: palette.accent || "#EC4899",
        textColor: "#1F2937",
      };
  }
}

/* ------------------------------- Image loader ------------------------------- */

/**
 * Fetch an image as Buffer for embedding with exponential backoff retry.
 * Optimizes image (downscale to 96dpi, convert to JPEG quality 82).
 * Returns null on failure after retries.
 * Only supports source.type === "url" here; other source types fall back to placeholder.
 */
async function fetchImageBuffer(url?: string, maxRetries = 2): Promise<Buffer | null> {
  if (!url) return null;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const controller = new AbortController();
      const timeoutMs = 4000 + attempt * 1000; // Increase timeout on retry
      const t = setTimeout(() => controller.abort(), timeoutMs);

      const res = await undiciFetch(url, { signal: controller.signal });
      clearTimeout(t);

      if (!res.ok) {
        // Don't retry on 4xx errors
        if (res.status >= 400 && res.status < 500) return null;
        // Retry on 5xx or network errors
        if (attempt < maxRetries) continue;
        return null;
      }

      const contentType = res.headers.get("content-type") || "";
      if (!/^image\//i.test(contentType)) return null;

      const ab = await res.arrayBuffer();
      const buffer = Buffer.from(ab);

      // Optimize image: downscale to 96dpi, convert to JPEG (quality 82) unless PNG transparency needed
      const optimized = await optimizeImage(buffer, url);
      return optimized;
    } catch (e) {
      // Retry on network errors
      if (attempt < maxRetries) {
        // Exponential backoff: 100ms, 200ms, 400ms
        await new Promise((resolve) => setTimeout(resolve, 100 * Math.pow(2, attempt)));
        continue;
      }
      return null;
    }
  }

  return null;
}


────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/pptxBuilder/index.ts
SIZE: 3.48 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * PPTX Builder Module (barrel)
 * Exposes:
 *  - buildSlideFromSpec: full SlideSpec renderer using the grid engine
 *  - buildHeaderOnlySlide: legacy/simple title+subtitle slide (back-compat)
 *  - assertValidSpec(s): schema-backed validation for inbound specs
 *  - createPptxFromSpecs: high-level PPTX generator (lazy-loads pptxgenjs)
 *  - SlideSpec / SlideSpecV1 / SlideSpecZ and core type exports
 *
 * Side-effect free and tree-shakeable: no heavy imports at module load.
 */

export { buildSlideFromSpec, buildHeaderOnlySlide } from "./headerOnlyBuilder";
export type { HeaderOnlySlideSpec } from "./headerOnlyBuilder";

import { SlideSpecZ } from "@plzfixthx/slide-spec";
export { SlideSpecZ } from "@plzfixthx/slide-spec";
export type {
  SlideSpec,
  SlideSpecV1,
  ChartKind,
  AspectRatio,
  RegionName,
} from "@plzfixthx/slide-spec";

/* -------------------------------------------------------------------------- */
/*                             Validation Utilities                            */
/* -------------------------------------------------------------------------- */

/** Validate & parse a single spec (throws on invalid). */
export function assertValidSpec(input: unknown): import("@plzfixthx/slide-spec").SlideSpec {
  return SlideSpecZ.parse(input);
}

/** Validate & parse an array of specs (throws with index on invalid). */
export function assertValidSpecs(input: unknown[]): import("@plzfixthx/slide-spec").SlideSpec[] {
  return input.map((s, i) => {
    try {
      return SlideSpecZ.parse(s);
    } catch (e: any) {
      e.message = `Spec at index ${i}: ${e.message || e}`;
      throw e;
    }
  });
}

/* -------------------------------------------------------------------------- */
/*                             Layout Helper (pure)                            */
/* -------------------------------------------------------------------------- */

/** Map aspect ratio to PptxGenJS layout keyword (string literal keeps this module lightweight). */
export function pptxLayoutByAspectRatio(
  ar: import("@plzfixthx/slide-spec").AspectRatio
): "LAYOUT_16x9" | "LAYOUT_4x3" {
  return ar === "4:3" ? "LAYOUT_4x3" : "LAYOUT_16x9";
}

/* -------------------------------------------------------------------------- */
/*                         High-level PPTX generation API                      */
/* -------------------------------------------------------------------------- */

/**
 * Render one or more SlideSpecV1 slides to a .pptx ArrayBuffer.
 * - Lazy-loads pptxgenjs to keep this barrel side-effect free.
 * - Uses the universal builder for each slide.
 */
export async function createPptxFromSpecs(
  specs: import("@plzfixthx/slide-spec").SlideSpec | import("@plzfixthx/slide-spec").SlideSpec[]
): Promise<ArrayBuffer> {
  const arr = Array.isArray(specs) ? specs : [specs];
  if (arr.length === 0) throw new Error("No slides to export");

  // Lazy import so apps that only need types/builders don’t pay the cost.
  const PptxGen = (await import("pptxgenjs")).default as any;
  const pptx: any = new PptxGen();

  pptx.layout = pptxLayoutByAspectRatio(arr[0].meta.aspectRatio);

  // Defer to the universal builder (already handles all content types).
  for (const spec of arr) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    await (await import("./headerOnlyBuilder")).buildSlideFromSpec(pptx, spec as any);
  }

  // ArrayBuffer output aligns with Cloud Functions’ send(Buffer.from(ab)).
  return (pptx.write({ outputType: "arraybuffer" }) as unknown) as Promise<ArrayBuffer>;
}


────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/prompts.ts
SIZE: 8.93 KB
────────────────────────────────────────────────────────────────────────────────

/** World-class system prompt for consulting-firm-quality slide generation */
export const ENHANCED_SYSTEM_PROMPT = `You are the elite SlideSpec generator for plzfixthx. Produce slides that meet board-level standards.

OUTPUT ONLY VALID JSON — NO MARKDOWN, NO EXPLANATIONS, NO COMMENTARY.
Return a SINGLE RFC8259‑compliant JSON object that VALIDATES against SlideSpec v1.

DESIGN PRINCIPLES
- Elegant: Minimal, purposeful, no clutter
- Powerful: Clear visual hierarchy, immediate impact
- Professional: Consulting-firm quality, boardroom-ready
- Sophisticated: Subtle accents, refined typography, premium feel
- Accessible: WCAG AAA contrast (7:1 minimum for text vs. background)

COLOR PALETTE STRATEGY
- Analyze prompt context to select primary color (tech→blue, finance→navy, creative→purple, energy→orange)
- Ensure primary + accent have 7:1+ contrast ratio for accessibility
- Use warm accent colors (#F59E0B, #EA580C, #D97706, #F97316, #DC2626) for visual pop
- Generate 9-step neutral ramp from #0F172A (darkest) to #F8FAFC (lightest)
- Avoid pure black/white; use sophisticated grays for premium feel

REQUIRED JSON SHAPE (ILLUSTRATIVE EXAMPLE)
{
  "meta": { "version": "1.0", "locale": "en-US", "theme": "Professional", "aspectRatio": "16:9" },
  "design": { "pattern": "minimal", "whitespace": { "strategy": "generous", "breathingRoom": 0.3 } },
  "content": {
    "title": { "id": "title", "text": "Accelerate Revenue Growth 40%" },
    "subtitle": { "id": "subtitle", "text": "Data-driven initiatives to expand share and improve unit economics" },
    "bullets": [
      {
        "id": "b1",
        "items": [
          { "text": "Implement AI-assisted pricing across top SKUs", "level": 1 },
          { "text": "A/B test elasticity in 3 priority regions", "level": 2 },
          { "text": "Pilot raises GM by 180 bps within 2 quarters", "level": 3 }
        ]
      }
    ],
    "dataViz": {
      "id": "dataviz",
      "kind": "bar",
      "title": "QoQ Growth by Region",
      "labels": ["Q1","Q2","Q3","Q4"],
      "series": [
        { "name": "North", "values": [8,12,15,18] },
        { "name": "West",  "values": [5,9,11,14] }
      ],
      "valueFormat": "percent"
    },
    "images": [
      {
        "id": "hero1",
        "role": "hero",
        "source": { "type": "url", "url": "https://images.example.com/boardroom.jpg" },
        "alt": "Executive boardroom",
        "fit": "cover"
      }
    ],
    "imagePlaceholders": [
      { "id": "ph1", "role": "illustration", "alt": "Illustration placeholder" }
    ]
  },
  "layout": {
    "grid": { "rows": 8, "cols": 12, "gutter": 8, "margin": { "t": 32, "r": 32, "b": 32, "l": 32 } },
    "regions": [
      { "name": "header", "rowStart": 1, "colStart": 1, "rowSpan": 2, "colSpan": 12 },
      { "name": "body",   "rowStart": 3, "colStart": 1, "rowSpan": 5, "colSpan": 12 }
    ],
    "anchors": [
      { "refId": "title",    "region": "header", "order": 0 },
      { "refId": "subtitle", "region": "header", "order": 1 },
      { "refId": "b1",       "region": "body",   "order": 0 },
      { "refId": "dataviz",  "region": "body",   "order": 1 },
      { "refId": "hero1",    "region": "body",   "order": 2 }
    ]
  },
  "styleTokens": {
    "palette": {
      "primary": "#1E40AF",
      "accent": "#F59E0B",
      "neutral": ["#0F172A","#1E293B","#334155","#475569","#64748B","#94A3B8","#CBD5E1","#E2E8F0","#F8FAFC"]
    },
    "typography": {
      "fonts": { "sans": "Aptos, Arial, sans-serif" },
      "sizes": { "step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 20, "step_2": 28, "step_3": 44 },
      "weights": { "regular": 400, "medium": 500, "semibold": 600, "bold": 700 },
      "lineHeights": { "compact": 1.2, "standard": 1.5 }
    },
    "spacing": { "base": 4, "steps": [0,4,8,12,16,24,32] },
    "radii": { "sm": 4, "md": 8, "lg": 12 },
    "shadows": {
      "sm": "0 2px 4px rgba(0,0,0,.08)",
      "md": "0 4px 12px rgba(0,0,0,.12)",
      "lg": "0 12px 32px rgba(0,0,0,.16)"
    },
    "contrast": { "minTextContrast": 7, "minUiContrast": 4.5 }
  }
}

STRICT RULES (MATCH THE CONTRACT)
1) Required top-level keys: meta, content, layout, styleTokens. Include design (recommended).
2) IDs: [A-Za-z0-9_-] only; provide unique, meaningful IDs.
3) Colors: Hex only (#RRGGBB). Palette.neutral must have EXACTLY 9 colors (dark → light).
4) Bullets: ≤3 groups total; each group has 1–5 items; item.level ∈ {1,2,3}.
5) DataViz:
   - kind ∈ {"bar","line","pie","doughnut","area","scatter","combo","waterfall","funnel"}.
   - labels: 2–10 items; every series.values length == labels length.
   - series: 1–4 series; valueFormat ∈ {"number","percent","currency","auto"}.
   - Note: "combo","waterfall","funnel" may render as placeholders in exporter (still generate valid data).
6) Images:
   - images[i].source.type "url" ⇒ include a valid absolute "url".
   - images[i].source.type "unsplash" ⇒ include a "query".
   - "placeholder" requires neither url nor query.
   - fit ∈ {"cover","contain","fill"}.
   - imagePlaceholders ≤3; images ≤4.
7) Layout:
   - regions MUST fit inside grid (no overflow) and should not overlap.
   - anchors.refId MUST reference an existing content id; order is a non-negative integer.
8) Typography: use professional hierarchy (Title ~44, Subtitle ~20, body ~16) unless space requires smaller.
9) Accessibility:
   - Text vs. background contrast ≥ 7:1 (WCAG AAA).
   - Primary vs. accent contrast ≥ 3:1 for legibility on accents.
10) Primary color must be a professional blue/teal (e.g., #1E40AF, #0369A1, #0891B2, #2563EB).
11) Accent color must be warm/complementary (e.g., #F59E0B, #EA580C, #D97706, #F97316, #DC2626).

CONTENT QUALITY GUARDRAILS
- Title: 4–8 words, ≤60 chars, action-oriented (e.g., Transform, Accelerate, Unlock, Optimize, Drive, Elevate, Maximize).
- Subtitle: 8–15 words, ≤100 chars; adds context without repeating title; use specific metrics or outcomes.
- Bullets: one idea per item, parallel structure; include credible metrics where possible; ≤80 chars per item.
  * Level 1: Main points (bold, primary color)
  * Level 2: Supporting details (regular weight, neutral color)
  * Level 3: Specific examples or data points (smaller, lighter)
- Callouts: Use for key insights, warnings, or success metrics; max 2 per slide.
  * Success: Positive outcomes, achievements, milestones
  * Warning: Important considerations, risks, constraints
  * Note: Additional context, definitions, references
  * Danger: Critical issues, blockers, urgent items

TYPOGRAPHY EXCELLENCE
- Headers: Aptos 26px bold in primary color; 1.2 line-height; -0.02em letter-spacing
- Subtitles: 16px in neutral[3] (#64748B); 1.3 line-height; -0.01em letter-spacing
- Body text: 12px for bullets, 14px for callouts; 1.5 line-height; 0em letter-spacing
- Ensure all text has 7:1 contrast ratio minimum (WCAG AAA)
- Use Aptos as primary font (Microsoft Office standard, highly readable)
- Fallback chain: Aptos → Calibri → Arial → sans-serif

PREMIUM TOUCHES (VISUAL)
- Left accent bar (~0.12in) in primary color for brand presence and visual anchor
- Subtle accent shapes with 8–12% opacity for sophisticated polish (never overwhelming)
- Divider under title (3px solid primary) + small accent dot (9px circle) in accent color
- Generous margins (≈32px) and consistent gutter (≈8px) for breathing room
- Top-right glaze effect (10% opacity accent) for depth and visual interest
- Vertical accent line (88% transparency) for premium feel and sophistication
- Accent placement: strategic, not random; supports visual hierarchy
- Color harmony: primary + accent must have 4.5:1 contrast minimum

INDUSTRY-SPECIFIC GUIDANCE
- Finance/Banking: Use navy/teal palettes, emphasize data precision, include metrics
- Technology: Use modern blues/purples, emphasize innovation, clean layouts
- Healthcare: Use cyan/green palettes, emphasize trust, clear information hierarchy
- Sustainability: Use green palettes, emphasize impact, visual storytelling
- Creative/Marketing: Use vibrant colors, bold typography, dynamic layouts
- Corporate: Use neutral palettes, professional tone, structured content

FAILSAFE BEHAVIOR
- If input is ambiguous, choose pattern "minimal" with generous whitespace.
- If layout is invalid, fallback to header/body layout from the example.
- If colors are invalid, use context-aware palette selection (see COLOR PALETTE STRATEGY).
- Ensure the final JSON passes all constraints above.
- Always prioritize readability and accessibility over aesthetics.

Now output ONLY the JSON object.`;

export const SIMPLE_SYSTEM_PROMPT = `You are SlideSpec generator. Output ONLY valid JSON that validates against SlideSpec v1.
Hard rules:
- meta.version "1.0"; aspectRatio "16:9".
- IDs: [A-Za-z0-9_-]; Colors: #RRGGBB.
- Palette.neutral: exactly 9 colors (dark → light).
- Bullets: ≤3 groups; each 1–5 items; levels 1–3.
- DataViz: labels 2–10; all series.values length == labels length; 1–4 series.
- Images: "url" ⇒ url required; "unsplash" ⇒ query required; "placeholder" needs neither.
Return a SINGLE JSON object, no commentary.`;


────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/security.ts
SIZE: 6.88 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * Security middleware and utilities for plzfixthx functions.
 * Includes rate limiting, request validation, and abuse detection.
 */

import * as logger from "firebase-functions/logger";
import { Request, Response } from "express";
import crypto from "crypto";

/* -------------------------------------------------------------------------- */
/*                            Rate Limiting                                   */
/* -------------------------------------------------------------------------- */

interface RateLimitEntry {
  count: number;
  resetTime: number;
}

// In-memory rate limit store (in production, use Redis or Firestore)
const rateLimitStore = new Map<string, RateLimitEntry>();

// Cleanup old entries every 5 minutes
setInterval(() => {
  const now = Date.now();
  for (const [key, entry] of rateLimitStore.entries()) {
    if (entry.resetTime < now) {
      rateLimitStore.delete(key);
    }
  }
}, 5 * 60 * 1000);

/**
 * Get client identifier from request (IP + User-Agent fingerprint)
 */
export function getClientId(req: Request): string {
  const ip = req.ip || req.socket.remoteAddress || "unknown";
  const userAgent = req.get("user-agent") || "unknown";
  const fingerprint = crypto
    .createHash("sha256")
    .update(`${ip}:${userAgent}`)
    .digest("hex")
    .slice(0, 16);
  return fingerprint;
}

/**
 * Rate limit middleware: max 100 requests per minute per client
 */
export function rateLimitMiddleware(
  req: Request,
  res: Response,
  next: () => void,
  options: { maxRequests?: number; windowMs?: number } = {}
): void {
  const maxRequests = options.maxRequests || 100;
  const windowMs = options.windowMs || 60 * 1000; // 1 minute

  const clientId = getClientId(req);
  const now = Date.now();

  let entry = rateLimitStore.get(clientId);

  if (!entry || entry.resetTime < now) {
    entry = { count: 0, resetTime: now + windowMs };
    rateLimitStore.set(clientId, entry);
  }

  entry.count++;

  // Set rate limit headers
  const remaining = Math.max(0, maxRequests - entry.count);
  const resetTime = Math.ceil(entry.resetTime / 1000);

  res.set("X-RateLimit-Limit", String(maxRequests));
  res.set("X-RateLimit-Remaining", String(remaining));
  res.set("X-RateLimit-Reset", String(resetTime));

  if (entry.count > maxRequests) {
    const retryAfter = Math.ceil((entry.resetTime - now) / 1000);
    logger.warn("Rate limit exceeded", { clientId, count: entry.count, maxRequests, retryAfter });

    // Set Retry-After header
    res.set("Retry-After", String(retryAfter));

    res.status(429).json({
      error: {
        code: "RATE_LIMIT_EXCEEDED",
        message: "Too many requests. Please try again later.",
        details: {
          retryAfter,
          limit: maxRequests,
          window: `${windowMs / 1000}s`,
        },
      },
    });
    return;
  }

  next();
}

/* -------------------------------------------------------------------------- */
/*                         Request Validation                                 */
/* -------------------------------------------------------------------------- */

/**
 * Validate request payload size
 */
export function validatePayloadSize(
  req: Request,
  res: Response,
  next: () => void,
  maxSizeBytes: number = 1024 * 100 // 100KB default
): void {
  const contentLength = parseInt(req.get("content-length") || "0", 10);

  if (contentLength > maxSizeBytes) {
    logger.warn("Payload too large", { contentLength, maxSizeBytes });
    res.status(413).json({
      error: {
        code: "PAYLOAD_TOO_LARGE",
        message: "Request payload exceeds maximum allowed size",
        details: {
          contentLength,
          maxSize: maxSizeBytes,
          maxSizeMB: (maxSizeBytes / 1024 / 1024).toFixed(2),
        },
      },
    });
    return;
  }

  next();
}

/**
 * Sanitize and validate prompt input
 */
export function sanitizePrompt(prompt: string): string {
  if (!prompt || typeof prompt !== "string") {
    throw new Error("Prompt must be a non-empty string");
  }

  // Trim whitespace
  let sanitized = prompt.trim();

  // Max length: 2000 characters
  if (sanitized.length > 2000) {
    sanitized = sanitized.slice(0, 2000);
  }

  // Min length: 3 characters
  if (sanitized.length < 3) {
    throw new Error("Prompt must be at least 3 characters");
  }

  return sanitized;
}

/* -------------------------------------------------------------------------- */
/*                         Abuse Detection                                    */
/* -------------------------------------------------------------------------- */

/**
 * Basic heuristics for detecting obvious abuse/misuse
 */
export function detectAbuse(prompt: string): { isAbusive: boolean; reason?: string } {
  // Check for excessive repetition (e.g., "aaaa...aaaa")
  const repetitionPattern = /(.)\1{20,}/;
  if (repetitionPattern.test(prompt)) {
    return { isAbusive: true, reason: "Excessive character repetition detected" };
  }

  // Check for excessive URLs
  const urlCount = (prompt.match(/https?:\/\//g) || []).length;
  if (urlCount > 5) {
    return { isAbusive: true, reason: "Too many URLs in prompt" };
  }

  // Check for common spam patterns
  const spamPatterns = [
    /viagra|cialis|casino|lottery|prize/i,
    /click here|buy now|limited offer/i,
    /free money|guaranteed|no risk/i,
  ];

  for (const pattern of spamPatterns) {
    if (pattern.test(prompt)) {
      return { isAbusive: true, reason: "Spam pattern detected" };
    }
  }

  return { isAbusive: false };
}

/* -------------------------------------------------------------------------- */
/*                         Request Tracing                                    */
/* -------------------------------------------------------------------------- */

/**
 * Generate or extract request ID for tracing
 */
export function getRequestId(req: Request): string {
  const existing = req.get("x-request-id");
  if (existing) return existing;

  return crypto.randomUUID();
}

/**
 * Add request ID to response headers
 */
export function setRequestId(req: Request, res: Response): string {
  const requestId = getRequestId(req);
  res.set("X-Request-ID", requestId);
  return requestId;
}

/* -------------------------------------------------------------------------- */
/*                         Error Response Helpers                             */
/* -------------------------------------------------------------------------- */

/**
 * Send a safe error response (no sensitive details)
 */
export function sendSafeError(
  res: Response,
  statusCode: number,
  message: string,
  requestId?: string
): void {
  res.status(statusCode).json({
    error: message,
    ...(requestId && { requestId }),
  });
}

/**
 * Send a structured error response
 */
export function sendStructuredError(
  res: Response,
  statusCode: number,
  code: string,
  message: string,
  details?: Record<string, unknown>
): void {
  res.status(statusCode).json({
    error: {
      code,
      message,
      ...(details && { details }),
    },
  });
}




────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/themePresets.ts
SIZE: 4.01 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * Theme Presets Module
 * - Predefined professional themes (Corporate, Tech, Finance, Healthcare, Sustainability, Luxury)
 * - Support for brand primary color input with auto-correction to nearest compliant color
 * - Ensures WCAG AAA contrast compliance (7:1 for text, 4.5:1 for UI accents)
 */

import { contrastRatio, nearestCompliantColor } from "./colorUtils";

export interface ThemePreset {
  name: string;
  primary: string;
  accent: string;
  neutral: string[];
  description: string;
}

/** Professional theme presets */
export const THEME_PRESETS: Record<string, ThemePreset> = {
  corporate: {
    name: "Corporate",
    primary: "#1E40AF", // Deep blue
    accent: "#DC2626", // Red
    neutral: [
      "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
      "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
    ],
    description: "Professional, trustworthy, traditional",
  },

  tech: {
    name: "Tech",
    primary: "#7C3AED", // Purple
    accent: "#06B6D4", // Cyan
    neutral: [
      "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
      "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
    ],
    description: "Modern, innovative, forward-thinking",
  },

  finance: {
    name: "Finance",
    primary: "#065F46", // Dark green
    accent: "#DC2626", // Red
    neutral: [
      "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
      "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
    ],
    description: "Stable, secure, growth-oriented",
  },

  healthcare: {
    name: "Healthcare",
    primary: "#0369A1", // Sky blue
    accent: "#059669", // Green
    neutral: [
      "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
      "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
    ],
    description: "Caring, trustworthy, professional",
  },

  sustainability: {
    name: "Sustainability",
    primary: "#15803D", // Green
    accent: "#EA580C", // Orange
    neutral: [
      "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
      "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
    ],
    description: "Eco-conscious, responsible, natural",
  },

  luxury: {
    name: "Luxury",
    primary: "#1F2937", // Dark gray
    accent: "#D97706", // Gold
    neutral: [
      "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
      "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
    ],
    description: "Elegant, premium, sophisticated",
  },
};

/**
 * Get theme preset by name
 */
export function getThemePreset(name: string): ThemePreset | null {
  return THEME_PRESETS[name.toLowerCase()] || null;
}

/**
 * Apply brand primary color to a theme preset
 * Auto-corrects color to nearest compliant color if needed
 */
export function applyBrandColor(
  preset: ThemePreset,
  brandPrimary: string
): ThemePreset {
  // Validate and correct brand color for WCAG AAA compliance
  const correctedPrimary = nearestCompliantColor(brandPrimary, preset.neutral);

  return {
    ...preset,
    primary: correctedPrimary,
  };
}

/**
 * Get all available theme names
 */
export function getAvailableThemes(): string[] {
  return Object.keys(THEME_PRESETS);
}

/**
 * Validate theme has proper contrast
 */
export function validateThemeContrast(theme: ThemePreset): {
  valid: boolean;
  issues: string[];
} {
  const issues: string[] = [];
  const white = "#FFFFFF";
  const black = "#000000";

  // Check primary color contrast
  const primaryVsWhite = contrastRatio(theme.primary, white);
  const primaryVsBlack = contrastRatio(theme.primary, black);
  const primaryContrast = Math.max(primaryVsWhite, primaryVsBlack);

  if (primaryContrast < 4.5) {
    issues.push(`Primary color contrast too low: ${primaryContrast.toFixed(2)}:1 (need ≥4.5:1)`);
  }

  // Check accent color contrast
  const accentVsWhite = contrastRatio(theme.accent, white);
  const accentVsBlack = contrastRatio(theme.accent, black);
  const accentContrast = Math.max(accentVsWhite, accentVsBlack);

  if (accentContrast < 4.5) {
    issues.push(`Accent color contrast too low: ${accentContrast.toFixed(2)}:1 (need ≥4.5:1)`);
  }

  return {
    valid: issues.length === 0,
    issues,
  };
}




────────────────────────────────────────────────────────────────────────────────
FILE: functions/src/typographyEnhancer.ts
SIZE: 7.57 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * Typography Enhancement Module
 * Provides advanced typography utilities for professional slide generation
 */

/* -------------------------------------------------------------------------- */
/*                        Font Pairing Recommendations                        */
/* -------------------------------------------------------------------------- */

export interface FontPair {
  display: string;
  body: string;
  description: string;
}

const PROFESSIONAL_FONT_PAIRS: Record<string, FontPair> = {
  modern: {
    display: "Aptos, Calibri, Arial",
    body: "Aptos, Calibri, Arial",
    description: "Modern, clean, Microsoft Office standard",
  },
  elegant: {
    display: "Georgia, Garamond, serif",
    body: "Calibri, Arial, sans-serif",
    description: "Elegant serif headers with clean body",
  },
  corporate: {
    display: "Aptos, Arial, sans-serif",
    body: "Aptos, Arial, sans-serif",
    description: "Corporate standard, highly readable",
  },
  tech: {
    display: "Aptos, Arial, sans-serif",
    body: "Aptos, Arial, sans-serif",
    description: "Tech-forward, modern sans-serif",
  },
};

/* -------------------------------------------------------------------------- */
/*                      Typography Size Scaling                               */
/* -------------------------------------------------------------------------- */

export interface TypographyScale {
  h1: number;
  h2: number;
  h3: number;
  body: number;
  small: number;
  caption: number;
}

/**
 * Generate a typographic scale based on a base size
 * Uses a 1.25 modular scale (perfect fifth)
 */
export function generateTypographyScale(baseSize: number = 16): TypographyScale {
  const ratio = 1.25; // Perfect fifth
  return {
    h1: Math.round(baseSize * Math.pow(ratio, 4)), // 44px
    h2: Math.round(baseSize * Math.pow(ratio, 3)), // 35px
    h3: Math.round(baseSize * Math.pow(ratio, 2)), // 28px
    body: baseSize, // 16px
    small: Math.round(baseSize * Math.pow(ratio, -1)), // 13px
    caption: Math.round(baseSize * Math.pow(ratio, -2)), // 10px
  };
}

/* -------------------------------------------------------------------------- */
/*                      Line Height Recommendations                           */
/* -------------------------------------------------------------------------- */

export interface LineHeightGuide {
  display: number;
  heading: number;
  body: number;
  compact: number;
}

export const LINE_HEIGHT_GUIDE: LineHeightGuide = {
  display: 1.1, // Tight for large headlines
  heading: 1.2, // Tight for subheadings
  body: 1.5, // Standard for body text
  compact: 1.3, // Slightly tight for UI
};

/* -------------------------------------------------------------------------- */
/*                      Letter Spacing Recommendations                        */
/* -------------------------------------------------------------------------- */

export interface LetterSpacingGuide {
  display: number;
  heading: number;
  body: number;
  caption: number;
}

export const LETTER_SPACING_GUIDE: LetterSpacingGuide = {
  display: -0.02, // Negative for large text
  heading: -0.01,
  body: 0,
  caption: 0.01, // Positive for small text
};

/* -------------------------------------------------------------------------- */
/*                      Font Weight Recommendations                           */
/* -------------------------------------------------------------------------- */

export interface FontWeightGuide {
  light: number;
  regular: number;
  medium: number;
  semibold: number;
  bold: number;
}

export const FONT_WEIGHT_GUIDE: FontWeightGuide = {
  light: 300,
  regular: 400,
  medium: 500,
  semibold: 600,
  bold: 700,
};

/* -------------------------------------------------------------------------- */
/*                      Professional Typography Presets                       */
/* -------------------------------------------------------------------------- */

export interface TypographyPreset {
  fonts: FontPair;
  scale: TypographyScale;
  lineHeights: LineHeightGuide;
  letterSpacing: LetterSpacingGuide;
  weights: FontWeightGuide;
}

/**
 * Get a professional typography preset
 */
export function getTypographyPreset(style: string = "modern"): TypographyPreset {
  const fontPair = PROFESSIONAL_FONT_PAIRS[style] || PROFESSIONAL_FONT_PAIRS.modern;
  
  return {
    fonts: fontPair,
    scale: generateTypographyScale(16),
    lineHeights: LINE_HEIGHT_GUIDE,
    letterSpacing: LETTER_SPACING_GUIDE,
    weights: FONT_WEIGHT_GUIDE,
  };
}

/* -------------------------------------------------------------------------- */
/*                      Text Fitting & Optimization                           */
/* -------------------------------------------------------------------------- */

/**
 * Calculate optimal font size for text to fit in a box using binary search
 * Considers text length, box dimensions, and line height
 * Respects minimum size constraints for accessibility
 */
export function calculateOptimalFontSize(
  text: string,
  maxWidth: number,
  maxHeight: number,
  startSize: number = 26,
  minSize: number = 12,
  lineHeight: number = 1.2
): number {
  // Enforce minimum sizes for accessibility
  const MIN_BODY = 11;

  // Determine actual minimum based on context
  const actualMinSize = Math.max(minSize, MIN_BODY);
  const actualStartSize = Math.min(startSize, 44); // Cap at 44pt

  if (actualStartSize <= actualMinSize) {
    return actualMinSize;
  }

  // Binary search for optimal size
  let low = actualMinSize;
  let high = actualStartSize;
  let bestSize = actualMinSize;

  while (low <= high) {
    const mid = Math.floor((low + high) / 2);

    if (canFitText(text, maxWidth, maxHeight, mid, lineHeight)) {
      bestSize = mid;
      low = mid + 1; // Try larger
    } else {
      high = mid - 1; // Try smaller
    }
  }

  return bestSize;
}

/**
 * Check if text can fit in box at given font size
 */
function canFitText(
  text: string,
  maxWidth: number,
  maxHeight: number,
  fontSize: number,
  lineHeight: number
): boolean {
  // Estimate character width: ~0.5em per character at given size
  const charWidthIn = (fontSize / 72) * 0.5;
  const lineHeightIn = (fontSize / 72) * lineHeight;

  // Calculate how many characters fit per line
  const charsPerLine = Math.max(1, Math.floor(maxWidth / charWidthIn));

  // Calculate how many lines fit in height
  const maxLines = Math.max(1, Math.floor(maxHeight / lineHeightIn));

  // Calculate total capacity with 5% safety margin
  const capacity = Math.floor(charsPerLine * maxLines * 0.95);

  return text.length <= capacity;
}

/**
 * Truncate text with ellipsis if it doesn't fit
 */
export function truncateWithEllipsis(
  text: string,
  maxWidth: number,
  maxHeight: number,
  fontSize: number,
  lineHeight: number = 1.2
): string {
  if (canFitText(text, maxWidth, maxHeight, fontSize, lineHeight)) {
    return text;
  }

  // Estimate how many characters fit
  const charWidthIn = (fontSize / 72) * 0.5;
  const lineHeightIn = (fontSize / 72) * lineHeight;
  const charsPerLine = Math.max(1, Math.floor(maxWidth / charWidthIn));
  const maxLines = Math.max(1, Math.floor(maxHeight / lineHeightIn));
  const capacity = Math.floor(charsPerLine * maxLines * 0.95);

  // Reserve 3 characters for ellipsis
  const maxChars = Math.max(10, capacity - 3);
  return text.slice(0, maxChars).trim() + "…";
}

/**
 * Truncate text with ellipsis if it exceeds max length
 */
export function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength - 3).trim() + "...";
}

export default {
  getTypographyPreset,
  generateTypographyScale,
  calculateOptimalFontSize,
  truncateText,
};




────────────────────────────────────────────────────────────────────────────────
FILE: functions/tsconfig.dev.json
SIZE: 0.04 KB
────────────────────────────────────────────────────────────────────────────────

{
  "include": [
    ".eslintrc.js"
  ]
}



────────────────────────────────────────────────────────────────────────────────
FILE: functions/tsconfig.json
SIZE: 0.50 KB
────────────────────────────────────────────────────────────────────────────────

{
  "compilerOptions": {
    "module": "esnext",
    "target": "ES2022",
    "lib": ["ES2022", "DOM"],
    "outDir": "lib",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  },
  "compileOnSave": true,
  "exclude": ["node_modules", "lib", "**/*.test.ts"]
}



────────────────────────────────────────────────────────────────────────────────
FILE: package.json
SIZE: 1.13 KB
────────────────────────────────────────────────────────────────────────────────

{
  "name": "plzfixthx",
  "version": "1.0.0",
  "description": "Professional PowerPoint slide generation with AI",
  "private": true,
  "scripts": {
    "install:all": "npm install && npm install --prefix functions && npm install --prefix web",
    "build": "npm run build --prefix functions && npm run build --prefix web",
    "build:functions": "npm run build --prefix functions",
    "build:web": "npm run build --prefix web",
    "dev": "npm run dev --prefix web",
    "dev:functions": "npm run serve --prefix functions",
    "lint": "npm run lint --prefix functions && npm run lint --prefix web",
    "test": "npm run test --prefix functions && npm run test --prefix web",
    "test:functions": "npm run test --prefix functions",
    "test:web": "npm run test --prefix web",
    "deploy": "npm run build && firebase deploy",
    "deploy:functions": "npm run deploy --prefix functions",
    "deploy:web": "npm run build:web && firebase deploy --only hosting",
    "deploy:all": "npm run build && firebase deploy"
  },
  "keywords": [
    "powerpoint",
    "slides",
    "ai",
    "generation"
  ],
  "author": "salscrudato",
  "license": "MIT"
}




────────────────────────────────────────────────────────────────────────────────
FILE: shared/slideSpec/package.json
SIZE: 0.44 KB
────────────────────────────────────────────────────────────────────────────────

{
  "name": "@plzfixthx/slide-spec",
  "version": "1.0.0",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "scripts": {
    "build": "tsc",
    "test": "vitest"
  },
  "dependencies": {
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "typescript": "^5.7.3",
    "vitest": "^1.0.0"
  },
  "private": true
}


────────────────────────────────────────────────────────────────────────────────
FILE: shared/slideSpec/src/index.test.ts
SIZE: 7.13 KB
────────────────────────────────────────────────────────────────────────────────

import { describe, it, expect } from "vitest";
import { SlideSpecZ, safePalette } from "./index";

describe("SlideSpec Schema", () => {
  describe("safePalette", () => {
    it("should accept valid hex colors", () => {
      const result = safePalette({
        primary: "#1E40AF",
        accent: "#F59E0B",
        neutral: ["#000000", "#111111", "#222222", "#333333", "#444444", "#555555", "#666666", "#777777", "#888888"],
      });

      expect(result.primary).toBe("#1E40AF");
      expect(result.accent).toBe("#F59E0B");
      expect(result.neutral.length).toBe(9);
    });

    it("should use defaults for invalid colors", () => {
      const result = safePalette({
        primary: "invalid",
        accent: "also-invalid",
      });

      expect(result.primary).toBe("#1E40AF");
      expect(result.accent).toBe("#F59E0B");
    });

    it("should pad neutral palette to 9 colors", () => {
      const result = safePalette({
        neutral: ["#000000", "#111111", "#222222"],
      });

      expect(result.neutral.length).toBe(9);
    });

    it("should filter invalid colors from neutral palette", () => {
      const result = safePalette({
        neutral: ["#000000", "invalid", "#111111", "also-invalid", "#222222", "#333333", "#444444", "#555555"],
      });

      expect(result.neutral.length).toBe(9);
      expect(result.neutral.every((c) => /^#[0-9A-Fa-f]{6}$/.test(c))).toBe(true);
    });

    it("should use default neutral if insufficient valid colors", () => {
      const result = safePalette({
        neutral: ["#000000", "invalid"],
      });

      expect(result.neutral.length).toBe(9);
    });
  });

  describe("SlideSpecZ validation", () => {
    const validSpec = {
      meta: {
        version: "1.0" as const,
        locale: "en-US",
        theme: "light",
        aspectRatio: "16:9" as const,
      },
      content: {
        title: {
          id: "title",
          text: "Test Slide",
        },
      },
      layout: {
        grid: {
          rows: 6,
          cols: 6,
          gutter: 16,
          margin: { t: 32, r: 32, b: 32, l: 32 },
        },
        regions: [
          {
            name: "header" as const,
            rowStart: 1,
            colStart: 1,
            rowSpan: 2,
            colSpan: 6,
          },
        ],
        anchors: [
          {
            refId: "title",
            region: "header" as const,
            order: 0,
          },
        ],
      },
      styleTokens: {
        palette: {
          primary: "#1E40AF",
          accent: "#F59E0B",
          neutral: ["#0F172A", "#1E293B", "#334155", "#475569", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC"],
        },
        typography: {
          fonts: { sans: "Inter, sans-serif" },
          sizes: {
            "step_-2": 12,
            "step_-1": 14,
            step_0: 16,
            step_1: 20,
            step_2: 24,
            step_3: 44,
          },
          weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
          lineHeights: { compact: 1.2, standard: 1.5 },
        },
        spacing: { base: 4, steps: [4, 8, 12, 16, 24, 32, 48, 64] },
        radii: { sm: 4, md: 8, lg: 16 },
        shadows: { sm: "0 1px 2px rgba(0,0,0,0.05)", md: "0 4px 6px rgba(0,0,0,0.1)", lg: "0 10px 15px rgba(0,0,0,0.1)" },
        contrast: { minTextContrast: 7, minUiContrast: 4.5 },
      },
    };

    it("should validate a complete spec", () => {
      const result = SlideSpecZ.safeParse(validSpec);
      expect(result.success).toBe(true);
    });

    it("should reject duplicate content IDs", () => {
      const spec = {
        ...validSpec,
        content: {
          ...validSpec.content,
          title: { id: "same-id", text: "Title" },
          subtitle: { id: "same-id", text: "Subtitle" },
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(false);
    });

    it("should reject anchors referencing non-existent content", () => {
      const spec = {
        ...validSpec,
        layout: {
          ...validSpec.layout,
          anchors: [
            {
              refId: "non-existent",
              region: "header" as const,
              order: 0,
            },
          ],
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(false);
    });

    it("should reject regions that exceed grid bounds", () => {
      const spec = {
        ...validSpec,
        layout: {
          ...validSpec.layout,
          regions: [
            {
              name: "header" as const,
              rowStart: 1,
              colStart: 1,
              rowSpan: 10, // Exceeds 6 rows
              colSpan: 6,
            },
          ],
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(false);
    });

    it("should reject overlapping regions", () => {
      const spec = {
        ...validSpec,
        layout: {
          ...validSpec.layout,
          regions: [
            {
              name: "header" as const,
              rowStart: 1,
              colStart: 1,
              rowSpan: 3,
              colSpan: 6,
            },
            {
              name: "body" as const,
              rowStart: 2,
              colStart: 1,
              rowSpan: 3,
              colSpan: 6,
            },
          ],
          anchors: [
            {
              refId: "title",
              region: "header" as const,
              order: 0,
            },
          ],
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(false);
    });

    it("should reject dataViz with mismatched series lengths", () => {
      const spec = {
        ...validSpec,
        content: {
          ...validSpec.content,
          dataViz: {
            id: "chart",
            kind: "bar" as const,
            labels: ["Q1", "Q2", "Q3"],
            series: [
              { name: "Series 1", values: [10, 20] }, // Only 2 values
            ],
          },
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(false);
    });

    it("should reject non-ascending typography sizes", () => {
      const spec = {
        ...validSpec,
        styleTokens: {
          ...validSpec.styleTokens,
          typography: {
            ...validSpec.styleTokens.typography,
            sizes: {
              "step_-2": 12,
              "step_-1": 14,
              step_0: 16,
              step_1: 15, // Not ascending
              step_2: 24,
              step_3: 44,
            },
          },
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(false);
    });

    it("should accept optional fields", () => {
      const spec = {
        ...validSpec,
        design: {
          pattern: "hero" as const,
          whitespace: {
            strategy: "generous" as const,
            breathingRoom: 0.5,
          },
        },
        content: {
          ...validSpec.content,
          subtitle: { id: "subtitle", text: "Subtitle" },
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(true);
    });
  });
});




────────────────────────────────────────────────────────────────────────────────
FILE: shared/slideSpec/src/index.ts
SIZE: 18.62 KB
────────────────────────────────────────────────────────────────────────────────

import { z } from "zod";

/* -------------------------------------------------------------------------- */
/*                                   Types                                    */
/* -------------------------------------------------------------------------- */

/** Aspect ratios supported by the deck */
export type AspectRatio = "16:9" | "4:3";

/** Named layout regions (grid areas) */
export type RegionName = "header" | "body" | "footer" | "aside";

/** Chart kinds supported by the universal builder/preview (others show placeholders) */
export type ChartKind =
  | "bar"
  | "line"
  | "pie"
  | "doughnut"
  | "area"
  | "scatter"
  | "combo"
  | "waterfall"
  | "funnel";

/** Value formatting hints for charts */
export type ChartValueFormat = "number" | "percent" | "currency" | "auto";

/** Optional high-level design intent to influence layout/style heuristics */
export interface DesignSpec {
  pattern: "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused";
  whitespace?: {
    strategy: "generous" | "balanced" | "compact";
    /** Additional breathing room hint in inches (0–0.75 typical). */
    breathingRoom?: number;
  };
}

/** Title alignment options */
export type TitleAlign = "left" | "center" | "right";

/** Chart legend position options */
export type ChartLegend = "none" | "right" | "bottom";

/** Image fit options */
export type ImageFit = "cover" | "contain" | "fill";

/** Image role/purpose */
export type ImageRole = "hero" | "logo" | "illustration" | "icon" | "background";

/** Typography scale definition */
export interface TypographyScale {
  fonts: { sans: string; serif?: string; mono?: string };
  sizes: {
    "step_-2": number;
    "step_-1": number;
    step_0: number;
    step_1: number;
    step_2: number;
    step_3: number;
  };
  weights: { regular: number; medium: number; semibold: number; bold: number };
  lineHeights: { compact: number; standard: number };
}

/** Style tokens for theming */
export interface StyleTokens {
  palette: { primary: string; accent: string; neutral: string[] };
  typography: TypographyScale;
  spacing: { base: number; steps: number[] };
  radii: { sm: number; md: number; lg: number };
  shadows: { sm: string; md: string; lg: string };
  contrast: { minTextContrast: number; minUiContrast: number };
}

/* -------------------------------------------------------------------------- */
/*                                 Zod helpers                                */
/* -------------------------------------------------------------------------- */

const HEX6 = /^#[0-9A-Fa-f]{6}$/;
const ID_RX = /^[A-Za-z0-9_-]+$/;

const idStr = z.string().regex(ID_RX, "IDs must contain only letters, numbers, underscores, or hyphens.");
const colorHex = z.string().regex(HEX6, "Color must be a #RRGGBB hex value.");

/**
 * Runtime palette sanitizer: ensures primary/accent are valid hex6,
 * and neutral is a 9-step scale (dark → light).
 */
export function safePalette(p: {
  primary?: string;
  accent?: string;
  neutral?: string[];
}): { primary: string; accent: string; neutral: string[] } {
  const DEFAULT_NEUTRAL_9 = [
    "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
    "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
  ];

  const isHex6 = (color: string | undefined | null): color is string =>
    !!color && /^#[0-9A-Fa-f]{6}$/.test(color);

  const primary = isHex6(p.primary) ? p.primary : "#1E40AF";
  const accent = isHex6(p.accent) ? p.accent : "#F59E0B";

  const neutral =
    Array.isArray(p.neutral) && p.neutral.filter(isHex6).length >= 5
      ? (() => {
          const cleaned = p.neutral.filter(isHex6).slice(0, 9);
          while (cleaned.length < 9) cleaned.push(DEFAULT_NEUTRAL_9[cleaned.length]);
          return cleaned;
        })()
      : [...DEFAULT_NEUTRAL_9];

  return { primary, accent, neutral };
}

/* -------------------------------------------------------------------------- */
/*                                Zod Schema                                  */
/* -------------------------------------------------------------------------- */

export const SlideSpecZ = z
  .object({
    meta: z.object({
      version: z.literal("1.0"),
      locale: z.string(),
      theme: z.string(),
      aspectRatio: z.enum(["16:9", "4:3"]),
    }),

    /** Design hints (optional but recommended by prompts) */
    design: z
      .object({
        pattern: z.enum(["hero", "split", "asymmetric", "grid", "minimal", "data-focused"]),
        whitespace: z
          .object({
            strategy: z.enum(["generous", "balanced", "compact"]).optional(),
            breathingRoom: z.number().min(0).max(0.75).optional(),
          })
          .optional(),
      })
      .optional(),

    content: z.object({
      title: z.object({
        id: idStr,
        text: z.string().min(1).max(60, "Title must be ≤ 60 characters."),
      }),
      subtitle: z
        .object({
          id: idStr,
          text: z.string().min(1).max(100, "Subtitle must be ≤ 100 characters."),
        })
        .optional(),

      bullets: z
        .array(
          z.object({
            id: idStr,
            items: z
              .array(
                z.object({
                  text: z.string().min(1).max(80, "Bullet text must be ≤ 80 characters."),
                  level: z.union([z.literal(1), z.literal(2), z.literal(3)]),
                })
              )
              .min(1)
              .max(5),
          })
        )
        .max(3)
        .optional(),

      callouts: z
        .array(
          z.object({
            id: idStr,
            title: z.string().optional(),
            text: z.string().min(1),
            variant: z.enum(["note", "success", "warning", "danger"]),
            elevated: z.boolean().optional(), // Optional elevated variant for callouts
          })
        )
        .max(2)
        .optional(),

      /** Speaker notes (presenter view only, not rendered on slide) */
      speakerNotes: z
        .object({
          id: idStr,
          text: z.string().min(1).max(500, "Speaker notes must be ≤ 500 characters."),
        })
        .optional(),

      /** Optional table content */
      table: z
        .object({
          id: idStr,
          title: z.string().optional(),
          headers: z.array(z.string()).min(1).max(6),
          rows: z
            .array(z.array(z.string()).min(1).max(6))
            .min(1)
            .max(10),
        })
        .optional(),

      dataViz: z
        .object({
          id: idStr,
          kind: z.enum(["bar", "line", "pie", "doughnut", "area", "scatter", "combo", "waterfall", "funnel"]),
          title: z.string().optional(),
          labels: z.array(z.string()).min(2).max(10),
          series: z
            .array(
              z.object({
                name: z.string().min(1),
                values: z.array(z.number()),
              })
            )
            .min(1)
            .max(4),
          valueFormat: z.enum(["number", "percent", "currency", "auto"]).optional(),
        })
        .optional(),

      /** For preview placeholders when real images are not yet resolved */
      imagePlaceholders: z
        .array(
          z.object({
            id: idStr,
            role: z.enum(["hero", "logo", "illustration", "icon", "background"]),
            alt: z.string(),
          })
        )
        .max(3)
        .optional(),

      /** Concrete images (optional) with sourcing hints */
      images: z
        .array(
          z.object({
            id: idStr,
            role: z.enum(["hero", "logo", "illustration", "icon", "background"]),
            source: z.object({
              type: z.enum(["url", "unsplash", "placeholder"]),
              url: z.string().url().optional(),
              query: z.string().optional(),
            }),
            alt: z.string(),
            fit: z.enum(["cover", "contain", "fill"]).optional(),
          })
        )
        .max(4)
        .optional(),
    }),

    layout: z.object({
      grid: z.object({
        rows: z.number().int().min(3).max(12),
        cols: z.number().int().min(3).max(12),
        gutter: z.number().min(0),
        margin: z.object({ t: z.number(), r: z.number(), b: z.number(), l: z.number() }),
      }),
      regions: z
        .array(
          z.object({
            name: z.enum(["header", "body", "footer", "aside"]),
            rowStart: z.number().int().positive(),
            colStart: z.number().int().positive(),
            rowSpan: z.number().int().positive(),
            colSpan: z.number().int().positive(),
          })
        )
        .min(1)
        .max(6),
      anchors: z
        .array(
          z.object({
            refId: idStr,
            region: z.enum(["header", "body", "footer", "aside"]),
            order: z.number().int().min(0),
            span: z
              .object({ rows: z.number().int().positive(), cols: z.number().int().positive() })
              .optional(),
          })
        )
        .min(1)
        .max(10),
    }),

    styleTokens: z.object({
      palette: z.object({
        primary: colorHex,
        accent: colorHex,
        neutral: z.array(colorHex).length(9),
      }),
      typography: z.object({
        fonts: z.object({ sans: z.string(), serif: z.string().optional(), mono: z.string().optional() }),
        sizes: z.object({
          "step_-2": z.number(),
          "step_-1": z.number(),
          step_0: z.number(),
          step_1: z.number(),
          step_2: z.number(),
          step_3: z.number(),
        }),
        weights: z.object({ regular: z.number(), medium: z.number(), semibold: z.number(), bold: z.number() }),
        lineHeights: z.object({ compact: z.number(), standard: z.number() }),
      }),
      spacing: z.object({ base: z.number(), steps: z.array(z.number()).min(5).max(10) }),
      radii: z.object({ sm: z.number(), md: z.number(), lg: z.number() }),
      shadows: z.object({ sm: z.string(), md: z.string(), lg: z.string() }),
      contrast: z.object({
        minTextContrast: z.number().min(7, "minTextContrast must be ≥ 7"),
        minUiContrast: z.number().min(4.5, "minUiContrast must be ≥ 4.5"),
      }),
    }),

    components: z
      .object({
        bulletList: z.object({ variant: z.enum(["compact", "spacious"]).optional() }).optional(),
        callout: z.object({ variant: z.enum(["flat", "elevated"]).optional() }).optional(),
        chart: z
          .object({
            legend: z.enum(["none", "right", "bottom"]).optional(),
            gridlines: z.boolean().optional(),
            dataLabels: z.boolean().optional(),
          })
          .optional(),
        image: z.object({ fit: z.enum(["cover", "contain", "fill"]).optional() }).optional(),
        title: z.object({ align: z.enum(["left", "center", "right"]).optional() }).optional(),
      })
      .optional(),
  })
  .superRefine((value, ctx) => {
    // Collect content IDs
    const c = value.content;
    const allContentIds: string[] = [];
    if (c.title?.id) allContentIds.push(c.title.id);
    if (c.subtitle?.id) allContentIds.push(c.subtitle.id);
    (c.bullets || []).forEach((b) => allContentIds.push(b.id));
    (c.callouts || []).forEach((co) => allContentIds.push(co.id));
    if (c.dataViz?.id) allContentIds.push(c.dataViz.id);
    (c.imagePlaceholders || []).forEach((ph) => allContentIds.push(ph.id));
    (c.images || []).forEach((img) => allContentIds.push(img.id));
    if (c.speakerNotes?.id) allContentIds.push(c.speakerNotes.id);
    if (c.table?.id) allContentIds.push(c.table.id);

    // 1) IDs across content must be unique
    const seen = new Set<string>();
    for (let i = 0; i < allContentIds.length; i++) {
      const id = allContentIds[i];
      if (seen.has(id)) {
        ctx.addIssue({
          code: "custom",
          path: ["content"],
          message: `Duplicate content id "${id}" detected.`,
        });
      }
      seen.add(id);
    }

    // 2) Anchors must reference existing content IDs and be unique by refId
    const allowed = new Set(allContentIds);
    const anchorRefSeen = new Set<string>();
    value.layout.anchors.forEach((a, i) => {
      if (!allowed.has(a.refId)) {
        ctx.addIssue({
          code: "custom",
          path: ["layout", "anchors", i, "refId"],
          message: `refId "${a.refId}" does not match any content id`,
        });
      }
      if (anchorRefSeen.has(a.refId)) {
        ctx.addIssue({
          code: "custom",
          path: ["layout", "anchors", i, "refId"],
          message: `refId "${a.refId}" is anchored more than once`,
        });
      }
      anchorRefSeen.add(a.refId);
    });

    // 3) Region bounds and non-overlap
    const { rows, cols } = value.layout.grid;
    type R = (typeof value.layout.regions)[number];
    const end = (r: R) => ({
      rowEnd: r.rowStart + r.rowSpan - 1,
      colEnd: r.colStart + r.colSpan - 1,
    });

    value.layout.regions.forEach((r, i) => {
      const { rowEnd, colEnd } = end(r);
      if (rowEnd > rows) {
        ctx.addIssue({
          code: "custom",
          path: ["layout", "regions", i, "rowSpan"],
          message: `region exceeds grid rows (rows=${rows})`,
        });
      }
      if (colEnd > cols) {
        ctx.addIssue({
          code: "custom",
          path: ["layout", "regions", i, "colSpan"],
          message: `region exceeds grid cols (cols=${cols})`,
        });
      }
    });

    for (let i = 0; i < value.layout.regions.length; i++) {
      for (let j = i + 1; j < value.layout.regions.length; j++) {
        const a = value.layout.regions[i];
        const b = value.layout.regions[j];
        const aEnd = end(a);
        const bEnd = end(b);
        const rowsOverlap = !(aEnd.rowEnd < b.rowStart || bEnd.rowEnd < a.rowStart);
        const colsOverlap = !(aEnd.colEnd < b.colStart || bEnd.colEnd < a.colStart);
        if (rowsOverlap && colsOverlap) {
          ctx.addIssue({
            code: "custom",
            path: ["layout", "regions", j],
            message: `region "${b.name}" overlaps with region "${a.name}"`,
          });
        }
      }
    }

    // 4) Anchor order must be unique within each region
    const ordersByRegion = new Map<RegionName, Set<number>>();
    value.layout.anchors.forEach((a, i) => {
      const set = ordersByRegion.get(a.region) ?? new Set<number>();
      if (set.has(a.order)) {
        ctx.addIssue({
          code: "custom",
          path: ["layout", "anchors", i, "order"],
          message: `Duplicate order ${a.order} in region "${a.region}"`,
        });
      }
      set.add(a.order);
      ordersByRegion.set(a.region, set);

      if (a.span) {
        const region = value.layout.regions.find((r) => r.name === a.region);
        if (region) {
          if (a.span.rows > region.rowSpan || a.span.cols > region.colSpan) {
            ctx.addIssue({
              code: "custom",
              path: ["layout", "anchors", i, "span"],
              message: `Anchor span exceeds available space of region "${a.region}"`,
            });
          }
        }
      }
    });

    // 5) DataViz series must match labels length
    if (c.dataViz) {
      const L = c.dataViz.labels.length;
      c.dataViz.series.forEach((s, j) => {
        if (s.values.length !== L) {
          ctx.addIssue({
            code: "custom",
            path: ["content", "dataViz", "series", j, "values"],
            message: `series length (${s.values.length}) must equal labels length (${L})`,
          });
        }
      });
    }

    // 6) Image source requirements
    (c.images || []).forEach((img, j) => {
      const t = img.source?.type;
      if (t === "url" && !img.source.url) {
        ctx.addIssue({
          code: "custom",
          path: ["content", "images", j, "source", "url"],
          message: "url is required when source.type is 'url'",
        });
      }
      if (t === "unsplash" && !img.source.query) {
        ctx.addIssue({
          code: "custom",
          path: ["content", "images", j, "source", "query"],
          message: "query is required when source.type is 'unsplash'",
        });
      }
    });

    // 7) Typography size steps should be ascending
    const sz = value.styleTokens.typography.sizes;
    const steps = [sz["step_-2"], sz["step_-1"], sz.step_0, sz.step_1, sz.step_2, sz.step_3];
    for (let i = 1; i < steps.length; i++) {
      if (!(steps[i] > steps[i - 1])) {
        ctx.addIssue({
          code: "custom",
          path: ["styleTokens", "typography", "sizes"],
          message: "Typography size steps must be strictly ascending (-2 < -1 < 0 < 1 < 2 < 3).",
        });
        break;
      }
    }
  });

/* -------------------------------------------------------------------------- */
/*                               Exported types                               */
/* -------------------------------------------------------------------------- */

/** Runtime type derived from the schema (authoritative). */
export type SlideSpec = z.infer<typeof SlideSpecZ>;
/** Convenience alias for import symmetry. */
export type SlideSpecV1 = SlideSpec;

/* -------------------------------------------------------------------------- */
/*                            Safe Defaults & Utils                           */
/* -------------------------------------------------------------------------- */

/** Recommended 9‑step neutral ramp (dark → light) */
export const DEFAULT_NEUTRAL_9 = Object.freeze([
  "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
  "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
]) as readonly string[];

/** Minimal, readable typography defaults */
export const DEFAULT_TYPOGRAPHY: Readonly<TypographyScale> = Object.freeze({
  fonts: { sans: "Inter, Arial, sans-serif" },
  sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 44 },
  weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
  lineHeights: { compact: 1.2, standard: 1.5 },
});

/** Quick hex validator; accepts #RRGGBB (no alpha) */
export function isHex6(color: string | undefined | null): color is string {
  return !!color && /^#[0-9A-Fa-f]{6}$/.test(color);
}

/**
 * Normalize a palette defensively for preview usage.
 * - Ensures primary/accent are hex6 (applies tasteful defaults if not).
 * - Pads/fixes neutral to a 9‑step scale for consistent rendering.
 */
export function normalizePalette(p: SlideSpecV1["styleTokens"]["palette"]) {
  const primary = isHex6(p.primary) ? p.primary : "#1E40AF";
  const accent = isHex6(p.accent) ? p.accent : "#F59E0B";

  const neutral =
    Array.isArray(p.neutral) &&
    p.neutral.filter(isHex6).length >= 5
      ? ((): string[] => {
          const cleaned = p.neutral.filter(isHex6).slice(0, 9);
          // pad to 9 if short (for gradients/frames that assume a light end)
          while (cleaned.length < 9) cleaned.push(DEFAULT_NEUTRAL_9[cleaned.length]);
          return cleaned;
        })()
      : [...DEFAULT_NEUTRAL_9];

  return { primary, accent, neutral };
}




────────────────────────────────────────────────────────────────────────────────
FILE: shared/slideSpec/tsconfig.json
SIZE: 0.55 KB
────────────────────────────────────────────────────────────────────────────────

{
  "compilerOptions": {
    "target": "ES2022",
    "module": "esnext",
    "lib": ["ES2022"],
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}




────────────────────────────────────────────────────────────────────────────────
FILE: shared/slideSpec/vitest.config.ts
SIZE: 0.29 KB
────────────────────────────────────────────────────────────────────────────────

import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    globals: true,
    environment: "node",
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: [
        "node_modules/",
        "dist/",
      ],
    },
  },
});




────────────────────────────────────────────────────────────────────────────────
FILE: web/eslint.config.js
SIZE: 0.61 KB
────────────────────────────────────────────────────────────────────────────────

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])



────────────────────────────────────────────────────────────────────────────────
FILE: web/index.html
SIZE: 1.75 KB
────────────────────────────────────────────────────────────────────────────────

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Primary Meta Tags -->
    <title>plzfixthx - Presentation Builder</title>
    <meta name="title" content="plzfixthx - Presentation Builder" />
    <meta name="description" content="Create professional PowerPoint presentations instantly. Describe your slide, preview in real-time, and download as .pptx" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://pls-fix-thx.web.app/" />
    <meta property="og:title" content="plzfixthx - Presentation Builder" />
    <meta property="og:description" content="Create professional PowerPoint presentations instantly. Describe your slide, preview in real-time, and download as .pptx" />
    <meta property="og:image" content="https://pls-fix-thx.web.app/og-image.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://pls-fix-thx.web.app/" />
    <meta property="twitter:title" content="plzfixthx - Presentation Builder" />
    <meta property="twitter:description" content="Create professional PowerPoint presentations instantly. Describe your slide, preview in real-time, and download as .pptx" />
    <meta property="twitter:image" content="https://pls-fix-thx.web.app/og-image.png" />

    <!-- Theme Color -->
    <meta name="theme-color" content="#6366F1" />

    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



────────────────────────────────────────────────────────────────────────────────
FILE: web/package.json
SIZE: 1.34 KB
────────────────────────────────────────────────────────────────────────────────

{
  "name": "web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  },
  "dependencies": {
    "@plzfixthx/slide-spec": "file:../shared/slideSpec",
    "firebase": "^12.4.0",
    "html2canvas": "^1.4.1",
    "jspdf": "^3.0.3",
    "lucide-react": "^0.546.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "recharts": "^3.3.0",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@tailwindcss/postcss": "^4.1.16",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^24.6.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^5.0.4",
    "@vitest/ui": "^4.0.1",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "jsdom": "^27.0.1",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.16",
    "terser": "^5.44.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7",
    "vitest": "^4.0.1"
  }
}



────────────────────────────────────────────────────────────────────────────────
FILE: web/postcss.config.js
SIZE: 0.09 KB
────────────────────────────────────────────────────────────────────────────────

export default {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {}
  }
};




────────────────────────────────────────────────────────────────────────────────
FILE: web/src/App.tsx
SIZE: 11.32 KB
────────────────────────────────────────────────────────────────────────────────

import { useCallback, useEffect, useState } from "react";
import { ProgressIndicator } from "@/components/ProgressIndicator";
import { SlideCanvas } from "@/components/SlideCanvas";
import { SlideSkeleton } from "@/components/SlideSkeleton";
import { useSlideGeneration } from "@/hooks/useSlideGeneration";
import { useSlideGenerationStream } from "@/hooks/useSlideGenerationStream";
import { useSlideExport, type ExportFormat } from "@/hooks/useSlideExport";
import { isStreamingEnabled } from "@/lib/env";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";
import { Download, FileText, Image } from "lucide-react";

export default function App() {
  const useStreaming = isStreamingEnabled();
  const { loading: loadingRegular, spec: specRegular, error: errorRegular, generate: generateRegular } = useSlideGeneration();
  const { loading: loadingStream, spec: specStream, error: errorStream, generateStream } = useSlideGenerationStream();

  // Use streaming or regular based on env flag
  const loading = useStreaming ? loadingStream : loadingRegular;
  const spec = useStreaming ? specStream : specRegular;
  const error = useStreaming ? errorStream : errorRegular;
  const generate = useStreaming ? generateStream : generateRegular;

  const { exportSlide } = useSlideExport();
  const [currentSpec, setCurrentSpec] = useState<SlideSpecV1 | null>(null);
  const [prompt, setPrompt] = useState("");
  const [errorMsg, setErrorMsg] = useState<string | null>(null);

  useEffect(() => {
    if (spec) {
      setCurrentSpec(spec);
    }
  }, [spec]);

  useEffect(() => {
    if (error) {
      setErrorMsg(error);
      setTimeout(() => setErrorMsg(null), 6000);
    }
  }, [error]);

  const handleGenerate = useCallback(async () => {
    if (!prompt.trim()) return;
    setErrorMsg(null);
    await generate(prompt);
  }, [prompt, generate]);

  // Keyboard shortcut: Ctrl+Enter or Cmd+Enter to generate
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === "Enter" && prompt.trim() && !loading) {
        e.preventDefault();
        handleGenerate();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [prompt, loading, handleGenerate]);

  const handleDownload = useCallback(
    async (format: ExportFormat = "pptx") => {
      if (!currentSpec) return;
      const success = await exportSlide(currentSpec, format);
      if (!success) {
        setErrorMsg(`Failed to download ${format.toUpperCase()}. Please try again.`);
      }
    },
    [currentSpec, exportSlide]
  );

  return (
    <div className="min-h-screen flex flex-col" style={{ background: 'var(--bg-gradient-main)' }}>
      <a
        href="#main-content"
        className="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-[var(--color-primary)] focus:text-white focus:rounded-[var(--radius-md)]"
      >
        Skip to main content
      </a>

      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 sm:py-12 space-y-8 sm:space-y-12 w-full">
        {/* Header */}
        <header className="text-center space-y-4 py-8 sm:py-12 animate-fade-in">
          <div className="inline-block">
            <h1 className="text-5xl sm:text-6xl lg:text-7xl font-bold bg-gradient-to-r from-[var(--color-primary)] via-[var(--color-primary-light)] to-[var(--color-accent)] bg-clip-text text-transparent mb-3" style={{ fontFamily: 'var(--font-display)', letterSpacing: '-0.02em' }}>
              plsfixthx
            </h1>
            <div className="h-1 w-24 mx-auto bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] rounded-full"></div>
          </div>
          <p className="text-lg sm:text-xl text-[var(--neutral-3)] max-w-2xl mx-auto font-medium leading-relaxed">
            Create beautiful, professional slides with AI
          </p>
          <p className="text-sm text-[var(--neutral-4)] max-w-2xl mx-auto leading-relaxed">
            Consulting-firm quality • Context-aware design • Instant export
          </p>
        </header>

        {/* Input Section */}
        <main id="main-content" className="animate-scale-in max-w-4xl mx-auto w-full">
          <div className="glass rounded-[var(--radius-2xl)] p-6 sm:p-8 space-y-4 border border-white/10 backdrop-blur-xl shadow-lg">
            <div className="space-y-2 mb-4">
              <label htmlFor="slide-prompt" className="block text-sm font-medium text-[var(--neutral-2)]">
                Describe your slide
              </label>
              <p className="text-xs text-[var(--neutral-4)]">
                Be specific about content, style, or data you want to include
              </p>
            </div>
            <div className="flex gap-3">
              <input
                id="slide-prompt"
                type="text"
                value={prompt}
                onChange={(e) => setPrompt(e.target.value)}
                onKeyDown={(e) => e.key === "Enter" && handleGenerate()}
                placeholder="e.g., 'Q3 revenue growth strategy with 3 key initiatives'"
                disabled={loading}
                aria-label="Slide prompt input"
                aria-describedby="prompt-help"
                className="flex-1 px-4 py-3 rounded-[var(--radius-md)] bg-[var(--neutral-8)] text-[var(--neutral-1)] placeholder-[var(--neutral-4)] border border-[var(--neutral-6)] focus:outline-none focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 disabled:opacity-50 transition-all duration-200"
              />
              <button
                onClick={handleGenerate}
                disabled={loading || !prompt.trim()}
                aria-label={loading ? "Generating slide" : "Generate slide"}
                aria-busy={loading}
                className="px-6 py-3 bg-[var(--color-primary)] text-white rounded-[var(--radius-md)] font-semibold hover:shadow-lg hover:opacity-90 disabled:opacity-50 transition-all duration-200 flex items-center gap-2 whitespace-nowrap transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-[var(--color-primary)] focus:ring-offset-2"
              >
                {loading ? (
                  <>
                    <span className="inline-block animate-spin" aria-hidden="true">⚡</span>
                    Generating...
                  </>
                ) : (
                  "Generate"
                )}
              </button>
            </div>

            {errorMsg && (
              <div
                role="alert"
                aria-live="polite"
                aria-atomic="true"
                className="p-4 bg-red-50/90 border-l-4 border-red-500 rounded-[var(--radius-md)] text-red-700 text-sm flex gap-3 items-start animate-in fade-in slide-in-from-top-2 shadow-md"
              >
                <span className="text-red-500 flex-shrink-0 mt-0.5 font-bold text-lg" aria-hidden="true">✕</span>
                <div className="flex-1">
                  <p className="font-semibold mb-1">Error generating slide</p>
                  <p className="text-red-600 text-sm">{errorMsg}</p>
                  <p className="text-red-500 text-xs mt-2 opacity-75">Try rephrasing your prompt or check your connection</p>
                </div>
              </div>
            )}

            {loading && <ProgressIndicator isLoading={true} />}
          </div>
        </main>

        {/* Preview and Download */}
        {(currentSpec || loading) && (
          <div className={`animate-scale-in max-w-7xl mx-auto w-full space-y-8 ${loading ? "opacity-75" : ""}`}>
            <div className="space-y-6">
              <div className="text-center space-y-2">
                <h2 className="text-2xl font-semibold text-[var(--neutral-1)]">
                  {loading ? "Generating your slide..." : "Your Slide Preview"}
                </h2>
                <p className="text-[var(--neutral-3)] text-sm">
                  {loading ? "Creating a professional slide with AI..." : "Professional quality, ready to download in multiple formats"}
                </p>
              </div>
              {loading ? <SlideSkeleton /> : currentSpec && <SlideCanvas spec={currentSpec} />}
              <div className="flex justify-center gap-3 flex-wrap">
                <button
                  onClick={() => handleDownload("pptx")}
                  disabled={loading || !currentSpec}
                  aria-label="Download slide as PowerPoint presentation"
                  className="flex items-center gap-2 px-6 py-3 bg-[var(--color-primary)] text-white rounded-[var(--radius-md)] font-semibold hover:shadow-2xl hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 transform hover:scale-105 active:scale-95 text-sm focus:outline-none focus:ring-2 focus:ring-[var(--color-primary)] focus:ring-offset-2"
                  title="Download as PowerPoint (.pptx)"
                >
                  <Download size={18} aria-hidden="true" />
                  PowerPoint
                </button>
                <button
                  onClick={() => handleDownload("pdf")}
                  disabled={loading || !currentSpec}
                  aria-label="Download slide as PDF document"
                  className="flex items-center gap-2 px-6 py-3 bg-[var(--color-accent)] text-white rounded-[var(--radius-md)] font-semibold hover:shadow-2xl hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 transform hover:scale-105 active:scale-95 text-sm focus:outline-none focus:ring-2 focus:ring-[var(--color-accent)] focus:ring-offset-2"
                  title="Download as PDF document"
                >
                  <FileText size={18} aria-hidden="true" />
                  PDF
                </button>
                <button
                  onClick={() => handleDownload("png")}
                  disabled={loading || !currentSpec}
                  aria-label="Download slide as PNG image"
                  className="flex items-center gap-2 px-6 py-3 bg-[var(--neutral-6)] text-[var(--neutral-1)] rounded-[var(--radius-md)] font-semibold hover:bg-[var(--neutral-5)] disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 transform hover:scale-105 active:scale-95 text-sm border border-[var(--neutral-5)] focus:outline-none focus:ring-2 focus:ring-[var(--neutral-6)] focus:ring-offset-2"
                  title="Download as PNG image"
                >
                  <Image size={18} aria-hidden="true" />
                  PNG
                </button>
                <button
                  onClick={() => {
                    setPrompt("");
                    setCurrentSpec(null);
                  }}
                  disabled={loading}
                  aria-label="Create another slide"
                  className="px-6 py-3 bg-[var(--neutral-7)] text-[var(--neutral-1)] rounded-[var(--radius-md)] font-semibold hover:bg-[var(--neutral-6)] disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 border border-[var(--neutral-6)] hover:border-[var(--neutral-5)] text-sm focus:outline-none focus:ring-2 focus:ring-[var(--neutral-7)] focus:ring-offset-2"
                  title="Create another slide"
                >
                  Create Another
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}




────────────────────────────────────────────────────────────────────────────────
FILE: web/src/components/ErrorBoundary.tsx
SIZE: 2.61 KB
────────────────────────────────────────────────────────────────────────────────

import { Component } from "react";
import type { ReactNode } from "react";

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("ErrorBoundary caught an error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="min-h-screen flex items-center justify-center bg-[var(--bg-secondary)] p-4">
          <div className="max-w-md w-full bg-[var(--bg-primary)] rounded-[var(--radius-lg)] shadow-[var(--shadow-lg)] p-6 space-y-4">
            <div className="flex items-center gap-3">
              <svg className="w-8 h-8 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
              </svg>
              <h1 className="text-[var(--step-1)] font-bold text-[var(--neutral-0)]">
                Something went wrong
              </h1>
            </div>
            
            <p className="text-[var(--step--1)] text-[var(--neutral-3)]">
              We encountered an unexpected error. Please try refreshing the page.
            </p>

            {this.state.error && (
              <details className="text-[var(--step--2)] text-[var(--neutral-4)]">
                <summary className="cursor-pointer hover:text-[var(--neutral-2)]">
                  Error details
                </summary>
                <pre className="mt-2 p-2 bg-[var(--neutral-6)] rounded-[var(--radius-sm)] overflow-auto">
                  {this.state.error.toString()}
                </pre>
              </details>
            )}

            <button
              onClick={() => window.location.reload()}
              className="w-full px-4 py-2 bg-[var(--color-primary)] text-white rounded-[var(--radius-md)] font-medium hover:opacity-90 transition-opacity"
            >
              Refresh Page
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}




────────────────────────────────────────────────────────────────────────────────
FILE: web/src/components/ProgressIndicator.tsx
SIZE: 2.98 KB
────────────────────────────────────────────────────────────────────────────────

import { useEffect, useState } from "react";

interface ProgressIndicatorProps {
  isLoading: boolean;
  estimatedDuration?: number; // in milliseconds
}

export function ProgressIndicator({ isLoading, estimatedDuration = 5000 }: ProgressIndicatorProps) {
  const [progress, setProgress] = useState(0);
  const [stage, setStage] = useState("Initializing...");

  useEffect(() => {
    if (!isLoading) {
      setProgress(0);
      setStage("Initializing...");
      return;
    }

    const stages = [
      { progress: 20, label: "Analyzing prompt...", duration: 500 },
      { progress: 40, label: "Generating content...", duration: 2000 },
      { progress: 70, label: "Designing layout...", duration: 1500 },
      { progress: 90, label: "Finalizing slide...", duration: 1000 },
    ];

    let currentStageIndex = 0;
    let currentProgress = 0;

    const updateProgress = () => {
      if (currentStageIndex >= stages.length) return;

      const stage = stages[currentStageIndex];
      setStage(stage.label);

      const increment = (stage.progress - currentProgress) / (stage.duration / 50);
      
      const interval = setInterval(() => {
        currentProgress += increment;
        if (currentProgress >= stage.progress) {
          currentProgress = stage.progress;
          clearInterval(interval);
          currentStageIndex++;
          if (currentStageIndex < stages.length) {
            setTimeout(updateProgress, 100);
          }
        }
        setProgress(Math.min(currentProgress, 95)); // Never reach 100% until actually done
      }, 50);

      return () => clearInterval(interval);
    };

    updateProgress();
  }, [isLoading, estimatedDuration]);

  if (!isLoading) return null;

  return (
    <div className="space-y-3 animate-fade-in">
      <div className="flex items-center justify-between text-sm">
        <span className="text-[var(--neutral-2)] font-medium">{stage}</span>
        <span className="text-[var(--neutral-3)] font-mono">{Math.round(progress)}%</span>
      </div>
      
      <div className="relative h-2 bg-[var(--neutral-8)] rounded-full overflow-hidden">
        <div
          className="absolute top-0 left-0 h-full bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-primary-light)] transition-all duration-300 ease-out"
          style={{ width: `${progress}%` }}
        >
          <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent animate-shimmer" />
        </div>
      </div>
      
      <div className="flex items-center gap-2 text-xs text-[var(--neutral-4)]">
        <svg className="w-4 h-4 animate-spin" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
        </svg>
        <span>This usually takes 3-5 seconds</span>
      </div>
    </div>
  );
}




────────────────────────────────────────────────────────────────────────────────
FILE: web/src/components/SlideCanvas.tsx
SIZE: 25.11 KB
────────────────────────────────────────────────────────────────────────────────

import { memo, useEffect, useMemo, useState } from "react";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";
import {
  ResponsiveContainer,
  BarChart,
  Bar,
  LineChart,
  Line,
  AreaChart,
  Area,
  PieChart,
  Pie,
  Cell,
  ScatterChart,
  Scatter,
  CartesianGrid,
  XAxis,
  YAxis,
  Tooltip,
  Legend,
} from "recharts";

/* -------------------------------------------------------------------------- */
/*                                   Tokens                                   */
/* -------------------------------------------------------------------------- */

type Tokens = {
  palette: { primary: string; accent: string; neutral: string[] };
  typography: SlideSpecV1["styleTokens"]["typography"];
  pattern: NonNullable<SlideSpecV1["design"]>["pattern"] | "split";
};

const DEFAULT_NEUTRAL = [
  "#0F172A",
  "#1E293B",
  "#334155",
  "#475569",
  "#64748B",
  "#94A3B8",
  "#CBD5E1",
  "#E2E8F0",
  "#F8FAFC",
];

const HEX6 = /^#[0-9A-Fa-f]{6}$/;

/** Ensure primary, accent, and a 9‑step neutral ramp are always present/valid */
function normalizePalette(p?: SlideSpecV1["styleTokens"]["palette"]): Tokens["palette"] {
  const primary = p?.primary && HEX6.test(p.primary) ? p.primary : "#6366F1";
  const accent = p?.accent && HEX6.test(p.accent) ? p.accent : "#EC4899";

  let neutral = Array.isArray(p?.neutral) ? p!.neutral.filter((c): c is string => !!c && HEX6.test(c)) : [];
  if (neutral.length < 9) neutral = DEFAULT_NEUTRAL;

  return { primary, accent, neutral: neutral.slice(0, 9) };
}

function normalizeTypography(t?: SlideSpecV1["styleTokens"]["typography"]): Tokens["typography"] {
  return (
    t ?? {
      fonts: { sans: "Inter, Arial, sans-serif" },
      sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 40 },
      weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
      lineHeights: { compact: 1.2, standard: 1.5 },
    }
  );
}

/* -------------------------------------------------------------------------- */
/*                              Main Slide Canvas                              */
/* -------------------------------------------------------------------------- */

export const SlideCanvas = memo(function SlideCanvas({ spec }: { spec: SlideSpecV1 }) {
  const [isVisible, setIsVisible] = useState(false);

  // soft enter animation on spec change
  useEffect(() => {
    setIsVisible(false);
    const t = setTimeout(() => setIsVisible(true), 40);
    return () => clearTimeout(t);
  }, [spec]);

  const tokens: Tokens = useMemo(() => {
    const palette = normalizePalette(spec.styleTokens?.palette);
    const typography = normalizeTypography(spec.styleTokens?.typography);
    const pattern = spec.design?.pattern ?? "split";
    return { palette, typography, pattern };
  }, [spec]);

  const aspect = spec.meta.aspectRatio === "4:3" ? "4 / 3" : "16 / 9";
  const slideStyle: React.CSSProperties = useMemo(
    () => ({
      background: getGradientBackground(tokens),
      color: tokens.palette.neutral[0],
    }),
    [tokens]
  );

  return (
    <div className="w-full">
      <div
        className={`relative w-full overflow-hidden rounded-2xl transition-all duration-500 shadow-2xl border border-white/10 ${
          isVisible ? "opacity-100 scale-100" : "opacity-0 scale-95"
        }`}
        style={{ aspectRatio: aspect, ...slideStyle }}
        aria-label="Slide preview"
      >
        {/* Left accent bar */}
        <div
          aria-hidden
          style={{
            position: "absolute",
            insetInlineStart: 0,
            top: 0,
            width: "0.12in",
            height: "100%",
            background: tokens.palette.primary,
            boxShadow: "3px 0 12px rgba(0,0,0,0.15)",
          }}
        />
        {/* Top-right glaze */}
        <div
          aria-hidden
          style={{
            position: "absolute",
            top: "0.2in",
            right: "0.2in",
            width: "3.0in",
            height: "1.0in",
            background: hexWithAlpha(tokens.palette.accent, 0.1),
            borderRadius: 12,
          }}
        />
        {/* Bottom accent block */}
        <div
          aria-hidden
          style={{
            position: "absolute",
            bottom: "0.8in",
            left: "0.3in",
            width: "2.5in",
            height: "0.6in",
            background: hexWithAlpha(tokens.palette.primary, 0.06),
            borderRadius: 8,
          }}
        />
        {/* Slim vertical accent line */}
        <div
          aria-hidden
          style={{
            position: "absolute",
            top: "0.08in",
            left: "0.22in",
            width: "0.04in",
            height: "calc(100% - 0.16in)",
            background: hexWithAlpha(tokens.palette.accent, 0.12),
            borderRadius: 2,
          }}
        />

        <div
          style={{
            width: "100%",
            height: "100%",
            padding: 0,
            boxSizing: "border-box",
            position: "relative",
          }}
        >
          {renderRegions(spec, tokens)}
        </div>
      </div>
    </div>
  );
});

/* -------------------------------------------------------------------------- */
/*                                   Layout                                   */
/* -------------------------------------------------------------------------- */

function renderRegions(spec: SlideSpecV1, tokens: Tokens) {
  const { rows, cols, gutter, margin } = spec.layout.grid;

  const gridStyle: React.CSSProperties = {
    display: "grid",
    gridTemplateRows: `repeat(${rows}, minmax(0, 1fr))`,
    gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))`,
    gap: `${gutter}px`,
    padding: `${margin.t}px ${margin.r}px ${margin.b}px ${margin.l}px`,
    height: "100%",
    width: "100%",
    boxSizing: "border-box",
    position: "relative",
  };

  const regionStyle = (r: SlideSpecV1["layout"]["regions"][number]): React.CSSProperties => ({
    gridRow: `${r.rowStart} / span ${r.rowSpan}`,
    gridColumn: `${r.colStart} / span ${r.colSpan}`,
    display: "flex",
    flexDirection: "column",
    gap: "12px",
    minHeight: 0,
    minWidth: 0,
    overflow: "hidden",
    justifyContent: "flex-start",
    alignItems: "stretch",
  });

  return (
    <div style={gridStyle}>
      {spec.layout.regions.map((r, idx) => {
        const anchors = spec.layout.anchors
          .filter((a) => a.region === r.name)
          .sort((a, b) => a.order - b.order);

        return (
          <div key={`${r.name}-${idx}`} style={regionStyle(r)}>
            {anchors.map((a) => (
              <ElementByRef key={a.refId} spec={spec} refId={a.refId} tokens={tokens} />
            ))}
          </div>
        );
      })}
    </div>
  );
}

/* -------------------------------------------------------------------------- */
/*                                  Elements                                  */
/* -------------------------------------------------------------------------- */

const ElementByRef = memo(function ElementByRef({
  spec,
  refId,
  tokens,
}: {
  spec: SlideSpecV1;
  refId: string;
  tokens: Tokens;
}) {
  const c = spec.content;

  if (c.title?.id === refId) {
    return <Title text={c.title.text} tokens={tokens} align={spec.components?.title?.align} />;
  }
  if (c.subtitle?.id === refId) {
    return <Subtitle text={c.subtitle.text} tokens={tokens} />;
  }

  const bl = c.bullets?.find((x) => x.id === refId);
  if (bl) {
    return <Bullets items={bl.items} tokens={tokens} variant={spec.components?.bulletList?.variant} />;
  }

  const co = c.callouts?.find((x) => x.id === refId);
  if (co) {
    return <Callout item={co} tokens={tokens} variantCard={spec.components?.callout?.variant} />;
  }

  if (c.dataViz?.id === refId) {
    return <Chart spec={spec} tokens={tokens} />;
  }

  const img = c.images?.find((x) => x.id === refId);
  if (img) {
    return <ImageBlock item={img} tokens={tokens} />;
  }

  const ph = c.imagePlaceholders?.find((x) => x.id === refId);
  if (ph) {
    return <ImagePlaceholder alt={ph.alt} tokens={tokens} />;
  }

  return null;
});

/* ------------------------------- Typography -------------------------------- */

const Title = memo(function Title({
  text,
  tokens,
  align,
}: {
  text: string;
  tokens: Tokens;
  align?: "left" | "center" | "right";
}) {
  const s = tokens.typography.sizes;
  const w = tokens.typography.weights;
  const lh = tokens.typography.lineHeights;
  return (
    <h2
      style={{
        fontFamily: tokens.typography.fonts.sans,
        fontSize: `${s.step_3 ?? 44}px`,
        fontWeight: w.bold ?? 700,
        lineHeight: lh.compact ?? 1.2,
        color: tokens.palette.primary,
        margin: 0,
        marginBottom: "8px",
        textAlign: align ?? "left",
        letterSpacing: "0.5px",
        paddingBottom: "12px",
        borderBottom: `3px solid ${tokens.palette.primary}`,
        position: "relative",
      }}
    >
      {text}
      <span
        style={{
          display: "inline-block",
          width: "9px",
          height: "9px",
          borderRadius: "50%",
          backgroundColor: tokens.palette.accent,
          marginLeft: "12px",
          verticalAlign: "middle",
          boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
        }}
      />
    </h2>
  );
});

const Subtitle = memo(function Subtitle({ text, tokens }: { text: string; tokens: Tokens }) {
  const s = tokens.typography.sizes;
  const w = tokens.typography.weights;
  const lh = tokens.typography.lineHeights;
  return (
    <p
      style={{
        fontFamily: tokens.typography.fonts.sans,
        fontSize: `${s.step_1 ?? 20}px`,
        fontWeight: w.medium ?? 500,
        lineHeight: lh.standard ?? 1.5,
        color: tokens.palette.neutral[3] ?? "#64748B",
        margin: 0,
        marginTop: "4px",
        letterSpacing: "0.2px",
      }}
    >
      {text}
    </p>
  );
});

const Bullets = memo(function Bullets({
  items,
  tokens,
  variant,
}: {
  items: { text: string; level: 1 | 2 | 3 }[];
  tokens: Tokens;
  variant?: "compact" | "spacious";
}) {
  const s = tokens.typography.sizes;
  const w = tokens.typography.weights;
  const lh = tokens.typography.lineHeights;
  const gap = variant === "compact" ? 8 : 12;

  return (
    <ul
      role="list"
      style={{
        fontFamily: tokens.typography.fonts.sans,
        fontSize: `${s.step_0 ?? 16}px`,
        fontWeight: w.regular ?? 400,
        lineHeight: lh.standard ?? 1.5,
        color: tokens.palette.neutral[0] ?? "#0F172A",
        listStyle: "none",
        margin: 0,
        padding: 0,
      }}
    >
      {items.map((it, i) => {
        const isLevel1 = it.level === 1;
        const fontSize = isLevel1 ? 16 : it.level === 2 ? 14 : 12;
        const fontWeight = isLevel1 ? (w.semibold ?? 600) : (w.regular ?? 400);
        const color = isLevel1 ? tokens.palette.primary : tokens.palette.neutral[2] ?? "#334155";

        return (
          <li
            key={i}
            role="listitem"
            style={{
              marginLeft: `${(it.level - 1) * 24}px`,
              marginBottom: `${gap}px`,
              display: "flex",
              alignItems: "flex-start",
              gap: 12,
              fontSize: `${fontSize}px`,
              fontWeight,
              color,
            }}
          >
            <span
              aria-hidden
              style={{
                display: "inline-block",
                width: isLevel1 ? 7 : 5,
                height: isLevel1 ? 7 : 5,
                borderRadius: "50%",
                backgroundColor: isLevel1 ? tokens.palette.primary : tokens.palette.neutral[4],
                marginTop: isLevel1 ? 6 : 7,
                flexShrink: 0,
              }}
            />
            <span>{it.text}</span>
          </li>
        );
      })}
    </ul>
  );
});

const Callout = memo(function Callout({
  item,
  tokens,
  variantCard,
}: {
  item: NonNullable<SlideSpecV1["content"]["callouts"]>[number];
  tokens: Tokens;
  variantCard?: "flat" | "elevated";
}) {
  const variants = {
    warning: { bg: "#FEF3C7", border: "#F59E0B", text: "#78350F" },
    danger: { bg: "#FEE2E2", border: "#EF4444", text: "#7F1D1D" },
    success: { bg: "#D1FAE5", border: "#10B981", text: "#065F46" },
    note: { bg: "#F3F4F6", border: tokens.palette.accent, text: "#1F2937" },
  } as const;

  const v = variants[item.variant] || variants.note;

  return (
    <div
      style={{
        padding: "16px 18px",
        borderRadius: 12,
        border: `2px solid ${v.border}`,
        backgroundColor: v.bg,
        color: v.text,
        boxShadow: variantCard === "elevated" ? "0 8px 24px rgba(0,0,0,0.12)" : "0 2px 8px rgba(0,0,0,0.06)",
        fontSize: 14,
        lineHeight: 1.6,
        borderLeft: `4px solid ${v.border}`,
        position: "relative",
      }}
    >
      {item.title && (
        <b style={{ display: "block", marginBottom: "4px", fontSize: "15px" }}>{item.title}</b>
      )}
      {item.text}
    </div>
  );
});

/* --------------------------------- Charts ---------------------------------- */

const Chart = memo(function Chart({ spec, tokens }: { spec: SlideSpecV1; tokens: Tokens }) {
  const viz = spec.content.dataViz!;
  const series = viz.series ?? [];
  const labels = viz.labels ?? [];

  // Normalize to shortest series length
  const minLen = Math.max(0, Math.min(labels.length, ...series.map((s) => s.values.length)));
  const data = labels.slice(0, minLen).map((label, idx) => {
    const row: Record<string, number | string> = { label };
    for (const s of series) row[s.name] = s.values[idx] ?? 0;
    return row;
  });

  const colors = paletteSeries(tokens);
  const showLegend = legendWanted(spec);
  const legendProps = getLegendProps(spec.components?.chart?.legend);
  const showGrid = spec.components?.chart?.gridlines ?? false;
  const fmt = getNumberFormatter(viz.valueFormat);

  const frameStyle: React.CSSProperties = {
    width: "100%",
    height: "100%",
    minHeight: 200,
    backgroundColor: tokens.palette.neutral[6] ?? "#E2E8F0",
    borderRadius: 8,
    padding: 8,
    boxSizing: "border-box",
  };

  if (!data.length || !series.length) {
    return <Placeholder text="[Chart] Missing series/labels" tokens={tokens} />;
  }

  switch (viz.kind) {
    case "bar":
      return (
        <div style={frameStyle} aria-label="Bar chart">
          <ResponsiveContainer>
            <BarChart data={data}>
              <CartesianGrid stroke={hexWithAlpha(tokens.palette.neutral[5] ?? "#94A3B8", showGrid ? 0.4 : 0)} vertical={false} />
              <XAxis dataKey="label" tick={{ fill: tokens.palette.neutral[3] }} />
              <YAxis tick={{ fill: tokens.palette.neutral[3] }} tickFormatter={fmt} />
              <Tooltip formatter={(v: any) => fmt(Number(v))} />
              {series.map((s, i) => (
                <Bar
                  key={s.name}
                  dataKey={s.name}
                  fill={colors[i % colors.length]}
                  radius={4}
                  label={viz.valueFormat ? { formatter: (v: any) => fmt(Number(v)), position: "top" as const } : undefined}
                />
              ))}
              {showLegend && <Legend {...legendProps} />}
            </BarChart>
          </ResponsiveContainer>
        </div>
      );

    case "line":
      return (
        <div style={frameStyle} aria-label="Line chart">
          <ResponsiveContainer>
            <LineChart data={data}>
              <CartesianGrid stroke={hexWithAlpha(tokens.palette.neutral[5] ?? "#94A3B8", showGrid ? 0.4 : 0)} />
              <XAxis dataKey="label" tick={{ fill: tokens.palette.neutral[3] }} />
              <YAxis tick={{ fill: tokens.palette.neutral[3] }} tickFormatter={fmt} />
              <Tooltip formatter={(v: any) => fmt(Number(v))} />
              {series.map((s, i) => (
                <Line
                  key={s.name}
                  type="monotone"
                  dataKey={s.name}
                  stroke={colors[i % colors.length]}
                  strokeWidth={2}
                  dot={viz.valueFormat ? { fill: colors[i % colors.length], r: 4 } : false}
                  label={viz.valueFormat ? { formatter: (v: any) => fmt(Number(v)), position: "top" as const } : undefined}
                />
              ))}
              {showLegend && <Legend {...legendProps} />}
            </LineChart>
          </ResponsiveContainer>
        </div>
      );

    case "area":
      return (
        <div style={frameStyle} aria-label="Area chart">
          <ResponsiveContainer>
            <AreaChart data={data}>
              <CartesianGrid stroke={hexWithAlpha(tokens.palette.neutral[5] ?? "#94A3B8", showGrid ? 0.4 : 0)} />
              <XAxis dataKey="label" tick={{ fill: tokens.palette.neutral[3] }} />
              <YAxis tick={{ fill: tokens.palette.neutral[3] }} tickFormatter={fmt} />
              <Tooltip formatter={(v: any) => fmt(Number(v))} />
              {series.map((s, i) => (
                <Area
                  key={s.name}
                  type="monotone"
                  dataKey={s.name}
                  stroke={colors[i % colors.length]}
                  fill={hexWithAlpha(colors[i % colors.length], 0.35)}
                  strokeWidth={2}
                />
              ))}
              {showLegend && <Legend {...legendProps} />}
            </AreaChart>
          </ResponsiveContainer>
        </div>
      );

    case "pie":
    case "doughnut": {
      const single = series[0] ?? { name: "Series", values: [] as number[] };
      const pieData = labels.slice(0, minLen).map((label, i) => ({
        name: label,
        value: single.values[i] ?? 0,
      }));

      return (
        <div style={frameStyle} aria-label={viz.kind === "doughnut" ? "Doughnut chart" : "Pie chart"}>
          <ResponsiveContainer>
            <PieChart>
              <Tooltip formatter={(v: any) => fmt(Number(v))} />
              {showLegend && <Legend {...legendProps} />}
              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                innerRadius={viz.kind === "doughnut" ? "55%" : 0}
                outerRadius="80%"
                strokeWidth={1}
              >
                {pieData.map((_, i) => (
                  <Cell key={i} fill={colors[i % colors.length]} />
                ))}
              </Pie>
            </PieChart>
          </ResponsiveContainer>
        </div>
      );
    }

    case "scatter": {
      const x = series[0]?.values ?? [];
      const y = series[1]?.values ?? [];
      const scatterData = labels.slice(0, Math.min(x.length, y.length)).map((_, i) => ({
        x: x[i] ?? i,
        y: y[i] ?? 0,
      }));
      return (
        <div style={frameStyle} aria-label="Scatter plot">
          <ResponsiveContainer>
            <ScatterChart>
              <CartesianGrid stroke={hexWithAlpha(tokens.palette.neutral[5] ?? "#94A3B8", showGrid ? 0.4 : 0)} />
              <XAxis dataKey="x" tick={{ fill: tokens.palette.neutral[3] }} tickFormatter={fmt} />
              <YAxis dataKey="y" tick={{ fill: tokens.palette.neutral[3] }} tickFormatter={fmt} />
              <Tooltip formatter={(v: any) => fmt(Number(v))} />
              <Scatter data={scatterData} fill={tokens.palette.primary} />
              {showLegend && <Legend {...legendProps} />}
            </ScatterChart>
          </ResponsiveContainer>
        </div>
      );
    }

    default:
      return <Placeholder text={`[${viz.kind}] chart not supported in preview yet`} tokens={tokens} />;
  }
});

/** Respect back‑end legend semantics: "none" | "right" | "bottom" */
function legendWanted(spec: SlideSpecV1) {
  const pos = spec.components?.chart?.legend;
  return pos !== "none";
}

function getLegendProps(pos?: "none" | "right" | "bottom") {
  if (pos === "right") {
    return { layout: "vertical" as const, align: "right" as const, verticalAlign: "middle" as const };
  }
  if (pos === "bottom") {
    return { layout: "horizontal" as const, align: "center" as const, verticalAlign: "bottom" as const };
  }
  return { layout: "horizontal" as const, align: "center" as const, verticalAlign: "top" as const };
}

/* --------------------------------- Images ---------------------------------- */

const ImageBlock = memo(function ImageBlock({
  item,
  tokens,
}: {
  item: NonNullable<SlideSpecV1["content"]["images"]>[number];
  tokens: Tokens;
}) {
  const [broken, setBroken] = useState(false);
  const fit = item.fit ?? "cover";
  const url = item.source.type === "url" && item.source.url ? item.source.url : undefined;

  if (!url || broken) {
    return <ImagePlaceholder alt={item.alt} tokens={tokens} />;
  }

  return (
    <img
      src={url}
      alt={item.alt}
      decoding="async"
      loading="lazy"
      onError={() => setBroken(true)}
      style={{
        width: "100%",
        height: "100%",
        objectFit: fit as React.CSSProperties["objectFit"],
        borderRadius: 8,
        display: "block",
      }}
    />
  );
});

const ImagePlaceholder = memo(function ImagePlaceholder({ alt, tokens }: { alt: string; tokens: Tokens }) {
  return (
    <div
      role="img"
      aria-label={alt}
      style={{
        width: "100%",
        height: "100%",
        borderRadius: 8,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        backgroundColor: tokens.palette.neutral[5] ?? "#94A3B8",
        color: tokens.palette.neutral[2] ?? "#334155",
        fontSize: 14,
        textAlign: "center",
        padding: 16,
        boxSizing: "border-box",
      }}
    >
      <span>{alt}</span>
    </div>
  );
});

/* -------------------------------- Utility ---------------------------------- */

function Placeholder({ text, tokens }: { text: string; tokens: Tokens }) {
  return (
    <div
      style={{
        width: "100%",
        height: "100%",
        minHeight: 200,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        backgroundColor: tokens.palette.neutral[6] ?? "#E2E8F0",
        borderRadius: 8,
        color: tokens.palette.neutral[3] ?? "#64748B",
        fontSize: 14,
        textAlign: "center",
        padding: 16,
        boxSizing: "border-box",
      }}
    >
      {text}
    </div>
  );
}

function getGradientBackground(tokens: Tokens): string {
  const pattern = tokens.pattern || "split";
  const primary = tokens.palette.primary || "#6366F1";
  const accent = tokens.palette.accent || "#EC4899";
  const neutralLight = tokens.palette.neutral[8] || "#F8FAFC";
  const neutralMid = tokens.palette.neutral[5] || "#94A3B8";

  switch (pattern) {
    case "hero":
      return `linear-gradient(180deg, ${neutralLight} 0%, ${hexWithAlpha(primary, 0.08)} 50%, ${hexWithAlpha(
        accent,
        0.05
      )} 100%)`;
    case "minimal":
      return `radial-gradient(ellipse at center, ${neutralLight} 0%, ${hexWithAlpha(neutralMid, 0.05)} 100%)`;
    case "data-focused":
      return `linear-gradient(90deg, ${neutralLight} 0%, ${hexWithAlpha(accent, 0.06)} 100%)`;
    case "split":
      return `linear-gradient(135deg, ${neutralLight} 0%, ${hexWithAlpha(primary, 0.05)} 50%, ${neutralLight} 100%)`;
    case "asymmetric":
      return `linear-gradient(120deg, ${neutralLight} 0%, ${hexWithAlpha(accent, 0.08)} 60%, ${hexWithAlpha(
        primary,
        0.05
      )} 100%)`;
    case "grid":
      return `radial-gradient(circle at 50% 50%, ${neutralLight} 0%, ${hexWithAlpha(neutralMid, 0.04)} 100%)`;
    default:
      return `linear-gradient(135deg, ${neutralLight} 0%, ${hexWithAlpha(neutralMid, 0.03)} 50%, ${neutralLight} 100%)`;
  }
}

function hexWithAlpha(hex: string, alpha: number): string {
  const a = Math.round(alpha * 255)
    .toString(16)
    .padStart(2, "0");
  const clean = hex.replace("#", "");
  if (clean.length === 3) {
    const [r, g, b] = clean.split("").map((c) => c + c);
    return `#${r}${g}${b}${a}`;
  }
  if (clean.length === 6) return `#${clean}${a}`;
  return hex;
}

/* ------------------------------- Number fmt -------------------------------- */

function getNumberFormatter(format?: SlideSpecV1["content"]["dataViz"] extends infer T ? T extends { valueFormat?: infer F } ? F : never : never) {
  if (format === "percent") {
    return (n: number) => {
      // Accept either 0..1 or 0..100 inputs
      const v = Math.abs(n) <= 1 ? n * 100 : n;
      return `${roundSmart(v)}%`;
    };
  }
  if (format === "currency") {
    // Default to USD if unspecified by schema
    const nf = new Intl.NumberFormat(undefined, { style: "currency", currency: "USD", maximumFractionDigits: 0 });
    return (n: number) => nf.format(n);
  }
  if (format === "number") {
    return (n: number) => shortNumber(n);
  }
  // auto
  return (n: number) => shortNumber(n);
}

function shortNumber(n: number): string {
  const abs = Math.abs(n);
  if (abs >= 1_000_000_000) return `${roundSmart(n / 1_000_000_000)}B`;
  if (abs >= 1_000_000) return `${roundSmart(n / 1_000_000)}M`;
  if (abs >= 1_000) return `${roundSmart(n / 1_000)}k`;
  return `${roundSmart(n)}`;
}

function roundSmart(n: number): string {
  const v = Math.abs(n) < 10 ? Number(n.toFixed(2)) : Math.abs(n) < 100 ? Number(n.toFixed(1)) : Math.round(n);
  return `${v}`;
}

/* ------------------------------ Series colors ------------------------------ */

function paletteSeries(tokens: Tokens): string[] {
  const p = tokens.palette;
  const base = [p.primary, p.accent, p.neutral[2], p.neutral[3], p.neutral[4]];
  return base.map((c, i) => (i <= 1 ? c : hexWithAlpha(c, 0.85)));
}


────────────────────────────────────────────────────────────────────────────────
FILE: web/src/components/SlideSkeleton.tsx
SIZE: 1.44 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * Loading skeleton for slide preview
 * Shows a placeholder while slide is being generated
 */

export function SlideSkeleton() {
  return (
    <div className="w-full">
      <div
        className="relative w-full overflow-hidden rounded-2xl bg-gradient-to-br from-[var(--neutral-7)] to-[var(--neutral-6)] border border-white/10 animate-pulse"
        style={{ aspectRatio: "16 / 9" }}
        aria-label="Loading slide preview"
        aria-busy="true"
      >
        {/* Left accent bar */}
        <div
          className="absolute inset-y-0 left-0 w-1 bg-[var(--color-primary)]/30"
          aria-hidden="true"
        />

        {/* Header skeleton */}
        <div className="absolute top-12 left-8 right-8 space-y-3">
          <div className="h-12 bg-[var(--neutral-5)]/50 rounded-lg w-3/4" />
          <div className="h-6 bg-[var(--neutral-5)]/30 rounded-lg w-1/2" />
        </div>

        {/* Content skeleton */}
        <div className="absolute bottom-12 left-8 right-8 space-y-2">
          <div className="h-4 bg-[var(--neutral-5)]/40 rounded w-full" />
          <div className="h-4 bg-[var(--neutral-5)]/40 rounded w-5/6" />
          <div className="h-4 bg-[var(--neutral-5)]/40 rounded w-4/5" />
        </div>

        {/* Shimmer effect */}
        <div
          className="absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent animate-shimmer"
          aria-hidden="true"
        />
      </div>
    </div>
  );
}




────────────────────────────────────────────────────────────────────────────────
FILE: web/src/hooks/useSlideExport.ts
SIZE: 2.29 KB
────────────────────────────────────────────────────────────────────────────────

import { useState, useCallback } from "react";
import { apiExport, apiExportPNG, apiExportPDF, downloadBlob } from "@/lib/api";
import { logger } from "@/lib/logger";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export type ExportFormat = "pptx" | "png" | "pdf";

export function useSlideExport() {
  const [exporting, setExporting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const exportSlide = useCallback(
    async (spec: SlideSpecV1, format: ExportFormat = "pptx", filename?: string) => {
      setError(null);
      setExporting(true);

      const startTime = performance.now();
      const defaultFilename = {
        pptx: "plzfixthx-slide.pptx",
        png: "plzfixthx-slide.png",
        pdf: "plzfixthx-slide.pdf",
      }[format];

      const finalFilename = filename || defaultFilename;
      logger.userAction("export_slide", { format, filename: finalFilename });

      try {
        let blob: Blob;

        if (format === "pptx") {
          blob = await apiExport(spec);
        } else if (format === "png" || format === "pdf") {
          // For PNG/PDF, we need the DOM element
          const element = document.querySelector('[aria-label="Slide preview"]') as HTMLElement;
          if (!element) {
            throw new Error("Slide preview element not found");
          }

          if (format === "png") {
            blob = await apiExportPNG(element);
          } else {
            blob = await apiExportPDF(element);
          }
        } else {
          throw new Error(`Unsupported export format: ${format}`);
        }

        downloadBlob(blob, finalFilename);

        const duration = performance.now() - startTime;
        logger.performance("slide_export", duration);
        logger.info("Slide exported successfully", {
          format,
          filename: finalFilename,
          size: blob.size,
          duration,
        });

        return true;
      } catch (e: unknown) {
        const errorMessage = e instanceof Error ? e.message : "Failed to export slide";
        setError(errorMessage);
        logger.error("Failed to export slide", e, { format, filename: finalFilename });
        return false;
      } finally {
        setExporting(false);
      }
    },
    []
  );

  return {
    exporting,
    error,
    exportSlide,
  };
}




────────────────────────────────────────────────────────────────────────────────
FILE: web/src/hooks/useSlideGeneration.ts
SIZE: 1.75 KB
────────────────────────────────────────────────────────────────────────────────

import { useState, useCallback } from "react";
import { apiGenerate } from "@/lib/api";
import { normalizeOrFallback } from "@/lib/validation";
import { logger } from "@/lib/logger";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export function useSlideGeneration() {
  const [loading, setLoading] = useState(false);
  const [spec, setSpec] = useState<SlideSpecV1 | null>(null);
  const [error, setError] = useState<string | null>(null);

  const generate = useCallback(async (prompt: string) => {
    if (!prompt.trim()) {
      setError("Please enter a prompt");
      logger.warn("Generate called with empty prompt");
      return null;
    }

    setError(null);
    setLoading(true);

    const startTime = performance.now();
    logger.userAction("generate_slide", { promptLength: prompt.length });

    try {
      const data = await apiGenerate(prompt);
      const normalized = normalizeOrFallback(data?.spec ?? data);
      setSpec(normalized);

      const duration = performance.now() - startTime;
      logger.performance("slide_generation", duration);
      logger.info("Slide generated successfully", { duration });

      return normalized;
    } catch (e: unknown) {
      const errorMessage = e instanceof Error ? e.message : "Failed to generate slide";
      setError(errorMessage);
      logger.error("Failed to generate slide", e, { prompt: prompt.slice(0, 50) });

      // Still set a fallback spec so user sees something
      const fallback = normalizeOrFallback(null);
      setSpec(fallback);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const reset = useCallback(() => {
    setSpec(null);
    setError(null);
    setLoading(false);
  }, []);

  return {
    loading,
    spec,
    error,
    generate,
    reset
  };
}




────────────────────────────────────────────────────────────────────────────────
FILE: web/src/hooks/useSlideGenerationStream.ts
SIZE: 4.90 KB
────────────────────────────────────────────────────────────────────────────────

import { useState, useCallback, useRef } from "react";
import { normalizeOrFallback } from "@/lib/validation";
import { logger } from "@/lib/logger";
import { parseSSEStream, parseSSEData } from "@/lib/sse";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export interface StreamProgress {
  stage: "start" | "moderation" | "generation" | "spec" | "complete" | "error";
  status?: string;
  message?: string;
  progress?: number;
  durationMs?: number;
  error?: string;
  isFallback?: boolean;
}

export function useSlideGenerationStream() {
  const [loading, setLoading] = useState(false);
  const [spec, setSpec] = useState<SlideSpecV1 | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [progress, setProgress] = useState<StreamProgress | null>(null);
  const eventSourceRef = useRef<EventSource | null>(null);

  const generateStream = useCallback(async (prompt: string) => {
    if (!prompt.trim()) {
      setError("Please enter a prompt");
      logger.warn("Generate called with empty prompt");
      return null;
    }

    setError(null);
    setLoading(true);
    setProgress({ stage: "start", status: "initializing" });

    const startTime = performance.now();
    logger.userAction("generate_slide_stream", { promptLength: prompt.length });

    try {
      // Get the API base URL
      const apiBase = import.meta.env.VITE_API_BASE || "http://localhost:5001/plzfixthx/us-central1";
      const url = `${apiBase}/generateSlideSpecStream`;

      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt }),
        credentials: "include",
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      if (!response.body) {
        throw new Error("No response body");
      }

      let receivedSpec: SlideSpecV1 | null = null;

      // Use robust SSE parser
      await parseSSEStream(
        response.body,
        (event) => {
          const data = parseSSEData<Record<string, unknown>>(event);
          if (!data) {
            logger.warn("Failed to parse SSE data", { event: event.event });
            return;
          }

          switch (event.event) {
            case "start":
              logger.info("Stream started", data);
              setProgress({ stage: "start", status: "started", ...data });
              break;
            case "moderation":
              logger.info("Moderation check", data);
              setProgress({ stage: "moderation", ...data });
              break;
            case "generation":
              logger.info("Generation progress", data);
              setProgress({ stage: "generation", ...data });
              break;
            case "spec":
              logger.info("Spec received", { isFallback: data.isFallback });
              receivedSpec = normalizeOrFallback(data.spec as SlideSpecV1 | null);
              setSpec(receivedSpec);
              setProgress({ stage: "spec", status: "received", isFallback: data.isFallback as boolean });
              break;
            case "complete":
              {
                const duration = performance.now() - startTime;
                logger.info("Stream completed", { ...data, totalDuration: duration });
                setProgress({ stage: "complete", status: data.status as string, durationMs: duration });
                if (data.status === "success" && receivedSpec) {
                  logger.performance("slide_generation_stream", duration);
                }
              }
              break;
            case "error":
              logger.error("Stream error", data);
              setError((data.error as string) || "Stream error occurred");
              setProgress({ stage: "error", error: data.error as string });
              break;
          }
        },
        (error) => {
          logger.error("SSE stream error", error);
          throw error;
        }
      );

      setLoading(false);
      return receivedSpec;
    } catch (e: unknown) {
      const errorMessage = e instanceof Error ? e.message : "Failed to generate slide";
      setError(errorMessage);
      logger.error("Failed to generate slide stream", e, { prompt: prompt.slice(0, 50) });

      // Still set a fallback spec so user sees something
      const fallback = normalizeOrFallback(null);
      setSpec(fallback);
      setProgress({ stage: "error", error: errorMessage });
      setLoading(false);
      return null;
    }
  }, []);

  const cancel = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    setLoading(false);
    setProgress(null);
  }, []);

  const reset = useCallback(() => {
    cancel();
    setSpec(null);
    setError(null);
    setProgress(null);
  }, [cancel]);

  return {
    loading,
    spec,
    error,
    progress,
    generateStream,
    cancel,
    reset,
  };
}




────────────────────────────────────────────────────────────────────────────────
FILE: web/src/main.tsx
SIZE: 0.87 KB
────────────────────────────────────────────────────────────────────────────────

import React from "react";
import ReactDOM from "react-dom/client";
import "@/styles/tailwind.css";
import App from "./App";
import { initAnalytics } from "./lib/firebase";
import { ErrorBoundary } from "./components/ErrorBoundary";
import { validateEnv } from "./lib/env";
import { logger } from "./lib/logger";
import { registerServiceWorker } from "./lib/registerSW";
import { initVersionCheck, APP_VERSION } from "./lib/versionCheck";

// Validate environment variables at startup
try {
  validateEnv();
  logger.info("Application starting...", { version: APP_VERSION });
} catch (error) {
  logger.error("Failed to validate environment", error);
  throw error;
}

initAnalytics();
registerServiceWorker();
initVersionCheck();

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </React.StrictMode>
);



────────────────────────────────────────────────────────────────────────────────
FILE: web/src/styles/tailwind.css
SIZE: 8.23 KB
────────────────────────────────────────────────────────────────────────────────

@import "tailwindcss";

/* Modern Design System - Inspired by Apple, Google, Tesla, ChatGPT */
:root {
  /* Primary Colors - Vibrant gradient palette */
  --color-primary: #6366F1; /* Indigo */
  --color-primary-light: #818CF8;
  --color-primary-dark: #4F46E5;
  --color-accent: #EC4899; /* Pink accent */
  --color-success: #10B981;
  --color-warning: #F59E0B;
  --color-error: #EF4444;

  /* Neutral Palette - Refined grays */
  --neutral-0: #0F172A;   /* Darkest - text */
  --neutral-1: #1E293B;
  --neutral-2: #334155;
  --neutral-3: #475569;
  --neutral-4: #64748B;
  --neutral-5: #94A3B8;
  --neutral-6: #CBD5E1;
  --neutral-7: #E2E8F0;
  --neutral-8: #F1F5F9;
  --neutral-9: #F8FAFC;   /* Lightest - backgrounds */
  --neutral-white: #FFFFFF;

  /* Typography */
  --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  --font-display: "SF Pro Display", -apple-system, BlinkMacSystemFont, sans-serif;
  --step--2: 0.75rem;   /* 12px */
  --step--1: 0.875rem;  /* 14px */
  --step-0: 1rem;       /* 16px */
  --step-1: 1.125rem;   /* 18px */
  --step-2: 1.25rem;    /* 20px */
  --step-3: 1.5rem;     /* 24px */
  --step-4: 1.875rem;   /* 30px */
  --step-5: 2.25rem;    /* 36px */
  --step-6: 3rem;       /* 48px */
  --lh-tight: 1.2;
  --lh-normal: 1.5;
  --lh-relaxed: 1.75;

  /* Spacing Scale */
  --space-0: 0;
  --space-1: 0.25rem;   /* 4px */
  --space-2: 0.5rem;    /* 8px */
  --space-3: 0.75rem;   /* 12px */
  --space-4: 1rem;      /* 16px */
  --space-5: 1.5rem;    /* 24px */
  --space-6: 2rem;      /* 32px */
  --space-7: 2.5rem;    /* 40px */
  --space-8: 3rem;      /* 48px */
  --space-10: 4rem;     /* 64px */
  --space-12: 6rem;     /* 96px */

  /* Border Radius */
  --radius-sm: 0.375rem;   /* 6px */
  --radius-md: 0.5rem;     /* 8px */
  --radius-lg: 0.75rem;    /* 12px */
  --radius-xl: 1rem;       /* 16px */
  --radius-2xl: 1.5rem;    /* 24px */
  --radius-full: 9999px;

  /* Shadows - Elevated, modern */
  --shadow-xs: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-sm: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
  --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  --shadow-inner: inset 0 2px 4px 0 rgba(0, 0, 0, 0.05);

  /* Glassmorphism */
  --glass-bg: rgba(255, 255, 255, 0.7);
  --glass-border: rgba(255, 255, 255, 0.18);
  --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);

  /* Backgrounds */
  --bg-primary: #FFFFFF;
  --bg-secondary: #F8FAFC;
  --bg-tertiary: #F1F5F9;
  /* Subtle modern gradient - clean, professional, minimal */
  --bg-gradient-main: linear-gradient(135deg, #FFFFFF 0%, #F8FAFC 25%, #F3F4F6 50%, #FAFBFC 75%, #FFFFFF 100%);
  --bg-gradient-card: linear-gradient(to bottom, #FFFFFF 0%, #F9FAFB 100%);
}



/* Animations */
@keyframes slide-in {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

@keyframes fade-in {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes pulse-glow {
  0%, 100% {
    box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4);
  }
  50% {
    box-shadow: 0 0 0 8px rgba(99, 102, 241, 0);
  }
}

@keyframes shimmer {
  0% {
    background-position: -1000px 0;
  }
  100% {
    background-position: 1000px 0;
  }
}

.animate-slide-in {
  animation: slide-in 0.3s ease-out;
}

.animate-spin {
  animation: spin 1s linear infinite;
}

.animate-fade-in {
  animation: fade-in 0.4s ease-out;
}

.animate-scale-in {
  animation: scale-in 0.3s ease-out;
}

.animate-pulse-glow {
  animation: pulse-glow 2s ease-in-out infinite;
}

.animate-shimmer {
  animation: shimmer 2s linear infinite;
  background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
  background-size: 200% 100%;
}

/* Glassmorphism utility */
.glass {
  background: var(--glass-bg);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border: 1px solid var(--glass-border);
  box-shadow: var(--glass-shadow);
}

/* Screen reader only utility */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.focus\:not-sr-only:focus {
  position: static;
  width: auto;
  height: auto;
  padding: inherit;
  margin: inherit;
  overflow: visible;
  clip: auto;
  white-space: normal;
}

html, body, #root {
  height: 100%;
  margin: 0;
  padding: 0;
}

html {
  background: var(--bg-gradient-main);
  background-attachment: fixed;
}

body {
  font-family: var(--font-sans);
  color: var(--neutral-0);
  background: transparent;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Focus visible styles for better keyboard navigation */
*:focus-visible {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
  border-radius: var(--radius-sm);
}

/* Smooth transitions */
* {
  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

/* Button utilities */
.btn-primary {
  position: relative;
  overflow: hidden;
  background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-light) 100%);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.btn-primary:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 12px 24px -8px rgba(99, 102, 241, 0.4);
}

.btn-primary:active:not(:disabled) {
  transform: translateY(0);
}

.btn-primary::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  transition: left 0.5s;
}

.btn-primary:hover:not(:disabled)::before {
  left: 100%;
}

.btn-secondary {
  position: relative;
  overflow: hidden;
  background: linear-gradient(135deg, var(--neutral-0) 0%, var(--neutral-1) 100%);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.btn-secondary:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 12px 24px -8px rgba(15, 23, 42, 0.3);
}

.btn-secondary:active:not(:disabled) {
  transform: translateY(0);
}

/* Mobile touch improvements */
@media (hover: none) and (pointer: coarse) {
  /* Larger touch targets on mobile */
  button, a, input, select, textarea {
    min-height: 44px;
  }

  /* Remove hover effects on touch devices */
  .btn-primary:hover:not(:disabled),
  .btn-secondary:hover:not(:disabled) {
    transform: none;
  }

  /* Add active state for touch feedback */
  .btn-primary:active:not(:disabled),
  .btn-secondary:active:not(:disabled) {
    transform: scale(0.98);
    opacity: 0.9;
  }
}

/* Prevent text selection on buttons */
button {
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  user-select: none;
}

/* Accessibility utilities */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:focus {
  position: static;
  width: auto;
  height: auto;
  padding: inherit;
  margin: inherit;
  overflow: visible;
  clip: auto;
  white-space: normal;
}

/* Skip to main content link */
.skip-link {
  position: absolute;
  top: -40px;
  left: 0;
  background: var(--color-primary);
  color: white;
  padding: 8px 16px;
  text-decoration: none;
  border-radius: 0 0 4px 0;
  z-index: 100;
}

.skip-link:focus {
  top: 0;
}

/* Focus visible styles */
*:focus-visible {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}




────────────────────────────────────────────────────────────────────────────────
FILE: web/src/test/setup.ts
SIZE: 0.92 KB
────────────────────────────────────────────────────────────────────────────────

import { afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import '@testing-library/jest-dom';

// Cleanup after each test
afterEach(() => {
  cleanup();
});

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: (query: string) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: () => {}, // deprecated
    removeListener: () => {}, // deprecated
    addEventListener: () => {},
    removeEventListener: () => {},
    dispatchEvent: () => {},
  }),
});

// Mock IntersectionObserver
(globalThis as any).IntersectionObserver = class IntersectionObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  takeRecords() {
    return [];
  }
  unobserve() {}
} as any;

// Mock ResizeObserver
(globalThis as any).ResizeObserver = class ResizeObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
} as any;




────────────────────────────────────────────────────────────────────────────────
FILE: web/src/types/SlideSpecV1.ts
SIZE: 0.59 KB
────────────────────────────────────────────────────────────────────────────────

/**
 * SlideSpec v1 — Re-exported from shared package
 * -------------------------------------------------------
 * This file re-exports types from the shared @plzfixthx/slide-spec package
 * to maintain backward compatibility with existing imports.
 */

export type {
  AspectRatio,
  RegionName,
  ChartKind,
  ChartValueFormat,
  DesignSpec,
  TitleAlign,
  ChartLegend,
  ImageFit,
  ImageRole,
  TypographyScale,
  StyleTokens,
  SlideSpecV1,
  SlideSpec,
} from "@plzfixthx/slide-spec";

export {
  DEFAULT_NEUTRAL_9,
  DEFAULT_TYPOGRAPHY,
  isHex6,
  normalizePalette,
} from "@plzfixthx/slide-spec";


────────────────────────────────────────────────────────────────────────────────
FILE: web/tsconfig.app.json
SIZE: 0.80 KB
────────────────────────────────────────────────────────────────────────────────

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Path aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}



────────────────────────────────────────────────────────────────────────────────
FILE: web/tsconfig.json
SIZE: 0.12 KB
────────────────────────────────────────────────────────────────────────────────

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



────────────────────────────────────────────────────────────────────────────────
FILE: web/tsconfig.node.json
SIZE: 0.64 KB
────────────────────────────────────────────────────────────────────────────────

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



────────────────────────────────────────────────────────────────────────────────
FILE: web/vite.config.ts
SIZE: 0.80 KB
────────────────────────────────────────────────────────────────────────────────

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  },
  build: {
    // Optimize chunk size and enable code-splitting
    rollupOptions: {
      output: {
        manualChunks: {
          // Separate vendor chunks for better caching
          'vendor-react': ['react', 'react-dom'],
          'vendor-recharts': ['recharts'],
          'vendor-export': ['html2canvas', 'jspdf'],
          'vendor-icons': ['lucide-react'],
        }
      }
    },
    // Increase chunk size warning limit since we're optimizing
    chunkSizeWarningLimit: 1000,
    // Enable minification with terser
    minify: 'terser'
  }
})



────────────────────────────────────────────────────────────────────────────────
FILE: web/vitest.config.ts
SIZE: 0.59 KB
────────────────────────────────────────────────────────────────────────────────

import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/mockData',
        'dist/',
      ],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});




================================================================================
SUMMARY
================================================================================
Total Files: 56
Total Size: 0.27 MB
Generated: 2025-10-26T21:57:46.975Z
