=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/aiHelpers.ts
=================================================================================
import * as logger from "firebase-functions/logger";
import { fetch as undiciFetch } from "undici";
import { z } from "zod";
import { ENHANCED_SYSTEM_PROMPT } from "./prompts";

/** Retry with exponential backoff */
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries = 3,
  baseDelay = 1000
): Promise<T> {
  let lastError: Error | undefined;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      
      if (attempt < maxRetries - 1) {
        const delay = baseDelay * Math.pow(2, attempt);
        logger.warn(`Attempt ${attempt + 1} failed, retrying in ${delay}ms...`, { error: lastError.message });
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw lastError || new Error("Max retries exceeded");
}

/** Call OpenAI-compatible API with retry logic */
export async function callAIWithRetry(
  prompt: string,
  apiKey: string,
  baseUrl: string,
  model: string,
  schema: z.ZodType
): Promise<unknown> {
  return retryWithBackoff(async () => {
    const response = await undiciFetch(`${baseUrl}/chat/completions`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        temperature: 0.3,
        response_format: { type: "json_object" },
        messages: [
          { role: "system", content: ENHANCED_SYSTEM_PROMPT },
          { role: "user", content: `User prompt:\n<<<${prompt}>>>` }
        ]
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`AI API error ${response.status}: ${errorText}`);
    }

    const data: any = await response.json();
    const content = data?.choices?.[0]?.message?.content;
    
    if (!content) {
      throw new Error("No content in AI response");
    }

    let parsed: unknown;
    try {
      parsed = JSON.parse(content);
    } catch (e) {
      throw new Error(`Failed to parse AI response as JSON: ${e}`);
    }

    const validationResult = schema.safeParse(parsed);
    if (!validationResult.success) {
      const errorDetails = validationResult.error.issues.map((issue: any) =>
        `${issue.path.join('.')}: ${issue.message}`
      ).join(', ');

      logger.error("Schema validation failed", {
        errors: validationResult.error.issues,
        errorDetails,
        aiResponse: JSON.stringify(parsed, null, 2)
      });
      throw new Error(`Schema validation failed: ${errorDetails}`);
    }

    logger.info("Schema validation successful");

    return validationResult.data;
  }, 3, 1000);
}

/** Validate and sanitize user prompt */
export function sanitizePrompt(prompt: string, maxLength = 800): string {
  if (!prompt || typeof prompt !== 'string') {
    throw new Error("Prompt must be a non-empty string");
  }

  const trimmed = prompt.trim();
  if (trimmed.length === 0) {
    throw new Error("Prompt cannot be empty");
  }

  if (trimmed.length > maxLength) {
    return trimmed.slice(0, maxLength);
  }

  return trimmed;
}

/** Check for inappropriate content (basic filter) */
export function moderateContent(prompt: string): { safe: boolean; reason?: string } {
  const lowerPrompt = prompt.toLowerCase();
  
  // Basic inappropriate content detection
  const inappropriatePatterns = [
    /\b(hack|exploit|vulnerability|inject|xss|sql\s*injection)\b/i,
    /\b(porn|xxx|nsfw|explicit)\b/i,
    /\b(violence|weapon|bomb|terror)\b/i
  ];

  for (const pattern of inappropriatePatterns) {
    if (pattern.test(lowerPrompt)) {
      return {
        safe: false,
        reason: "Content may contain inappropriate or unsafe material"
      };
    }
  }

  return { safe: true };
}

/** Post-process and enhance AI-generated slide spec */
export function enhanceSlideSpec(spec: any): any {
  // Ensure all required fields are present
  if (!spec.meta) {
    spec.meta = {
      version: "1.0",
      locale: "en-US",
      theme: "Professional",
      aspectRatio: "16:9"
    };
  }

  // Ensure content has at least a title
  if (!spec.content?.title?.text) {
    if (!spec.content) spec.content = {};
    spec.content.title = {
      id: "title",
      text: "Untitled Slide"
    };
  }

  // Limit bullet points to 6 total
  if (spec.content?.bullets) {
    spec.content.bullets.forEach((bulletGroup: any) => {
      if (bulletGroup.items && bulletGroup.items.length > 6) {
        bulletGroup.items = bulletGroup.items.slice(0, 6);
      }
    });
  }

  // Validate chart data if present
  if (spec.content?.dataViz) {
    const viz = spec.content.dataViz;
    if (viz.labels && viz.series) {
      const labelCount = viz.labels.length;
      // Ensure all series have matching value counts
      viz.series.forEach((s: any) => {
        if (s.values.length !== labelCount) {
          // Pad or trim to match
          if (s.values.length < labelCount) {
            s.values = [...s.values, ...Array(labelCount - s.values.length).fill(0)];
          } else {
            s.values = s.values.slice(0, labelCount);
          }
        }
      });
    }
  }

  // Ensure color palette is valid
  if (spec.styleTokens?.palette) {
    const palette = spec.styleTokens.palette;
    // Validate hex colors
    const hexPattern = /^#[0-9A-Fa-f]{6}$/;
    if (palette.primary && !hexPattern.test(palette.primary)) {
      palette.primary = "#6366F1"; // Default primary
    }
    if (palette.accent && !hexPattern.test(palette.accent)) {
      palette.accent = "#EC4899"; // Default accent
    }
  }

  // FIX LAYOUT ISSUES
  spec = fixLayoutIssues(spec);

  return spec;
}

/**
 * Fix common layout issues in generated specs
 */
function fixLayoutIssues(spec: any): any {
  logger.info("fixLayoutIssues called", {
    hasLayout: !!spec.layout,
    hasRegions: !!spec.layout?.regions,
    hasAnchors: !!spec.layout?.anchors,
    hasTitle: !!spec.content?.title?.text,
    hasSubtitle: !!spec.content?.subtitle?.text
  });

  if (!spec.layout?.regions || !spec.layout?.anchors) {
    logger.warn("No layout regions or anchors found");
    return spec;
  }

  const hasSubtitle = !!spec.content?.subtitle?.text;
  const hasTitle = !!spec.content?.title?.text;

  // Find header region
  const headerRegion = spec.layout.regions.find((r: any) => r.name === "header");

  logger.info("Header region check", {
    headerRegionExists: !!headerRegion,
    headerRowSpan: headerRegion?.rowSpan,
    hasTitle,
    hasSubtitle
  });

  if (headerRegion && hasTitle && hasSubtitle) {
    // If header has both title and subtitle but only 1 row, expand it to 2 rows
    if (headerRegion.rowSpan === 1) {
      logger.info("Expanding header region from 1 to 2 rows for title + subtitle");
      headerRegion.rowSpan = 2;

      // Adjust body region if it exists
      const bodyRegion = spec.layout.regions.find((r: any) => r.name === "body");
      if (bodyRegion && bodyRegion.rowStart === 2) {
        logger.info("Adjusting body region");
        bodyRegion.rowStart = 3;
        bodyRegion.rowSpan = Math.max(1, bodyRegion.rowSpan - 1);
      }

      // Adjust aside region if it exists
      const asideRegion = spec.layout.regions.find((r: any) => r.name === "aside");
      if (asideRegion && asideRegion.rowStart === 2) {
        logger.info("Adjusting aside region");
        asideRegion.rowStart = 3;
        asideRegion.rowSpan = Math.max(1, asideRegion.rowSpan - 1);
      }
    }
  }

  // Validate all anchors have corresponding regions
  const regionNames = new Set(spec.layout.regions.map((r: any) => r.name));
  spec.layout.anchors = spec.layout.anchors.filter((a: any) => {
    if (!regionNames.has(a.region)) {
      logger.warn(`Removing anchor ${a.refId} with non-existent region ${a.region}`);
      return false;
    }
    return true;
  });

  return spec;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/designValidator.ts
=================================================================================
/**
 * Design Validator
 * Validates design specifications against professional standards
 */

import type { SlideSpecV2 } from "./types/SlideSpecV2";

export interface ValidationResult {
  isValid: boolean;
  score: number;
  errors: ValidationError[];
  warnings: ValidationWarning[];
  recommendations: string[];
}

export interface ValidationError {
  field: string;
  message: string;
  severity: "critical" | "high" | "medium";
}

export interface ValidationWarning {
  field: string;
  message: string;
}

/**
 * Validate complete slide specification
 */
export function validateSlideSpec(spec: SlideSpecV2): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];
  const recommendations: string[] = [];

  // Validate structure
  validateStructure(spec, errors);

  // Validate colors
  validateColors(spec, errors, warnings);

  // Validate typography
  validateTypography(spec, errors, warnings);

  // Validate layout
  validateLayout(spec, errors, warnings);

  // Validate design pattern
  validateDesignPattern(spec, errors, warnings);

  // Validate accessibility
  validateAccessibility(spec, errors, warnings, recommendations);

  // Validate content
  validateContent(spec, errors, warnings);

  const score = calculateValidationScore(errors, warnings);

  return {
    isValid: errors.length === 0,
    score,
    errors,
    warnings,
    recommendations
  };
}

/**
 * Validate basic structure
 */
function validateStructure(spec: SlideSpecV2, errors: ValidationError[]): void {
  if (!spec.meta) {
    errors.push({
      field: "meta",
      message: "Missing meta information",
      severity: "critical"
    });
  }

  if (!spec.content) {
    errors.push({
      field: "content",
      message: "Missing content",
      severity: "critical"
    });
  }

  if (!spec.layout) {
    errors.push({
      field: "layout",
      message: "Missing layout configuration",
      severity: "critical"
    });
  }

  if (!spec.styleTokens) {
    errors.push({
      field: "styleTokens",
      message: "Missing style tokens",
      severity: "critical"
    });
  }

  if (!spec.design) {
    errors.push({
      field: "design",
      message: "Missing design configuration",
      severity: "high"
    });
  }
}

/**
 * Validate colors
 */
function validateColors(
  spec: SlideSpecV2,
  errors: ValidationError[],
  warnings: ValidationWarning[]
): void {
  const hexPattern = /^#[0-9A-Fa-f]{6}$/;
  const palette = spec.styleTokens.palette;

  if (!hexPattern.test(palette.primary)) {
    errors.push({
      field: "palette.primary",
      message: "Invalid primary color format (must be #RRGGBB)",
      severity: "high"
    });
  }

  if (!hexPattern.test(palette.accent)) {
    errors.push({
      field: "palette.accent",
      message: "Invalid accent color format (must be #RRGGBB)",
      severity: "high"
    });
  }

  if (!Array.isArray(palette.neutral) || palette.neutral.length < 5) {
    errors.push({
      field: "palette.neutral",
      message: "Neutral palette must have at least 5 colors",
      severity: "high"
    });
  }

  palette.neutral?.forEach((color: string, idx: number) => {
    if (!hexPattern.test(color)) {
      warnings.push({
        field: `palette.neutral[${idx}]`,
        message: `Invalid neutral color format at index ${idx}`
      });
    }
  });
}

/**
 * Validate typography
 */
function validateTypography(
  spec: SlideSpecV2,
  errors: ValidationError[],
  warnings: ValidationWarning[]
): void {
  const typography = spec.styleTokens.typography;

  if (!typography.fonts || !typography.fonts.sans) {
    errors.push({
      field: "typography.fonts",
      message: "Missing sans-serif font definition",
      severity: "high"
    });
  }

  if (!typography.sizes) {
    errors.push({
      field: "typography.sizes",
      message: "Missing typography sizes",
      severity: "high"
    });
  }

  if (!typography.weights) {
    errors.push({
      field: "typography.weights",
      message: "Missing typography weights",
      severity: "high"
    });
  }

  // Check size hierarchy
  const sizes = typography.sizes;
  if (sizes.step_3 && sizes.step_0 && sizes.step_3 <= sizes.step_0) {
    warnings.push({
      field: "typography.sizes",
      message: "Title size should be larger than body size"
    });
  }

  // Check line heights
  const lineHeights = typography.lineHeights;
  if (lineHeights.standard && (lineHeights.standard < 1.4 || lineHeights.standard > 2)) {
    warnings.push({
      field: "typography.lineHeights",
      message: "Standard line height should be between 1.4 and 2"
    });
  }
}

/**
 * Validate layout
 */
function validateLayout(
  spec: SlideSpecV2,
  errors: ValidationError[],
  warnings: ValidationWarning[]
): void {
  const layout = spec.layout;

  if (!layout.grid) {
    errors.push({
      field: "layout.grid",
      message: "Missing grid configuration",
      severity: "high"
    });
    return;
  }

  if (!layout.regions || layout.regions.length === 0) {
    errors.push({
      field: "layout.regions",
      message: "No layout regions defined",
      severity: "high"
    });
  }

  if (!layout.anchors || layout.anchors.length === 0) {
    warnings.push({
      field: "layout.anchors",
      message: "No content anchors defined"
    });
  }
}

/**
 * Validate design pattern
 */
function validateDesignPattern(
  spec: SlideSpecV2,
  errors: ValidationError[],
  warnings: ValidationWarning[]
): void {
  const validPatterns = ["hero", "split", "asymmetric", "grid", "minimal", "data-focused"];

  if (!spec.design.pattern || !validPatterns.includes(spec.design.pattern)) {
    errors.push({
      field: "design.pattern",
      message: `Invalid design pattern. Must be one of: ${validPatterns.join(", ")}`,
      severity: "high"
    });
  }

  if (!spec.design.visualHierarchy) {
    warnings.push({
      field: "design.visualHierarchy",
      message: "Visual hierarchy not defined"
    });
  }

  if (!spec.design.whitespace) {
    warnings.push({
      field: "design.whitespace",
      message: "Whitespace strategy not defined"
    });
  }
}

/**
 * Validate accessibility
 */
function validateAccessibility(
  spec: SlideSpecV2,
  errors: ValidationError[],
  warnings: ValidationWarning[],
  recommendations: string[]
): void {
  const sizes = spec.styleTokens.typography.sizes;

  if (sizes.step_0 < 14) {
    warnings.push({
      field: "typography.sizes.step_0",
      message: "Body font size is below recommended 14px minimum"
    });
  }

  if (sizes.step_0 < 12) {
    errors.push({
      field: "typography.sizes.step_0",
      message: "Body font size is below accessibility minimum of 12px",
      severity: "medium"
    });
  }

  const lineHeight = spec.styleTokens.typography.lineHeights.standard;
  if (lineHeight < 1.5) {
    recommendations.push("Increase line height to at least 1.5 for better readability");
  }

  recommendations.push("Ensure all text has sufficient contrast (WCAG AA: 4.5:1 minimum)");
  recommendations.push("Test with screen readers for semantic structure");
}

/**
 * Validate content
 */
function validateContent(
  spec: SlideSpecV2,
  errors: ValidationError[],
  warnings: ValidationWarning[]
): void {
  const content = spec.content;

  if (!content.title || !content.title.text) {
    warnings.push({
      field: "content.title",
      message: "No title text provided"
    });
  }

  if (content.title?.text && content.title.text.length > 100) {
    warnings.push({
      field: "content.title",
      message: "Title is very long (>100 characters)"
    });
  }

  if (content.bullets && content.bullets[0]) {
    const bulletCount = content.bullets[0].items.length;
    if (bulletCount > 6) {
      warnings.push({
        field: "content.bullets",
        message: `Too many bullet points (${bulletCount}). Recommended maximum is 6.`
      });
    }
  }
}

/**
 * Calculate validation score
 */
function calculateValidationScore(
  errors: ValidationError[],
  warnings: ValidationWarning[]
): number {
  let score = 100;

  // Deduct for errors
  const criticalErrors = errors.filter(e => e.severity === "critical").length;
  const highErrors = errors.filter(e => e.severity === "high").length;
  const mediumErrors = errors.filter(e => e.severity === "medium").length;

  score -= criticalErrors * 20;
  score -= highErrors * 10;
  score -= mediumErrors * 5;

  // Deduct for warnings
  score -= warnings.length * 2;

  return Math.max(0, score);
}

/**
 * Get validation summary
 */
export function getValidationSummary(result: ValidationResult): string {
  let summary = `Validation Score: ${result.score}/100\n`;
  summary += `Status: ${result.isValid ? "✓ Valid" : "✗ Invalid"}\n\n`;

  if (result.errors.length > 0) {
    summary += `Errors (${result.errors.length}):\n`;
    result.errors.forEach(error => {
      summary += `  [${error.severity.toUpperCase()}] ${error.field}: ${error.message}\n`;
    });
    summary += "\n";
  }

  if (result.warnings.length > 0) {
    summary += `Warnings (${result.warnings.length}):\n`;
    result.warnings.forEach(warning => {
      summary += `  ${warning.field}: ${warning.message}\n`;
    });
    summary += "\n";
  }

  if (result.recommendations.length > 0) {
    summary += `Recommendations:\n`;
    result.recommendations.forEach(rec => {
      summary += `  • ${rec}\n`;
    });
  }

  return summary;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/errorHandler.ts
=================================================================================
/**
 * Enhanced Error Handler
 * Provides comprehensive error handling, logging, and recovery strategies
 */

import { logger } from "firebase-functions/v2";

export class AppError extends Error {
  constructor(
    public code: string,
    public message: string,
    public statusCode: number = 500,
    public details?: Record<string, any>
  ) {
    super(message);
    this.name = "AppError";
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: Record<string, any>) {
    super("VALIDATION_ERROR", message, 400, details);
    this.name = "ValidationError";
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string, details?: Record<string, any>) {
    super("NOT_FOUND", `${resource} not found`, 404, details);
    this.name = "NotFoundError";
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string = "Unauthorized", details?: Record<string, any>) {
    super("UNAUTHORIZED", message, 401, details);
    this.name = "UnauthorizedError";
  }
}

export class RateLimitError extends AppError {
  constructor(message: string = "Rate limit exceeded", details?: Record<string, any>) {
    super("RATE_LIMIT", message, 429, details);
    this.name = "RateLimitError";
  }
}

export class TimeoutError extends AppError {
  constructor(operation: string, details?: Record<string, any>) {
    super("TIMEOUT", `${operation} timed out`, 504, details);
    this.name = "TimeoutError";
  }
}

/**
 * Error logger with context
 */
export function logError(
  error: Error | AppError,
  context: Record<string, any> = {}
): void {
  const errorInfo: Record<string, any> = {
    name: error.name,
    message: error.message,
    stack: error.stack,
    ...context
  };

  if (error instanceof AppError) {
    errorInfo.code = error.code;
    errorInfo.statusCode = error.statusCode;
    if (error.details) {
      errorInfo.details = error.details;
    }
  }

  logger.error("Error occurred", errorInfo);
}

/**
 * Safe error response for API
 */
export function getSafeErrorResponse(error: Error | AppError): {
  error: string;
  code?: string;
  statusCode: number;
} {
  if (error instanceof AppError) {
    return {
      error: error.message,
      code: error.code,
      statusCode: error.statusCode
    };
  }

  // Don't expose internal error details
  return {
    error: "An unexpected error occurred",
    statusCode: 500
  };
}

/**
 * Wrap async function with error handling
 */
export async function withErrorHandling<T>(
  fn: () => Promise<T>,
  context: Record<string, any> = {}
): Promise<T> {
  try {
    return await fn();
  } catch (error) {
    logError(error as Error, context);
    throw error;
  }
}

/**
 * Wrap sync function with error handling
 */
export function withErrorHandlingSync<T>(
  fn: () => T,
  context: Record<string, any> = {}
): T {
  try {
    return fn();
  } catch (error) {
    logError(error as Error, context);
    throw error;
  }
}

/**
 * Validate required fields
 */
export function validateRequired(
  obj: Record<string, any>,
  fields: string[]
): void {
  const missing = fields.filter(field => !obj[field]);
  if (missing.length > 0) {
    throw new ValidationError(`Missing required fields: ${missing.join(", ")}`, {
      missing
    });
  }
}

/**
 * Validate field types
 */
export function validateTypes(
  obj: Record<string, any>,
  schema: Record<string, string>
): void {
  const errors: Record<string, string> = {};

  for (const [field, expectedType] of Object.entries(schema)) {
    const value = obj[field];
    const actualType = typeof value;

    if (actualType !== expectedType) {
      errors[field] = `Expected ${expectedType}, got ${actualType}`;
    }
  }

  if (Object.keys(errors).length > 0) {
    throw new ValidationError("Type validation failed", errors);
  }
}

/**
 * Validate string length
 */
export function validateStringLength(
  value: string,
  minLength: number,
  maxLength: number,
  fieldName: string = "value"
): void {
  if (value.length < minLength || value.length > maxLength) {
    throw new ValidationError(
      `${fieldName} must be between ${minLength} and ${maxLength} characters`,
      { fieldName, minLength, maxLength, actualLength: value.length }
    );
  }
}

/**
 * Validate email format
 */
export function validateEmail(email: string): void {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    throw new ValidationError("Invalid email format", { email });
  }
}

/**
 * Validate URL format
 */
export function validateUrl(url: string): void {
  try {
    new URL(url);
  } catch {
    throw new ValidationError("Invalid URL format", { url });
  }
}

/**
 * Validate JSON
 */
export function validateJSON(jsonString: string): Record<string, any> {
  try {
    return JSON.parse(jsonString);
  } catch (error) {
    throw new ValidationError("Invalid JSON format", {
      error: (error as Error).message
    });
  }
}

/**
 * Create timeout promise
 */
export function createTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number,
  operationName: string = "Operation"
): Promise<T> {
  return Promise.race([
    promise,
    new Promise<T>((_, reject) =>
      setTimeout(
        () => reject(new TimeoutError(operationName)),
        timeoutMs
      )
    )
  ]);
}

/**
 * Retry with exponential backoff and error handling
 */
export async function retryWithErrorHandling<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  initialDelay: number = 100,
  context: Record<string, any> = {}
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      if (attempt < maxRetries - 1) {
        const delay = initialDelay * Math.pow(2, attempt);
        logger.warn(`Retry attempt ${attempt + 1}/${maxRetries}`, {
          ...context,
          delay,
          error: (error as Error).message
        });
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  logError(lastError || new Error("Max retries exceeded"), context);
  throw lastError || new Error("Max retries exceeded");
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/imageHelpers.ts
=================================================================================
/**
 * Image Helpers
 * Fetch, process, and embed images from various sources
 */

import { logger } from "firebase-functions/v2";

export interface ImageSource {
  type: "url" | "unsplash" | "placeholder";
  url?: string;
  query?: string;
  alt?: string;
}

export interface ProcessedImage {
  data: Buffer;
  mimeType: string;
  width: number;
  height: number;
}

/**
 * Fetch image from URL
 */
export async function fetchImageFromUrl(url: string): Promise<ProcessedImage | null> {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      logger.warn(`Failed to fetch image from ${url}: ${response.status}`);
      return null;
    }

    const contentType = response.headers.get("content-type") || "image/jpeg";
    const arrayBuffer = await response.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Basic validation
    if (buffer.length === 0) {
      logger.warn(`Empty image data from ${url}`);
      return null;
    }

    // Estimate dimensions (actual dimensions would require image processing library)
    // For now, use default dimensions
    return {
      data: buffer,
      mimeType: contentType,
      width: 1920,
      height: 1080
    };
  } catch (error) {
    logger.error(`Error fetching image from ${url}:`, error);
    return null;
  }
}

/**
 * Fetch image from Unsplash
 * Uses Unsplash API to get high-quality stock photos
 */
export async function fetchImageFromUnsplash(
  query: string,
  width: number = 1920,
  height: number = 1080
): Promise<ProcessedImage | null> {
  try {
    // Unsplash Source API (no API key required for basic usage)
    // For production, use official Unsplash API with proper attribution
    const unsplashUrl = `https://source.unsplash.com/${width}x${height}/?${encodeURIComponent(query)}`;
    
    logger.info(`Fetching Unsplash image for query: ${query}`);
    return await fetchImageFromUrl(unsplashUrl);
  } catch (error) {
    logger.error(`Error fetching Unsplash image for query "${query}":`, error);
    return null;
  }
}

/**
 * Generate placeholder image data URL
 * Creates a simple colored rectangle as placeholder
 */
export function generatePlaceholderImage(
  width: number = 1920,
  height: number = 1080,
  color: string = "#E5E7EB",
  text: string = "Image Placeholder"
): string {
  // Generate SVG placeholder
  const svg = `
    <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="${color}"/>
      <text x="50%" y="50%" font-family="Arial, sans-serif" font-size="48" 
            fill="#6B7280" text-anchor="middle" dominant-baseline="middle">
        ${text}
      </text>
    </svg>
  `;
  
  return `data:image/svg+xml;base64,${Buffer.from(svg).toString("base64")}`;
}

/**
 * Process image source and return image data
 */
export async function processImageSource(source: ImageSource): Promise<ProcessedImage | string | null> {
  switch (source.type) {
    case "url":
      if (!source.url) {
        logger.warn("URL image source missing url property");
        return null;
      }
      return await fetchImageFromUrl(source.url);

    case "unsplash":
      if (!source.query) {
        logger.warn("Unsplash image source missing query property");
        return null;
      }
      return await fetchImageFromUnsplash(source.query);

    case "placeholder":
      return generatePlaceholderImage(1920, 1080, "#E5E7EB", source.alt || "Image");

    default:
      logger.warn(`Unknown image source type: ${source.type}`);
      return null;
  }
}

/**
 * Validate image URL
 */
export function isValidImageUrl(url: string): boolean {
  try {
    const parsed = new URL(url);
    const validProtocols = ["http:", "https:"];
    const validExtensions = [".jpg", ".jpeg", ".png", ".gif", ".webp", ".svg"];
    
    if (!validProtocols.includes(parsed.protocol)) {
      return false;
    }

    const pathname = parsed.pathname.toLowerCase();
    return validExtensions.some(ext => pathname.endsWith(ext)) || pathname.includes("/image");
  } catch {
    return false;
  }
}

/**
 * Get optimal image dimensions for slide layout
 */
export function getOptimalImageDimensions(
  role: "hero" | "logo" | "illustration" | "icon" | "background",
  slideWidth: number = 10,
  slideHeight: number = 7.5
): { width: number; height: number; x: number; y: number; w: number; h: number } {
  switch (role) {
    case "hero":
      // Large hero image - 60% of slide width, centered
      return {
        width: 1920,
        height: 1080,
        x: slideWidth * 0.05,
        y: slideHeight * 0.15,
        w: slideWidth * 0.9,
        h: slideHeight * 0.7
      };

    case "logo":
      // Small logo - top right corner
      return {
        width: 400,
        height: 400,
        x: slideWidth - 1.5,
        y: 0.5,
        w: 1,
        h: 1
      };

    case "illustration":
      // Medium illustration - right side
      return {
        width: 1200,
        height: 1200,
        x: slideWidth * 0.55,
        y: slideHeight * 0.2,
        w: slideWidth * 0.4,
        h: slideHeight * 0.6
      };

    case "icon":
      // Small icon - inline with content
      return {
        width: 200,
        height: 200,
        x: 0.5,
        y: 2,
        w: 0.5,
        h: 0.5
      };

    case "background":
      // Full slide background
      return {
        width: 1920,
        height: 1080,
        x: 0,
        y: 0,
        w: slideWidth,
        h: slideHeight
      };

    default:
      // Default medium size
      return {
        width: 1200,
        height: 800,
        x: slideWidth * 0.1,
        y: slideHeight * 0.2,
        w: slideWidth * 0.8,
        h: slideHeight * 0.6
      };
  }
}

/**
 * Extract dominant color from image URL (simplified)
 * In production, use image processing library to analyze actual image
 */
export function estimateDominantColor(imageUrl: string): string {
  // Simple heuristic based on URL keywords
  const url = imageUrl.toLowerCase();
  
  if (url.includes("blue") || url.includes("ocean") || url.includes("sky")) return "#3B82F6";
  if (url.includes("green") || url.includes("nature") || url.includes("forest")) return "#10B981";
  if (url.includes("red") || url.includes("fire") || url.includes("sunset")) return "#EF4444";
  if (url.includes("purple") || url.includes("violet")) return "#8B5CF6";
  if (url.includes("orange") || url.includes("autumn")) return "#F59E0B";
  if (url.includes("pink") || url.includes("rose")) return "#EC4899";
  
  // Default neutral
  return "#64748B";
}

/**
 * Suggest Unsplash search queries based on slide content
 */
export function suggestImageQuery(
  title: string,
  subtitle?: string,
  contentType?: string
): string {
  const text = `${title} ${subtitle || ""}`.toLowerCase();
  
  // Business/Corporate
  if (text.match(/business|corporate|office|meeting|team/)) {
    return "business professional office";
  }
  
  // Technology
  if (text.match(/tech|software|digital|ai|data|cloud/)) {
    return "technology abstract modern";
  }
  
  // Finance
  if (text.match(/finance|money|investment|revenue|profit/)) {
    return "finance business growth";
  }
  
  // Healthcare
  if (text.match(/health|medical|care|wellness/)) {
    return "healthcare medical professional";
  }
  
  // Marketing
  if (text.match(/marketing|brand|campaign|social/)) {
    return "marketing creative design";
  }
  
  // Growth/Success
  if (text.match(/growth|success|achievement|goal/)) {
    return "success growth achievement";
  }
  
  // Innovation
  if (text.match(/innovation|future|transform|disrupt/)) {
    return "innovation technology future";
  }
  
  // Default
  return "business professional modern";
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/index.ts
=================================================================================
import * as logger from "firebase-functions/logger";
import corsLib from "cors";
import { setGlobalOptions } from "firebase-functions/v2";
import { onRequest } from "firebase-functions/v2/https";
import { defineSecret } from "firebase-functions/params";
import { getApp } from "firebase-admin/app";
import { initializeApp } from "firebase-admin/app";
import { z } from "zod";
import PptxGenJS from "pptxgenjs";

// For external calls
import { fetch as undiciFetch } from "undici";

// Import AI helpers
import { callAIWithRetry, sanitizePrompt, moderateContent, enhanceSlideSpec } from "./aiHelpers";
import { ENHANCED_SYSTEM_PROMPT } from "./prompts";
import { generatePresentationPrompt, analyzePresentationRequest, validatePresentationFlow } from "./presentationAI";
import type { PresentationRequest } from "./presentationAI";

// Import PPTX builders
import { buildProfessionalSlide } from "./pptxBuilder";
import { buildMinimalSlide } from "./pptxBuilder/minimalBuilder";
import { buildHybridSlide } from "./pptxBuilder/hybridBuilder";
import { buildPremiumSlide } from "./pptxBuilder/premiumBuilder";
import { buildLayoutSlide } from "./pptxBuilder/layoutBuilder";

// Define secrets
const AI_API_KEY = defineSecret("AI_API_KEY");
const AI_BASE_URL = defineSecret("AI_BASE_URL");
const AI_MODEL = defineSecret("AI_MODEL");

setGlobalOptions({ region: "us-central1", memory: "512MiB", cpu: 1, timeoutSeconds: 60 });

// Admin init (idempotent)
try { getApp(); } catch { initializeApp(); }

const cors = corsLib({ origin: true }); // simple permissive CORS for MVP

/** SlideSpec schema (lean) */
const SlideSpecZ = z.object({
  meta: z.object({
    version: z.literal("1.0"),
    locale: z.string().default("en-US"),
    theme: z.string(),
    aspectRatio: z.enum(["16:9","4:3"]).default("16:9")
  }),
  content: z.object({
    title: z.object({ id: z.string(), text: z.string().min(1) }),
    subtitle: z.object({ id: z.string(), text: z.string().min(1) }).optional(),
    bullets: z.array(z.object({
      id: z.string(),
      items: z.array(z.object({ text: z.string(), level: z.number().int().min(1).max(3) })).min(1).max(8)
    })).max(3).optional(),
    callouts: z.array(z.object({
      id: z.string(), title: z.string().optional(), text: z.string(), variant: z.enum(["note","success","warning","danger"])
    })).max(2).optional(),
    dataViz: z.object({
      id: z.string(),
      kind: z.enum(["bar","line","pie"]),
      title: z.string().optional(),
      labels: z.array(z.string()).min(2).max(10),
      series: z.array(z.object({ name: z.string(), values: z.array(z.number()) })).min(1).max(3)
    }).optional(),
    imagePlaceholders: z.array(z.object({
      id: z.string(), role: z.enum(["hero","logo","illustration","icon"]), alt: z.string()
    })).max(2).optional()
  }),
  layout: z.object({
    grid: z.object({
      rows: z.number().int().min(3).max(12),
      cols: z.number().int().min(3).max(12),
      gutter: z.number().min(0),
      margin: z.object({ t: z.number(), r: z.number(), b: z.number(), l: z.number() })
    }),
    regions: z.array(z.object({
      name: z.enum(["header","body","footer","aside"]),
      rowStart: z.number().int().positive(), colStart: z.number().int().positive(),
      rowSpan: z.number().int().positive(),  colSpan: z.number().int().positive()
    })).min(1).max(4),
    anchors: z.array(z.object({
      refId: z.string(), region: z.enum(["header","body","footer","aside"]), order: z.number().int().min(0),
      span: z.object({ rows: z.number().int().positive(), cols: z.number().int().positive() }).optional()
    })).min(1).max(8)
  }),
  styleTokens: z.object({
    palette: z.object({ primary: z.string(), accent: z.string(), neutral: z.array(z.string()).min(5).max(9) }),
    typography: z.object({
      fonts: z.object({ sans: z.string(), serif: z.string().optional(), mono: z.string().optional() }),
      sizes: z.object({ "step_-2": z.number(), "step_-1": z.number(), step_0: z.number(), step_1: z.number(), step_2: z.number(), step_3: z.number() }),
      weights: z.object({ regular: z.number(), medium: z.number(), semibold: z.number(), bold: z.number() }),
      lineHeights: z.object({ compact: z.number(), standard: z.number() })
    }),
    spacing: z.object({ base: z.number(), steps: z.array(z.number()).min(5).max(10) }),
    radii: z.object({ sm: z.number(), md: z.number(), lg: z.number() }),
    shadows: z.object({ sm: z.string(), md: z.string(), lg: z.string() }),
    contrast: z.object({ minTextContrast: z.number(), minUiContrast: z.number() })
  }),
  components: z.object({
    bulletList: z.object({ variant: z.enum(["compact","spacious"]).optional() }).optional(),
    callout: z.object({ variant: z.enum(["flat","elevated"]).optional() }).optional(),
    chart: z.object({ legend: z.enum(["none","right","bottom"]).optional(), gridlines: z.boolean().optional() }).optional(),
    image: z.object({ fit: z.enum(["cover","contain"]).optional() }).optional(),
    title: z.object({ align: z.enum(["left","center","right"]).optional() }).optional()
  }).optional()
});
type SlideSpec = z.infer<typeof SlideSpecZ>;

/** System prompt (JSON-only) */
const SYSTEM_PROMPT = `
You are the SlideSpec generator for plzfixthx.
Return a SINGLE RFC8259-compliant JSON object that VALIDATES against SlideSpec v1.
Hard rules:
- Output ONLY JSON.
- meta.version "1.0"; aspectRatio "16:9" default.
- Concise, professional text; <=6 bullets total; levels 1-3.
- If dataViz present, labels 2..10; series lengths == labels length.
- Hex colors (#RRGGBB). IDs [A-Za-z0-9_-].
`;

/** Offline fallback SlideSpec (no AI) */
function fallbackSpec(prompt: string): SlideSpec {
  return {
    meta: { version: "1.0", locale: "en-US", theme: "Clean", aspectRatio: "16:9" },
    content: {
      title: { id: "title", text: prompt?.trim() ? prompt : "AI-Powered Slide in Seconds" },
      subtitle: { id: "subtitle", text: "plzfixthx — preview & export" },
      bullets: [{ id: "b1", items: [
        { text: "Type a prompt; get a polished slide", level: 1 },
        { text: "Live preview in browser", level: 1 },
        { text: "Download a .pptx", level: 1 }
      ]}],
      callouts: [{ id: "c1", text: "Preview ≤ 3s, Export ≤ 10s", variant: "success" }]
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 24, r: 24, b: 24, l: 24 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body",   rowStart: 3, colStart: 1, rowSpan: 5, colSpan: 8 },
        { name: "aside",  rowStart: 3, colStart: 9, rowSpan: 5, colSpan: 4 }
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "subtitle", region: "header", order: 1 },
        { refId: "b1", region: "body", order: 0 },
        { refId: "c1", region: "aside", order: 0 }
      ]
    },
    styleTokens: {
      palette: { primary: "#2563EB", accent: "#F59E0B", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#E2E8F0"] },
      typography: {
        fonts: { sans: "Inter, Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 32 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.5 }
      },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32] },
      radii: { sm: 2, md: 6, lg: 12 },
      shadows: { sm: "0 1px 2px rgba(0,0,0,.06)", md: "0 4px 8px rgba(0,0,0,.12)", lg: "0 12px 24px rgba(0,0,0,.18)" },
      contrast: { minTextContrast: 4.5, minUiContrast: 3 }
    }
  };
}


/** AI adapter (OpenAI-compatible HTTP). Returns SlideSpec or throws. */
async function callVendor(prompt: string): Promise<SlideSpec> {
  const key = AI_API_KEY.value() ?? "";
  const base = AI_BASE_URL.value() || "https://api.openai.com/v1";
  const model = AI_MODEL.value() || "gpt-4o-mini"; // any JSON-capable chat model

  if (!key) {
    logger.warn("AI_API_KEY not set — using fallback");
    return fallbackSpec(prompt);
  }

  // Use enhanced AI calling with retry logic
  const result = await callAIWithRetry(prompt, key, base, model, SlideSpecZ);

  // Post-process and enhance the result
  const enhanced = enhanceSlideSpec(result);

  return enhanced as SlideSpec;
}

/** POST /generateSlideSpec {prompt} -> {spec} */
export const generateSlideSpec = onRequest({ cors: false, secrets: [AI_API_KEY, AI_BASE_URL, AI_MODEL] }, (req, res) => {
  cors(req, res, async () => {
    if (req.method !== "POST") return res.status(405).send("Method Not Allowed");

    try {
      // Sanitize and validate prompt
      const rawPrompt = (req.body?.prompt ?? "").toString();
      const prompt = sanitizePrompt(rawPrompt, 800);

      // Content moderation
      const moderation = moderateContent(prompt);
      if (!moderation.safe) {
        return res.status(400).json({
          error: moderation.reason || "Content not allowed",
          spec: fallbackSpec("Content moderation failed")
        });
      }

      // Generate slide spec
      const spec = await callVendor(prompt);
      res.status(200).json({ spec });
    } catch (e: any) {
      logger.error("Error generating slide spec", { error: e.message, stack: e.stack });

      // Return fallback spec on error
      const fallback = fallbackSpec(req.body?.prompt || "");
      res.status(200).json({
        spec: fallback,
        warning: "Using fallback due to error: " + e.message
      });
    }
  });
});

/** POST /exportPPTX {spec} or {specs: []} -> .pptx binary */
export const exportPPTX = onRequest({ cors: false }, (req, res) => {
  cors(req, res, async () => {
    if (req.method !== "POST") return res.status(405).send("Method Not Allowed");
    try {
      // Support both single spec and array of specs
      const body = req.body;
      let specs: any[];

      if (body?.specs && Array.isArray(body.specs)) {
        // Multiple slides
        specs = body.specs.map((s: any) => SlideSpecZ.parse(s));
      } else if (body?.spec) {
        // Single slide (backward compatibility)
        specs = [SlideSpecZ.parse(body.spec)];
      } else {
        throw new Error("Missing spec or specs in request body");
      }

      const buf = await buildPptx(specs);
      res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.presentationml.presentation");
      res.setHeader("Content-Disposition", `attachment; filename="plzfixthx-presentation.pptx"`);
      res.status(200).send(Buffer.from(buf));
    } catch (e: any) {
      logger.error(e);
      res.status(400).send(`Export error: ${e.message || String(e)}`);
    }
  });
});

/** PPTX builder - supports single or multiple slides */
async function buildPptx(specs: SlideSpec | SlideSpec[]): Promise<ArrayBuffer> {
  const specsArray = Array.isArray(specs) ? specs : [specs];
  if (specsArray.length === 0) {
    throw new Error("No slides to export");
  }

  const pptx = new PptxGenJS();
  const firstSpec = specsArray[0];
  pptx.layout = firstSpec.meta.aspectRatio === "4:3" ? "LAYOUT_4x3" : "LAYOUT_16x9";

  // Build each slide
  for (const spec of specsArray) {
    await buildSlide(pptx, spec);
  }

  return pptx.write({ outputType: "arraybuffer" }) as Promise<ArrayBuffer>;
}

/** Build a single slide */
async function buildSlide(pptx: PptxGenJS, spec: SlideSpec): Promise<void> {
  logger.info("🏗️ buildSlide called", {
    hasTitle: !!spec.content.title,
    hasSubtitle: !!spec.content.subtitle,
    hasLayout: !!spec.layout,
  });

  try {
    // Use layout builder first - respects spec's layout grid system
    logger.info("📐 Attempting layout builder...");
    await buildLayoutSlide(pptx, spec as any);
    logger.info("✅ Layout builder succeeded");
    return;
  } catch (e) {
    logger.error("❌ Layout slide builder failed, falling back to minimal", { error: String(e) });
    // Fallback to minimal builder if layout fails
    try {
      logger.info("📐 Attempting minimal builder...");
      await buildMinimalSlide(pptx, spec as any);
      logger.info("✅ Minimal builder succeeded");
      return;
    } catch (minimalError) {
      logger.error("❌ Minimal slide builder also failed, falling back to premium", { error: String(minimalError) });
      // Final fallback to premium builder
      try {
        logger.info("📐 Attempting premium builder...");
        await buildPremiumSlide(pptx, spec as any);
        logger.info("✅ Premium builder succeeded");
      } catch (fallbackError) {
        logger.error("❌ Premium slide builder also failed", { error: String(fallbackError) });
        throw fallbackError;
      }
    }
  }
}

/** Legacy basic builder - kept for reference */
async function buildSlideBasic(pptx: PptxGenJS, spec: SlideSpec): Promise<void> {
  const slide = pptx.addSlide();

  // Helpers
  const pxToIn = (px: number) => (px * 0.75) / 72;
  const { rows, cols, gutter, margin } = spec.layout.grid;
  const slideW = pptx.presLayout.width;
  const slideH = pptx.presLayout.height;
  const pad = { t: pxToIn(margin.t), r: pxToIn(margin.r), b: pxToIn(margin.b), l: pxToIn(margin.l) };
  const gridW = slideW - pad.l - pad.r;
  const gridH = slideH - pad.t - pad.b;
  const cellW = (gridW - ((cols - 1) * pxToIn(gutter))) / cols;
  const cellH = (gridH - ((rows - 1) * pxToIn(gutter))) / rows;

  const regionRect = (r: any) => ({
    x: pad.l + (r.colStart - 1) * (cellW + pxToIn(gutter)),
    y: pad.t + (r.rowStart - 1) * (cellH + pxToIn(gutter)),
    w: r.colSpan * cellW + (r.colSpan - 1) * pxToIn(gutter),
    h: r.rowSpan * cellH + (r.rowSpan - 1) * pxToIn(gutter)
  });
  const regions: Record<string, any> = {};
  spec.layout.regions.forEach(r => { regions[r.name] = regionRect(r); });

  const fonts = spec.styleTokens.typography.fonts;
  const sizes = spec.styleTokens.typography.sizes;
  const colorText = spec.styleTokens.palette.neutral[0];

  // Title
  const tA = spec.layout.anchors.find(a => a.refId === spec.content.title.id);
  if (tA) {
    const rect = regions[tA.region];
    slide.addText(spec.content.title.text, {
      x: rect.x, y: rect.y, w: rect.w, h: 1,
      fontFace: fonts.sans, fontSize: sizes.step_3 * 0.75, bold: true, color: colorText, align: spec.components?.title?.align || "left"
    });
  }

  // Subtitle
  const sub = spec.content.subtitle;
  if (sub) {
    const a = spec.layout.anchors.find(x => x.refId === sub.id);
    if (a) {
      const rect = regions[a.region];
      slide.addText(sub.text, { x: rect.x, y: rect.y + 0.7, w: rect.w, h: 0.7, fontFace: fonts.sans, fontSize: sizes.step_1 * 0.75, color: colorText });
    }
  }

  // Bullets (first list)
  const bl = spec.content.bullets?.[0];
  if (bl) {
    const a = spec.layout.anchors.find(x => x.refId === bl.id);
    if (a) {
      const rect = regions[a.region];
      slide.addText(
        bl.items.map(it => ({ text: it.text, options: { bullet: true, indentLevel: it.level - 1 } })),
        { x: rect.x, y: rect.y, w: rect.w, h: rect.h, fontFace: fonts.sans, fontSize: sizes.step_0 * 0.75, color: colorText, wrap: true }
      );
    }
  }

  // Callout (first)
  const co = spec.content.callouts?.[0];
  if (co) {
    const a = spec.layout.anchors.find(x => x.refId === co.id);
    if (a) {
      const rect = regions[a.region];
      slide.addShape(pptx.ShapeType.roundRect, {
        x: rect.x, y: rect.y, w: rect.w, h: 1.2,
        fill: { color: "FFFFFF" }, line: { color: spec.styleTokens.palette.accent },
        shadow: { type: "outer", color: "000000", opacity: 0.08, blur: 4, offset: 2 }
      });
      slide.addText(`${co.title ? co.title + " — " : ""}${co.text}`, {
        x: rect.x + 0.1, y: rect.y + 0.15, w: rect.w - 0.2, h: 0.9,
        fontFace: fonts.sans, fontSize: sizes.step_0 * 0.75, color: colorText
      });
    }
  }

  // Chart (naive)
  const dv = spec.content.dataViz;
  if (dv) {
    const a = spec.layout.anchors.find(x => x.refId === dv.id);
    if (a) {
      const rect = regions[a.region];
      const chartData = dv.series.map(s => ({ name: s.name, labels: dv.labels, values: s.values }));
      const type = dv.kind === "pie" ? pptx.ChartType.pie : dv.kind === "line" ? pptx.ChartType.line : pptx.ChartType.bar;
      slide.addChart(type, chartData, { x: rect.x, y: rect.y, w: rect.w, h: rect.h, showLegend: true });
    }
  }
}

/**
 * Generate Full Presentation
 * Creates a complete multi-slide presentation with narrative flow
 */
export const generatePresentation = onRequest(
  { cors: ["*"], secrets: [AI_API_KEY, AI_BASE_URL, AI_MODEL] },
  async (req, res) => {
    return cors(req, res, async () => {
      try {
        if (req.method !== "POST") {
          res.status(405).json({ error: "Method not allowed" });
          return;
        }

        const body = req.body as PresentationRequest;

        if (!body.topic) {
          res.status(400).json({ error: "Missing required field: topic" });
          return;
        }

        logger.info("Generating presentation", { topic: body.topic, audience: body.audience });

        // Analyze request and generate structure
        const structure = analyzePresentationRequest(body);

        // Generate enhanced prompt for full presentation
        const enhancedPrompt = generatePresentationPrompt(body);

        // Call AI to generate all slides
        const aiResponse = await callAIWithRetry(
          enhancedPrompt,
          AI_API_KEY.value(),
          AI_BASE_URL.value(),
          AI_MODEL.value() || "gpt-4",
          z.any() // Accept any response format for multi-slide
        );

        // Parse AI response - expecting array of slide specs
        let slideSpecs: any[];
        try {
          const parsed = JSON.parse(String(aiResponse));
          slideSpecs = Array.isArray(parsed) ? parsed : [parsed];
        } catch (parseError) {
          logger.error("Failed to parse AI response", { error: String(parseError) });
          res.status(500).json({ error: "Invalid AI response format" });
          return;
        }

        // Validate and enhance each slide
        const validatedSlides = slideSpecs.map(spec => {
          try {
            const validated = SlideSpecZ.parse(spec);
            return enhanceSlideSpec(validated);
          } catch (validationError) {
            logger.warn("Slide validation failed, using fallback", { error: String(validationError) });
            return spec; // Use as-is if validation fails
          }
        });

        // Validate presentation flow
        const flowValidation = validatePresentationFlow(validatedSlides);
        if (!flowValidation.valid) {
          logger.warn("Presentation flow issues detected", { issues: flowValidation.issues });
        }

        res.status(200).json({
          presentation: {
            title: body.topic,
            slideCount: validatedSlides.length,
            slides: validatedSlides,
            structure: structure,
            flowValidation: flowValidation
          }
        });

      } catch (error) {
        logger.error("Error generating presentation", { error: String(error) });
        res.status(500).json({ error: "Failed to generate presentation" });
      }
    });
  }
);

// Export performance and error handling utilities
export * from "./performanceOptimizer";
export * from "./errorHandler";



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/performanceOptimizer.ts
=================================================================================
/**
 * Performance Optimizer
 * Handles caching, memoization, and performance monitoring
 */

import { logger } from "firebase-functions/v2";

interface CacheEntry<T> {
  value: T;
  timestamp: number;
  ttl: number;
}

class PerformanceCache {
  private cache: Map<string, CacheEntry<any>> = new Map();
  private readonly defaultTTL = 5 * 60 * 1000; // 5 minutes

  /**
   * Get cached value if not expired
   */
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    const isExpired = Date.now() - entry.timestamp > entry.ttl;
    if (isExpired) {
      this.cache.delete(key);
      return null;
    }

    return entry.value as T;
  }

  /**
   * Set cache value with TTL
   */
  set<T>(key: string, value: T, ttl: number = this.defaultTTL): void {
    this.cache.set(key, {
      value,
      timestamp: Date.now(),
      ttl
    });
  }

  /**
   * Clear all cache
   */
  clear(): void {
    this.cache.clear();
  }

  /**
   * Get cache size
   */
  size(): number {
    return this.cache.size;
  }
}

/**
 * Performance metrics tracker
 */
class PerformanceMetrics {
  private metrics: Map<string, number[]> = new Map();

  /**
   * Record metric value
   */
  record(name: string, value: number): void {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name)!.push(value);
  }

  /**
   * Get average for metric
   */
  getAverage(name: string): number {
    const values = this.metrics.get(name);
    if (!values || values.length === 0) return 0;
    return values.reduce((a, b) => a + b, 0) / values.length;
  }

  /**
   * Get max for metric
   */
  getMax(name: string): number {
    const values = this.metrics.get(name);
    if (!values || values.length === 0) return 0;
    return Math.max(...values);
  }

  /**
   * Get min for metric
   */
  getMin(name: string): number {
    const values = this.metrics.get(name);
    if (!values || values.length === 0) return 0;
    return Math.min(...values);
  }

  /**
   * Get all metrics summary
   */
  getSummary(): Record<string, { avg: number; min: number; max: number; count: number }> {
    const summary: Record<string, any> = {};
    for (const [name, values] of this.metrics.entries()) {
      summary[name] = {
        avg: this.getAverage(name),
        min: this.getMin(name),
        max: this.getMax(name),
        count: values.length
      };
    }
    return summary;
  }

  /**
   * Clear metrics
   */
  clear(): void {
    this.metrics.clear();
  }
}

/**
 * Measure execution time of async function
 */
export async function measureAsync<T>(
  name: string,
  fn: () => Promise<T>,
  metrics?: PerformanceMetrics
): Promise<T> {
  const start = Date.now();
  try {
    const result = await fn();
    const duration = Date.now() - start;
    if (metrics) {
      metrics.record(name, duration);
    }
    logger.info(`⏱️ ${name} completed in ${duration}ms`);
    return result;
  } catch (error) {
    const duration = Date.now() - start;
    logger.error(`❌ ${name} failed after ${duration}ms`, { error });
    throw error;
  }
}

/**
 * Measure execution time of sync function
 */
export function measureSync<T>(
  name: string,
  fn: () => T,
  metrics?: PerformanceMetrics
): T {
  const start = Date.now();
  try {
    const result = fn();
    const duration = Date.now() - start;
    if (metrics) {
      metrics.record(name, duration);
    }
    logger.info(`⏱️ ${name} completed in ${duration}ms`);
    return result;
  } catch (error) {
    const duration = Date.now() - start;
    logger.error(`❌ ${name} failed after ${duration}ms`, { error });
    throw error;
  }
}

/**
 * Retry logic with exponential backoff
 */
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  initialDelay: number = 100
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      if (attempt < maxRetries - 1) {
        const delay = initialDelay * Math.pow(2, attempt);
        logger.warn(`Retry attempt ${attempt + 1}/${maxRetries} after ${delay}ms`, { error });
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError || new Error("Max retries exceeded");
}

/**
 * Debounce function calls
 */
export function debounce<T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout | null = null;

  return (...args: Parameters<T>) => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      fn(...args);
      timeoutId = null;
    }, delay);
  };
}

/**
 * Memoize function results
 */
export function memoize<T extends (...args: any[]) => any>(fn: T): T {
  const cache = new Map<string, any>();

  return ((...args: Parameters<T>) => {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn(...args);
    cache.set(key, result);
    return result;
  }) as T;
}

/**
 * Batch operations for efficiency
 */
export class BatchProcessor<T, R> {
  private queue: T[] = [];
  private processing = false;
  private readonly batchSize: number;
  private readonly processor: (batch: T[]) => Promise<R[]>;

  constructor(batchSize: number, processor: (batch: T[]) => Promise<R[]>) {
    this.batchSize = batchSize;
    this.processor = processor;
  }

  /**
   * Add item to batch
   */
  async add(item: T): Promise<R[] | null> {
    this.queue.push(item);
    if (this.queue.length >= this.batchSize) {
      return this.flush();
    }
    return null;
  }

  /**
   * Process all queued items
   */
  async flush(): Promise<R[] | null> {
    if (this.queue.length === 0 || this.processing) {
      return null;
    }

    this.processing = true;
    try {
      const batch = this.queue.splice(0, this.batchSize);
      const results = await this.processor(batch);
      return results;
    } finally {
      this.processing = false;
    }
  }

  /**
   * Get queue size
   */
  size(): number {
    return this.queue.length;
  }
}

// Export singleton instances
export const performanceCache = new PerformanceCache();
export const performanceMetrics = new PerformanceMetrics();



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/__tests__/designAccents.test.ts
=================================================================================
/**
 * Tests for Design Accents
 * Validates that all design accent functions work correctly
 */

import { describe, it, expect, beforeEach, vi } from "vitest";
import {
  addGradientOverlay,
  addCornerFlourish,
  addLineAccent,
  addDotPattern,
  addWaveAccent,
  addContentShadow,
  addFrameAccent,
  addConnectorLine
} from "../designAccents";

describe("Design Accents", () => {
  let mockSlide: any;

  beforeEach(() => {
    mockSlide = {
      addShape: vi.fn()
    };
  });

  describe("addGradientOverlay", () => {
    it("should add gradient overlay with default parameters", () => {
      addGradientOverlay(mockSlide, "#6366F1", "#EC4899");
      expect(mockSlide.addShape).toHaveBeenCalled();
      expect(mockSlide.addShape.mock.calls.length).toBeGreaterThan(0);
    });

    it("should add gradient overlay with custom opacity", () => {
      addGradientOverlay(mockSlide, "#6366F1", "#EC4899", 0.1);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add gradient overlay with different directions", () => {
      addGradientOverlay(mockSlide, "#6366F1", "#EC4899", 0.05, "top-to-bottom");
      addGradientOverlay(mockSlide, "#6366F1", "#EC4899", 0.05, "left-to-right");
      addGradientOverlay(mockSlide, "#6366F1", "#EC4899", 0.05, "diagonal");
      expect(mockSlide.addShape.mock.calls.length).toBeGreaterThan(0);
    });
  });

  describe("addCornerFlourish", () => {
    it("should add corner flourish to top-left", () => {
      addCornerFlourish(mockSlide, "top-left", "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add corner flourish to top-right", () => {
      addCornerFlourish(mockSlide, "top-right", "#EC4899");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add corner flourish to bottom-left", () => {
      addCornerFlourish(mockSlide, "bottom-left", "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add corner flourish to bottom-right", () => {
      addCornerFlourish(mockSlide, "bottom-right", "#EC4899");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add corner flourish with custom size", () => {
      addCornerFlourish(mockSlide, "top-right", "#6366F1", 0.5);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });

  describe("addLineAccent", () => {
    it("should add line accent to top", () => {
      addLineAccent(mockSlide, "top", "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add line accent to bottom", () => {
      addLineAccent(mockSlide, "bottom", "#EC4899");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add line accent to left", () => {
      addLineAccent(mockSlide, "left", "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add line accent to right", () => {
      addLineAccent(mockSlide, "right", "#EC4899");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add line accent with custom thickness", () => {
      addLineAccent(mockSlide, "top", "#6366F1", 0.12);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });

  describe("addDotPattern", () => {
    it("should add sparse dot pattern", () => {
      addDotPattern(mockSlide, "#6366F1", "sparse");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add moderate dot pattern", () => {
      addDotPattern(mockSlide, "#EC4899", "moderate");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add dense dot pattern", () => {
      addDotPattern(mockSlide, "#6366F1", "dense");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add dot pattern with custom opacity", () => {
      addDotPattern(mockSlide, "#6366F1", "sparse", 0.2);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });

  describe("addWaveAccent", () => {
    it("should add wave accent with default height", () => {
      addWaveAccent(mockSlide, "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add wave accent with custom height", () => {
      addWaveAccent(mockSlide, "#EC4899", 0.8);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });

  describe("addContentShadow", () => {
    it("should add content shadow with default parameters", () => {
      addContentShadow(mockSlide, 0.5, 0.5, 2, 1);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add content shadow with custom color", () => {
      addContentShadow(mockSlide, 0.5, 0.5, 2, 1, "FF0000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add content shadow with custom blur", () => {
      addContentShadow(mockSlide, 0.5, 0.5, 2, 1, "000000", 12);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });

  describe("addFrameAccent", () => {
    it("should add frame accent", () => {
      addFrameAccent(mockSlide, 0.5, 0.5, 2, 1, "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
      // Should create 4 borders (top, right, bottom, left)
      expect(mockSlide.addShape.mock.calls.length).toBe(4);
    });

    it("should add frame accent with custom thickness", () => {
      addFrameAccent(mockSlide, 0.5, 0.5, 2, 1, "#EC4899", 0.08);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });

  describe("addConnectorLine", () => {
    it("should add connector line between two points", () => {
      addConnectorLine(mockSlide, 0, 0, 2, 2, "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add connector line with custom thickness", () => {
      addConnectorLine(mockSlide, 0, 0, 2, 2, "#EC4899", 0.08);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add horizontal connector line", () => {
      addConnectorLine(mockSlide, 0, 1, 5, 1, "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add vertical connector line", () => {
      addConnectorLine(mockSlide, 2, 0, 2, 5, "#EC4899");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/__tests__/enhancedAnimations.test.ts
=================================================================================
import { describe, it, expect } from "vitest";
import {
  createAnimation,
  getRecommendedAnimation,
  getAnimationDuration,
  createStaggerConfig,
  getEasingCurve,
  calculateSequenceTiming,
  getAnimationPreset,
  validateAnimationConfig,
  getAnimationMetadata,
  type AnimationType,
  type AnimationConfig
} from "../enhancedAnimations";

describe("Enhanced Animations", () => {
  describe("createAnimation", () => {
    it("should create animation with default values", () => {
      const animation = createAnimation("fade-in");
      expect(animation.type).toBe("fade-in");
      expect(animation.duration).toBe(500);
      expect(animation.delay).toBe(0);
      expect(animation.easing).toBe("ease-out");
    });

    it("should create animation with custom values", () => {
      const animation = createAnimation("slide-in-left", 800, 200, "ease-in");
      expect(animation.type).toBe("slide-in-left");
      expect(animation.duration).toBe(800);
      expect(animation.delay).toBe(200);
      expect(animation.easing).toBe("ease-in");
    });
  });

  describe("getRecommendedAnimation", () => {
    it("should return fade-in for title", () => {
      const animation = getRecommendedAnimation("title");
      expect(animation.type).toBe("fade-in");
      expect(animation.duration).toBe(600);
    });

    it("should return fade-in for subtitle", () => {
      const animation = getRecommendedAnimation("subtitle");
      expect(animation.type).toBe("fade-in");
      expect(animation.duration).toBe(500);
      expect(animation.delay).toBe(200);
    });

    it("should return slide-in-left for bullet", () => {
      const animation = getRecommendedAnimation("bullet");
      expect(animation.type).toBe("slide-in-left");
      expect(animation.duration).toBe(400);
      expect(animation.delay).toBe(300);
    });

    it("should return zoom-in for chart", () => {
      const animation = getRecommendedAnimation("chart");
      expect(animation.type).toBe("zoom-in");
      expect(animation.duration).toBe(700);
      expect(animation.delay).toBe(400);
    });

    it("should return fade-in for image", () => {
      const animation = getRecommendedAnimation("image");
      expect(animation.type).toBe("fade-in");
      expect(animation.duration).toBe(500);
      expect(animation.delay).toBe(300);
    });
  });

  describe("getAnimationDuration", () => {
    it("should return 300ms for simple animation", () => {
      expect(getAnimationDuration("simple")).toBe(300);
    });

    it("should return 500ms for moderate animation", () => {
      expect(getAnimationDuration("moderate")).toBe(500);
    });

    it("should return 800ms for complex animation", () => {
      expect(getAnimationDuration("complex")).toBe(800);
    });
  });

  describe("createStaggerConfig", () => {
    it("should create stagger config with defaults", () => {
      const config = createStaggerConfig();
      expect(config.enabled).toBe(true);
      expect(config.delay).toBe(100);
      expect(config.direction).toBe("forward");
    });

    it("should create stagger config with custom values", () => {
      const config = createStaggerConfig(false, 200, "backward");
      expect(config.enabled).toBe(false);
      expect(config.delay).toBe(200);
      expect(config.direction).toBe("backward");
    });
  });

  describe("getEasingCurve", () => {
    it("should return ease-in curve", () => {
      const curve = getEasingCurve("ease-in");
      expect(curve).toBe("cubic-bezier(0.42, 0, 1, 1)");
    });

    it("should return ease-out curve", () => {
      const curve = getEasingCurve("ease-out");
      expect(curve).toBe("cubic-bezier(0, 0, 0.58, 1)");
    });

    it("should return ease-in-out curve", () => {
      const curve = getEasingCurve("ease-in-out");
      expect(curve).toBe("cubic-bezier(0.42, 0, 0.58, 1)");
    });

    it("should return linear curve", () => {
      const curve = getEasingCurve("linear");
      expect(curve).toBe("linear");
    });
  });

  describe("calculateSequenceTiming", () => {
    it("should calculate forward timing", () => {
      const timings = calculateSequenceTiming(3, 0, 100, "forward");
      expect(timings).toEqual([0, 100, 200]);
    });

    it("should calculate backward timing", () => {
      const timings = calculateSequenceTiming(3, 0, 100, "backward");
      expect(timings).toEqual([0, 100, 200]);
    });

    it("should calculate with base delay", () => {
      const timings = calculateSequenceTiming(3, 200, 100, "forward");
      expect(timings).toEqual([200, 300, 400]);
    });

    it("should calculate random timing", () => {
      const timings = calculateSequenceTiming(3, 0, 100, "random");
      expect(timings.length).toBe(3);
      timings.forEach(t => {
        expect(t).toBeGreaterThanOrEqual(0);
        expect(t).toBeLessThanOrEqual(300);
      });
    });
  });

  describe("getAnimationPreset", () => {
    it("should return entrance preset", () => {
      const preset = getAnimationPreset("entrance");
      expect(preset.length).toBe(4);
      expect(preset[0].type).toBe("fade-in");
    });

    it("should return emphasis preset", () => {
      const preset = getAnimationPreset("emphasis");
      expect(preset.length).toBe(3);
      expect(preset[0].type).toBe("pulse");
    });

    it("should return exit preset", () => {
      const preset = getAnimationPreset("exit");
      expect(preset.length).toBe(3);
      expect(preset[0].type).toBe("fade-out");
    });

    it("should return transition preset", () => {
      const preset = getAnimationPreset("transition");
      expect(preset.length).toBe(3);
      expect(preset[0].type).toBe("fade-in");
    });
  });

  describe("validateAnimationConfig", () => {
    it("should validate correct config", () => {
      const config: AnimationConfig = {
        type: "fade-in",
        duration: 500,
        delay: 0
      };
      const result = validateAnimationConfig(config);
      expect(result.valid).toBe(true);
      expect(result.errors.length).toBe(0);
    });

    it("should reject negative duration", () => {
      const config: AnimationConfig = {
        type: "fade-in",
        duration: -100,
        delay: 0
      };
      const result = validateAnimationConfig(config);
      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    it("should reject negative delay", () => {
      const config: AnimationConfig = {
        type: "fade-in",
        duration: 500,
        delay: -100
      };
      const result = validateAnimationConfig(config);
      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    it("should accept valid repeat count", () => {
      const config: AnimationConfig = {
        type: "fade-in",
        duration: 500,
        delay: 0,
        repeat: 2
      };
      const result = validateAnimationConfig(config);
      expect(result.valid).toBe(true);
    });
  });

  describe("getAnimationMetadata", () => {
    it("should return metadata for fade-in", () => {
      const metadata = getAnimationMetadata("fade-in");
      expect(metadata.name).toBe("Fade In");
      expect(metadata.category).toBe("entrance");
      expect(metadata.duration).toBe(500);
    });

    it("should return metadata for pulse", () => {
      const metadata = getAnimationMetadata("pulse");
      expect(metadata.name).toBe("Pulse");
      expect(metadata.category).toBe("emphasis");
      expect(metadata.duration).toBe(600);
    });

    it("should return metadata for zoom-out", () => {
      const metadata = getAnimationMetadata("zoom-out");
      expect(metadata.name).toBe("Zoom Out");
      expect(metadata.category).toBe("exit");
      expect(metadata.duration).toBe(600);
    });

    it("should have description for all animations", () => {
      const animations: AnimationType[] = [
        "fade-in", "slide-in-left", "zoom-in", "pulse", "bounce-in"
      ];
      animations.forEach(anim => {
        const metadata = getAnimationMetadata(anim);
        expect(metadata.description).toBeTruthy();
        expect(metadata.description.length).toBeGreaterThan(0);
      });
    });
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/__tests__/iconLibrary.test.ts
=================================================================================
import { describe, it, expect, beforeEach, vi } from "vitest";
import { addIcon, type IconType } from "../iconLibrary";

describe("Icon Library", () => {
  let mockSlide: any;

  beforeEach(() => {
    mockSlide = {
      addShape: vi.fn(),
      addText: vi.fn()
    };
  });

  describe("addIcon", () => {
    it("should add a checkmark icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "checkmark", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a cross icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "cross", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an arrow-right icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "arrow-right", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an arrow-left icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "arrow-left", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an arrow-up icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "arrow-up", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an arrow-down icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "arrow-down", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a star icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "star", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a heart icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "heart", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a lightbulb icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "lightbulb", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a target icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "target", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a chart icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "chart", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a settings icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "settings", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a user icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "user", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a users icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "users", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a lock icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "lock", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an unlock icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "unlock", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a download icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "download", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an upload icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "upload", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a search icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "search", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a bell icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "bell", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a mail icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "mail", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a phone icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "phone", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a calendar icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "calendar", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a clock icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "clock", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a folder icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "folder", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a file icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "file", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a trash icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "trash", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an edit icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "edit", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a copy icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "copy", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a share icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "share", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a play icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "play", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a pause icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "pause", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a stop icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "stop", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a volume icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "volume", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a wifi icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "wifi", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a battery icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "battery", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should use default color if not provided", () => {
      addIcon(mockSlide, 1, 1, 0.5, "checkmark");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should handle different sizes", () => {
      addIcon(mockSlide, 1, 1, 0.25, "star", "#000000");
      addIcon(mockSlide, 1, 1, 0.5, "star", "#000000");
      addIcon(mockSlide, 1, 1, 1, "star", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalledTimes(3);
    });

    it("should handle different positions", () => {
      addIcon(mockSlide, 0, 0, 0.5, "star", "#000000");
      addIcon(mockSlide, 5, 5, 0.5, "star", "#000000");
      addIcon(mockSlide, 10, 7.5, 0.5, "star", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalledTimes(3);
    });

    it("should handle different colors", () => {
      addIcon(mockSlide, 1, 1, 0.5, "star", "#FF0000");
      addIcon(mockSlide, 1, 1, 0.5, "star", "#00FF00");
      addIcon(mockSlide, 1, 1, 0.5, "star", "#0000FF");
      expect(mockSlide.addShape).toHaveBeenCalledTimes(3);
    });
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/__tests__/professionalTemplates.test.ts
=================================================================================
import { describe, it, expect } from "vitest";
import {
  getAllTemplates,
  getTemplate,
  getTemplatesByUseCase,
  getTemplateLayout,
  getRecommendedTemplate,
  validateTemplate,
  createCustomTemplate,
  getTemplateStats,
  TITLE_SLIDE_TEMPLATE,
  CONTENT_SLIDE_TEMPLATE,
  TWO_COLUMN_TEMPLATE,
  THREE_COLUMN_TEMPLATE,
  DATA_VIZ_TEMPLATE,
  IMAGE_FOCUS_TEMPLATE,
  TIMELINE_TEMPLATE,
  CENTERED_FOCUS_TEMPLATE,
  SIDEBAR_TEMPLATE,
  STACKED_TEMPLATE,
  MINIMAL_TEMPLATE,
  FULL_BLEED_TEMPLATE
} from "../professionalTemplates";

describe("Professional Templates", () => {
  describe("getAllTemplates", () => {
    it("should return all templates", () => {
      const templates = getAllTemplates();
      expect(templates.length).toBe(12);
    });

    it("should include title slide template", () => {
      const templates = getAllTemplates();
      expect(templates).toContainEqual(TITLE_SLIDE_TEMPLATE);
    });

    it("should include content slide template", () => {
      const templates = getAllTemplates();
      expect(templates).toContainEqual(CONTENT_SLIDE_TEMPLATE);
    });
  });

  describe("getTemplate", () => {
    it("should get template by name", () => {
      const template = getTemplate("Title Slide");
      expect(template).toEqual(TITLE_SLIDE_TEMPLATE);
    });

    it("should be case insensitive", () => {
      const template = getTemplate("title slide");
      expect(template).toEqual(TITLE_SLIDE_TEMPLATE);
    });

    it("should return undefined for unknown template", () => {
      const template = getTemplate("Unknown Template");
      expect(template).toBeUndefined();
    });

    it("should get content slide template", () => {
      const template = getTemplate("Content Slide");
      expect(template).toEqual(CONTENT_SLIDE_TEMPLATE);
    });

    it("should get two column template", () => {
      const template = getTemplate("Two Column");
      expect(template).toEqual(TWO_COLUMN_TEMPLATE);
    });
  });

  describe("getTemplatesByUseCase", () => {
    it("should find templates by use case", () => {
      const templates = getTemplatesByUseCase("comparison");
      expect(templates.length).toBeGreaterThan(0);
      expect(templates).toContainEqual(TWO_COLUMN_TEMPLATE);
    });

    it("should be case insensitive", () => {
      const templates = getTemplatesByUseCase("COMPARISON");
      expect(templates.length).toBeGreaterThan(0);
    });

    it("should find chart templates", () => {
      const templates = getTemplatesByUseCase("chart");
      expect(templates.length).toBeGreaterThan(0);
    });

    it("should find chart templates", () => {
      const templates = getTemplatesByUseCase("charts");
      expect(templates.length).toBeGreaterThan(0);
    });
  });

  describe("getTemplateLayout", () => {
    it("should return professional layout", () => {
      const layout = getTemplateLayout("professional");
      expect(layout.title.fontSize).toBe(44);
      expect(layout.title.bold).toBe(true);
      expect(layout.body.fontSize).toBe(16);
    });

    it("should return modern layout", () => {
      const layout = getTemplateLayout("modern");
      expect(layout.title.fontSize).toBe(48);
      expect(layout.subtitle.bold).toBe(true);
    });

    it("should return minimal layout", () => {
      const layout = getTemplateLayout("minimal");
      expect(layout.title.fontSize).toBe(40);
      expect(layout.body.fontSize).toBe(14);
    });

    it("should return bold layout", () => {
      const layout = getTemplateLayout("bold");
      expect(layout.title.fontSize).toBe(52);
      expect(layout.title.color).toBe("#DC2626");
    });

    it("should default to professional layout", () => {
      const layout = getTemplateLayout("unknown");
      expect(layout.title.fontSize).toBe(44);
    });
  });

  describe("getRecommendedTemplate", () => {
    it("should recommend title slide for title content", () => {
      const template = getRecommendedTemplate("title");
      expect(template).toEqual(TITLE_SLIDE_TEMPLATE);
    });

    it("should recommend content slide for content", () => {
      const template = getRecommendedTemplate("content");
      expect(template).toEqual(CONTENT_SLIDE_TEMPLATE);
    });

    it("should recommend two column for comparison", () => {
      const template = getRecommendedTemplate("comparison");
      expect(template).toEqual(TWO_COLUMN_TEMPLATE);
    });

    it("should recommend data viz for data", () => {
      const template = getRecommendedTemplate("data");
      expect(template).toEqual(DATA_VIZ_TEMPLATE);
    });

    it("should recommend image focus for image", () => {
      const template = getRecommendedTemplate("image");
      expect(template).toEqual(IMAGE_FOCUS_TEMPLATE);
    });

    it("should recommend timeline for process", () => {
      const template = getRecommendedTemplate("process");
      expect(template).toEqual(TIMELINE_TEMPLATE);
    });
  });

  describe("validateTemplate", () => {
    it("should validate correct template", () => {
      const result = validateTemplate(TITLE_SLIDE_TEMPLATE);
      expect(result.valid).toBe(true);
      expect(result.errors.length).toBe(0);
    });

    it("should reject template without name", () => {
      const template = { ...TITLE_SLIDE_TEMPLATE, name: "" };
      const result = validateTemplate(template);
      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    it("should reject template without pattern", () => {
      const template = { ...TITLE_SLIDE_TEMPLATE, pattern: "" };
      const result = validateTemplate(template);
      expect(result.valid).toBe(false);
    });

    it("should reject template without color scheme", () => {
      const template = { ...TITLE_SLIDE_TEMPLATE, colorScheme: "" };
      const result = validateTemplate(template);
      expect(result.valid).toBe(false);
    });

    it("should reject template without typography", () => {
      const template = { ...TITLE_SLIDE_TEMPLATE, typography: "" };
      const result = validateTemplate(template);
      expect(result.valid).toBe(false);
    });
  });

  describe("createCustomTemplate", () => {
    it("should create custom template", () => {
      const template = createCustomTemplate(
        "Custom",
        "A custom template",
        "split",
        "tech",
        "modern",
        "Custom use case"
      );
      expect(template.name).toBe("Custom");
      expect(template.description).toBe("A custom template");
      expect(template.pattern).toBe("split");
      expect(template.colorScheme).toBe("tech");
      expect(template.typography).toBe("modern");
      expect(template.useCase).toBe("Custom use case");
    });

    it("should create valid custom template", () => {
      const template = createCustomTemplate(
        "Custom",
        "A custom template",
        "split",
        "tech",
        "modern",
        "Custom use case"
      );
      const result = validateTemplate(template);
      expect(result.valid).toBe(true);
    });
  });

  describe("getTemplateStats", () => {
    it("should return template statistics", () => {
      const stats = getTemplateStats();
      expect(stats.total).toBe(12);
      expect(stats.byPattern).toBeDefined();
      expect(stats.byColorScheme).toBeDefined();
    });

    it("should count patterns correctly", () => {
      const stats = getTemplateStats();
      expect(stats.byPattern["split"]).toBeGreaterThan(0);
      expect(stats.byPattern["hero"]).toBeGreaterThan(0);
    });

    it("should count color schemes correctly", () => {
      const stats = getTemplateStats();
      expect(stats.byColorScheme["corporate"]).toBeGreaterThan(0);
      expect(stats.byColorScheme["minimal"]).toBeGreaterThan(0);
    });
  });

  describe("Template Constants", () => {
    it("should have title slide template", () => {
      expect(TITLE_SLIDE_TEMPLATE.name).toBe("Title Slide");
      expect(TITLE_SLIDE_TEMPLATE.pattern).toBe("hero");
    });

    it("should have content slide template", () => {
      expect(CONTENT_SLIDE_TEMPLATE.name).toBe("Content Slide");
      expect(CONTENT_SLIDE_TEMPLATE.pattern).toBe("split");
    });

    it("should have two column template", () => {
      expect(TWO_COLUMN_TEMPLATE.name).toBe("Two Column");
      expect(TWO_COLUMN_TEMPLATE.pattern).toBe("comparison");
    });

    it("should have three column template", () => {
      expect(THREE_COLUMN_TEMPLATE.name).toBe("Three Column");
      expect(THREE_COLUMN_TEMPLATE.pattern).toBe("three-column");
    });

    it("should have data viz template", () => {
      expect(DATA_VIZ_TEMPLATE.name).toBe("Data Visualization");
      expect(DATA_VIZ_TEMPLATE.pattern).toBe("data-focused");
    });

    it("should have image focus template", () => {
      expect(IMAGE_FOCUS_TEMPLATE.name).toBe("Image Focus");
      expect(IMAGE_FOCUS_TEMPLATE.pattern).toBe("asymmetric");
    });

    it("should have timeline template", () => {
      expect(TIMELINE_TEMPLATE.name).toBe("Timeline");
      expect(TIMELINE_TEMPLATE.pattern).toBe("timeline");
    });

    it("should have centered focus template", () => {
      expect(CENTERED_FOCUS_TEMPLATE.name).toBe("Centered Focus");
      expect(CENTERED_FOCUS_TEMPLATE.pattern).toBe("centered");
    });

    it("should have sidebar template", () => {
      expect(SIDEBAR_TEMPLATE.name).toBe("Sidebar");
      expect(SIDEBAR_TEMPLATE.pattern).toBe("sidebar");
    });

    it("should have stacked template", () => {
      expect(STACKED_TEMPLATE.name).toBe("Stacked");
      expect(STACKED_TEMPLATE.pattern).toBe("stacked");
    });

    it("should have minimal template", () => {
      expect(MINIMAL_TEMPLATE.name).toBe("Minimal");
      expect(MINIMAL_TEMPLATE.pattern).toBe("minimal");
    });

    it("should have full bleed template", () => {
      expect(FULL_BLEED_TEMPLATE.name).toBe("Full Bleed");
      expect(FULL_BLEED_TEMPLATE.pattern).toBe("full-bleed");
    });
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/__tests__/whitespaceManager.test.ts
=================================================================================
import { describe, it, expect } from "vitest";
import {
  getSpacing,
  createUniformPadding,
  createUniformMargin,
  createCustomPadding,
  createCustomMargin,
  calculateContentWidth,
  calculateContentHeight,
  getRecommendedLineHeight,
  getRecommendedParagraphSpacing,
  calculateVerticalRhythm,
  getBreathingRoomPercentage,
  validateBreathingRoom,
  getContentMargin,
  getContainerPadding,
  calculateGridGap,
  calculateColumnWidth,
  getRecommendedSectionSpacing,
  getOptimalSlideMargins,
  getTextBoxPadding,
  getListItemSpacing,
  getElementSpacing,
  validateLayoutSpacing,
  SPACING_SCALE
} from "../whitespaceManager";

describe("Whitespace Manager", () => {
  describe("getSpacing", () => {
    it("should return correct spacing values", () => {
      expect(getSpacing("xs")).toBe(0.25);
      expect(getSpacing("sm")).toBe(0.5);
      expect(getSpacing("md")).toBe(0.75);
      expect(getSpacing("lg")).toBe(1);
      expect(getSpacing("xl")).toBe(1.5);
      expect(getSpacing("xxl")).toBe(2);
    });
  });

  describe("createUniformPadding", () => {
    it("should create uniform padding", () => {
      const padding = createUniformPadding("md");
      expect(padding.top).toBe(0.75);
      expect(padding.right).toBe(0.75);
      expect(padding.bottom).toBe(0.75);
      expect(padding.left).toBe(0.75);
    });
  });

  describe("createUniformMargin", () => {
    it("should create uniform margin", () => {
      const margin = createUniformMargin("lg");
      expect(margin.top).toBe(1);
      expect(margin.right).toBe(1);
      expect(margin.bottom).toBe(1);
      expect(margin.left).toBe(1);
    });
  });

  describe("createCustomPadding", () => {
    it("should create custom padding", () => {
      const padding = createCustomPadding(0.5, 1, 0.5, 1);
      expect(padding.top).toBe(0.5);
      expect(padding.right).toBe(1);
      expect(padding.bottom).toBe(0.5);
      expect(padding.left).toBe(1);
    });
  });

  describe("createCustomMargin", () => {
    it("should create custom margin", () => {
      const margin = createCustomMargin(0.25, 0.5, 0.25, 0.5);
      expect(margin.top).toBe(0.25);
      expect(margin.right).toBe(0.5);
      expect(margin.bottom).toBe(0.25);
      expect(margin.left).toBe(0.5);
    });
  });

  describe("calculateContentWidth", () => {
    it("should calculate content width with padding", () => {
      const padding = createCustomPadding(0, 0.5, 0, 0.5);
      const width = calculateContentWidth(10, padding);
      expect(width).toBe(9);
    });

    it("should handle zero padding", () => {
      const padding = createCustomPadding(0, 0, 0, 0);
      const width = calculateContentWidth(10, padding);
      expect(width).toBe(10);
    });
  });

  describe("calculateContentHeight", () => {
    it("should calculate content height with padding", () => {
      const padding = createCustomPadding(0.5, 0, 0.5, 0);
      const height = calculateContentHeight(7.5, padding);
      expect(height).toBe(6.5);
    });
  });

  describe("getRecommendedLineHeight", () => {
    it("should return 1.2 for large headings", () => {
      expect(getRecommendedLineHeight(44)).toBe(1.2);
    });

    it("should return 1.3 for subheadings", () => {
      expect(getRecommendedLineHeight(24)).toBe(1.3);
    });

    it("should return 1.5 for body text", () => {
      expect(getRecommendedLineHeight(16)).toBe(1.5);
    });
  });

  describe("getRecommendedParagraphSpacing", () => {
    it("should calculate paragraph spacing", () => {
      const spacing = getRecommendedParagraphSpacing(16);
      expect(spacing).toBeGreaterThan(0);
    });
  });

  describe("calculateVerticalRhythm", () => {
    it("should calculate vertical rhythm", () => {
      const rhythm = calculateVerticalRhythm(0.5, 2);
      expect(rhythm).toBe(1);
    });

    it("should use default multiplier", () => {
      const rhythm = calculateVerticalRhythm(0.5);
      expect(rhythm).toBe(0.5);
    });
  });

  describe("getBreathingRoomPercentage", () => {
    it("should calculate breathing room percentage", () => {
      const percentage = getBreathingRoomPercentage(50, 100);
      expect(percentage).toBe(50);
    });

    it("should handle full content", () => {
      const percentage = getBreathingRoomPercentage(100, 100);
      expect(percentage).toBe(0);
    });

    it("should handle empty content", () => {
      const percentage = getBreathingRoomPercentage(0, 100);
      expect(percentage).toBe(100);
    });
  });

  describe("validateBreathingRoom", () => {
    it("should validate optimal breathing room", () => {
      const result = validateBreathingRoom(60, 100);
      expect(result.valid).toBe(true);
      expect(result.percentage).toBe(40);
    });

    it("should reject too dense content", () => {
      const result = validateBreathingRoom(90, 100);
      expect(result.valid).toBe(false);
      expect(result.percentage).toBe(10);
    });

    it("should reject too much whitespace", () => {
      const result = validateBreathingRoom(30, 100);
      expect(result.valid).toBe(false);
      expect(result.percentage).toBe(70);
    });
  });

  describe("getContentMargin", () => {
    it("should return margin for title", () => {
      const margin = getContentMargin("title");
      expect(margin.bottom).toBe(0.5);
    });

    it("should return margin for body", () => {
      const margin = getContentMargin("body");
      expect(margin.top).toBe(0.25);
    });

    it("should return margin for chart", () => {
      const margin = getContentMargin("chart");
      expect(margin.top).toBe(0.5);
    });

    it("should return margin for image", () => {
      const margin = getContentMargin("image");
      expect(margin.top).toBe(0.5);
    });
  });

  describe("getContainerPadding", () => {
    it("should return padding for card", () => {
      const padding = getContainerPadding("card");
      expect(padding.top).toBe(0.5);
    });

    it("should return padding for box", () => {
      const padding = getContainerPadding("box");
      expect(padding.top).toBe(0.75);
    });

    it("should return padding for section", () => {
      const padding = getContainerPadding("section");
      expect(padding.top).toBe(1);
    });

    it("should return padding for highlight", () => {
      const padding = getContainerPadding("highlight");
      expect(padding.top).toBe(0.5);
    });
  });

  describe("calculateGridGap", () => {
    it("should return 0.5 for 2 columns", () => {
      expect(calculateGridGap(2, 10)).toBe(0.5);
    });

    it("should return 0.4 for 3 columns", () => {
      expect(calculateGridGap(3, 10)).toBe(0.4);
    });

    it("should return 0.25 for 4+ columns", () => {
      expect(calculateGridGap(4, 10)).toBe(0.25);
    });
  });

  describe("calculateColumnWidth", () => {
    it("should calculate column width", () => {
      const width = calculateColumnWidth(10, 2, 0.5);
      expect(width).toBe(4.75);
    });

    it("should handle multiple columns", () => {
      const width = calculateColumnWidth(10, 3, 0.4);
      expect(width).toBeCloseTo(3.067, 2);
    });
  });

  describe("getRecommendedSectionSpacing", () => {
    it("should return spacing for header", () => {
      expect(getRecommendedSectionSpacing("header")).toBe(0.5);
    });

    it("should return spacing for body", () => {
      expect(getRecommendedSectionSpacing("body")).toBe(0.75);
    });

    it("should return spacing for footer", () => {
      expect(getRecommendedSectionSpacing("footer")).toBe(0.5);
    });
  });

  describe("getOptimalSlideMargins", () => {
    it("should calculate optimal margins", () => {
      const margins = getOptimalSlideMargins(10, 7.5);
      expect(margins.top).toBeCloseTo(0.5);
      expect(margins.left).toBeCloseTo(0.5);
    });
  });

  describe("getTextBoxPadding", () => {
    it("should return padding for short text", () => {
      const padding = getTextBoxPadding(100);
      expect(padding.top).toBe(0.25);
    });

    it("should return padding for medium text", () => {
      const padding = getTextBoxPadding(300);
      expect(padding.top).toBe(0.5);
    });

    it("should return padding for long text", () => {
      const padding = getTextBoxPadding(600);
      expect(padding.top).toBe(0.75);
    });
  });

  describe("getListItemSpacing", () => {
    it("should return spacing for 3 items", () => {
      expect(getListItemSpacing(3)).toBe(0.4);
    });

    it("should return spacing for 5 items", () => {
      expect(getListItemSpacing(5)).toBe(0.3);
    });

    it("should return spacing for 6+ items", () => {
      expect(getListItemSpacing(6)).toBe(0.2);
    });
  });

  describe("getElementSpacing", () => {
    it("should return spacing for heading-body", () => {
      expect(getElementSpacing("heading-body")).toBe(0.3);
    });

    it("should return spacing for body-body", () => {
      expect(getElementSpacing("body-body")).toBe(0.2);
    });

    it("should return spacing for section-section", () => {
      expect(getElementSpacing("section-section")).toBe(0.75);
    });
  });

  describe("validateLayoutSpacing", () => {
    it("should validate non-overlapping elements", () => {
      const elements = [
        { y: 0, h: 1 },
        { y: 1.5, h: 1 },
        { y: 3, h: 1 }
      ];
      const result = validateLayoutSpacing(elements, 7.5);
      expect(result.valid).toBe(true);
      expect(result.issues.length).toBe(0);
    });

    it("should detect overlapping elements", () => {
      const elements = [
        { y: 0, h: 2 },
        { y: 1, h: 1 }
      ];
      const result = validateLayoutSpacing(elements, 7.5);
      expect(result.valid).toBe(false);
      expect(result.issues.length).toBeGreaterThan(0);
    });

    it("should detect content exceeding slide height", () => {
      const elements = [
        { y: 0, h: 5 },
        { y: 5, h: 3 }
      ];
      const result = validateLayoutSpacing(elements, 7.5);
      expect(result.valid).toBe(false);
    });
  });

  describe("SPACING_SCALE", () => {
    it("should have all spacing values", () => {
      expect(SPACING_SCALE.xs).toBe(0.25);
      expect(SPACING_SCALE.sm).toBe(0.5);
      expect(SPACING_SCALE.md).toBe(0.75);
      expect(SPACING_SCALE.lg).toBe(1);
      expect(SPACING_SCALE.xl).toBe(1.5);
      expect(SPACING_SCALE.xxl).toBe(2);
    });
  });
});


=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/advancedPatterns.ts
=================================================================================
/**
 * Advanced Design Patterns for Professional Slides
 * Implements hero, split, asymmetric, grid, minimal, and data-focused layouts
 */

import PptxGenJS from "pptxgenjs";
import type { SlideSpecV1 } from "../types/SlideSpecV1";
import {
  addAccentBar,
  addDecorativeCircle,
  addPremiumDivider,
  addCornerAccent,
  addStatBlock,
  addFeatureHighlight,
  addArrow
} from "./premiumComponents";

const SLIDE_WIDTH = 10;
const SLIDE_HEIGHT = 7.5;

export type DesignPattern = "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused";

/**
 * Apply design pattern to slide
 */
export function applyDesignPattern(
  slide: any,
  spec: SlideSpecV1,
  pattern: DesignPattern
): void {
  const palette = spec.styleTokens.palette;
  const primaryColor = palette.primary.replace("#", "");
  const accentColor = palette.accent.replace("#", "");

  switch (pattern) {
    case "hero":
      applyHeroPattern(slide, spec, primaryColor, accentColor);
      break;
    case "split":
      applySplitPattern(slide, spec, primaryColor, accentColor);
      break;
    case "asymmetric":
      applyAsymmetricPattern(slide, spec, primaryColor, accentColor);
      break;
    case "grid":
      applyGridPattern(slide, spec, primaryColor, accentColor);
      break;
    case "minimal":
      applyMinimalPattern(slide, spec, primaryColor, accentColor);
      break;
    case "data-focused":
      applyDataFocusedPattern(slide, spec, primaryColor, accentColor);
      break;
  }
}

/**
 * Hero Pattern: Large title/image (55-65% of slide), minimal supporting text
 * Best for: Executive summaries, product reveals, keynote slides
 */
function applyHeroPattern(slide: any, spec: SlideSpecV1, primaryColor: string, accentColor: string): void {
  // Large accent bar on left
  addAccentBar(slide, {
    position: "left",
    color: primaryColor,
    thickness: 0.15
  });

  // Top accent bar
  addAccentBar(slide, {
    position: "top",
    color: accentColor,
    thickness: 0.06
  });

  // Large decorative circles for visual interest
  addDecorativeCircle(slide, 8.0, 6.0, 1.2, primaryColor, 0.08);
  addDecorativeCircle(slide, 9.0, 7.0, 0.8, accentColor, 0.1);

  // Corner accents
  addCornerAccent(slide, "top-right", accentColor, 0.25);
  addCornerAccent(slide, "bottom-left", primaryColor, 0.2);
}

/**
 * Split Pattern: 50/50 content division with clear visual separation
 * Best for: Comparisons, pros/cons, two-part stories
 */
function applySplitPattern(slide: any, spec: SlideSpecV1, primaryColor: string, accentColor: string): void {
  // Vertical divider in center
  slide.addShape("rect", {
    x: SLIDE_WIDTH / 2 - 0.05,
    y: 0.5,
    w: 0.1,
    h: SLIDE_HEIGHT - 1,
    fill: { color: primaryColor, transparency: 80 },
    line: { type: "none" }
  });

  // Left accent bar
  addAccentBar(slide, {
    position: "left",
    color: primaryColor,
    thickness: 0.08
  });

  // Right accent bar
  addAccentBar(slide, {
    position: "right",
    color: accentColor,
    thickness: 0.08
  });

  // Corner accents
  addCornerAccent(slide, "top-left", primaryColor, 0.15);
  addCornerAccent(slide, "bottom-right", accentColor, 0.15);
}

/**
 * Asymmetric Pattern: Dynamic off-center layout with visual tension
 * Best for: Creative industries, feature highlights, modern tech
 */
function applyAsymmetricPattern(slide: any, spec: SlideSpecV1, primaryColor: string, accentColor: string): void {
  // Diagonal accent bar
  slide.addShape("rect", {
    x: 0,
    y: 0,
    w: SLIDE_WIDTH,
    h: 0.08,
    fill: { color: primaryColor },
    line: { type: "none" }
  });

  // Asymmetric accent shapes
  addDecorativeCircle(slide, 7.5, 1.0, 1.5, accentColor, 0.1);
  addDecorativeCircle(slide, 0.5, 5.5, 1.0, primaryColor, 0.08);

  // Corner accent
  addCornerAccent(slide, "top-right", accentColor, 0.3);
}

/**
 * Grid Pattern: Structured multi-element layout (2x2, 3x3, etc.)
 * Best for: Portfolio items, process steps, multiple metrics
 */
function applyGridPattern(slide: any, spec: SlideSpecV1, primaryColor: string, accentColor: string): void {
  // Top accent bar
  addAccentBar(slide, {
    position: "top",
    color: primaryColor,
    thickness: 0.08
  });

  // Left accent bar
  addAccentBar(slide, {
    position: "left",
    color: accentColor,
    thickness: 0.08
  });

  // Grid lines (subtle)
  const gridColor = primaryColor;
  slide.addShape("rect", {
    x: SLIDE_WIDTH / 2 - 0.02,
    y: 1.0,
    w: 0.04,
    h: SLIDE_HEIGHT - 1.5,
    fill: { color: gridColor, transparency: 90 },
    line: { type: "none" }
  });

  slide.addShape("rect", {
    x: 0.5,
    y: SLIDE_HEIGHT / 2 - 0.02,
    w: SLIDE_WIDTH - 1,
    h: 0.04,
    fill: { color: gridColor, transparency: 90 },
    line: { type: "none" }
  });

  // Corner accents
  addCornerAccent(slide, "top-right", accentColor, 0.15);
  addCornerAccent(slide, "bottom-left", primaryColor, 0.15);
}

/**
 * Minimal Pattern: Maximum white space (40%+), essential content only
 * Best for: Quotes, key takeaways, luxury/premium positioning
 */
function applyMinimalPattern(slide: any, spec: SlideSpecV1, primaryColor: string, accentColor: string): void {
  // Subtle top accent bar
  addAccentBar(slide, {
    position: "top",
    color: primaryColor,
    thickness: 0.04
  });

  // Single corner accent for sophistication
  addCornerAccent(slide, "bottom-right", accentColor, 0.12);

  // Minimal decorative element
  addDecorativeCircle(slide, 0.3, 0.4, 0.4, primaryColor, 0.05);
}

/**
 * Data-Focused Pattern: Chart as primary (55-70%), supporting text sidebar
 * Best for: Analytics, financial reports, data-driven insights
 */
function applyDataFocusedPattern(slide: any, spec: SlideSpecV1, primaryColor: string, accentColor: string): void {
  // Left accent bar - strong visual anchor
  addAccentBar(slide, {
    position: "left",
    color: primaryColor,
    thickness: 0.12
  });

  // Top accent bar
  addAccentBar(slide, {
    position: "top",
    color: accentColor,
    thickness: 0.05
  });

  // Vertical divider between chart and sidebar
  slide.addShape("rect", {
    x: 6.8,
    y: 1.0,
    w: 0.08,
    h: SLIDE_HEIGHT - 1.5,
    fill: { color: primaryColor, transparency: 85 },
    line: { type: "none" }
  });

  // Corner accents
  addCornerAccent(slide, "top-right", accentColor, 0.2);
  addCornerAccent(slide, "bottom-left", primaryColor, 0.15);

  // Decorative elements
  addDecorativeCircle(slide, 8.5, 6.5, 0.7, accentColor, 0.08);
}

/**
 * Get recommended pattern based on content type
 */
export function getRecommendedPattern(spec: SlideSpecV1): DesignPattern {
  const content = spec.content;

  // If has chart, use data-focused
  if (content.dataViz) {
    return "data-focused";
  }

  // If has multiple callouts, use grid
  if (content.callouts && content.callouts.length > 2) {
    return "grid";
  }

  // If has many bullets, use split
  if (content.bullets && content.bullets[0]?.items.length > 4) {
    return "split";
  }

  // If short content, use minimal
  const totalWords = (content.title?.text || "").split(" ").length +
                     (content.subtitle?.text || "").split(" ").length +
                     (content.bullets?.[0]?.items || []).reduce((sum, item) => sum + item.text.split(" ").length, 0);

  if (totalWords < 30) {
    return "minimal";
  }

  // Default to split
  return "split";
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/advancedShapes.ts
=================================================================================
/**
 * Advanced Shapes and Visual Elements for Premium PowerPoint Slides
 * Provides sophisticated decorative and functional elements
 * Inspired by Apple, Google, Tesla, and ChatGPT design systems
 */

import PptxGenJS from "pptxgenjs";

/**
 * Add a directional arrow with professional styling
 */
export function addDirectionalArrow(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  direction: "right" | "left" | "up" | "down",
  color: string,
  thickness: number = 3
): void {
  const arrowShapes: Record<string, string> = {
    right: "rightArrow",
    left: "leftArrow",
    up: "upArrow",
    down: "downArrow"
  };

  slide.addShape(arrowShapes[direction], {
    x,
    y,
    w: width,
    h: height,
    fill: { color },
    line: { type: "none" },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.1,
      blur: 4,
      offset: 2
    }
  });
}

/**
 * Add a curved connector between two points
 */
export function addCurvedConnector(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string,
  thickness: number = 2
): void {
  // Use a curved connector shape
  slide.addShape("curve", {
    x: Math.min(x1, x2),
    y: Math.min(y1, y2),
    w: Math.abs(x2 - x1) || 0.1,
    h: Math.abs(y2 - y1) || 0.1,
    line: { color, width: thickness },
    fill: { type: "none" }
  });
}

/**
 * Add a professional progress bar
 */
export function addProgressBar(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  percentage: number,
  color: string,
  backgroundColor: string = "#E5E7EB"
): void {
  // Background bar
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: backgroundColor },
    line: { type: "none" }
  });

  // Progress fill
  const fillWidth = (width * Math.min(percentage, 100)) / 100;
  slide.addShape("roundRect", {
    x,
    y,
    w: fillWidth,
    h: height,
    fill: { color },
    line: { type: "none" }
  });

  // Percentage text
  slide.addText(`${Math.round(percentage)}%`, {
    x: x + width + 0.1,
    y: y - 0.05,
    w: 0.4,
    h: height + 0.1,
    fontSize: 11,
    bold: true,
    color,
    align: "left",
    valign: "middle"
  });
}

/**
 * Add a numbered step indicator
 */
export function addStepIndicator(
  slide: any,
  x: number,
  y: number,
  stepNumber: number,
  totalSteps: number,
  color: string,
  size: number = 0.4
): void {
  // Circle background
  slide.addShape("ellipse", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.12,
      blur: 6,
      offset: 2
    }
  });

  // Step number
  slide.addText(stepNumber.toString(), {
    x,
    y,
    w: size,
    h: size,
    fontSize: 16,
    bold: true,
    color: "#FFFFFF",
    align: "center",
    valign: "middle",
    fontFace: "Inter, Arial, sans-serif"
  });
}

/**
 * Add a comparison box with two columns
 */
export function addComparisonBox(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  leftLabel: string,
  rightLabel: string,
  leftColor: string,
  rightColor: string
): void {
  const halfWidth = width / 2;
  const dividerX = x + halfWidth;

  // Left box
  slide.addShape("rect", {
    x,
    y,
    w: halfWidth - 0.05,
    h: height,
    fill: { color: leftColor, transparency: 90 },
    line: { color: leftColor, width: 2 }
  });

  // Right box
  slide.addShape("rect", {
    x: dividerX + 0.05,
    y,
    w: halfWidth - 0.05,
    h: height,
    fill: { color: rightColor, transparency: 90 },
    line: { color: rightColor, width: 2 }
  });

  // Left label
  slide.addText(leftLabel, {
    x,
    y: y + height + 0.1,
    w: halfWidth,
    h: 0.3,
    fontSize: 12,
    bold: true,
    color: leftColor,
    align: "center"
  });

  // Right label
  slide.addText(rightLabel, {
    x: dividerX,
    y: y + height + 0.1,
    w: halfWidth,
    h: 0.3,
    fontSize: 12,
    bold: true,
    color: rightColor,
    align: "center"
  });
}

/**
 * Add a highlight badge with icon-like appearance
 */
export function addHighlightBadge(
  slide: any,
  x: number,
  y: number,
  text: string,
  color: string,
  backgroundColor: string = "#FFFFFF"
): void {
  const width = 1.5;
  const height = 0.4;

  // Badge background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: backgroundColor },
    line: { color, width: 2 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.1,
      blur: 4,
      offset: 1
    }
  });

  // Badge text
  slide.addText(text, {
    x,
    y,
    w: width,
    h: height,
    fontSize: 11,
    bold: true,
    color,
    align: "center",
    valign: "middle",
    fontFace: "Inter, Arial, sans-serif"
  });
}

/**
 * Add a subtle background shape for emphasis
 */
export function addEmphasisBackground(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  color: string,
  opacity: number = 0.08,
  borderRadius: number = 0.15
): void {
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color, transparency: Math.round((1 - opacity) * 100) },
    line: { type: "none" }
  });
}

/**
 * Add a vertical divider line
 */
export function addVerticalDivider(
  slide: any,
  x: number,
  y: number,
  height: number,
  color: string = "#E5E7EB",
  thickness: number = 0.02
): void {
  slide.addShape("rect", {
    x,
    y,
    w: thickness,
    h: height,
    fill: { color },
    line: { type: "none" }
  });
}

/**
 * Add a horizontal divider line
 */
export function addHorizontalDivider(
  slide: any,
  x: number,
  y: number,
  width: number,
  color: string = "#E5E7EB",
  thickness: number = 0.02
): void {
  slide.addShape("rect", {
    x,
    y,
    w: width,
    h: thickness,
    fill: { color },
    line: { type: "none" }
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/animations.ts
=================================================================================
/**
 * Slide Animations & Transitions
 * Entrance, exit, emphasis animations and slide transitions
 */

import PptxGenJS from "pptxgenjs";

export type EntranceAnimation = 
  | "fade" 
  | "wipe" 
  | "fly-in" 
  | "zoom" 
  | "appear" 
  | "split" 
  | "dissolve"
  | "box"
  | "checkerboard"
  | "blinds"
  | "random-bars";

export type ExitAnimation = 
  | "fade" 
  | "wipe" 
  | "fly-out" 
  | "zoom" 
  | "disappear";

export type EmphasisAnimation = 
  | "pulse" 
  | "color-pulse" 
  | "grow-shrink" 
  | "spin" 
  | "transparency"
  | "bold-flash"
  | "underline";

export type SlideTransition = 
  | "fade" 
  | "push" 
  | "wipe" 
  | "split" 
  | "reveal" 
  | "cover"
  | "uncover"
  | "flash"
  | "dissolve"
  | "random-bars"
  | "checkerboard"
  | "blinds"
  | "clock"
  | "ripple"
  | "honeycomb"
  | "glitter"
  | "vortex"
  | "shred"
  | "switch"
  | "flip"
  | "gallery"
  | "cube"
  | "doors"
  | "box"
  | "comb"
  | "zoom"
  | "random";

export interface AnimationConfig {
  type: EntranceAnimation | ExitAnimation | EmphasisAnimation;
  duration?: number; // milliseconds (default: 500)
  delay?: number; // milliseconds (default: 0)
  direction?: "left" | "right" | "top" | "bottom" | "center";
}

export interface TransitionConfig {
  type: SlideTransition;
  duration?: number; // milliseconds (default: 1000)
  direction?: "left" | "right" | "top" | "bottom";
}

/**
 * Apply entrance animation to slide element
 * Note: PptxGenJS has limited animation support, this is a best-effort implementation
 */
export function applyEntranceAnimation(
  slide: any,
  elementId: string,
  animation: AnimationConfig
): void {
  // PptxGenJS doesn't have full animation API yet
  // This is a placeholder for future implementation
  // For now, we'll document the animation intent in slide notes
  
  const animationNote = `Animation: ${animation.type} (${animation.duration || 500}ms, delay: ${animation.delay || 0}ms)`;
  
  // Store animation metadata (would be used by rendering engine)
  if (!slide._animations) {
    slide._animations = [];
  }
  
  slide._animations.push({
    elementId,
    type: "entrance",
    animation: animation.type,
    duration: animation.duration || 500,
    delay: animation.delay || 0,
    direction: animation.direction
  });
}

/**
 * Apply exit animation to slide element
 */
export function applyExitAnimation(
  slide: any,
  elementId: string,
  animation: AnimationConfig
): void {
  if (!slide._animations) {
    slide._animations = [];
  }
  
  slide._animations.push({
    elementId,
    type: "exit",
    animation: animation.type,
    duration: animation.duration || 500,
    delay: animation.delay || 0,
    direction: animation.direction
  });
}

/**
 * Apply emphasis animation to slide element
 */
export function applyEmphasisAnimation(
  slide: any,
  elementId: string,
  animation: AnimationConfig
): void {
  if (!slide._animations) {
    slide._animations = [];
  }
  
  slide._animations.push({
    elementId,
    type: "emphasis",
    animation: animation.type,
    duration: animation.duration || 500,
    delay: animation.delay || 0
  });
}

/**
 * Apply slide transition
 */
export function applySlideTransition(
  slide: any,
  transition: TransitionConfig
): void {
  // Map our transition types to PptxGenJS transition types
  const transitionMap: Record<string, string> = {
    "fade": "fade",
    "push": "push",
    "wipe": "wipe",
    "split": "split",
    "reveal": "reveal",
    "cover": "cover",
    "uncover": "uncover",
    "flash": "flash",
    "dissolve": "dissolve",
    "random-bars": "randomBars",
    "checkerboard": "checkerboard",
    "blinds": "blinds",
    "clock": "clock",
    "ripple": "ripple",
    "honeycomb": "honeycomb",
    "glitter": "glitter",
    "vortex": "vortex",
    "shred": "shred",
    "switch": "switch",
    "flip": "flip",
    "gallery": "gallery",
    "cube": "cube",
    "doors": "doors",
    "box": "box",
    "comb": "comb",
    "zoom": "zoom",
    "random": "random"
  };

  const pptxTransition = transitionMap[transition.type] || "fade";
  
  // Apply transition using PptxGenJS API
  slide.transition = {
    type: pptxTransition,
    duration: (transition.duration || 1000) / 1000, // Convert to seconds
    direction: transition.direction
  };
}

/**
 * Create animation sequence for multiple elements
 */
export function createAnimationSequence(
  slide: any,
  sequence: Array<{
    elementId: string;
    animation: AnimationConfig;
    order: number;
  }>
): void {
  // Sort by order
  const sorted = sequence.sort((a, b) => a.order - b.order);
  
  // Apply animations with calculated delays
  let cumulativeDelay = 0;
  
  for (const item of sorted) {
    const animationWithDelay = {
      ...item.animation,
      delay: cumulativeDelay + (item.animation.delay || 0)
    };
    
    applyEntranceAnimation(slide, item.elementId, animationWithDelay);
    
    // Add duration to cumulative delay for next item
    cumulativeDelay += (item.animation.duration || 500);
  }
}

/**
 * Get recommended animation based on slide pattern
 */
export function getRecommendedAnimation(
  pattern: "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused"
): {
  entrance: EntranceAnimation;
  transition: SlideTransition;
} {
  const recommendations = {
    hero: {
      entrance: "zoom" as EntranceAnimation,
      transition: "fade" as SlideTransition
    },
    split: {
      entrance: "wipe" as EntranceAnimation,
      transition: "split" as SlideTransition
    },
    asymmetric: {
      entrance: "fly-in" as EntranceAnimation,
      transition: "push" as SlideTransition
    },
    grid: {
      entrance: "appear" as EntranceAnimation,
      transition: "dissolve" as SlideTransition
    },
    minimal: {
      entrance: "fade" as EntranceAnimation,
      transition: "fade" as SlideTransition
    },
    "data-focused": {
      entrance: "wipe" as EntranceAnimation,
      transition: "wipe" as SlideTransition
    }
  };
  
  return recommendations[pattern] || recommendations.minimal;
}

/**
 * Apply professional animation preset to slide
 */
export function applyProfessionalAnimationPreset(
  slide: any,
  pattern: "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused",
  elementIds: {
    title?: string;
    subtitle?: string;
    bullets?: string[];
    chart?: string;
    image?: string;
  }
): void {
  const recommended = getRecommendedAnimation(pattern);
  
  // Apply slide transition
  applySlideTransition(slide, {
    type: recommended.transition,
    duration: 800
  });
  
  // Create animation sequence
  const sequence: Array<{
    elementId: string;
    animation: AnimationConfig;
    order: number;
  }> = [];
  
  let order = 0;
  
  // Title appears first
  if (elementIds.title) {
    sequence.push({
      elementId: elementIds.title,
      animation: {
        type: recommended.entrance,
        duration: 600,
        delay: 0
      },
      order: order++
    });
  }
  
  // Subtitle appears second
  if (elementIds.subtitle) {
    sequence.push({
      elementId: elementIds.subtitle,
      animation: {
        type: "fade",
        duration: 500,
        delay: 200
      },
      order: order++
    });
  }
  
  // Bullets appear one by one
  if (elementIds.bullets) {
    for (const bulletId of elementIds.bullets) {
      sequence.push({
        elementId: bulletId,
        animation: {
          type: "fly-in",
          duration: 400,
          delay: 150,
          direction: "left"
        },
        order: order++
      });
    }
  }
  
  // Chart appears
  if (elementIds.chart) {
    sequence.push({
      elementId: elementIds.chart,
      animation: {
        type: "wipe",
        duration: 800,
        delay: 0,
        direction: "bottom"
      },
      order: order++
    });
  }
  
  // Image appears
  if (elementIds.image) {
    sequence.push({
      elementId: elementIds.image,
      animation: {
        type: "zoom",
        duration: 600,
        delay: 0
      },
      order: order++
    });
  }
  
  createAnimationSequence(slide, sequence);
}

/**
 * Export animation metadata for web preview
 */
export function exportAnimationMetadata(slide: any): any {
  return {
    animations: slide._animations || [],
    transition: slide.transition || null
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/chartBuilder.ts
=================================================================================
/**
 * Enhanced Chart Builder
 * Creates professional, styled charts with design tokens
 */

import PptxGenJS from "pptxgenjs";

export interface ChartConfig {
  title?: string;
  subtitle?: string;
  labels: string[];
  series: Array<{
    name: string;
    values: number[];
  }>;
  colors?: string[];
  showLegend?: boolean;
  showDataLabels?: boolean;
  chartType: "bar" | "line" | "pie" | "area" | "scatter" | "combo" | "waterfall" | "funnel" | "doughnut";
  // Advanced options
  showTrendline?: boolean;
  showDataTable?: boolean;
  annotations?: Array<{
    text: string;
    x: number;
    y: number;
  }>;
  // Combo chart specific
  comboTypes?: Array<"bar" | "line" | "area">;
  // Waterfall specific
  waterfallConnectors?: boolean;
}

/**
 * Build a premium professional bar chart with advanced styling
 */
export function buildBarChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  const chartData = config.series.map(s => ({
    name: s.name,
    labels: config.labels,
    values: s.values
  }));

  // Premium color palette for charts - vibrant, modern, professional
  const premiumColors = config.colors || [
    "#3B82F6",  // Bright blue - primary
    "#10B981",  // Emerald - success
    "#F59E0B",  // Amber - warning
    "#8B5CF6",  // Purple - creative
    "#EC4899",  // Magenta - accent
    "#06B6D4",  // Cyan - tech
    "#EF4444",  // Red - alert
    "#14B8A6"   // Teal - calm
  ];

  const chartOptions: any = {
    x,
    y,
    w,
    h,
    chartColors: premiumColors,
    showLegend: config.showLegend !== false,
    legendPos: "b" as const,
    dataLabelFontSize: config.showDataLabels ? 12 : 0,
    dataLabelPosition: "ctr" as const,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    dataLabelFontBold: true,
    barDir: "bar" as const,
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    chartGridLine: { style: "solid", color: "#E5E7EB", size: 0.75 },
    showValue: config.showDataLabels !== false,
    barGapWidthPercent: 120,
    catAxisLabelFontSize: 12,
    catAxisLabelColor: "#475569",
    catAxisLabelFontFace: "Inter, Arial, sans-serif",
    valAxisLabelFontSize: 12,
    valAxisLabelColor: "#475569",
    valAxisLabelFontFace: "Inter, Arial, sans-serif",
    legendFontSize: 12,
    legendFontFace: "Inter, Arial, sans-serif",
    legendColor: "#475569",
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.05,
      blur: 4,
      offset: 2
    }
  };

  slide.addChart(PptxGenJS.ChartType.bar, chartData, chartOptions);
}

/**
 * Build a premium professional line chart with advanced styling
 */
export function buildLineChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  const chartData = config.series.map(s => ({
    name: s.name,
    labels: config.labels,
    values: s.values
  }));

  // Premium color palette for charts - vibrant, modern, professional
  const premiumColors = config.colors || [
    "#3B82F6",  // Bright blue - primary
    "#10B981",  // Emerald - success
    "#F59E0B",  // Amber - warning
    "#8B5CF6",  // Purple - creative
    "#EC4899",  // Magenta - accent
    "#06B6D4",  // Cyan - tech
    "#EF4444",  // Red - alert
    "#14B8A6"   // Teal - calm
  ];

  const chartOptions: any = {
    x,
    y,
    w,
    h,
    chartColors: premiumColors,
    showLegend: config.showLegend !== false,
    legendPos: "b" as const,
    dataLabelFontSize: config.showDataLabels ? 12 : 0,
    dataLabelPosition: "ctr" as const,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    dataLabelFontBold: true,
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    lineSmooth: true,
    chartGridLine: { style: "solid", color: "#E5E7EB", size: 0.75 },
    showValue: config.showDataLabels !== false,
    catAxisLabelFontSize: 12,
    catAxisLabelColor: "#475569",
    catAxisLabelFontFace: "Inter, Arial, sans-serif",
    valAxisLabelFontSize: 12,
    valAxisLabelColor: "#475569",
    valAxisLabelFontFace: "Inter, Arial, sans-serif",
    legendFontSize: 12,
    legendFontFace: "Inter, Arial, sans-serif",
    legendColor: "#475569",
    lineSize: 3,
    lineDataSymbol: "circle",
    lineDataSymbolSize: 6,
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.05,
      blur: 4,
      offset: 2
    }
  };

  slide.addChart(PptxGenJS.ChartType.line, chartData, chartOptions);
}

/**
 * Build a premium professional pie chart with advanced styling
 */
export function buildPieChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  const chartData = [
    {
      name: config.series[0]?.name || "Data",
      labels: config.labels,
      values: config.series[0]?.values || []
    }
  ];

  // Premium color palette for pie charts - vibrant, modern, professional
  const premiumColors = config.colors || [
    "#3B82F6",  // Bright blue - primary
    "#10B981",  // Emerald - success
    "#F59E0B",  // Amber - warning
    "#8B5CF6",  // Purple - creative
    "#EC4899",  // Magenta - accent
    "#06B6D4",  // Cyan - tech
    "#EF4444",  // Red - alert
    "#14B8A6",  // Teal - calm
    "#F97316",  // Orange - energy
    "#A855F7"   // Violet - luxury
  ];

  const chartOptions: any = {
    x,
    y,
    w,
    h,
    chartColors: premiumColors,
    showLegend: config.showLegend !== false,
    legendPos: "r" as const,
    dataLabelFontSize: config.showDataLabels ? 12 : 0,
    dataLabelPosition: "ctr" as const,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    dataLabelFontBold: true,
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    showValue: config.showDataLabels !== false,
    legendFontSize: 12,
    legendFontFace: "Inter, Arial, sans-serif",
    legendColor: "#475569",
    pieHole: 0,
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 6,
      offset: 3
    }
  };

  slide.addChart(PptxGenJS.ChartType.pie, chartData, chartOptions);
}

/**
 * Build a premium professional area chart with advanced styling
 */
export function buildAreaChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  const chartData = config.series.map(s => ({
    name: s.name,
    labels: config.labels,
    values: s.values
  }));

  // Premium color palette for area charts with transparency - vibrant, modern
  const premiumColors = config.colors || [
    "#3B82F6",  // Bright blue - primary
    "#10B981",  // Emerald - success
    "#F59E0B",  // Amber - warning
    "#8B5CF6",  // Purple - creative
    "#EC4899",  // Magenta - accent
    "#06B6D4",  // Cyan - tech
    "#EF4444",  // Red - alert
    "#14B8A6"   // Teal - calm
  ];

  const chartOptions: any = {
    x,
    y,
    w,
    h,
    chartColors: premiumColors,
    showLegend: config.showLegend !== false,
    legendPos: "b" as const,
    dataLabelFontSize: config.showDataLabels ? 12 : 0,
    dataLabelPosition: "ctr" as const,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    dataLabelFontBold: true,
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    lineSmooth: true,
    chartGridLine: { style: "solid", color: "#E5E7EB", size: 0.75 },
    showValue: config.showDataLabels !== false,
    catAxisLabelFontSize: 12,
    catAxisLabelColor: "#475569",
    catAxisLabelFontFace: "Inter, Arial, sans-serif",
    valAxisLabelFontSize: 12,
    valAxisLabelColor: "#475569",
    valAxisLabelFontFace: "Inter, Arial, sans-serif",
    legendFontSize: 12,
    legendFontFace: "Inter, Arial, sans-serif",
    legendColor: "#475569",
    lineSize: 2,
    fillOpacity: 30,
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.05,
      blur: 4,
      offset: 2
    }
  };

  slide.addChart(PptxGenJS.ChartType.area, chartData, chartOptions);
}

/**
 * Build a premium professional scatter chart with advanced styling
 */
export function buildScatterChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  const chartData = config.series.map(s => ({
    name: s.name,
    labels: config.labels,
    values: s.values
  }));

  const premiumColors = config.colors || [
    "#3B82F6", "#10B981", "#F59E0B", "#8B5CF6", "#EC4899", "#06B6D4", "#EF4444", "#14B8A6"
  ];

  const chartOptions: any = {
    x, y, w, h,
    chartColors: premiumColors,
    showLegend: config.showLegend !== false,
    legendPos: "b" as const,
    dataLabelFontSize: config.showDataLabels ? 10 : 0,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    chartGridLine: { style: "solid", color: "#E5E7EB", size: 0.75 },
    catAxisLabelFontSize: 12,
    catAxisLabelColor: "#475569",
    valAxisLabelFontSize: 12,
    valAxisLabelColor: "#475569",
    lineDataSymbol: "circle",
    lineDataSymbolSize: 8,
    lineSize: 0, // No connecting lines for scatter
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 4,
      offset: 2
    }
  };

  slide.addChart(PptxGenJS.ChartType.scatter, chartData, chartOptions);
}

/**
 * Build a doughnut chart (pie chart with hole)
 */
export function buildDoughnutChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  const chartData = [
    {
      name: config.series[0]?.name || "Data",
      labels: config.labels,
      values: config.series[0]?.values || []
    }
  ];

  const premiumColors = config.colors || [
    "#3B82F6", "#10B981", "#F59E0B", "#8B5CF6", "#EC4899", "#06B6D4", "#EF4444", "#14B8A6", "#F97316", "#A855F7"
  ];

  const chartOptions: any = {
    x, y, w, h,
    chartColors: premiumColors,
    showLegend: config.showLegend !== false,
    legendPos: "r" as const,
    dataLabelFontSize: config.showDataLabels ? 12 : 0,
    dataLabelPosition: "ctr" as const,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    dataLabelFontBold: true,
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    showValue: config.showDataLabels !== false,
    legendFontSize: 12,
    legendFontFace: "Inter, Arial, sans-serif",
    legendColor: "#475569",
    pieHole: 0.5, // 50% hole for doughnut effect
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 6,
      offset: 3
    }
  };

  slide.addChart(PptxGenJS.ChartType.pie, chartData, chartOptions);
}

/**
 * Build a waterfall chart showing cumulative effect
 */
export function buildWaterfallChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  // Waterfall charts show cumulative values
  // We'll use a bar chart with custom colors for positive/negative
  const values = config.series[0]?.values || [];
  const colors: string[] = [];

  // Color code: green for positive, red for negative, blue for total
  values.forEach((val, idx) => {
    if (idx === values.length - 1) {
      colors.push("#3B82F6"); // Blue for total
    } else if (val >= 0) {
      colors.push("#10B981"); // Green for positive
    } else {
      colors.push("#EF4444"); // Red for negative
    }
  });

  const chartData = [{
    name: config.series[0]?.name || "Values",
    labels: config.labels,
    values: values
  }];

  const chartOptions: any = {
    x, y, w, h,
    chartColors: colors,
    showLegend: false,
    dataLabelFontSize: config.showDataLabels ? 12 : 0,
    dataLabelPosition: "outEnd" as const,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    dataLabelFontBold: true,
    barDir: "bar" as const,
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    chartGridLine: { style: "solid", color: "#E5E7EB", size: 0.75 },
    showValue: config.showDataLabels !== false,
    barGapWidthPercent: 150,
    catAxisLabelFontSize: 12,
    catAxisLabelColor: "#475569",
    valAxisLabelFontSize: 12,
    valAxisLabelColor: "#475569",
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.05,
      blur: 4,
      offset: 2
    }
  };

  slide.addChart(PptxGenJS.ChartType.bar, chartData, chartOptions);
}

/**
 * Build chart based on type
 */
export function buildChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  switch (config.chartType) {
    case "bar":
      buildBarChart(slide, config, x, y, w, h);
      break;
    case "line":
      buildLineChart(slide, config, x, y, w, h);
      break;
    case "pie":
      buildPieChart(slide, config, x, y, w, h);
      break;
    case "area":
      buildAreaChart(slide, config, x, y, w, h);
      break;
    case "scatter":
      buildScatterChart(slide, config, x, y, w, h);
      break;
    case "doughnut":
      buildDoughnutChart(slide, config, x, y, w, h);
      break;
    case "waterfall":
      buildWaterfallChart(slide, config, x, y, w, h);
      break;
    case "combo":
      // Combo charts use multiple series with different types
      // For now, use line chart as fallback
      buildLineChart(slide, config, x, y, w, h);
      break;
    case "funnel":
      // Funnel charts are similar to bar charts but with decreasing widths
      // Use bar chart as fallback for now
      buildBarChart(slide, config, x, y, w, h);
      break;
    default:
      buildBarChart(slide, config, x, y, w, h);
  }
}

/**
 * Validate chart config
 */
export function validateChartConfig(config: ChartConfig): boolean {
  if (!config.labels || config.labels.length === 0) {
    return false;
  }

  if (!config.series || config.series.length === 0) {
    return false;
  }

  for (const series of config.series) {
    if (series.values.length !== config.labels.length) {
      return false;
    }
  }

  return true;
}

/**
 * Get recommended chart type for data
 */
export function getRecommendedChartType(
  dataPoints: number,
  seriesCount: number,
  hasNegativeValues: boolean = false,
  isCumulative: boolean = false
): "bar" | "line" | "pie" | "area" | "scatter" | "doughnut" | "waterfall" {
  // Waterfall for cumulative/sequential data with positive and negative values
  if (isCumulative && hasNegativeValues) {
    return "waterfall";
  }

  // Doughnut for single series with few categories (better than pie for modern look)
  if (seriesCount === 1 && dataPoints <= 6) {
    return "doughnut";
  }

  // Scatter for correlation analysis (multiple series, moderate data points)
  if (seriesCount >= 2 && dataPoints >= 5 && dataPoints <= 20) {
    return "scatter";
  }

  // Line for time series or trends (many data points)
  if (seriesCount > 1 && dataPoints > 10) {
    return "line";
  }

  // Area for showing volume/magnitude over time
  if (dataPoints > 15) {
    return "area";
  }

  // Bar as default for comparisons
  return "bar";
}

/**
 * Format chart data for display
 */
export function formatChartData(
  labels: string[],
  values: number[]
): Array<{ label: string; value: number }> {
  return labels.map((label, index) => ({
    label,
    value: values[index] || 0
  }));
}

/**
 * Calculate chart statistics
 */
export function calculateChartStats(values: number[]) {
  const sum = values.reduce((a, b) => a + b, 0);
  const avg = sum / values.length;
  const max = Math.max(...values);
  const min = Math.min(...values);

  return { sum, avg, max, min };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/designAccents.ts
=================================================================================
/**
 * Professional Design Accents
 * Subtle, sophisticated visual elements that enhance slide quality
 * Inspired by Apple, Google, Tesla, and ChatGPT design systems
 */

import PptxGenJS from "pptxgenjs";

const SLIDE_WIDTH = 10;
const SLIDE_HEIGHT = 7.5;

/**
 * Add a subtle gradient overlay for depth
 */
export function addGradientOverlay(
  slide: any,
  startColor: string,
  endColor: string,
  opacity: number = 0.05,
  direction: "top-to-bottom" | "left-to-right" | "diagonal" = "diagonal"
): void {
  const colors = [startColor, endColor];
  
  // Create gradient effect using semi-transparent rectangles
  const steps = 10;
  for (let i = 0; i < steps; i++) {
    const transparency = 100 - (opacity * 100 * (i / steps));
    const color = i < steps / 2 ? startColor : endColor;
    
    let x = 0, y = 0, w = SLIDE_WIDTH, h = SLIDE_HEIGHT;
    
    if (direction === "top-to-bottom") {
      y = (SLIDE_HEIGHT / steps) * i;
      h = SLIDE_HEIGHT / steps;
    } else if (direction === "left-to-right") {
      x = (SLIDE_WIDTH / steps) * i;
      w = SLIDE_WIDTH / steps;
    } else {
      // Diagonal
      x = (SLIDE_WIDTH / steps) * i;
      y = (SLIDE_HEIGHT / steps) * i;
      w = SLIDE_WIDTH / steps;
      h = SLIDE_HEIGHT / steps;
    }
    
    slide.addShape("rect", {
      x, y, w, h,
      fill: { color: color.replace("#", ""), transparency },
      line: { type: "none" }
    });
  }
}

/**
 * Add subtle corner flourish
 */
export function addCornerFlourish(
  slide: any,
  corner: "top-left" | "top-right" | "bottom-left" | "bottom-right",
  color: string,
  size: number = 0.3
): void {
  const cleanColor = color.replace("#", "");
  let x = 0, y = 0;
  
  switch (corner) {
    case "top-right":
      x = SLIDE_WIDTH - size;
      y = 0;
      break;
    case "bottom-left":
      x = 0;
      y = SLIDE_HEIGHT - size;
      break;
    case "bottom-right":
      x = SLIDE_WIDTH - size;
      y = SLIDE_HEIGHT - size;
      break;
    case "top-left":
    default:
      x = 0;
      y = 0;
  }
  
  // Main accent shape
  slide.addShape("roundRect", {
    x, y, w: size, h: size,
    fill: { color: cleanColor, transparency: 85 },
    line: { type: "none" }
  });
  
  // Smaller accent dot
  const dotSize = size * 0.4;
  const dotX = corner.includes("right") ? x + size - dotSize : x;
  const dotY = corner.includes("bottom") ? y + size - dotSize : y;
  
  slide.addShape("ellipse", {
    x: dotX, y: dotY, w: dotSize, h: dotSize,
    fill: { color: cleanColor, transparency: 70 },
    line: { type: "none" }
  });
}

/**
 * Add subtle line accent with gradient effect
 */
export function addLineAccent(
  slide: any,
  position: "top" | "bottom" | "left" | "right",
  color: string,
  thickness: number = 0.08
): void {
  const cleanColor = color.replace("#", "");
  let x = 0, y = 0, w = SLIDE_WIDTH, h = thickness;
  
  switch (position) {
    case "bottom":
      y = SLIDE_HEIGHT - thickness;
      break;
    case "left":
      w = thickness;
      h = SLIDE_HEIGHT;
      break;
    case "right":
      x = SLIDE_WIDTH - thickness;
      w = thickness;
      h = SLIDE_HEIGHT;
      break;
    case "top":
    default:
      break;
  }
  
  slide.addShape("rect", {
    x, y, w, h,
    fill: { color: cleanColor, transparency: 80 },
    line: { type: "none" }
  });
}

/**
 * Add subtle dot pattern for visual interest
 */
export function addDotPattern(
  slide: any,
  color: string,
  density: "sparse" | "moderate" | "dense" = "sparse",
  opacity: number = 0.1
): void {
  const cleanColor = color.replace("#", "");
  const dotSize = 0.08;
  
  const spacing = density === "sparse" ? 1.5 : density === "moderate" ? 1.0 : 0.6;
  const transparency = 100 - (opacity * 100);
  
  for (let x = 0; x < SLIDE_WIDTH; x += spacing) {
    for (let y = 0; y < SLIDE_HEIGHT; y += spacing) {
      // Random offset for organic feel
      const offsetX = (Math.random() - 0.5) * 0.2;
      const offsetY = (Math.random() - 0.5) * 0.2;
      
      slide.addShape("ellipse", {
        x: x + offsetX,
        y: y + offsetY,
        w: dotSize,
        h: dotSize,
        fill: { color: cleanColor, transparency },
        line: { type: "none" }
      });
    }
  }
}

/**
 * Add subtle wave pattern at bottom
 */
export function addWaveAccent(
  slide: any,
  color: string,
  height: number = 0.5
): void {
  const cleanColor = color.replace("#", "");
  const waveY = SLIDE_HEIGHT - height;
  
  // Create wave effect with curved shapes
  const waveSegments = 8;
  const segmentWidth = SLIDE_WIDTH / waveSegments;
  
  for (let i = 0; i < waveSegments; i++) {
    const x = i * segmentWidth;
    const curveHeight = Math.sin((i / waveSegments) * Math.PI) * (height * 0.5);
    
    slide.addShape("rect", {
      x,
      y: waveY + curveHeight,
      w: segmentWidth,
      h: height - curveHeight,
      fill: { color: cleanColor, transparency: 85 },
      line: { type: "none" }
    });
  }
}

/**
 * Add subtle shadow effect to content area
 */
export function addContentShadow(
  slide: any,
  x: number,
  y: number,
  w: number,
  h: number,
  color: string = "000000",
  blur: number = 8
): void {
  slide.addShape("rect", {
    x: x + 0.05,
    y: y + 0.05,
    w,
    h,
    fill: { color, transparency: 95 },
    line: { type: "none" },
    shadow: {
      type: "outer",
      color,
      opacity: 0.15,
      blur,
      offset: 4
    }
  });
}

/**
 * Add subtle frame/border accent
 */
export function addFrameAccent(
  slide: any,
  x: number,
  y: number,
  w: number,
  h: number,
  color: string,
  thickness: number = 0.06
): void {
  const cleanColor = color.replace("#", "");
  
  // Top border
  slide.addShape("rect", {
    x, y, w, h: thickness,
    fill: { color: cleanColor, transparency: 80 },
    line: { type: "none" }
  });
  
  // Right border
  slide.addShape("rect", {
    x: x + w - thickness, y, w: thickness, h,
    fill: { color: cleanColor, transparency: 80 },
    line: { type: "none" }
  });
  
  // Bottom border
  slide.addShape("rect", {
    x, y: y + h - thickness, w, h: thickness,
    fill: { color: cleanColor, transparency: 80 },
    line: { type: "none" }
  });
  
  // Left border
  slide.addShape("rect", {
    x, y, w: thickness, h,
    fill: { color: cleanColor, transparency: 80 },
    line: { type: "none" }
  });
}

/**
 * Add subtle connecting line between elements
 */
export function addConnectorLine(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string,
  thickness: number = 0.04
): void {
  const cleanColor = color.replace("#", "");
  const dx = x2 - x1;
  const dy = y2 - y1;
  const length = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx) * (180 / Math.PI);
  
  slide.addShape("rect", {
    x: x1,
    y: y1 - thickness / 2,
    w: length,
    h: thickness,
    fill: { color: cleanColor, transparency: 85 },
    line: { type: "none" },
    rotate: angle
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/designTokenMapper.ts
=================================================================================
/**
 * Design Token Mapper
 * Maps design tokens to PptxGenJS options for consistent styling
 */

export interface MappedColors {
  primary: string;
  accent: string;
  neutral: string[];
  text: string;
  background: string;
}

export interface MappedTypography {
  title: {
    fontFace: string;
    fontSize: number;
    bold: boolean;
    lineHeight: number;
    color?: string;
  };
  subtitle: {
    fontFace: string;
    fontSize: number;
    bold: boolean;
    lineHeight: number;
    color?: string;
  };
  body: {
    fontFace: string;
    fontSize: number;
    bold: boolean;
    lineHeight: number;
    color?: string;
  };
  caption: {
    fontFace: string;
    fontSize: number;
    bold: boolean;
    lineHeight: number;
    color?: string;
  };
}

export interface MappedShadows {
  sm: {
    type: "outer" | "inner";
    blur: number;
    offset: number;
    opacity: number;
  };
  md: {
    type: "outer" | "inner";
    blur: number;
    offset: number;
    opacity: number;
  };
  lg: {
    type: "outer" | "inner";
    blur: number;
    offset: number;
    opacity: number;
  };
}

/**
 * Map color palette to PptxGenJS format with premium color standards
 */
export function mapColorPalette(palette: any): MappedColors {
  // Premium neutral palette from dark to light
  const premiumNeutral = palette.neutral || [
    "#0F172A", // Charcoal - text
    "#1E293B", // Dark slate
    "#334155", // Slate
    "#64748B", // Medium slate
    "#94A3B8", // Light slate
    "#CBD5E1", // Lighter slate
    "#F8FAFC"  // Almost white - background
  ];

  return {
    primary: palette.primary || "#1E40AF", // Premium navy blue
    accent: palette.accent || "#10B981",   // Premium emerald
    neutral: premiumNeutral,
    text: premiumNeutral[0],
    background: premiumNeutral[6]
  };
}

/**
 * Map typography tokens to PptxGenJS format with premium standards
 */
export function mapTypography(tokens: any): MappedTypography {
  // Premium font pairings for professional presentations
  const fonts = tokens.fonts || {
    sans: "Inter, Arial, sans-serif",
    serif: "Georgia, serif",
    mono: "Courier New, monospace"
  };

  const sizes = tokens.sizes || {
    step_4: 56,   // Hero title - larger for impact
    step_3: 44,   // Premium title size - increased
    step_2: 32,   // Subtitle - more prominent
    step_1: 24,   // Secondary - better hierarchy
    step_0: 18,   // Body - more readable
    "step_-1": 16, // Caption - clearer
    "step_-2": 14  // Small - still legible
  };

  const weights = tokens.weights || {
    bold: 700,
    semibold: 600,
    medium: 500,
    regular: 400,
    light: 300
  };

  const lineHeights = tokens.lineHeights || {
    tight: 1.15,    // Slightly more breathing room
    compact: 1.25,  // Better readability
    standard: 1.6,  // Optimal for body text
    relaxed: 1.8    // Maximum comfort
  };

  return {
    title: {
      fontFace: fonts.sans,
      fontSize: sizes.step_3,
      bold: true,
      lineHeight: lineHeights.compact,
      color: "#0F172A"
    },
    subtitle: {
      fontFace: fonts.sans,
      fontSize: sizes.step_2,
      bold: false,
      lineHeight: 1.4,
      color: "#334155"
    },
    body: {
      fontFace: fonts.sans,
      fontSize: sizes.step_0,
      bold: false,
      lineHeight: lineHeights.standard,
      color: "#1E293B"
    },
    caption: {
      fontFace: fonts.sans,
      fontSize: sizes["step_-1"],
      bold: false,
      lineHeight: lineHeights.standard,
      color: "#64748B"
    }
  };
}

/**
 * Map shadows to PptxGenJS format with premium depth
 */
export function mapShadows(tokens: any): MappedShadows {
  return {
    sm: {
      type: "outer",
      blur: 4,
      offset: 2,
      opacity: 0.08  // Subtle, premium
    },
    md: {
      type: "outer",
      blur: 12,
      offset: 4,
      opacity: 0.12  // Professional depth
    },
    lg: {
      type: "outer",
      blur: 32,
      offset: 8,
      opacity: 0.16  // Elevated, sophisticated
    }
  };
}

/**
 * Map spacing tokens with premium standards
 */
export function mapSpacing(tokens: any): Record<string, number> {
  const base = tokens.base || 4;
  const steps = tokens.steps || [0, 4, 8, 12, 16, 24, 32];

  return {
    xs: steps[0] || 0,
    sm: steps[1] || 4,
    md: steps[2] || 8,
    lg: steps[3] || 12,
    xl: steps[4] || 16,
    "2xl": steps[5] || 24,
    "3xl": steps[6] || 32,
    "4xl": 48,  // Premium breathing room
    "5xl": 64   // Luxury spacing
  };
}

/**
 * Map border radius tokens with premium standards
 */
export function mapRadii(tokens: any): Record<string, number> {
  const radii = tokens.radii || { sm: 4, md: 8, lg: 12 };

  return {
    sm: radii.sm || 4,      // Subtle rounding
    md: radii.md || 8,      // Standard
    lg: radii.lg || 12,     // Generous
    xl: (radii.lg || 12) * 1.5,  // Extra generous
    "2xl": (radii.lg || 12) * 2,  // Premium
    full: 9999              // Fully rounded
  };
}

/**
 * Convert pixels to inches (for PptxGenJS)
 */
export function pxToIn(px: number): number {
  return (px * 0.75) / 72;
}

/**
 * Convert inches to pixels
 */
export function inToPx(inches: number): number {
  return (inches * 72) / 0.75;
}

/**
 * Get text options from typography config
 */
export function getTextOptions(
  typography: MappedTypography,
  colors: MappedColors,
  level: "title" | "subtitle" | "body" | "caption" = "body"
) {
  const config = typography[level];

  return {
    fontFace: config.fontFace,
    fontSize: config.fontSize,
    bold: config.bold,
    color: colors.text,
    align: "left" as const,
    valign: "middle" as const,
    wrap: true,
    lineSpacing: config.lineHeight * 100
  };
}

/**
 * Get shape options with shadow
 */
export function getShapeOptions(
  colors: MappedColors,
  shadows: MappedShadows,
  shadowLevel: "sm" | "md" | "lg" = "md"
) {
  const shadow = shadows[shadowLevel];

  return {
    fill: { color: colors.background },
    line: { color: colors.accent, width: 1 },
    shadow: {
      type: shadow.type,
      color: "000000",
      opacity: shadow.opacity,
      blur: shadow.blur,
      offset: shadow.offset
    }
  };
}

/**
 * Get advanced typography configuration for premium presentations
 */
export function getAdvancedTypography(theme: string = "professional"): any {
  const typographyThemes: Record<string, any> = {
    professional: {
      fontPairing: {
        primary: "Inter, Arial, sans-serif",
        secondary: "Inter, Arial, sans-serif"
      },
      hierarchy: {
        hero: { size: 56, weight: 700, lineHeight: 1.1, letterSpacing: -0.5 },
        title: { size: 40, weight: 700, lineHeight: 1.2, letterSpacing: 0 },
        subtitle: { size: 28, weight: 500, lineHeight: 1.4, letterSpacing: 0.2 },
        body: { size: 16, weight: 400, lineHeight: 1.5, letterSpacing: 0 },
        caption: { size: 14, weight: 400, lineHeight: 1.5, letterSpacing: 0.1 }
      }
    },
    elegant: {
      fontPairing: {
        primary: "Georgia, serif",
        secondary: "Inter, Arial, sans-serif"
      },
      hierarchy: {
        hero: { size: 52, weight: 700, lineHeight: 1.15, letterSpacing: -0.3 },
        title: { size: 36, weight: 700, lineHeight: 1.25, letterSpacing: 0 },
        subtitle: { size: 24, weight: 400, lineHeight: 1.5, letterSpacing: 0.1 },
        body: { size: 16, weight: 400, lineHeight: 1.6, letterSpacing: 0 },
        caption: { size: 13, weight: 400, lineHeight: 1.5, letterSpacing: 0.05 }
      }
    },
    modern: {
      fontPairing: {
        primary: "Inter, Arial, sans-serif",
        secondary: "Inter, Arial, sans-serif"
      },
      hierarchy: {
        hero: { size: 60, weight: 800, lineHeight: 1.0, letterSpacing: -1 },
        title: { size: 44, weight: 700, lineHeight: 1.15, letterSpacing: -0.5 },
        subtitle: { size: 32, weight: 600, lineHeight: 1.3, letterSpacing: 0 },
        body: { size: 16, weight: 400, lineHeight: 1.5, letterSpacing: 0 },
        caption: { size: 14, weight: 500, lineHeight: 1.4, letterSpacing: 0.2 }
      }
    }
  };

  return typographyThemes[theme] || typographyThemes.professional;
}

/**
 * Validate design tokens
 */
export function validateDesignTokens(tokens: any): boolean {
  if (!tokens.palette || !tokens.typography) {
    return false;
  }

  const palette = tokens.palette;
  const hexPattern = /^#[0-9A-Fa-f]{6}$/;

  if (!hexPattern.test(palette.primary) || !hexPattern.test(palette.accent)) {
    return false;
  }

  if (!Array.isArray(palette.neutral) || palette.neutral.length < 5) {
    return false;
  }

  return true;
}

/**
 * Get complete design token map
 */
export function getCompleteTokenMap(tokens: any) {
  return {
    colors: mapColorPalette(tokens.palette),
    typography: mapTypography(tokens.typography),
    shadows: mapShadows(tokens.shadows),
    spacing: mapSpacing(tokens.spacing),
    radii: mapRadii(tokens.radii)
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/enhancedAnimations.ts
=================================================================================
/**
 * Enhanced Animations for Professional PowerPoint Slides
 * Sophisticated entrance, emphasis, and exit animations
 * Inspired by Apple Keynote and Google Slides
 */

import PptxGenJS from "pptxgenjs";

export type AnimationType = 
  | "fade-in" | "fade-out"
  | "slide-in-left" | "slide-in-right" | "slide-in-top" | "slide-in-bottom"
  | "slide-out-left" | "slide-out-right" | "slide-out-top" | "slide-out-bottom"
  | "zoom-in" | "zoom-out"
  | "scale-up" | "scale-down"
  | "rotate-in" | "rotate-out"
  | "bounce-in" | "bounce-out"
  | "flip-in" | "flip-out"
  | "pulse" | "glow" | "shake" | "swing"
  | "grow" | "shrink"
  | "color-flash" | "bold-flash"
  | "spin-clockwise" | "spin-counter-clockwise";

export interface AnimationConfig {
  type: AnimationType;
  duration: number; // milliseconds
  delay: number; // milliseconds
  easing?: "ease-in" | "ease-out" | "ease-in-out" | "linear";
  repeat?: number; // number of times to repeat
  direction?: "left" | "right" | "top" | "bottom" | "center";
}

export interface StaggerConfig {
  enabled: boolean;
  delay: number; // milliseconds between each element
  direction?: "forward" | "backward" | "random";
}

/**
 * Create an animation configuration with sensible defaults
 */
export function createAnimation(
  type: AnimationType,
  duration: number = 500,
  delay: number = 0,
  easing: "ease-in" | "ease-out" | "ease-in-out" | "linear" = "ease-out"
): AnimationConfig {
  return {
    type,
    duration,
    delay,
    easing
  };
}

/**
 * Get recommended animation for content type
 */
export function getRecommendedAnimation(contentType: "title" | "subtitle" | "bullet" | "chart" | "image"): AnimationConfig {
  const animations: Record<string, AnimationConfig> = {
    title: createAnimation("fade-in", 600, 0),
    subtitle: createAnimation("fade-in", 500, 200),
    bullet: createAnimation("slide-in-left", 400, 300),
    chart: createAnimation("zoom-in", 700, 400),
    image: createAnimation("fade-in", 500, 300)
  };

  return animations[contentType] || createAnimation("fade-in", 500, 0);
}

/**
 * Get animation duration based on complexity
 */
export function getAnimationDuration(complexity: "simple" | "moderate" | "complex"): number {
  const durations: Record<string, number> = {
    simple: 300,
    moderate: 500,
    complex: 800
  };

  return durations[complexity] || 500;
}

/**
 * Create a stagger configuration for sequential animations
 */
export function createStaggerConfig(
  enabled: boolean = true,
  delay: number = 100,
  direction: "forward" | "backward" | "random" = "forward"
): StaggerConfig {
  return {
    enabled,
    delay,
    direction
  };
}

/**
 * Get easing function curve
 */
export function getEasingCurve(easing: string): string {
  const curves: Record<string, string> = {
    "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
    "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
    "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)",
    "linear": "linear"
  };

  return curves[easing] || curves["ease-out"];
}

/**
 * Calculate animation timing for a sequence
 */
export function calculateSequenceTiming(
  elementCount: number,
  baseDelay: number = 0,
  staggerDelay: number = 100,
  direction: "forward" | "backward" | "random" = "forward"
): number[] {
  const timings: number[] = [];

  if (direction === "forward") {
    for (let i = 0; i < elementCount; i++) {
      timings.push(baseDelay + i * staggerDelay);
    }
  } else if (direction === "backward") {
    for (let i = elementCount - 1; i >= 0; i--) {
      timings.push(baseDelay + (elementCount - 1 - i) * staggerDelay);
    }
  } else {
    // Random
    for (let i = 0; i < elementCount; i++) {
      timings.push(baseDelay + Math.random() * (elementCount * staggerDelay));
    }
  }

  return timings;
}

/**
 * Get animation preset for common scenarios
 */
export function getAnimationPreset(preset: "entrance" | "emphasis" | "exit" | "transition"): AnimationConfig[] {
  const presets: Record<string, AnimationConfig[]> = {
    entrance: [
      createAnimation("fade-in", 400, 0),
      createAnimation("slide-in-left", 500, 100),
      createAnimation("slide-in-left", 500, 200),
      createAnimation("slide-in-left", 500, 300)
    ],
    emphasis: [
      createAnimation("pulse", 600, 0),
      createAnimation("glow", 800, 0),
      createAnimation("scale-up", 400, 0)
    ],
    exit: [
      createAnimation("fade-out", 400, 0),
      createAnimation("slide-out-right", 500, 100),
      createAnimation("zoom-out", 500, 200)
    ],
    transition: [
      createAnimation("fade-in", 500, 0),
      createAnimation("slide-in-right", 600, 0),
      createAnimation("zoom-in", 700, 0)
    ]
  };

  return presets[preset] || presets.entrance;
}

/**
 * Validate animation configuration
 */
export function validateAnimationConfig(config: AnimationConfig): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!config.type) {
    errors.push("Animation type is required");
  }

  if (config.duration < 0) {
    errors.push("Duration must be non-negative");
  }

  if (config.delay < 0) {
    errors.push("Delay must be non-negative");
  }

  if (config.repeat && config.repeat < 1) {
    errors.push("Repeat count must be at least 1");
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Get animation metadata for documentation
 */
export function getAnimationMetadata(type: AnimationType): {
  name: string;
  category: "entrance" | "emphasis" | "exit";
  duration: number;
  description: string;
} {
  const metadata: Record<AnimationType, any> = {
    "fade-in": {
      name: "Fade In",
      category: "entrance",
      duration: 500,
      description: "Element fades in from transparent to opaque"
    },
    "fade-out": {
      name: "Fade Out",
      category: "exit",
      duration: 500,
      description: "Element fades out from opaque to transparent"
    },
    "slide-in-left": {
      name: "Slide In Left",
      category: "entrance",
      duration: 500,
      description: "Element slides in from the left"
    },
    "slide-in-right": {
      name: "Slide In Right",
      category: "entrance",
      duration: 500,
      description: "Element slides in from the right"
    },
    "slide-in-top": {
      name: "Slide In Top",
      category: "entrance",
      duration: 500,
      description: "Element slides in from the top"
    },
    "slide-in-bottom": {
      name: "Slide In Bottom",
      category: "entrance",
      duration: 500,
      description: "Element slides in from the bottom"
    },
    "slide-out-left": {
      name: "Slide Out Left",
      category: "exit",
      duration: 500,
      description: "Element slides out to the left"
    },
    "slide-out-right": {
      name: "Slide Out Right",
      category: "exit",
      duration: 500,
      description: "Element slides out to the right"
    },
    "slide-out-top": {
      name: "Slide Out Top",
      category: "exit",
      duration: 500,
      description: "Element slides out to the top"
    },
    "slide-out-bottom": {
      name: "Slide Out Bottom",
      category: "exit",
      duration: 500,
      description: "Element slides out to the bottom"
    },
    "zoom-in": {
      name: "Zoom In",
      category: "entrance",
      duration: 600,
      description: "Element zooms in from small to full size"
    },
    "zoom-out": {
      name: "Zoom Out",
      category: "exit",
      duration: 600,
      description: "Element zooms out from full size to small"
    },
    "scale-up": {
      name: "Scale Up",
      category: "emphasis",
      duration: 400,
      description: "Element scales up slightly for emphasis"
    },
    "scale-down": {
      name: "Scale Down",
      category: "emphasis",
      duration: 400,
      description: "Element scales down slightly"
    },
    "rotate-in": {
      name: "Rotate In",
      category: "entrance",
      duration: 600,
      description: "Element rotates in"
    },
    "rotate-out": {
      name: "Rotate Out",
      category: "exit",
      duration: 600,
      description: "Element rotates out"
    },
    "bounce-in": {
      name: "Bounce In",
      category: "entrance",
      duration: 700,
      description: "Element bounces in with elastic effect"
    },
    "bounce-out": {
      name: "Bounce Out",
      category: "exit",
      duration: 700,
      description: "Element bounces out with elastic effect"
    },
    "flip-in": {
      name: "Flip In",
      category: "entrance",
      duration: 600,
      description: "Element flips in"
    },
    "flip-out": {
      name: "Flip Out",
      category: "exit",
      duration: 600,
      description: "Element flips out"
    },
    "pulse": {
      name: "Pulse",
      category: "emphasis",
      duration: 600,
      description: "Element pulses with scale effect"
    },
    "glow": {
      name: "Glow",
      category: "emphasis",
      duration: 800,
      description: "Element glows with shadow effect"
    },
    "shake": {
      name: "Shake",
      category: "emphasis",
      duration: 500,
      description: "Element shakes side to side"
    },
    "swing": {
      name: "Swing",
      category: "emphasis",
      duration: 600,
      description: "Element swings back and forth"
    },
    "grow": {
      name: "Grow",
      category: "emphasis",
      duration: 500,
      description: "Element grows in size"
    },
    "shrink": {
      name: "Shrink",
      category: "emphasis",
      duration: 500,
      description: "Element shrinks in size"
    },
    "color-flash": {
      name: "Color Flash",
      category: "emphasis",
      duration: 400,
      description: "Element flashes with color change"
    },
    "bold-flash": {
      name: "Bold Flash",
      category: "emphasis",
      duration: 400,
      description: "Element flashes bold"
    },
    "spin-clockwise": {
      name: "Spin Clockwise",
      category: "emphasis",
      duration: 600,
      description: "Element spins clockwise"
    },
    "spin-counter-clockwise": {
      name: "Spin Counter-Clockwise",
      category: "emphasis",
      duration: 600,
      description: "Element spins counter-clockwise"
    }
  };

  return metadata[type] || {
    name: "Unknown",
    category: "entrance",
    duration: 500,
    description: "Unknown animation"
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/enhancedDataViz.ts
=================================================================================
/**
 * Enhanced Data Visualization
 * Advanced chart styling, annotations, and visual enhancements
 */

import PptxGenJS from "pptxgenjs";

export interface ChartAnnotation {
  label: string;
  value: number | string;
  x: number;
  y: number;
  color: string;
}

export interface DataVizConfig {
  title?: string;
  subtitle?: string;
  showLegend?: boolean;
  showGridlines?: boolean;
  showDataLabels?: boolean;
  annotations?: ChartAnnotation[];
  colors?: string[];
}

/**
 * Add a professional chart title with subtitle
 */
export function addChartHeader(
  slide: any,
  x: number,
  y: number,
  width: number,
  title: string,
  subtitle?: string,
  titleColor: string = "#0F172A",
  subtitleColor: string = "#64748B"
): void {
  // Title
  slide.addText(title, {
    x,
    y,
    w: width,
    h: 0.35,
    fontSize: 18,
    bold: true,
    color: titleColor,
    align: "left",
    fontFace: "Inter, Arial, sans-serif"
  });

  // Subtitle
  if (subtitle) {
    slide.addText(subtitle, {
      x,
      y: y + 0.35,
      w: width,
      h: 0.25,
      fontSize: 12,
      color: subtitleColor,
      align: "left",
      fontFace: "Inter, Arial, sans-serif"
    });
  }
}

/**
 * Add data point annotations to chart
 */
export function addChartAnnotations(
  slide: any,
  annotations: ChartAnnotation[]
): void {
  annotations.forEach((annotation) => {
    // Annotation background
    slide.addShape("roundRect", {
      x: annotation.x - 0.3,
      y: annotation.y - 0.15,
      w: 0.6,
      h: 0.3,
      fill: { color: "#FFFFFF" },
      line: { color: annotation.color, width: 1.5 },
      shadow: {
        type: "outer",
        color: "000000",
        opacity: 0.1,
        blur: 3,
        offset: 1
      }
    });

    // Annotation text
    slide.addText(annotation.label, {
      x: annotation.x - 0.3,
      y: annotation.y - 0.15,
      w: 0.6,
      h: 0.3,
      fontSize: 10,
      bold: true,
      color: annotation.color,
      align: "center",
      valign: "middle"
    });
  });
}

/**
 * Add a legend with custom styling
 */
export function addCustomLegend(
  slide: any,
  x: number,
  y: number,
  items: Array<{ label: string; color: string }>,
  columns: number = 1
): void {
  const itemHeight = 0.25;
  const itemWidth = 2;
  const gap = 0.1;

  items.forEach((item, index) => {
    const col = index % columns;
    const row = Math.floor(index / columns);
    const itemX = x + col * (itemWidth + gap);
    const itemY = y + row * (itemHeight + gap);

    // Color indicator
    slide.addShape("rect", {
      x: itemX,
      y: itemY + 0.05,
      w: 0.15,
      h: 0.15,
      fill: { color: item.color },
      line: { type: "none" }
    });

    // Label
    slide.addText(item.label, {
      x: itemX + 0.2,
      y: itemY,
      w: itemWidth - 0.2,
      h: itemHeight,
      fontSize: 11,
      color: "#334155",
      align: "left",
      valign: "middle"
    });
  });
}

/**
 * Add a data highlight box with key metric
 */
export function addMetricHighlight(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  metric: string,
  value: string,
  change?: string,
  changeColor?: string
): void {
  // Background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: "#F8FAFC" },
    line: { color: "#E2E8F0", width: 1 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.06,
      blur: 4,
      offset: 1
    }
  });

  // Metric label
  slide.addText(metric, {
    x: x + 0.15,
    y: y + 0.1,
    w: width - 0.3,
    h: 0.2,
    fontSize: 11,
    color: "#64748B",
    align: "left"
  });

  // Value
  slide.addText(value, {
    x: x + 0.15,
    y: y + 0.35,
    w: width - 0.3,
    h: 0.35,
    fontSize: 24,
    bold: true,
    color: "#0F172A",
    align: "left"
  });

  // Change indicator
  if (change && changeColor) {
    slide.addText(change, {
      x: x + 0.15,
      y: y + height - 0.25,
      w: width - 0.3,
      h: 0.2,
      fontSize: 10,
      bold: true,
      color: changeColor,
      align: "left"
    });
  }
}

/**
 * Add a trend indicator (up/down arrow with percentage)
 */
export function addTrendIndicator(
  slide: any,
  x: number,
  y: number,
  percentage: number,
  isPositive: boolean = true
): void {
  const color = isPositive ? "#10B981" : "#EF4444";
  const arrow = isPositive ? "↑" : "↓";

  slide.addText(`${arrow} ${Math.abs(percentage)}%`, {
    x,
    y,
    w: 0.8,
    h: 0.25,
    fontSize: 12,
    bold: true,
    color,
    align: "center",
    valign: "middle"
  });
}

/**
 * Add a comparison bar between two values
 */
export function addComparisonBar(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  value1: number,
  value2: number,
  label1: string,
  label2: string,
  color1: string,
  color2: string
): void {
  const maxValue = Math.max(value1, value2);
  const bar1Width = (value1 / maxValue) * width;
  const bar2Width = (value2 / maxValue) * width;

  // Bar 1
  slide.addShape("rect", {
    x,
    y,
    w: bar1Width,
    h: height / 2 - 0.05,
    fill: { color: color1 },
    line: { type: "none" }
  });

  // Label 1
  slide.addText(label1, {
    x: x + bar1Width + 0.1,
    y,
    w: 1,
    h: height / 2 - 0.05,
    fontSize: 10,
    color: "#334155",
    align: "left",
    valign: "middle"
  });

  // Bar 2
  slide.addShape("rect", {
    x,
    y: y + height / 2 + 0.05,
    w: bar2Width,
    h: height / 2 - 0.05,
    fill: { color: color2 },
    line: { type: "none" }
  });

  // Label 2
  slide.addText(label2, {
    x: x + bar2Width + 0.1,
    y: y + height / 2 + 0.05,
    w: 1,
    h: height / 2 - 0.05,
    fontSize: 10,
    color: "#334155",
    align: "left",
    valign: "middle"
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/hybridBuilder.ts
=================================================================================
/**
 * Hybrid Slide Builder
 * Combines SVG backgrounds with PptxGenJS editable content
 * 
 * This approach gives us:
 * - Professional, Apple/Tesla-quality visual design (SVG)
 * - Editable, accessible content (PptxGenJS)
 * - Small file sizes
 * - Innovation and creativity
 */

import PptxGenJS from "pptxgenjs";
import { SlideSpecV1 } from "../types/SlideSpecV1";
import { generateBackgroundForSlide, svgToPngDataUrl } from "../svgGenerator";

const SLIDE_WIDTH = 10; // inches
const SLIDE_HEIGHT = 5.625; // inches (16:9 aspect ratio)

/**
 * Build slide using hybrid approach
 */
export async function buildHybridSlide(pptx: PptxGenJS, spec: SlideSpecV1): Promise<void> {
  const slide = pptx.addSlide();

  try {
    // Step 1: Generate SVG background with professional design
    const svgBackground = generateBackgroundForSlide(spec);

    // Step 2: Convert SVG to PNG and add as slide background
    const backgroundDataUrl = await svgToPngDataUrl(svgBackground, 1920, 1080);
    slide.background = { data: backgroundDataUrl };

    // Step 3: Add editable content on top using PptxGenJS
    await addEditableContent(slide, spec);
  } catch (error) {
    console.error("Error building hybrid slide:", error);
    // Fallback: use solid color background
    const bgColor = spec.styleTokens?.palette?.neutral?.[8] || "F8FAFC";
    slide.background = { color: bgColor.replace("#", "") };
    await addEditableContent(slide, spec);
  }
}

/**
 * Add editable content (text, bullets, metrics) on top of SVG background
 * Enhanced with better typography and spacing
 */
async function addEditableContent(slide: any, spec: SlideSpecV1): Promise<void> {
  const tokens = spec.styleTokens;
  const palette = tokens?.palette;
  const typography = tokens?.typography;

  // Colors - enhanced contrast
  const textColor = palette?.neutral?.[0] || "#0F172A";
  const subtitleColor = palette?.neutral?.[2] || "#64748B";
  const primaryColor = palette?.primary || "#6366F1";
  const accentColor = palette?.accent || "#10B981";

  // Typography - refined sizes
  const titleSize = typography?.sizes?.step_3 || 40;
  const subtitleSize = typography?.sizes?.step_1 || 20;
  const bodySize = typography?.sizes?.step_0 || 18;

  let currentY = 0.7; // Start position - slightly higher

  // Add Title with enhanced styling
  if (spec.content.title) {
    slide.addText(spec.content.title.text, {
      x: 0.7,
      y: currentY,
      w: SLIDE_WIDTH - 1.4,
      h: 1.0,
      fontSize: titleSize,
      bold: true,
      color: textColor.replace("#", ""),
      fontFace: typography?.fonts?.sans || "Aptos",
      align: "left",
      valign: "top",
      lineSpacing: 110, // Slightly tighter line spacing for titles
    });

    // Add subtle accent line under title
    slide.addShape("rect", {
      x: 0.7,
      y: currentY + 0.85,
      w: 2.5,
      h: 0.04,
      fill: { color: primaryColor.replace("#", "") },
      line: { type: "none" },
    });

    currentY += 1.3;
  }

  // Add Subtitle with refined styling
  if (spec.content.subtitle) {
    slide.addText(spec.content.subtitle.text, {
      x: 0.7,
      y: currentY,
      w: SLIDE_WIDTH - 1.4,
      h: 0.6,
      fontSize: subtitleSize,
      color: subtitleColor.replace("#", ""),
      fontFace: typography?.fonts?.sans || "Aptos",
      align: "left",
      valign: "top",
      lineSpacing: 130,
    });
    currentY += 0.9;
  }

  // Add Content with enhanced styling
  await addContent(slide, spec.content, currentY, {
    textColor,
    subtitleColor,
    primaryColor,
    accentColor,
    bodySize,
    palette,
    fontFace: typography?.fonts?.sans || "Aptos",
  });
}

/**
 * Add content (bullets, dataViz, etc.)
 */
async function addContent(
  slide: any,
  content: SlideSpecV1["content"],
  startY: number,
  colors: any
): Promise<void> {
  if (!content) return;

  let currentY = startY;

  // Bullets - Enhanced with better spacing and styling
  if (content.bullets && content.bullets.length > 0) {
    const allBulletItems: any[] = [];

    content.bullets.forEach((bulletGroup) => {
      bulletGroup.items.forEach((item) => {
        allBulletItems.push({
          text: item.text,
          options: {
            bullet: {
              code: "2022", // Bullet character
              color: colors.primaryColor.replace("#", ""),
            },
            indentLevel: item.level - 1,
            color: colors.textColor.replace("#", ""),
            fontSize: colors.bodySize,
            fontFace: colors.fontFace,
            paraSpaceBefore: 0,
            paraSpaceAfter: 4, // Reduced spacing between bullets
          },
        });
      });
    });

    slide.addText(allBulletItems, {
      x: 0.9,
      y: currentY,
      w: SLIDE_WIDTH - 1.8,
      h: SLIDE_HEIGHT - currentY - 0.6,
      fontSize: colors.bodySize,
      color: colors.textColor.replace("#", ""),
      fontFace: colors.fontFace,
      valign: "top",
      lineSpacing: 120, // Tighter line spacing
    });
  }

  // Data Visualization (chart)
  if (content.dataViz) {
    await addDataViz(slide, content.dataViz, currentY, colors);
  }

  // Callouts - Enhanced with better visual design
  if (content.callouts && content.callouts.length > 0) {
    content.callouts.forEach((callout, index) => {
      const y = currentY + index * 0.9;
      const calloutColor =
        callout.variant === "success" ? "#10B981" :
        callout.variant === "warning" ? "#F59E0B" :
        callout.variant === "danger" ? "#EF4444" :
        colors.primaryColor;

      const bgColor =
        callout.variant === "success" ? "#D1FAE5" :
        callout.variant === "warning" ? "#FEF3C7" :
        callout.variant === "danger" ? "#FEE2E2" :
        "#EEF2FF";

      // Add callout background with rounded corners
      slide.addShape("roundRect", {
        x: 0.9,
        y,
        w: SLIDE_WIDTH - 1.8,
        h: 0.7,
        fill: { color: bgColor.replace("#", "") },
        line: {
          color: calloutColor.replace("#", ""),
          width: 2,
        },
      });

      // Add left accent bar
      slide.addShape("rect", {
        x: 0.9,
        y,
        w: 0.08,
        h: 0.7,
        fill: { color: calloutColor.replace("#", "") },
        line: { type: "none" },
      });

      // Add callout text
      const displayText = callout.title ? `${callout.title}: ${callout.text}` : callout.text;
      slide.addText(displayText, {
        x: 1.1,
        y: y + 0.1,
        w: SLIDE_WIDTH - 2.2,
        h: 0.5,
        fontSize: colors.bodySize - 1,
        color: colors.textColor.replace("#", ""),
        fontFace: colors.fontFace,
        align: "left",
        valign: "middle",
        bold: !!callout.title,
      });
    });
  }
}

/**
 * Add data visualization (chart) to slide with enhanced styling
 */
async function addDataViz(slide: any, dataViz: any, startY: number, colors: any): Promise<void> {
  if (!dataViz || !dataViz.labels || dataViz.labels.length === 0) return;

  const chartKind = dataViz.kind || "bar";
  const chartWidth = SLIDE_WIDTH - 1.8;
  const chartHeight = SLIDE_HEIGHT - startY - 0.6;

  try {
    // Prepare chart data for PptxGenJS
    const chartDataFormatted = dataViz.series.map((series: any) => ({
      name: series.name,
      labels: dataViz.labels,
      values: series.values,
    }));

    // Map chart kind to PptxGenJS chart type
    const chartTypeMap: any = {
      bar: "bar",
      line: "line",
      pie: "pie",
      area: "area",
      scatter: "scatter",
      doughnut: "doughnut",
    };

    const chartType = chartTypeMap[chartKind] || "bar";

    // Enhanced chart colors - use a professional palette
    const chartColors = [
      colors.primaryColor.replace("#", ""),
      colors.accentColor.replace("#", ""),
      "#8B5CF6", // Purple
      "#F59E0B", // Amber
      "#10B981", // Emerald
      "#EF4444", // Red
    ];

    slide.addChart(chartType, chartDataFormatted, {
      x: 0.9,
      y: startY,
      w: chartWidth,
      h: chartHeight,
      showTitle: !!dataViz.title,
      title: dataViz.title || "",
      titleFontSize: 16,
      titleColor: colors.textColor.replace("#", ""),
      titleFontFace: colors.fontFace,
      showLegend: dataViz.series.length > 1,
      legendPos: "r", // Right position for legend
      legendFontSize: 11,
      legendColor: colors.subtitleColor?.replace("#", "") || colors.textColor.replace("#", ""),
      showValue: chartKind !== "line", // Show values except for line charts
      dataLabelFontSize: 10,
      dataLabelColor: colors.textColor.replace("#", ""),
      catAxisLabelColor: colors.subtitleColor?.replace("#", "") || colors.textColor.replace("#", ""),
      catAxisLabelFontSize: 11,
      valAxisLabelColor: colors.subtitleColor?.replace("#", "") || colors.textColor.replace("#", ""),
      valAxisLabelFontSize: 11,
      chartColors: chartColors,
      border: { pt: 1, color: colors.palette?.neutral?.[5]?.replace("#", "") || "E2E8F0" },
      plotArea: {
        fill: { color: "FFFFFF", transparency: 0 },
      },
    });
  } catch (error) {
    console.error("Error adding data visualization:", error);
  }
}

/**
 * Build multiple slides (for future use)
 */
export async function buildHybridSlides(pptx: PptxGenJS, specs: SlideSpecV1[]): Promise<void> {
  for (const spec of specs) {
    await buildHybridSlide(pptx, spec);
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/iconLibrary.ts
=================================================================================
/**
 * Professional Icon Library for PowerPoint Slides
 * Provides simple geometric icons that work well in presentations
 * Icons are drawn using basic shapes for maximum compatibility
 */

import PptxGenJS from "pptxgenjs";

export type IconType = 
  | "checkmark" | "cross" | "arrow-right" | "arrow-left" | "arrow-up" | "arrow-down"
  | "star" | "heart" | "lightbulb" | "target" | "chart" | "settings"
  | "user" | "users" | "lock" | "unlock" | "download" | "upload"
  | "search" | "bell" | "mail" | "phone" | "calendar" | "clock"
  | "folder" | "file" | "trash" | "edit" | "copy" | "share"
  | "play" | "pause" | "stop" | "volume" | "wifi" | "battery";

/**
 * Add a professional icon to the slide
 */
export function addIcon(
  slide: any,
  x: number,
  y: number,
  size: number,
  iconType: IconType,
  color: string = "#0F172A",
  strokeWidth: number = 2
): void {
  const iconDrawers: Record<IconType, (slide: any, x: number, y: number, size: number, color: string, strokeWidth: number) => void> = {
    checkmark: drawCheckmark,
    cross: drawCross,
    "arrow-right": drawArrowRight,
    "arrow-left": drawArrowLeft,
    "arrow-up": drawArrowUp,
    "arrow-down": drawArrowDown,
    star: drawStar,
    heart: drawHeart,
    lightbulb: drawLightbulb,
    target: drawTarget,
    chart: drawChart,
    settings: drawSettings,
    user: drawUser,
    users: drawUsers,
    lock: drawLock,
    unlock: drawUnlock,
    download: drawDownload,
    upload: drawUpload,
    search: drawSearch,
    bell: drawBell,
    mail: drawMail,
    phone: drawPhone,
    calendar: drawCalendar,
    clock: drawClock,
    folder: drawFolder,
    file: drawFile,
    trash: drawTrash,
    edit: drawEdit,
    copy: drawCopy,
    share: drawShare,
    play: drawPlay,
    pause: drawPause,
    stop: drawStop,
    volume: drawVolume,
    wifi: drawWifi,
    battery: drawBattery
  };

  const drawer = iconDrawers[iconType];
  if (drawer) {
    drawer(slide, x, y, size, color, strokeWidth);
  }
}

// Icon drawing functions
function drawCheckmark(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("line", {
    x: x + size * 0.2,
    y: y + size * 0.5,
    w: size * 0.3,
    h: size * 0.3,
    line: { color, width: 2 }
  });
  slide.addShape("line", {
    x: x + size * 0.5,
    y: y + size * 0.2,
    w: size * 0.3,
    h: size * 0.6,
    line: { color, width: 2 }
  });
}

function drawCross(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("line", {
    x: x + size * 0.2,
    y: y + size * 0.2,
    w: size * 0.6,
    h: size * 0.6,
    line: { color, width: 2 }
  });
  slide.addShape("line", {
    x: x + size * 0.8,
    y: y + size * 0.2,
    w: -size * 0.6,
    h: size * 0.6,
    line: { color, width: 2 }
  });
}

function drawArrowRight(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("rightArrow", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawArrowLeft(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("leftArrow", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawArrowUp(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("upArrow", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawArrowDown(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("downArrow", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawStar(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("star5", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawHeart(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("heart", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawLightbulb(slide: any, x: number, y: number, size: number, color: string): void {
  // Bulb circle
  slide.addShape("ellipse", {
    x: x + size * 0.2,
    y: y + size * 0.1,
    w: size * 0.6,
    h: size * 0.5,
    fill: { color },
    line: { type: "none" }
  });
  // Base
  slide.addShape("rect", {
    x: x + size * 0.35,
    y: y + size * 0.6,
    w: size * 0.3,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
}

function drawTarget(slide: any, x: number, y: number, size: number, color: string): void {
  // Outer circle
  slide.addShape("ellipse", {
    x,
    y,
    w: size,
    h: size,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Middle circle
  slide.addShape("ellipse", {
    x: x + size * 0.25,
    y: y + size * 0.25,
    w: size * 0.5,
    h: size * 0.5,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Center dot
  slide.addShape("ellipse", {
    x: x + size * 0.4,
    y: y + size * 0.4,
    w: size * 0.2,
    h: size * 0.2,
    fill: { color },
    line: { type: "none" }
  });
}

function drawChart(slide: any, x: number, y: number, size: number, color: string): void {
  // Bar 1
  slide.addShape("rect", {
    x,
    y: y + size * 0.5,
    w: size * 0.2,
    h: size * 0.5,
    fill: { color },
    line: { type: "none" }
  });
  // Bar 2
  slide.addShape("rect", {
    x: x + size * 0.4,
    y: y + size * 0.3,
    w: size * 0.2,
    h: size * 0.7,
    fill: { color },
    line: { type: "none" }
  });
  // Bar 3
  slide.addShape("rect", {
    x: x + size * 0.8,
    y: y + size * 0.1,
    w: size * 0.2,
    h: size * 0.9,
    fill: { color },
    line: { type: "none" }
  });
}

function drawSettings(slide: any, x: number, y: number, size: number, color: string): void {
  // Center circle
  slide.addShape("ellipse", {
    x: x + size * 0.35,
    y: y + size * 0.35,
    w: size * 0.3,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
  // Gear teeth (simplified with rectangles)
  slide.addShape("rect", {
    x: x + size * 0.45,
    y: y,
    w: size * 0.1,
    h: size * 0.2,
    fill: { color },
    line: { type: "none" }
  });
}

function drawUser(slide: any, x: number, y: number, size: number, color: string): void {
  // Head
  slide.addShape("ellipse", {
    x: x + size * 0.25,
    y: y + size * 0.1,
    w: size * 0.5,
    h: size * 0.4,
    fill: { color },
    line: { type: "none" }
  });
  // Body
  slide.addShape("rect", {
    x: x + size * 0.15,
    y: y + size * 0.5,
    w: size * 0.7,
    h: size * 0.5,
    fill: { color },
    line: { type: "none" }
  });
}

function drawUsers(slide: any, x: number, y: number, size: number, color: string): void {
  // User 1
  drawUser(slide, x, y + size * 0.1, size * 0.6, color);
  // User 2
  drawUser(slide, x + size * 0.4, y + size * 0.2, size * 0.6, color);
}

function drawLock(slide: any, x: number, y: number, size: number, color: string): void {
  // Shackle
  slide.addShape("arc", {
    x: x + size * 0.2,
    y: y + size * 0.1,
    w: size * 0.6,
    h: size * 0.4,
    line: { color, width: 2 },
    fill: { type: "none" }
  });
  // Body
  slide.addShape("rect", {
    x: x + size * 0.15,
    y: y + size * 0.4,
    w: size * 0.7,
    h: size * 0.5,
    fill: { color },
    line: { type: "none" }
  });
}

function drawUnlock(slide: any, x: number, y: number, size: number, color: string): void {
  // Open shackle
  slide.addShape("line", {
    x: x + size * 0.2,
    y: y + size * 0.5,
    w: 0,
    h: -size * 0.3,
    line: { color, width: 2 }
  });
  // Body
  slide.addShape("rect", {
    x: x + size * 0.15,
    y: y + size * 0.4,
    w: size * 0.7,
    h: size * 0.5,
    fill: { color },
    line: { type: "none" }
  });
}

function drawDownload(slide: any, x: number, y: number, size: number, color: string): void {
  // Arrow down
  slide.addShape("downArrow", {
    x: x + size * 0.2,
    y: y + size * 0.1,
    w: size * 0.6,
    h: size * 0.4,
    fill: { color },
    line: { type: "none" }
  });
  // Line
  slide.addShape("rect", {
    x: x + size * 0.1,
    y: y + size * 0.65,
    w: size * 0.8,
    h: size * 0.05,
    fill: { color },
    line: { type: "none" }
  });
}

function drawUpload(slide: any, x: number, y: number, size: number, color: string): void {
  // Arrow up
  slide.addShape("upArrow", {
    x: x + size * 0.2,
    y: y + size * 0.4,
    w: size * 0.6,
    h: size * 0.4,
    fill: { color },
    line: { type: "none" }
  });
  // Line
  slide.addShape("rect", {
    x: x + size * 0.1,
    y: y + size * 0.1,
    w: size * 0.8,
    h: size * 0.05,
    fill: { color },
    line: { type: "none" }
  });
}

function drawSearch(slide: any, x: number, y: number, size: number, color: string): void {
  // Circle
  slide.addShape("ellipse", {
    x: x + size * 0.1,
    y: y + size * 0.1,
    w: size * 0.5,
    h: size * 0.5,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Handle
  slide.addShape("line", {
    x: x + size * 0.6,
    y: y + size * 0.6,
    w: size * 0.3,
    h: size * 0.3,
    line: { color, width: 2 }
  });
}

function drawBell(slide: any, x: number, y: number, size: number, color: string): void {
  // Bell shape
  slide.addShape("ellipse", {
    x: x + size * 0.2,
    y: y + size * 0.1,
    w: size * 0.6,
    h: size * 0.6,
    fill: { color },
    line: { type: "none" }
  });
  // Clapper
  slide.addShape("ellipse", {
    x: x + size * 0.35,
    y: y + size * 0.65,
    w: size * 0.3,
    h: size * 0.25,
    fill: { color },
    line: { type: "none" }
  });
}

function drawMail(slide: any, x: number, y: number, size: number, color: string): void {
  // Envelope
  slide.addShape("rect", {
    x,
    y: y + size * 0.2,
    w: size,
    h: size * 0.6,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Flap
  slide.addShape("line", {
    x,
    y: y + size * 0.2,
    w: size * 0.5,
    h: size * 0.3,
    line: { color, width: 2 }
  });
}

function drawPhone(slide: any, x: number, y: number, size: number, color: string): void {
  // Phone body
  slide.addShape("roundRect", {
    x: x + size * 0.15,
    y,
    w: size * 0.7,
    h: size,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Screen
  slide.addShape("rect", {
    x: x + size * 0.2,
    y: y + size * 0.1,
    w: size * 0.6,
    h: size * 0.7,
    fill: { color, transparency: 80 },
    line: { type: "none" }
  });
}

function drawCalendar(slide: any, x: number, y: number, size: number, color: string): void {
  // Calendar body
  slide.addShape("rect", {
    x,
    y: y + size * 0.15,
    w: size,
    h: size * 0.85,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Header
  slide.addShape("rect", {
    x,
    y: y + size * 0.15,
    w: size,
    h: size * 0.2,
    fill: { color },
    line: { type: "none" }
  });
}

function drawClock(slide: any, x: number, y: number, size: number, color: string): void {
  // Circle
  slide.addShape("ellipse", {
    x,
    y,
    w: size,
    h: size,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Hour hand
  slide.addShape("line", {
    x: x + size * 0.5,
    y: y + size * 0.5,
    w: 0,
    h: -size * 0.2,
    line: { color, width: 2 }
  });
  // Minute hand
  slide.addShape("line", {
    x: x + size * 0.5,
    y: y + size * 0.5,
    w: size * 0.2,
    h: 0,
    line: { color, width: 2 }
  });
}

function drawFolder(slide: any, x: number, y: number, size: number, color: string): void {
  // Folder tab
  slide.addShape("rect", {
    x,
    y,
    w: size * 0.4,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
  // Folder body
  slide.addShape("rect", {
    x,
    y: y + size * 0.25,
    w: size,
    h: size * 0.75,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
}

function drawFile(slide: any, x: number, y: number, size: number, color: string): void {
  // Document
  slide.addShape("rect", {
    x: x + size * 0.15,
    y,
    w: size * 0.7,
    h: size,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Lines
  for (let i = 0; i < 3; i++) {
    slide.addShape("line", {
      x: x + size * 0.25,
      y: y + size * (0.3 + i * 0.2),
      w: size * 0.5,
      h: 0,
      line: { color, width: 1 }
    });
  }
}

function drawTrash(slide: any, x: number, y: number, size: number, color: string): void {
  // Handle
  slide.addShape("rect", {
    x: x + size * 0.35,
    y,
    w: size * 0.3,
    h: size * 0.15,
    fill: { color },
    line: { type: "none" }
  });
  // Can
  slide.addShape("rect", {
    x: x + size * 0.1,
    y: y + size * 0.15,
    w: size * 0.8,
    h: size * 0.85,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
}

function drawEdit(slide: any, x: number, y: number, size: number, color: string): void {
  // Pencil
  slide.addShape("line", {
    x: x + size * 0.1,
    y: y + size * 0.9,
    w: size * 0.8,
    h: -size * 0.8,
    line: { color, width: 2 }
  });
  // Eraser
  slide.addShape("rect", {
    x: x + size * 0.8,
    y: y + size * 0.1,
    w: size * 0.2,
    h: size * 0.2,
    fill: { color },
    line: { type: "none" }
  });
}

function drawCopy(slide: any, x: number, y: number, size: number, color: string): void {
  // First rectangle
  slide.addShape("rect", {
    x,
    y,
    w: size * 0.7,
    h: size * 0.7,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Second rectangle (offset)
  slide.addShape("rect", {
    x: x + size * 0.3,
    y: y + size * 0.3,
    w: size * 0.7,
    h: size * 0.7,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
}

function drawShare(slide: any, x: number, y: number, size: number, color: string): void {
  // Nodes
  slide.addShape("ellipse", {
    x: x + size * 0.35,
    y,
    w: size * 0.3,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
  slide.addShape("ellipse", {
    x,
    y: y + size * 0.6,
    w: size * 0.3,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
  slide.addShape("ellipse", {
    x: x + size * 0.7,
    y: y + size * 0.6,
    w: size * 0.3,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
}

function drawPlay(slide: any, x: number, y: number, size: number, color: string): void {
  // Triangle
  slide.addShape("triangle", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawPause(slide: any, x: number, y: number, size: number, color: string): void {
  // Bar 1
  slide.addShape("rect", {
    x: x + size * 0.2,
    y,
    w: size * 0.15,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
  // Bar 2
  slide.addShape("rect", {
    x: x + size * 0.65,
    y,
    w: size * 0.15,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawStop(slide: any, x: number, y: number, size: number, color: string): void {
  // Square
  slide.addShape("rect", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawVolume(slide: any, x: number, y: number, size: number, color: string): void {
  // Speaker
  slide.addShape("triangle", {
    x: x + size * 0.1,
    y: y + size * 0.2,
    w: size * 0.3,
    h: size * 0.6,
    fill: { color },
    line: { type: "none" }
  });
  // Wave
  slide.addShape("arc", {
    x: x + size * 0.4,
    y: y + size * 0.1,
    w: size * 0.5,
    h: size * 0.8,
    line: { color, width: 2 },
    fill: { type: "none" }
  });
}

function drawWifi(slide: any, x: number, y: number, size: number, color: string): void {
  // Dot
  slide.addShape("ellipse", {
    x: x + size * 0.4,
    y: y + size * 0.8,
    w: size * 0.2,
    h: size * 0.2,
    fill: { color },
    line: { type: "none" }
  });
  // Arcs
  for (let i = 1; i <= 2; i++) {
    slide.addShape("arc", {
      x: x + size * (0.5 - i * 0.15),
      y: y + size * (0.8 - i * 0.15),
      w: size * (0.3 + i * 0.3),
      h: size * (0.3 + i * 0.3),
      line: { color, width: 2 },
      fill: { type: "none" }
    });
  }
}

function drawBattery(slide: any, x: number, y: number, size: number, color: string): void {
  // Battery body
  slide.addShape("rect", {
    x,
    y: y + size * 0.2,
    w: size * 0.8,
    h: size * 0.6,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Terminal
  slide.addShape("rect", {
    x: x + size * 0.8,
    y: y + size * 0.35,
    w: size * 0.2,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
  // Charge level
  slide.addShape("rect", {
    x: x + size * 0.05,
    y: y + size * 0.3,
    w: size * 0.6,
    h: size * 0.4,
    fill: { color },
    line: { type: "none" }
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/index.ts
=================================================================================
/**
 * PPTX Builder Module
 * Exports all PPTX building utilities
 */

export * from "./designTokenMapper";
export * from "./patterns";
export * from "./slideBuilder";
export * from "./chartBuilder";
export * from "./premiumComponents";
export * from "./shapeHelpers";
export * from "./advancedShapes";
export * from "./enhancedDataViz";
export * from "./iconLibrary";
export * from "./enhancedAnimations";
export * from "./whitespaceManager";
export * from "./professionalTemplates";
export * from "./designAccents";

// Re-export commonly used functions
export {
  buildProfessionalSlide,
  buildProfessionalSlide as buildSlide
} from "./slideBuilder";

export {
  buildChart,
  buildBarChart,
  buildLineChart,
  buildPieChart,
  buildAreaChart,
  validateChartConfig,
  getRecommendedChartType
} from "./chartBuilder";

export {
  getRegionsForPattern,
  validatePatternRegions,
  calculateWhitespacePercentage
} from "./patterns";

export {
  addConnectorArrow,
  addCalloutBox,
  addProcessFlow,
  addMetricCard,
} from "./shapeHelpers";

export {
  mapColorPalette,
  mapTypography,
  mapShadows,
  mapSpacing,
  mapRadii,
  getCompleteTokenMap,
  validateDesignTokens
} from "./designTokenMapper";

// Advanced shapes
export {
  addDirectionalArrow,
  addCurvedConnector,
  addProgressBar,
  addStepIndicator,
  addComparisonBox,
  addHighlightBadge,
  addEmphasisBackground,
  addVerticalDivider,
  addHorizontalDivider
} from "./advancedShapes";

// Enhanced data visualization
export {
  addChartHeader,
  addChartAnnotations,
  addCustomLegend,
  addMetricHighlight,
  addTrendIndicator,
  addComparisonBar
} from "./enhancedDataViz";

// Icon library
export {
  addIcon,
  type IconType
} from "./iconLibrary";

// Enhanced animations
export {
  createAnimation,
  getRecommendedAnimation,
  getAnimationDuration,
  createStaggerConfig,
  getEasingCurve,
  calculateSequenceTiming,
  getAnimationPreset,
  validateAnimationConfig,
  getAnimationMetadata,
  type AnimationType,
  type AnimationConfig,
  type StaggerConfig
} from "./enhancedAnimations";

// Whitespace management
export {
  getSpacing,
  createUniformPadding,
  createUniformMargin,
  createCustomPadding,
  createCustomMargin,
  calculateContentWidth,
  calculateContentHeight,
  getRecommendedLineHeight,
  getRecommendedParagraphSpacing,
  calculateVerticalRhythm,
  getBreathingRoomPercentage,
  validateBreathingRoom,
  getContentMargin,
  getContainerPadding,
  calculateGridGap,
  calculateColumnWidth,
  getRecommendedSectionSpacing,
  getOptimalSlideMargins,
  getTextBoxPadding,
  getListItemSpacing,
  getElementSpacing,
  validateLayoutSpacing,
  SPACING_SCALE,
  type SpacingConfig,
  type PaddingConfig,
  type MarginConfig
} from "./whitespaceManager";

// Professional templates
export {
  getAllTemplates,
  getTemplate,
  getTemplatesByUseCase,
  getTemplateLayout,
  getRecommendedTemplate,
  validateTemplate,
  createCustomTemplate,
  getTemplateStats,
  TITLE_SLIDE_TEMPLATE,
  CONTENT_SLIDE_TEMPLATE,
  TWO_COLUMN_TEMPLATE,
  THREE_COLUMN_TEMPLATE,
  DATA_VIZ_TEMPLATE,
  IMAGE_FOCUS_TEMPLATE,
  TIMELINE_TEMPLATE,
  CENTERED_FOCUS_TEMPLATE,
  SIDEBAR_TEMPLATE,
  STACKED_TEMPLATE,
  MINIMAL_TEMPLATE,
  FULL_BLEED_TEMPLATE,
  type TemplateConfig,
  type TemplateLayout
} from "./professionalTemplates";



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/layoutBuilder.ts
=================================================================================
/**
 * Layout-Based PPTX Builder
 * Uses the spec's layout grid system to properly position and size content
 * Prevents overlapping text and ensures professional formatting
 */

import PptxGenJS from "pptxgenjs";
import type { SlideSpecV1 } from "../types/SlideSpecV1";
import { logger } from "firebase-functions/v2";

const SLIDE_WIDTH = 10; // inches
const SLIDE_HEIGHT = 7.5; // inches

/**
 * Convert pixels to inches
 */
function pxToIn(px: number): number {
  return (px * 0.75) / 72;
}

/**
 * Build slide using layout grid system
 */
export async function buildLayoutSlide(
  pptx: PptxGenJS,
  spec: SlideSpecV1
): Promise<void> {
  const slide = pptx.addSlide();

  try {
    logger.info("🎨 Layout builder starting", {
      hasTitle: !!spec.content.title,
      hasSubtitle: !!spec.content.subtitle,
      anchorsCount: spec.layout.anchors.length,
    });

    // Apply background
    applyBackground(slide, spec);

    // Calculate grid dimensions
    const { rows, cols, gutter, margin } = spec.layout.grid;
    const marginTop = pxToIn(margin.t);
    const marginRight = pxToIn(margin.r);
    const marginBottom = pxToIn(margin.b);
    const marginLeft = pxToIn(margin.l);
    const gutterIn = pxToIn(gutter);

    const gridWidth = SLIDE_WIDTH - marginLeft - marginRight;
    const gridHeight = SLIDE_HEIGHT - marginTop - marginBottom;
    const cellWidth = (gridWidth - (cols - 1) * gutterIn) / cols;
    const cellHeight = (gridHeight - (rows - 1) * gutterIn) / rows;

    // Create region map
    const regions: Record<string, any> = {};
    spec.layout.regions.forEach((region) => {
      const x = marginLeft + (region.colStart - 1) * (cellWidth + gutterIn);
      const y = marginTop + (region.rowStart - 1) * (cellHeight + gutterIn);
      const w = region.colSpan * cellWidth + (region.colSpan - 1) * gutterIn;
      const h = region.rowSpan * cellHeight + (region.rowSpan - 1) * gutterIn;

      regions[region.name] = { x, y, w, h };
    });

    // Get style tokens
    const palette = spec.styleTokens.palette;
    const typography = spec.styleTokens.typography;
    const textColor = palette.neutral[0] || "#0F172A";
    const subtitleColor = palette.neutral[2] || "#334155";
    const primaryColor = palette.primary || "#6366F1";

    const titleSize = typography?.sizes?.step_3 || 44;
    const subtitleSize = typography?.sizes?.step_1 || 22;
    const bodySize = typography?.sizes?.step_0 || 18;

    // Group anchors by region to handle stacking
    const anchorsByRegion: Record<string, any[]> = {};
    spec.layout.anchors.forEach((anchor) => {
      if (!anchorsByRegion[anchor.region]) {
        anchorsByRegion[anchor.region] = [];
      }
      anchorsByRegion[anchor.region].push(anchor);
    });

    // Render content by region, stacking multiple anchors vertically
    Object.entries(anchorsByRegion).forEach(([regionName, anchors]) => {
      const region = regions[regionName];
      if (!region) return;

      let currentY = region.y;
      const regionHeight = region.h;
      let usedHeight = 0;

      // Sort anchors by order
      anchors.sort((a, b) => a.order - b.order);

      anchors.forEach((anchor) => {
        // Title
        if (anchor.refId === spec.content.title?.id) {
          // Calculate title height based on text length and width
          const titleText = spec.content.title.text;
          const estimatedLines = Math.ceil(titleText.length / 40); // Rough estimate
          const titleHeight = Math.max(0.6, estimatedLines * (titleSize / 72) * 1.5); // Convert to inches

          logger.info("📝 Rendering title", {
            text: titleText.substring(0, 50),
            y: currentY,
            height: titleHeight,
            fontSize: titleSize,
            estimatedLines,
          });
          slide.addText(spec.content.title.text, {
            x: region.x,
            y: currentY,
            w: region.w,
            h: titleHeight,
            fontSize: titleSize,
            bold: true,
            color: primaryColor.replace("#", ""),
            fontFace: "Aptos",
            align: "left",
            valign: "top",
            wrap: true,
          });
          currentY += titleHeight + 0.15; // Add gap between title and subtitle
          usedHeight += titleHeight + 0.15;
          return;
        }

        // Subtitle
        if (anchor.refId === spec.content.subtitle?.id && spec.content.subtitle) {
          // Calculate subtitle height based on text length and width
          const subtitleText = spec.content.subtitle.text;
          const estimatedLines = Math.ceil(subtitleText.length / 50); // Rough estimate
          const subtitleHeight = Math.max(0.4, estimatedLines * (subtitleSize / 72) * 1.5); // Convert to inches

          logger.info("📝 Rendering subtitle", {
            text: subtitleText.substring(0, 50),
            y: currentY,
            height: subtitleHeight,
            fontSize: subtitleSize,
            estimatedLines,
          });
          slide.addText(spec.content.subtitle.text, {
            x: region.x,
            y: currentY,
            w: region.w,
            h: subtitleHeight,
            fontSize: subtitleSize,
            color: subtitleColor.replace("#", ""),
            fontFace: "Aptos",
            align: "left",
            valign: "top",
            wrap: true,
          });
          currentY += subtitleHeight + 0.15; // Add gap
          usedHeight += subtitleHeight + 0.15;
          return;
        }

        // Bullets
        const bulletList = spec.content.bullets?.find((b) => b.id === anchor.refId);
        if (bulletList) {
          const bulletTexts = bulletList.items.map((item) => ({
            text: item.text,
            options: {
              bullet: true,
              indentLevel: Math.max(0, item.level - 1),
            },
          }));

          const bulletHeight = Math.min(regionHeight - usedHeight, bulletList.items.length * bodySize * 1.5);
          slide.addText(bulletTexts, {
            x: region.x,
            y: currentY,
            w: region.w,
            h: bulletHeight,
            fontSize: bodySize,
            color: textColor.replace("#", ""),
            fontFace: "Aptos",
            align: "left",
            valign: "top",
            wrap: true,
          });
          return;
        }

        // Callouts
        const callout = spec.content.callouts?.find((c) => c.id === anchor.refId);
        if (callout) {
          const bgColor =
            callout.variant === "warning"
              ? "FEF3C7"
              : callout.variant === "danger"
                ? "FEE2E2"
                : callout.variant === "success"
                  ? "D1FAE5"
                  : "F3F4F6";

          const calloutHeight = Math.min(regionHeight - usedHeight, 1.0);
          slide.addShape("rect", {
            x: region.x,
            y: currentY,
            w: region.w,
            h: calloutHeight,
            fill: { color: bgColor },
            line: { color: primaryColor.replace("#", ""), width: 2 },
          });

          const calloutText = callout.title
            ? `${callout.title} — ${callout.text}`
            : callout.text;

          slide.addText(calloutText, {
            x: region.x + 0.2,
            y: currentY + 0.1,
            w: region.w - 0.4,
            h: calloutHeight - 0.2,
            fontSize: bodySize - 2,
            color: textColor.replace("#", ""),
            fontFace: "Aptos",
            align: "left",
            valign: "top",
            wrap: true,
          });
          return;
        }
      });
    });
  } catch (error) {
    logger.error("❌ Error building layout slide:", {
      error: String(error),
      message: error instanceof Error ? error.message : "Unknown error",
      stack: error instanceof Error ? error.stack : undefined,
    });
    throw error;
  }
}

/**
 * Apply background with subtle gradient
 */
function applyBackground(slide: any, spec: SlideSpecV1): void {
  const palette = spec.styleTokens.palette;
  const neutralLight = palette.neutral[8] || "#F8FAFC";

  slide.background = { fill: neutralLight.replace("#", "") };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/minimalBuilder.ts
=================================================================================
/**
 * Professional PPTX Builder
 * Creates beautiful, professional PowerPoint slides with subtle accents, shapes, and modern design
 */

import PptxGenJS from "pptxgenjs";
import type { SlideSpecV1 } from "../types/SlideSpecV1";
import { processImageSource, getOptimalImageDimensions } from "../imageHelpers";
import { logger } from "firebase-functions/v2";
import {
  addAccentBar,
  addDecorativeCircle,
  addPremiumDivider,
  addCornerAccent
} from "./premiumComponents";

/**
 * Build a professional slide with beautiful design elements
 */
export async function buildMinimalSlide(
  pptx: PptxGenJS,
  spec: SlideSpecV1
): Promise<void> {
  const slide = pptx.addSlide();

  // Apply subtle gradient background for modern, professional look
  applyGradientBackground(slide, spec);

  // Add professional design accents
  addProfessionalAccents(slide, spec);

  // Add title with enhanced styling
  const title = spec.content.title;
  if (title && title.text) {
    slide.addText(title.text, {
      x: 0.5,
      y: 0.5,
      w: 9,
      h: 0.6,
      fontFace: "Aptos",
      fontSize: 32,
      bold: true,
      color: "0F172A",
      align: "left",
      valign: "top"
    });

    // Add subtle accent line under title
    const primaryColor = spec.styleTokens.palette.primary.replace("#", "");
    addPremiumDivider(slide, 0.5, 1.15, 2.5, primaryColor, 0.04);
  }

  // Add subtitle with refined styling
  const subtitle = spec.content.subtitle;
  if (subtitle && subtitle.text) {
    slide.addText(subtitle.text, {
      x: 0.5,
      y: 1.3,
      w: 9,
      h: 0.4,
      fontFace: "Aptos",
      fontSize: 18,
      color: "64748B",
      align: "left",
      valign: "top"
    });
  }

  // Add bullets with enhanced styling and subtle accents
  const bullets = spec.content.bullets?.[0];
  if (bullets && bullets.items && bullets.items.length > 0) {
    const primaryColor = spec.styleTokens.palette.primary.replace("#", "");
    let currentY = subtitle ? 2.0 : 1.8;
    const lineHeight = 0.4;

    for (let i = 0; i < bullets.items.length; i++) {
      const item = bullets.items[i];

      // Add subtle accent circle for each bullet
      addDecorativeCircle(slide, 0.55, currentY + 0.05, 0.12, primaryColor, 0.2);

      // Add bullet text with professional styling
      slide.addText(item.text, {
        x: 0.85,
        y: currentY,
        w: 8.65,
        h: lineHeight,
        fontFace: "Aptos",
        fontSize: 18,
        color: "1E293B",
        align: "left",
        valign: "top",
        wrap: true
      });

      currentY += lineHeight + 0.1;
    }
  }

  // Add images if present
  const images = spec.content.images;
  if (images && images.length > 0) {
    for (const image of images) {
      try {
        const imageData = await processImageSource(image.source);
        if (imageData) {
          const dimensions = getOptimalImageDimensions(image.role);

          // If imageData is a string (data URL), use it directly
          if (typeof imageData === "string") {
            const fitType = (image.fit === "fill" ? "cover" : image.fit) || "cover";
            slide.addImage({
              data: imageData,
              x: dimensions.x,
              y: dimensions.y,
              w: dimensions.w,
              h: dimensions.h,
              sizing: { type: fitType as "cover" | "contain" | "crop", w: dimensions.w, h: dimensions.h }
            });
          } else {
            // If imageData is ProcessedImage, convert buffer to base64
            const base64 = imageData.data.toString("base64");
            const dataUrl = `data:${imageData.mimeType};base64,${base64}`;
            const fitType = (image.fit === "fill" ? "cover" : image.fit) || "cover";

            slide.addImage({
              data: dataUrl,
              x: dimensions.x,
              y: dimensions.y,
              w: dimensions.w,
              h: dimensions.h,
              sizing: { type: fitType as "cover" | "contain" | "crop", w: dimensions.w, h: dimensions.h }
            });
          }
        }
      } catch (error) {
        logger.warn(`Failed to add image ${image.id}:`, error);
        // Continue with other images
      }
    }
  }
}

/**
 * Add professional design accents to the slide
 * Includes subtle shapes, lines, and decorative elements
 */
function addProfessionalAccents(slide: any, spec: SlideSpecV1): void {
  const primaryColor = spec.styleTokens.palette.primary.replace("#", "");
  const accentColor = spec.styleTokens.palette.accent.replace("#", "");

  // Add subtle left accent bar for visual interest
  addAccentBar(slide, {
    position: "left",
    color: primaryColor,
    thickness: 0.08
  });

  // Add decorative corner accent (top-right)
  addCornerAccent(slide, "top-right", accentColor, 0.15);

  // Add subtle decorative circles in bottom-right for depth
  addDecorativeCircle(slide, 8.8, 6.5, 0.6, primaryColor, 0.05);
  addDecorativeCircle(slide, 9.1, 6.8, 0.4, accentColor, 0.08);
}

/**
 * Apply subtle gradient background to slide
 * Creates a modern, professional look with minimal visual noise
 */
function applyGradientBackground(slide: any, spec: SlideSpecV1): void {
  // Get theme-based colors from spec
  const primaryColor = spec.styleTokens.palette.primary || "#6366F1";
  const neutralLight = spec.styleTokens.palette.neutral[6] || "#F8FAFC";
  const neutralLighter = spec.styleTokens.palette.neutral[5] || "#F1F5F9";

  // Create subtle gradient using overlapping rectangles with transparency
  // This simulates a gradient effect in PowerPoint

  // Base layer - lightest color
  slide.background = { fill: neutralLight.replace("#", "") };

  // Add subtle gradient overlay using semi-transparent shapes
  // Top-left to bottom-right gradient effect
  const gradientSteps = 5;
  const slideWidth = 10;
  const slideHeight = 7.5;

  for (let i = 0; i < gradientSteps; i++) {
    const transparency = 95 - (i * 2); // 95%, 93%, 91%, 89%, 87%
    const yPos = (slideHeight / gradientSteps) * i;
    const height = slideHeight / gradientSteps + 0.1; // Slight overlap

    slide.addShape("rect", {
      x: 0,
      y: yPos,
      w: slideWidth,
      h: height,
      fill: {
        color: neutralLighter.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }

  // Add very subtle accent gradient on the right edge for depth
  slide.addShape("rect", {
    x: slideWidth - 0.5,
    y: 0,
    w: 0.5,
    h: slideHeight,
    fill: {
      color: primaryColor.replace("#", ""),
      transparency: 97 // Very subtle
    },
    line: { type: "none" }
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/patterns.ts
=================================================================================
/**
 * Design Pattern Builders
 * Builds slide layouts based on design patterns
 */

import type { SlideSpecV2 } from "../types/SlideSpecV2";

export interface PatternRegions {
  header?: RegionRect;
  body?: RegionRect;
  footer?: RegionRect;
  aside?: RegionRect;
  left?: RegionRect;
  right?: RegionRect;
  primary?: RegionRect;
  secondary?: RegionRect;
  chart?: RegionRect;
  sidebar?: RegionRect;
  content?: RegionRect;
  item1?: RegionRect;
  item2?: RegionRect;
  item3?: RegionRect;
  item4?: RegionRect;
}

export interface RegionRect {
  x: number;
  y: number;
  w: number;
  h: number;
}

const SLIDE_WIDTH = 10;
const SLIDE_HEIGHT = 7.5;
const MARGIN = 0.5;

/**
 * Apply Hero Pattern
 * Large title/image focus with supporting content
 */
export function applyHeroPattern(spec: SlideSpecV2): PatternRegions {
  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: SLIDE_HEIGHT * 0.6 - MARGIN
    },
    body: {
      x: MARGIN,
      y: SLIDE_HEIGHT * 0.6 + MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: SLIDE_HEIGHT * 0.4 - 2 * MARGIN
    }
  };
}

/**
 * Apply Split Pattern
 * 50/50 left/right content division
 */
export function applySplitPattern(spec: SlideSpecV2): PatternRegions {
  const midpoint = SLIDE_WIDTH / 2;

  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1.5
    },
    left: {
      x: MARGIN,
      y: 2,
      w: midpoint - MARGIN - 0.25,
      h: SLIDE_HEIGHT - 2.5
    },
    right: {
      x: midpoint + 0.25,
      y: 2,
      w: midpoint - MARGIN - 0.25,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Asymmetric Pattern
 * Dynamic off-center layout with visual balance
 */
export function applyAsymmetricPattern(spec: SlideSpecV2): PatternRegions {
  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1.2
    },
    primary: {
      x: MARGIN,
      y: 1.8,
      w: SLIDE_WIDTH * 0.65 - MARGIN,
      h: SLIDE_HEIGHT - 2.3
    },
    secondary: {
      x: SLIDE_WIDTH * 0.65 + 0.25,
      y: 1.8,
      w: SLIDE_WIDTH * 0.35 - MARGIN - 0.25,
      h: SLIDE_HEIGHT - 2.3
    }
  };
}

/**
 * Apply Grid Pattern
 * Structured multi-element layout (2x2 grid)
 */
export function applyGridPattern(spec: SlideSpecV2): PatternRegions {
  const itemWidth = (SLIDE_WIDTH - 2 * MARGIN - 0.25) / 2;
  const itemHeight = (SLIDE_HEIGHT - 2.3) / 2;

  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1.2
    },
    item1: {
      x: MARGIN,
      y: 1.8,
      w: itemWidth,
      h: itemHeight
    },
    item2: {
      x: SLIDE_WIDTH / 2 + 0.25,
      y: 1.8,
      w: itemWidth,
      h: itemHeight
    },
    item3: {
      x: MARGIN,
      y: SLIDE_HEIGHT / 2 + 0.8,
      w: itemWidth,
      h: itemHeight
    },
    item4: {
      x: SLIDE_WIDTH / 2 + 0.25,
      y: SLIDE_HEIGHT / 2 + 0.8,
      w: itemWidth,
      h: itemHeight
    }
  };
}

/**
 * Apply Minimal Pattern
 * Single focal point with generous white space
 */
export function applyMinimalPattern(spec: SlideSpecV2): PatternRegions {
  return {
    content: {
      x: SLIDE_WIDTH * 0.2,
      y: SLIDE_HEIGHT * 0.25,
      w: SLIDE_WIDTH * 0.6,
      h: SLIDE_HEIGHT * 0.5
    }
  };
}

/**
 * Apply Data-Focused Pattern
 * Chart/data as primary focus with supporting text
 */
export function applyDataFocusedPattern(spec: SlideSpecV2): PatternRegions {
  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 0.8
    },
    chart: {
      x: MARGIN,
      y: 1.2,
      w: SLIDE_WIDTH * 0.65 - MARGIN,
      h: SLIDE_HEIGHT - 1.7
    },
    sidebar: {
      x: SLIDE_WIDTH * 0.65 + 0.25,
      y: 1.2,
      w: SLIDE_WIDTH * 0.35 - MARGIN - 0.25,
      h: SLIDE_HEIGHT - 1.7
    }
  };
}

/**
 * Get regions for pattern
 */
export function getRegionsForPattern(pattern: string, spec: SlideSpecV2): PatternRegions {
  switch (pattern) {
    case "hero":
      return applyHeroPattern(spec);
    case "split":
      return applySplitPattern(spec);
    case "asymmetric":
      return applyAsymmetricPattern(spec);
    case "grid":
      return applyGridPattern(spec);
    case "minimal":
      return applyMinimalPattern(spec);
    case "data-focused":
      return applyDataFocusedPattern(spec);
    case "sidebar":
      return applySidebarPattern(spec);
    case "three-column":
      return applyThreeColumnPattern(spec);
    case "two-column-accent":
      return applyTwoColumnAccentPattern(spec);
    case "timeline":
      return applyTimelinePattern(spec);
    case "centered":
      return applyCenteredPattern(spec);
    case "full-bleed":
      return applyFullBleedPattern(spec);
    case "comparison":
      return applyComparisonPattern(spec);
    case "stacked":
      return applyStackedPattern(spec);
    default:
      return applySplitPattern(spec);
  }
}

/**
 * Validate pattern regions
 */
export function validatePatternRegions(regions: PatternRegions): boolean {
  for (const region of Object.values(regions)) {
    if (!region) continue;

    if (
      region.x < 0 ||
      region.y < 0 ||
      region.w <= 0 ||
      region.h <= 0 ||
      region.x + region.w > SLIDE_WIDTH ||
      region.y + region.h > SLIDE_HEIGHT
    ) {
      return false;
    }
  }

  return true;
}

/**
 * Get region by name
 */
export function getRegion(regions: PatternRegions, name: string): RegionRect | undefined {
  return regions[name as keyof PatternRegions];
}

/**
 * Calculate total used area
 */
export function calculateUsedArea(regions: PatternRegions): number {
  let total = 0;

  for (const region of Object.values(regions)) {
    if (region) {
      total += region.w * region.h;
    }
  }

  return total;
}

/**
 * Calculate white space percentage
 */
export function calculateWhitespacePercentage(regions: PatternRegions): number {
  const totalArea = SLIDE_WIDTH * SLIDE_HEIGHT;
  const usedArea = calculateUsedArea(regions);
  const whiteSpace = totalArea - usedArea;

  return (whiteSpace / totalArea) * 100;
}

/**
 * Apply Sidebar Pattern
 * Content with prominent sidebar for navigation or key points
 */
export function applySidebarPattern(spec: SlideSpecV2): PatternRegions {
  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1
    },
    sidebar: {
      x: MARGIN,
      y: 1.5 + MARGIN,
      w: 2,
      h: SLIDE_HEIGHT - 2.5
    },
    content: {
      x: 2.5 + MARGIN,
      y: 1.5 + MARGIN,
      w: SLIDE_WIDTH - 3.5 - 2 * MARGIN,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Three Column Pattern
 * Equal three-column layout for comparison or features
 */
export function applyThreeColumnPattern(spec: SlideSpecV2): PatternRegions {
  const colWidth = (SLIDE_WIDTH - 2 * MARGIN - 0.4) / 3;

  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1
    },
    item1: {
      x: MARGIN,
      y: 1.5 + MARGIN,
      w: colWidth,
      h: SLIDE_HEIGHT - 2.5
    },
    item2: {
      x: MARGIN + colWidth + 0.2,
      y: 1.5 + MARGIN,
      w: colWidth,
      h: SLIDE_HEIGHT - 2.5
    },
    item3: {
      x: MARGIN + (colWidth + 0.2) * 2,
      y: 1.5 + MARGIN,
      w: colWidth,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Two Column Pattern with Accent
 * Two columns with accent bar on the side
 */
export function applyTwoColumnAccentPattern(spec: SlideSpecV2): PatternRegions {
  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1
    },
    left: {
      x: MARGIN,
      y: 1.5 + MARGIN,
      w: (SLIDE_WIDTH - 2 * MARGIN - 0.3) / 2,
      h: SLIDE_HEIGHT - 2.5
    },
    right: {
      x: MARGIN + (SLIDE_WIDTH - 2 * MARGIN - 0.3) / 2 + 0.3,
      y: 1.5 + MARGIN,
      w: (SLIDE_WIDTH - 2 * MARGIN - 0.3) / 2,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Timeline Pattern
 * Horizontal timeline layout for processes or history
 */
export function applyTimelinePattern(spec: SlideSpecV2): PatternRegions {
  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1
    },
    item1: {
      x: MARGIN,
      y: 2,
      w: (SLIDE_WIDTH - 2 * MARGIN) / 4,
      h: SLIDE_HEIGHT - 2.5
    },
    item2: {
      x: MARGIN + (SLIDE_WIDTH - 2 * MARGIN) / 4,
      y: 2,
      w: (SLIDE_WIDTH - 2 * MARGIN) / 4,
      h: SLIDE_HEIGHT - 2.5
    },
    item3: {
      x: MARGIN + (SLIDE_WIDTH - 2 * MARGIN) / 2,
      y: 2,
      w: (SLIDE_WIDTH - 2 * MARGIN) / 4,
      h: SLIDE_HEIGHT - 2.5
    },
    item4: {
      x: MARGIN + (SLIDE_WIDTH - 2 * MARGIN) * 0.75,
      y: 2,
      w: (SLIDE_WIDTH - 2 * MARGIN) / 4,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Centered Pattern
 * Centered content with maximum focus
 */
export function applyCenteredPattern(spec: SlideSpecV2): PatternRegions {
  const contentWidth = SLIDE_WIDTH * 0.6;
  const contentX = (SLIDE_WIDTH - contentWidth) / 2;

  return {
    header: {
      x: contentX,
      y: MARGIN,
      w: contentWidth,
      h: 1.5
    },
    content: {
      x: contentX,
      y: 2,
      w: contentWidth,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Full Bleed Pattern
 * Content extends to edges for maximum impact
 */
export function applyFullBleedPattern(spec: SlideSpecV2): PatternRegions {
  return {
    content: {
      x: 0,
      y: 0,
      w: SLIDE_WIDTH,
      h: SLIDE_HEIGHT
    }
  };
}

/**
 * Apply Comparison Pattern
 * Side-by-side comparison with divider
 */
export function applyComparisonPattern(spec: SlideSpecV2): PatternRegions {
  const midpoint = SLIDE_WIDTH / 2;

  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1
    },
    left: {
      x: MARGIN,
      y: 1.5 + MARGIN,
      w: midpoint - MARGIN - 0.15,
      h: SLIDE_HEIGHT - 2.5
    },
    right: {
      x: midpoint + 0.15,
      y: 1.5 + MARGIN,
      w: midpoint - MARGIN - 0.15,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Stacked Pattern
 * Vertical stacking of content sections
 */
export function applyStackedPattern(spec: SlideSpecV2): PatternRegions {
  const sectionHeight = (SLIDE_HEIGHT - 2 * MARGIN - 1) / 3;

  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1
    },
    item1: {
      x: MARGIN,
      y: 1 + MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: sectionHeight
    },
    item2: {
      x: MARGIN,
      y: 1 + MARGIN + sectionHeight,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: sectionHeight
    },
    item3: {
      x: MARGIN,
      y: 1 + MARGIN + sectionHeight * 2,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: sectionHeight
    }
  };
}

/**
 * Get all available patterns
 */
export function getAllPatterns(): string[] {
  return [
    "hero",
    "split",
    "asymmetric",
    "grid",
    "minimal",
    "data-focused",
    "sidebar",
    "three-column",
    "two-column-accent",
    "timeline",
    "centered",
    "full-bleed",
    "comparison",
    "stacked"
  ];
}

/**
 * Get pattern description
 */
export function getPatternDescription(pattern: string): string {
  const descriptions: Record<string, string> = {
    hero: "Large hero section with supporting content below",
    split: "50/50 left-right content division",
    asymmetric: "Dynamic off-center layout with visual balance",
    grid: "4-item grid layout for equal content",
    minimal: "Minimal layout with maximum whitespace",
    "data-focused": "Optimized for charts and data visualization",
    sidebar: "Content with prominent sidebar",
    "three-column": "Three equal columns for comparison",
    "two-column-accent": "Two columns with accent divider",
    timeline: "Horizontal timeline for processes",
    centered: "Centered content with maximum focus",
    "full-bleed": "Content extends to edges",
    comparison: "Side-by-side comparison layout",
    stacked: "Vertically stacked content sections"
  };

  return descriptions[pattern] || "Unknown pattern";
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/premiumBuilder.ts
=================================================================================
/**
 * Premium PPTX Builder
 * Creates world-class professional PowerPoint slides with sophisticated design
 * Combines best practices from Apple, Google, Tesla, and ChatGPT design systems
 */

import PptxGenJS from "pptxgenjs";
import type { SlideSpecV1 } from "../types/SlideSpecV1";
import { logger } from "firebase-functions/v2";
import {
  addAccentBar,
  addDecorativeCircle,
  addPremiumDivider,
  addCornerAccent,
  addMetricCard,
  addStatBlock,
  addFeatureHighlight,
  addGradientAccentBar,
  addProcessFlow,
  addArrow
} from "./premiumComponents";
import {
  addDirectionalArrow,
  addProgressBar,
  addStepIndicator,
  addHighlightBadge,
  addEmphasisBackground,
  addVerticalDivider,
  addHorizontalDivider
} from "./advancedShapes";
import {
  addChartHeader,
  addMetricHighlight,
  addTrendIndicator
} from "./enhancedDataViz";
import { applyDesignPattern, getRecommendedPattern } from "./advancedPatterns";
import {
  addGradientOverlay,
  addCornerFlourish,
  addLineAccent,
  addFrameAccent
} from "./designAccents";

const SLIDE_WIDTH = 10; // inches
const SLIDE_HEIGHT = 7.5; // inches (4:3 aspect ratio)

/**
 * Build a premium world-class slide
 */
export async function buildPremiumSlide(
  pptx: PptxGenJS,
  spec: SlideSpecV1
): Promise<void> {
  const slide = pptx.addSlide();

  try {
    // Apply sophisticated background
    applyPremiumBackground(slide, spec);

    // Determine and apply design pattern
    const pattern = getRecommendedPattern(spec);
    applyDesignPattern(slide, spec, pattern);

    // Add content with refined typography
    await addPremiumContent(slide, spec);
  } catch (error) {
    logger.error("Error building premium slide:", error);
    throw error;
  }
}

/**
 * Apply sophisticated gradient background with depth
 */
function applyPremiumBackground(slide: any, spec: SlideSpecV1): void {
  const palette = spec.styleTokens.palette;
  const primaryColor = palette.primary || "#6366F1";
  const accentColor = palette.accent || "#EC4899";
  const neutralLight = palette.neutral[6] || "#F8FAFC";

  // Base background - light neutral
  slide.background = { fill: neutralLight.replace("#", "") };

  // Add sophisticated gradient overlay
  addGradientOverlay(slide, primaryColor, accentColor, 0.03, "diagonal");

  // Add subtle corner flourishes for visual interest
  addCornerFlourish(slide, "top-right", accentColor, 0.35);
  addCornerFlourish(slide, "bottom-left", primaryColor, 0.3);

  // Add subtle line accents
  addLineAccent(slide, "top", accentColor, 0.06);
}



/**
 * Add premium content with refined typography
 */
async function addPremiumContent(slide: any, spec: SlideSpecV1): Promise<void> {
  const palette = spec.styleTokens.palette;
  const typography = spec.styleTokens.typography;

  const textColor = palette.neutral[0] || "#0F172A";
  const subtitleColor = palette.neutral[2] || "#64748B";
  const primaryColor = palette.primary || "#6366F1";

  const titleSize = typography?.sizes?.step_3 || 44;
  const subtitleSize = typography?.sizes?.step_1 || 22;
  const bodySize = typography?.sizes?.step_0 || 18;

  let currentY = 0.6;

  // Add title with premium styling
  if (spec.content.title) {
    slide.addText(spec.content.title.text, {
      x: 0.7,
      y: currentY,
      w: SLIDE_WIDTH - 1.4,
      h: 1.0,
      fontSize: titleSize,
      bold: true,
      color: textColor.replace("#", ""),
      fontFace: "Aptos",
      align: "left",
      valign: "top",
      lineSpacing: 110
    });

    // Premium divider under title
    addPremiumDivider(slide, 0.7, currentY + 0.95, 2.8, primaryColor.replace("#", ""), 0.05);
    currentY += 1.4;
  }

  // Add subtitle
  if (spec.content.subtitle) {
    slide.addText(spec.content.subtitle.text, {
      x: 0.7,
      y: currentY,
      w: SLIDE_WIDTH - 1.4,
      h: 0.6,
      fontSize: subtitleSize,
      color: subtitleColor.replace("#", ""),
      fontFace: "Aptos",
      align: "left",
      valign: "top",
      lineSpacing: 130
    });
    currentY += 0.9;
  }

  // Add bullets with premium styling
  if (spec.content.bullets && spec.content.bullets.length > 0) {
    const bullets = spec.content.bullets[0];
    const bulletColor = primaryColor.replace("#", "");

    bullets.items.forEach((item, index) => {
      // Add subtle background for emphasis
      if (index === 0) {
        addEmphasisBackground(slide, 0.6, currentY - 0.05, SLIDE_WIDTH - 1.2, 0.5, primaryColor, 0.04);
      }

      // Decorative bullet circle with step indicator for first few items
      if (index < 3) {
        addStepIndicator(slide, 0.65, currentY + 0.05, index + 1, bullets.items.length, bulletColor, 0.25);
      } else {
        addDecorativeCircle(slide, 0.65, currentY + 0.08, 0.14, bulletColor, 0.25);
      }

      // Bullet text
      slide.addText(item.text, {
        x: 0.95,
        y: currentY,
        w: SLIDE_WIDTH - 1.65,
        h: 0.4,
        fontSize: bodySize,
        color: textColor.replace("#", ""),
        fontFace: "Aptos",
        align: "left",
        valign: "top",
        wrap: true
      });

      currentY += 0.5;
    });
  }

  // Add callouts if present
  if (spec.content.callouts && spec.content.callouts.length > 0) {
    for (const callout of spec.content.callouts) {
      const bgColor = callout.variant === "warning" ? "FEF3C7" :
                      callout.variant === "danger" ? "FEE2E2" :
                      callout.variant === "success" ? "D1FAE5" : "F3F4F6";

      // Add subtle frame accent
      addFrameAccent(slide, 0.65, currentY - 0.05, SLIDE_WIDTH - 1.3, 0.7, primaryColor, 0.04);

      slide.addShape("roundRect", {
        x: 0.7,
        y: currentY,
        w: SLIDE_WIDTH - 1.4,
        h: 0.6,
        fill: { color: bgColor },
        line: { color: primaryColor.replace("#", ""), width: 2 }
      });

      const calloutText = callout.title ? `${callout.title} — ${callout.text}` : callout.text;
      slide.addText(calloutText, {
        x: 0.9,
        y: currentY + 0.1,
        w: SLIDE_WIDTH - 1.8,
        h: 0.4,
        fontSize: bodySize - 2,
        color: textColor.replace("#", ""),
        fontFace: "Aptos",
        align: "left",
        valign: "middle",
        wrap: true
      });

      currentY += 0.8;
    }
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/premiumComponents.ts
=================================================================================
/**
 * Premium UI Components for Professional PowerPoint Slides
 * Provides sophisticated, production-ready components
 */

import PptxGenJS from "pptxgenjs";

export interface BadgeConfig {
  text: string;
  color: string;
  backgroundColor: string;
  x: number;
  y: number;
  width?: number;
  height?: number;
}

export interface AccentBarConfig {
  position: "top" | "bottom" | "left" | "right";
  color: string;
  thickness: number;
}

export interface DecorativeElementConfig {
  type: "circle" | "line" | "accent-bar" | "corner-accent";
  color: string;
  x: number;
  y: number;
  width?: number;
  height?: number;
}

/**
 * Add a professional badge/tag to the slide
 */
export function addPremiumBadge(
  slide: any,
  config: BadgeConfig
): void {
  const width = config.width || 1.2;
  const height = config.height || 0.35;

  // Badge background
  slide.addShape("roundRect", {
    x: config.x,
    y: config.y,
    w: width,
    h: height,
    fill: { color: config.backgroundColor },
    line: { color: config.color, width: 1.5 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 4,
      offset: 1
    }
  });

  // Badge text
  slide.addText(config.text, {
    x: config.x,
    y: config.y,
    w: width,
    h: height,
    fontSize: 10,
    bold: true,
    color: config.color,
    align: "center",
    valign: "middle",
    fontFace: "Inter, Arial, sans-serif"
  });
}

/**
 * Add an accent bar for visual emphasis
 */
export function addAccentBar(
  slide: any,
  config: AccentBarConfig
): void {
  const slideWidth = 10;
  const slideHeight = 7.5;

  let x = 0, y = 0, w = slideWidth, h = config.thickness;

  switch (config.position) {
    case "top":
      x = 0;
      y = 0;
      w = slideWidth;
      h = config.thickness;
      break;
    case "bottom":
      x = 0;
      y = slideHeight - config.thickness;
      w = slideWidth;
      h = config.thickness;
      break;
    case "left":
      x = 0;
      y = 0;
      w = config.thickness;
      h = slideHeight;
      break;
    case "right":
      x = slideWidth - config.thickness;
      y = 0;
      w = config.thickness;
      h = slideHeight;
      break;
  }

  slide.addShape("rect", {
    x,
    y,
    w,
    h,
    fill: { color: config.color },
    line: { type: "none" }
  });
}

/**
 * Add a decorative circle accent
 */
export function addDecorativeCircle(
  slide: any,
  x: number,
  y: number,
  size: number,
  color: string,
  opacity: number = 0.1
): void {
  slide.addShape("ellipse", {
    x,
    y,
    w: size,
    h: size,
    fill: { color, transparency: Math.round((1 - opacity) * 100) },
    line: { type: "none" }
  });
}

/**
 * Add a decorative line accent
 */
export function addDecorativeLine(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string,
  width: number = 2
): void {
  slide.addShape("line", {
    x: x1,
    y: y1,
    w: x2 - x1,
    h: y2 - y1,
    line: { color, width }
  });
}

/**
 * Add a corner accent for premium feel
 */
export function addCornerAccent(
  slide: any,
  corner: "top-left" | "top-right" | "bottom-left" | "bottom-right",
  color: string,
  size: number = 0.3
): void {
  const slideWidth = 10;
  const slideHeight = 7.5;

  let x = 0, y = 0;

  switch (corner) {
    case "top-left":
      x = 0;
      y = 0;
      break;
    case "top-right":
      x = slideWidth - size;
      y = 0;
      break;
    case "bottom-left":
      x = 0;
      y = slideHeight - size;
      break;
    case "bottom-right":
      x = slideWidth - size;
      y = slideHeight - size;
      break;
  }

  slide.addShape("rect", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

/**
 * Add a premium divider line
 */
export function addPremiumDivider(
  slide: any,
  x: number,
  y: number,
  width: number,
  color: string = "#E2E8F0",
  thickness: number = 0.02
): void {
  slide.addShape("rect", {
    x,
    y,
    w: width,
    h: thickness,
    fill: { color },
    line: { type: "none" }
  });
}

/**
 * Add a premium highlight box
 */
export function addHighlightBox(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  color: string,
  opacity: number = 0.15
): void {
  slide.addShape("rect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color, transparency: Math.round((1 - opacity) * 100) },
    line: { type: "none" }
  });
}

/**
 * Add a premium metric card
 */
export function addMetricCard(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  metric: string,
  value: string,
  unit?: string,
  accentColor: string = "#3B82F6"
): void {
  // Card background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: "#FFFFFF" },
    line: { color: "#E5E7EB", width: 1 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 8,
      offset: 2
    }
  });

  // Accent bar
  slide.addShape("rect", {
    x,
    y,
    w: 0.08,
    h: height,
    fill: { color: accentColor },
    line: { type: "none" }
  });

  // Metric label
  slide.addText(metric, {
    x: x + 0.15,
    y: y + 0.1,
    w: width - 0.25,
    h: 0.25,
    fontSize: 11,
    color: "#6B7280",
    fontFace: "Inter, Arial, sans-serif",
    bold: false
  });

  // Value
  slide.addText(value, {
    x: x + 0.15,
    y: y + 0.4,
    w: width - 0.25,
    h: 0.5,
    fontSize: 28,
    bold: true,
    color: "#0F172A",
    fontFace: "Inter, Arial, sans-serif"
  });

  // Unit
  if (unit) {
    slide.addText(unit, {
      x: x + 0.15,
      y: y + 0.85,
      w: width - 0.25,
      h: 0.2,
      fontSize: 10,
      color: "#9CA3AF",
      fontFace: "Inter, Arial, sans-serif"
    });
  }
}

/**
 * Add a sophisticated gradient-like accent bar with multiple colors
 */
export function addGradientAccentBar(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  colors: string[]
): void {
  if (colors.length === 0) return;

  const segmentWidth = width / colors.length;

  colors.forEach((color, index) => {
    slide.addShape("rect", {
      x: x + index * segmentWidth,
      y,
      w: segmentWidth,
      h: height,
      fill: { color },
      line: { type: "none" }
    });
  });
}

/**
 * Add a premium stat block with icon placeholder
 */
export function addStatBlock(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  stat: string,
  label: string,
  backgroundColor: string = "#F8FAFC",
  accentColor: string = "#3B82F6"
): void {
  // Background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: backgroundColor },
    line: { color: "#E5E7EB", width: 1 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.06,
      blur: 6,
      offset: 1
    }
  });

  // Top accent bar
  slide.addShape("rect", {
    x,
    y,
    w: width,
    h: 0.04,
    fill: { color: accentColor },
    line: { type: "none" }
  });

  // Stat value
  slide.addText(stat, {
    x: x + 0.2,
    y: y + 0.3,
    w: width - 0.4,
    h: 0.6,
    fontSize: 32,
    bold: true,
    color: accentColor,
    fontFace: "Inter, Arial, sans-serif",
    align: "center"
  });

  // Label
  slide.addText(label, {
    x: x + 0.2,
    y: y + 0.95,
    w: width - 0.4,
    h: 0.3,
    fontSize: 12,
    color: "#6B7280",
    fontFace: "Inter, Arial, sans-serif",
    align: "center"
  });
}

/**
 * Add a premium section divider with icon
 */
export function addSectionDivider(
  slide: any,
  x: number,
  y: number,
  width: number,
  color: string = "#E2E8F0",
  thickness: number = 0.03
): void {
  // Main divider line
  slide.addShape("rect", {
    x,
    y,
    w: width,
    h: thickness,
    fill: { color },
    line: { type: "none" }
  });

  // Accent circle in center
  const centerX = x + width / 2 - 0.08;
  const centerY = y - 0.08;

  slide.addShape("ellipse", {
    x: centerX,
    y: centerY,
    w: 0.16,
    h: 0.16,
    fill: { color: "#FFFFFF" },
    line: { color, width: 2 }
  });
}

/**
 * Add a premium feature highlight box
 */
export function addFeatureHighlight(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  title: string,
  description: string,
  accentColor: string = "#3B82F6"
): void {
  // Background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: "#FFFFFF" },
    line: { color: accentColor, width: 2 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 12,
      offset: 3
    }
  });

  // Title
  slide.addText(title, {
    x: x + 0.2,
    y: y + 0.2,
    w: width - 0.4,
    h: 0.4,
    fontSize: 16,
    bold: true,
    color: accentColor,
    fontFace: "Inter, Arial, sans-serif"
  });

  // Description
  slide.addText(description, {
    x: x + 0.2,
    y: y + 0.65,
    w: width - 0.4,
    h: height - 0.85,
    fontSize: 12,
    color: "#6B7280",
    fontFace: "Inter, Arial, sans-serif",
    wrap: true
  });
}

/**
 * Add a professional arrow for flow diagrams
 */
export function addArrow(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string = "#3B82F6",
  width: number = 3
): void {
  // Calculate angle and length
  const dx = x2 - x1;
  const dy = y2 - y1;
  const length = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx) * (180 / Math.PI);

  // Add arrow shape
  slide.addShape("rightArrow", {
    x: x1,
    y: y1 - 0.08,
    w: length,
    h: 0.16,
    fill: { color },
    line: { type: "none" },
    rotate: angle
  });
}

/**
 * Add a curved connector arrow
 */
export function addCurvedArrow(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string = "#3B82F6"
): void {
  // For now, use a simple line with arrowhead
  // PptxGenJS has limited support for curved connectors
  slide.addShape("line", {
    x: x1,
    y: y1,
    w: x2 - x1,
    h: y2 - y1,
    line: {
      color,
      width: 2,
      endArrowType: "triangle"
    }
  });
}

/**
 * Add a process flow with arrows
 */
export function addProcessFlow(
  slide: any,
  steps: string[],
  startX: number,
  startY: number,
  stepWidth: number,
  stepHeight: number,
  spacing: number,
  accentColor: string = "#3B82F6"
): void {
  const totalWidth = steps.length * stepWidth + (steps.length - 1) * spacing;
  let currentX = startX;

  steps.forEach((step, index) => {
    // Add step box
    slide.addShape("roundRect", {
      x: currentX,
      y: startY,
      w: stepWidth,
      h: stepHeight,
      fill: { color: "#FFFFFF" },
      line: { color: accentColor, width: 2 },
      shadow: {
        type: "outer",
        color: "000000",
        opacity: 0.08,
        blur: 6,
        offset: 2
      }
    });

    // Add step text
    slide.addText(step, {
      x: currentX,
      y: startY,
      w: stepWidth,
      h: stepHeight,
      fontSize: 12,
      bold: true,
      color: accentColor,
      fontFace: "Inter, Arial, sans-serif",
      align: "center",
      valign: "middle",
      wrap: true
    });

    // Add arrow to next step (if not last)
    if (index < steps.length - 1) {
      addArrow(
        slide,
        currentX + stepWidth + 0.05,
        startY + stepHeight / 2,
        currentX + stepWidth + spacing - 0.05,
        startY + stepHeight / 2,
        accentColor,
        2
      );
    }

    currentX += stepWidth + spacing;
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/professionalTemplates.ts
=================================================================================
/**
 * Professional Slide Templates
 * Pre-designed templates for common slide types
 */

export interface TemplateConfig {
  name: string;
  description: string;
  pattern: string;
  colorScheme: string;
  typography: string;
  useCase: string;
}

export interface TemplateLayout {
  title: {
    fontSize: number;
    bold: boolean;
    color: string;
  };
  subtitle: {
    fontSize: number;
    bold: boolean;
    color: string;
  };
  body: {
    fontSize: number;
    color: string;
    lineHeight: number;
  };
  accent: string;
  background: string;
}

/**
 * Title Slide Template
 * Large, impactful opening slide
 */
export const TITLE_SLIDE_TEMPLATE: TemplateConfig = {
  name: "Title Slide",
  description: "Large, impactful opening slide with title and subtitle",
  pattern: "hero",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Presentation opening, cover slide"
};

/**
 * Content Slide Template
 * Standard content with title and bullet points
 */
export const CONTENT_SLIDE_TEMPLATE: TemplateConfig = {
  name: "Content Slide",
  description: "Standard slide with title and bullet point content",
  pattern: "split",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Main content, information delivery"
};

/**
 * Two Column Template
 * Side-by-side comparison or contrast
 */
export const TWO_COLUMN_TEMPLATE: TemplateConfig = {
  name: "Two Column",
  description: "Side-by-side layout for comparison or contrast",
  pattern: "comparison",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Comparison, pros/cons, before/after"
};

/**
 * Three Column Template
 * Feature showcase or comparison
 */
export const THREE_COLUMN_TEMPLATE: TemplateConfig = {
  name: "Three Column",
  description: "Three equal columns for features or comparison",
  pattern: "three-column",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Feature showcase, three-way comparison"
};

/**
 * Data Visualization Template
 * Optimized for charts and graphs
 */
export const DATA_VIZ_TEMPLATE: TemplateConfig = {
  name: "Data Visualization",
  description: "Optimized layout for charts, graphs, and data",
  pattern: "data-focused",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Charts, graphs, metrics, analytics"
};

/**
 * Image Focus Template
 * Large image with minimal text
 */
export const IMAGE_FOCUS_TEMPLATE: TemplateConfig = {
  name: "Image Focus",
  description: "Large image with minimal supporting text",
  pattern: "asymmetric",
  colorScheme: "minimal",
  typography: "professional",
  useCase: "Product showcase, photography, visual focus"
};

/**
 * Timeline Template
 * Process or timeline visualization
 */
export const TIMELINE_TEMPLATE: TemplateConfig = {
  name: "Timeline",
  description: "Horizontal timeline for processes or history",
  pattern: "timeline",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Process flow, timeline, roadmap"
};

/**
 * Centered Focus Template
 * Centered content for maximum impact
 */
export const CENTERED_FOCUS_TEMPLATE: TemplateConfig = {
  name: "Centered Focus",
  description: "Centered content with maximum focus",
  pattern: "centered",
  colorScheme: "minimal",
  typography: "professional",
  useCase: "Key message, quote, emphasis"
};

/**
 * Sidebar Template
 * Content with prominent sidebar
 */
export const SIDEBAR_TEMPLATE: TemplateConfig = {
  name: "Sidebar",
  description: "Content with prominent sidebar for navigation",
  pattern: "sidebar",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Navigation, key points, supplementary info"
};

/**
 * Stacked Template
 * Vertically stacked sections
 */
export const STACKED_TEMPLATE: TemplateConfig = {
  name: "Stacked",
  description: "Vertically stacked content sections",
  pattern: "stacked",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Sequential information, steps, sections"
};

/**
 * Minimal Template
 * Maximum whitespace, minimal content
 */
export const MINIMAL_TEMPLATE: TemplateConfig = {
  name: "Minimal",
  description: "Minimal layout with maximum whitespace",
  pattern: "minimal",
  colorScheme: "minimal",
  typography: "professional",
  useCase: "Key message, breathing room, elegance"
};

/**
 * Full Bleed Template
 * Content extends to edges
 */
export const FULL_BLEED_TEMPLATE: TemplateConfig = {
  name: "Full Bleed",
  description: "Content extends to edges for maximum impact",
  pattern: "full-bleed",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Background image, full-screen content"
};

/**
 * Get all available templates
 */
export function getAllTemplates(): TemplateConfig[] {
  return [
    TITLE_SLIDE_TEMPLATE,
    CONTENT_SLIDE_TEMPLATE,
    TWO_COLUMN_TEMPLATE,
    THREE_COLUMN_TEMPLATE,
    DATA_VIZ_TEMPLATE,
    IMAGE_FOCUS_TEMPLATE,
    TIMELINE_TEMPLATE,
    CENTERED_FOCUS_TEMPLATE,
    SIDEBAR_TEMPLATE,
    STACKED_TEMPLATE,
    MINIMAL_TEMPLATE,
    FULL_BLEED_TEMPLATE
  ];
}

/**
 * Get template by name
 */
export function getTemplate(name: string): TemplateConfig | undefined {
  return getAllTemplates().find(t => t.name.toLowerCase() === name.toLowerCase());
}

/**
 * Get templates by use case
 */
export function getTemplatesByUseCase(useCase: string): TemplateConfig[] {
  return getAllTemplates().filter(t => t.useCase.toLowerCase().includes(useCase.toLowerCase()));
}

/**
 * Get template layout configuration
 */
export function getTemplateLayout(templateName: string, colorScheme: string = "corporate"): TemplateLayout {
  const layouts: Record<string, TemplateLayout> = {
    professional: {
      title: { fontSize: 44, bold: true, color: "#0F172A" },
      subtitle: { fontSize: 28, bold: false, color: "#334155" },
      body: { fontSize: 16, color: "#334155", lineHeight: 150 },
      accent: "#2563EB",
      background: "#FFFFFF"
    },
    modern: {
      title: { fontSize: 48, bold: true, color: "#0F172A" },
      subtitle: { fontSize: 32, bold: true, color: "#2563EB" },
      body: { fontSize: 16, color: "#334155", lineHeight: 150 },
      accent: "#6366F1",
      background: "#FFFFFF"
    },
    minimal: {
      title: { fontSize: 40, bold: true, color: "#1F2937" },
      subtitle: { fontSize: 24, bold: false, color: "#6B7280" },
      body: { fontSize: 14, color: "#6B7280", lineHeight: 160 },
      accent: "#1F2937",
      background: "#FFFFFF"
    },
    bold: {
      title: { fontSize: 52, bold: true, color: "#DC2626" },
      subtitle: { fontSize: 32, bold: true, color: "#0F172A" },
      body: { fontSize: 18, color: "#0F172A", lineHeight: 140 },
      accent: "#DC2626",
      background: "#FFFFFF"
    }
  };

  return layouts[templateName] || layouts.professional;
}

/**
 * Get recommended template for content type
 */
export function getRecommendedTemplate(contentType: "title" | "content" | "comparison" | "data" | "image" | "process"): TemplateConfig {
  const recommendations: Record<string, TemplateConfig> = {
    title: TITLE_SLIDE_TEMPLATE,
    content: CONTENT_SLIDE_TEMPLATE,
    comparison: TWO_COLUMN_TEMPLATE,
    data: DATA_VIZ_TEMPLATE,
    image: IMAGE_FOCUS_TEMPLATE,
    process: TIMELINE_TEMPLATE
  };

  return recommendations[contentType] || CONTENT_SLIDE_TEMPLATE;
}

/**
 * Validate template configuration
 */
export function validateTemplate(template: TemplateConfig): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!template.name) {
    errors.push("Template name is required");
  }

  if (!template.pattern) {
    errors.push("Template pattern is required");
  }

  if (!template.colorScheme) {
    errors.push("Template color scheme is required");
  }

  if (!template.typography) {
    errors.push("Template typography is required");
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Create custom template
 */
export function createCustomTemplate(
  name: string,
  description: string,
  pattern: string,
  colorScheme: string,
  typography: string,
  useCase: string
): TemplateConfig {
  return {
    name,
    description,
    pattern,
    colorScheme,
    typography,
    useCase
  };
}

/**
 * Get template statistics
 */
export function getTemplateStats(): {
  total: number;
  byPattern: Record<string, number>;
  byColorScheme: Record<string, number>;
} {
  const templates = getAllTemplates();
  const byPattern: Record<string, number> = {};
  const byColorScheme: Record<string, number> = {};

  templates.forEach(t => {
    byPattern[t.pattern] = (byPattern[t.pattern] || 0) + 1;
    byColorScheme[t.colorScheme] = (byColorScheme[t.colorScheme] || 0) + 1;
  });

  return {
    total: templates.length,
    byPattern,
    byColorScheme
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/shapeHelpers.ts
=================================================================================
/**
 * Shape Helpers for PowerPoint Slides
 * Professional shapes, arrows, and visual elements
 */

import PptxGenJS from "pptxgenjs";

/**
 * Add a professional arrow between two points
 */
export function addConnectorArrow(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string = "#3B82F6",
  thickness: number = 3
): void {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const length = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx) * (180 / Math.PI);

  slide.addShape("rightArrow", {
    x: x1,
    y: y1 - 0.08,
    w: length,
    h: 0.16,
    fill: { color: color.replace("#", "") },
    line: { type: "none" },
    rotate: angle,
  });
}

/**
 * Add a curved connector line
 */
export function addCurvedConnector(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string = "#3B82F6",
  thickness: number = 2
): void {
  slide.addShape("line", {
    x: x1,
    y: y1,
    w: x2 - x1,
    h: y2 - y1,
    line: {
      color: color.replace("#", ""),
      width: thickness,
      endArrowType: "triangle",
      dashType: "solid",
    },
  });
}

/**
 * Add a callout box with pointer
 */
export function addCalloutBox(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  text: string,
  color: string = "#3B82F6",
  backgroundColor: string = "#EEF2FF"
): void {
  // Background box
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: backgroundColor.replace("#", "") },
    line: { color: color.replace("#", ""), width: 2 },
  });

  // Text
  slide.addText(text, {
    x: x + 0.1,
    y: y + 0.1,
    w: width - 0.2,
    h: height - 0.2,
    fontSize: 14,
    color: "#0F172A",
    fontFace: "Aptos",
    align: "center",
    valign: "middle",
    wrap: true,
  });
}

/**
 * Add a process flow diagram
 */
export function addProcessFlow(
  slide: any,
  steps: string[],
  startX: number,
  startY: number,
  stepWidth: number,
  stepHeight: number,
  spacing: number,
  color: string = "#3B82F6"
): void {
  let currentX = startX;

  steps.forEach((step, index) => {
    // Step box
    slide.addShape("roundRect", {
      x: currentX,
      y: startY,
      w: stepWidth,
      h: stepHeight,
      fill: { color: "#FFFFFF" },
      line: { color: color.replace("#", ""), width: 2 },
      shadow: {
        type: "outer",
        color: "000000",
        opacity: 0.1,
        blur: 8,
        offset: 2,
      },
    });

    // Step number badge
    slide.addShape("ellipse", {
      x: currentX + 0.05,
      y: startY + 0.05,
      w: 0.25,
      h: 0.25,
      fill: { color: color.replace("#", "") },
      line: { type: "none" },
    });

    slide.addText((index + 1).toString(), {
      x: currentX + 0.05,
      y: startY + 0.05,
      w: 0.25,
      h: 0.25,
      fontSize: 12,
      bold: true,
      color: "#FFFFFF",
      align: "center",
      valign: "middle",
    });

    // Step text
    slide.addText(step, {
      x: currentX + 0.1,
      y: startY + 0.35,
      w: stepWidth - 0.2,
      h: stepHeight - 0.4,
      fontSize: 12,
      color: "#0F172A",
      fontFace: "Aptos",
      align: "center",
      valign: "middle",
      wrap: true,
    });

    // Arrow to next step
    if (index < steps.length - 1) {
      addConnectorArrow(
        slide,
        currentX + stepWidth + 0.05,
        startY + stepHeight / 2,
        currentX + stepWidth + spacing - 0.05,
        startY + stepHeight / 2,
        color,
        2
      );
    }

    currentX += stepWidth + spacing;
  });
}

/**
 * Add a metric card
 */
export function addMetricCard(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  value: string,
  label: string,
  color: string = "#3B82F6"
): void {
  // Card background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: "#FFFFFF" },
    line: { color: "#E5E7EB", width: 1 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 8,
      offset: 2,
    },
  });

  // Accent bar
  slide.addShape("rect", {
    x,
    y,
    w: 0.08,
    h: height,
    fill: { color: color.replace("#", "") },
    line: { type: "none" },
  });

  // Value
  slide.addText(value, {
    x: x + 0.15,
    y: y + 0.15,
    w: width - 0.25,
    h: height * 0.6,
    fontSize: 32,
    bold: true,
    color: color.replace("#", ""),
    fontFace: "Aptos",
    align: "center",
    valign: "middle",
  });

  // Label
  slide.addText(label, {
    x: x + 0.15,
    y: y + height * 0.65,
    w: width - 0.25,
    h: height * 0.25,
    fontSize: 12,
    color: "#6B7280",
    fontFace: "Aptos",
    align: "center",
    valign: "middle",
  });
}

/**
 * Add a comparison box (for before/after, pros/cons)
 */
export function addComparisonBox(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  title: string,
  items: string[],
  color: string = "#3B82F6",
  isPositive: boolean = true
): void {
  // Background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: "#FFFFFF" },
    line: { color: color.replace("#", ""), width: 2 },
  });

  // Header bar
  slide.addShape("rect", {
    x,
    y,
    w: width,
    h: 0.4,
    fill: { color: color.replace("#", "") },
    line: { type: "none" },
  });

  // Title
  slide.addText(title, {
    x,
    y,
    w: width,
    h: 0.4,
    fontSize: 14,
    bold: true,
    color: "#FFFFFF",
    fontFace: "Aptos",
    align: "center",
    valign: "middle",
  });

  // Items
  let currentY = y + 0.5;
  items.forEach((item) => {
    // Bullet icon
    const icon = isPositive ? "✓" : "✗";
    slide.addText(icon, {
      x: x + 0.1,
      y: currentY,
      w: 0.2,
      h: 0.25,
      fontSize: 12,
      color: color.replace("#", ""),
      align: "center",
      valign: "middle",
    });

    // Item text
    slide.addText(item, {
      x: x + 0.35,
      y: currentY,
      w: width - 0.45,
      h: 0.25,
      fontSize: 11,
      color: "#0F172A",
      fontFace: "Aptos",
      align: "left",
      valign: "middle",
      wrap: true,
    });

    currentY += 0.3;
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/slideBuilder.ts
=================================================================================
/**
 * Enhanced Slide Builder
 * Builds professional slides with design tokens and patterns
 */

import PptxGenJS from "pptxgenjs";
import type { SlideSpecV2 } from "../types/SlideSpecV2";
import {
  mapColorPalette,
  mapTypography,
  mapShadows,
  pxToIn,
  getTextOptions,
  getShapeOptions
} from "./designTokenMapper";
import { getRegionsForPattern, validatePatternRegions } from "./patterns";

/**
 * Build a professional slide with design tokens
 */
export async function buildProfessionalSlide(
  pptx: PptxGenJS,
  spec: SlideSpecV2
): Promise<void> {
  // Validate spec has required fields
  if (!spec.design || !spec.styleTokens) {
    throw new Error("Spec missing design or styleTokens");
  }

  const slide = pptx.addSlide();

  // Map design tokens
  const colors = mapColorPalette(spec.styleTokens.palette);
  const typography = mapTypography(spec.styleTokens.typography);
  const shadows = mapShadows(spec.styleTokens.shadows);

  // Get regions based on design pattern
  const regions = getRegionsForPattern(spec.design.pattern, spec);

  if (!validatePatternRegions(regions)) {
    throw new Error("Invalid pattern regions");
  }

  // Apply background
  applyBackground(slide, spec, colors);

  // Render content elements
  renderTitle(slide, spec, regions, typography, colors);
  renderSubtitle(slide, spec, regions, typography, colors);
  renderBullets(slide, spec, regions, typography, colors);
  renderCallouts(slide, spec, regions, typography, colors, shadows);
  renderChart(slide, spec, regions, colors);
  renderImages(slide, spec, regions);
}

/**
 * Apply premium background styling with professional design
 */
function applyBackground(
  slide: any,
  spec: SlideSpecV2,
  colors: any
): void {
  // Apply sophisticated gradient background
  applyPremiumGradientBackground(slide, spec, colors);

  // Get accent color with fallback
  const accentColor = spec.design?.colorStrategy?.emphasis || colors.accent || "#10B981";

  // Add sophisticated accent bar for premium feel
  if (spec.design?.pattern === "hero" || spec.design?.pattern === "minimal") {
    // Add subtle accent line at top for visual interest
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: 0,
      w: "100%",
      h: 0.08,
      fill: { color: accentColor },
      line: { type: "none" }
    });
  }

  // Add decorative accent bar for data-focused pattern
  if (spec.design?.pattern === "data-focused") {
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: 0,
      w: 0.04,
      h: "100%",
      fill: { color: accentColor },
      line: { type: "none" }
    });
  }

  // Add subtle gradient overlay for split pattern
  if (spec.design?.pattern === "split") {
    // Left accent
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: 0,
      w: 0.02,
      h: "100%",
      fill: { color: accentColor },
      line: { type: "none" }
    });
  }

  // Add asymmetric pattern accent
  if (spec.design?.pattern === "asymmetric") {
    // Diagonal accent element for dynamic feel
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 8.5,
      y: 0,
      w: 1.5,
      h: 0.06,
      fill: { color: accentColor },
      line: { type: "none" }
    });
  }

  // Add grid pattern subtle dividers
  if (spec.design?.pattern === "grid") {
    // Subtle divider lines for grid structure
    const dividerColor = "#E5E7EB";
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 5,
      y: 0.5,
      w: 0.01,
      h: 6.5,
      fill: { color: dividerColor },
      line: { type: "none" }
    });
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0.5,
      y: 3.75,
      w: 9,
      h: 0.01,
      fill: { color: dividerColor },
      line: { type: "none" }
    });
  }
}

/**
 * Render premium title with sophisticated styling
 */
function renderTitle(
  slide: any,
  spec: SlideSpecV2,
  regions: any,
  typography: any,
  colors: any
): void {
  const title = spec.content.title;
  if (!title) return;

  const titleAnchor = spec.layout.anchors.find((a: any) => a.refId === title.id);
  if (!titleAnchor) return;

  const rect = regions[titleAnchor.region];
  if (!rect) return;

  const titleConfig = spec.design?.typography?.hierarchy?.title || {
    size: typography.title.fontSize,
    weight: 700,
    lineHeight: 1.2,
    letterSpacing: 0.5
  };

  const fontPrimary = spec.design?.typography?.fontPairing?.primary || spec.styleTokens.typography.fonts.sans || "Arial";

  // Premium title with enhanced spacing and color
  slide.addText(title.text, {
    x: rect.x,
    y: rect.y,
    w: rect.w,
    h: rect.h,
    fontFace: fontPrimary,
    fontSize: titleConfig.size,
    bold: titleConfig.weight >= 600,
    color: colors.primary || colors.text,
    align: spec.components?.title?.align || "left",
    valign: "middle",
    wrap: true,
    lineSpacing: titleConfig.lineHeight * 100
  });
}

/**
 * Render subtitle
 */
function renderSubtitle(
  slide: any,
  spec: SlideSpecV2,
  regions: any,
  typography: any,
  colors: any
): void {
  const subtitle = spec.content.subtitle;
  if (!subtitle) return;

  const subtitleAnchor = spec.layout.anchors.find((a: any) => a.refId === subtitle.id);
  if (!subtitleAnchor) return;

  const rect = regions[subtitleAnchor.region];
  if (!rect) return;

  const subtitleConfig = spec.design.typography.hierarchy.subtitle || {
    size: typography.subtitle.fontSize,
    weight: 500,
    lineHeight: 1.4
  };

  slide.addText(subtitle.text, {
    x: rect.x,
    y: rect.y,
    w: rect.w,
    h: rect.h,
    fontFace: spec.design.typography.fontPairing.secondary,
    fontSize: subtitleConfig.size,
    bold: subtitleConfig.weight >= 600,
    color: colors.text,
    align: "left",
    valign: "top",
    wrap: true,
    lineSpacing: subtitleConfig.lineHeight * 100
  });
}

/**
 * Render bullet points
 */
function renderBullets(
  slide: any,
  spec: SlideSpecV2,
  regions: any,
  typography: any,
  colors: any
): void {
  const bullets = spec.content.bullets?.[0];
  if (!bullets) return;

  const bulletAnchor = spec.layout.anchors.find((a: any) => a.refId === bullets.id);
  if (!bulletAnchor) return;

  const rect = regions[bulletAnchor.region];
  if (!rect) return;

  const bodyConfig = spec.design.typography.hierarchy.body || {
    size: typography.body.fontSize,
    weight: 400,
    lineHeight: 1.5
  };

  slide.addText(
    bullets.items.map((item: any) => ({
      text: item.text,
      options: { bullet: true, indentLevel: item.level - 1 }
    })),
    {
      x: rect.x,
      y: rect.y,
      w: rect.w,
      h: rect.h,
      fontFace: spec.design.typography.fontPairing.secondary,
      fontSize: bodyConfig.size,
      bold: bodyConfig.weight >= 600,
      color: colors.text,
      wrap: true,
      lineSpacing: bodyConfig.lineHeight * 100
    }
  );
}

/**
 * Render callouts
 */
function renderCallouts(
  slide: any,
  spec: SlideSpecV2,
  regions: any,
  typography: any,
  colors: any,
  shadows: any
): void {
  const callout = spec.content.callouts?.[0];
  if (!callout) return;

  const calloutAnchor = spec.layout.anchors.find((a: any) => a.refId === callout.id);
  if (!calloutAnchor) return;

  const rect = regions[calloutAnchor.region];
  if (!rect) return;

  // Determine callout background and border colors based on variant
  const bgColor = getCalloutBackgroundColor(callout.variant, colors);
  const borderColor = getCalloutBorderColor(callout.variant, colors);

  // Add professional callout shape with premium styling
  slide.addShape(PptxGenJS.ShapeType.roundRect, {
    x: rect.x,
    y: rect.y,
    w: rect.w,
    h: rect.h,
    fill: { color: bgColor },
    line: { color: borderColor, width: 2 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 8,
      offset: 2
    }
  });

  // Add callout text
  const text = `${callout.title ? callout.title + " — " : ""}${callout.text}`;
  const fontSecondary = spec.design?.typography?.fontPairing?.secondary || spec.styleTokens.typography.fonts.sans || "Arial";

  slide.addText(text, {
    x: rect.x + 0.15,
    y: rect.y + 0.15,
    w: rect.w - 0.3,
    h: rect.h - 0.3,
    fontFace: fontSecondary,
    fontSize: typography.body.fontSize,
    color: colors.text,
    align: "left",
    valign: "middle",
    wrap: true
  });
}

/**
 * Get professional callout background color with premium styling
 */
function getCalloutBackgroundColor(variant: string, colors: any): string {
  switch (variant) {
    case "success":
      return "#ECFDF5"; // Premium light green
    case "warning":
      return "#FFFBEB"; // Premium light amber
    case "danger":
      return "#FEF2F2"; // Premium light red
    case "note":
    default:
      return "#F9FAFB"; // Premium light gray
  }
}

/**
 * Get professional callout border color
 */
function getCalloutBorderColor(variant: string, colors: any): string {
  switch (variant) {
    case "success":
      return "#10B981"; // Emerald
    case "warning":
      return "#F59E0B"; // Amber
    case "danger":
      return "#EF4444"; // Red
    case "note":
    default:
      return "#6B7280"; // Gray
  }
}

/**
 * Render chart with professional styling
 */
function renderChart(
  slide: any,
  spec: SlideSpecV2,
  regions: any,
  colors: any
): void {
  const dataViz = spec.content.dataViz;
  if (!dataViz) return;

  const chartAnchor = spec.layout.anchors.find((a: any) => a.refId === dataViz.id);
  if (!chartAnchor) return;

  const rect = regions[chartAnchor.region];
  if (!rect) return;

  const chartData = dataViz.series.map((s: any) => ({
    name: s.name,
    labels: dataViz.labels,
    values: s.values
  }));

  const chartType =
    dataViz.kind === "pie"
      ? PptxGenJS.ChartType.pie
      : dataViz.kind === "line"
      ? PptxGenJS.ChartType.line
      : PptxGenJS.ChartType.bar;

  // Premium color palette for charts
  const chartColors = [
    colors.primary || "#1E40AF",
    colors.accent || "#10B981",
    "#F59E0B",
    "#8B5CF6",
    "#EC4899",
    "#06B6D4",
    "#7C3AED"
  ];

  const chartOptions: any = {
    x: rect.x,
    y: rect.y,
    w: rect.w,
    h: rect.h,
    chartColors: chartColors,
    showLegend: true,
    legendPos: dataViz.kind === "pie" ? "r" : "b",
    dataLabelFontSize: 11,
    dataLabelPosition: "ctr",
    showTitle: !!dataViz.title,
    title: dataViz.title || "",
    titleFontSize: 16,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: colors.text || "#0F172A",
    chartGridLine: { style: "solid", color: "#E2E8F0", size: 0.5 },
    showValue: true
  };

  // Add line smoothing for line charts
  if (dataViz.kind === "line") {
    chartOptions.lineSmooth = true;
  }

  slide.addChart(chartType, chartData, chartOptions);
}

/**
 * Render images
 */
function renderImages(
  slide: any,
  spec: SlideSpecV2,
  regions: any
): void {
  const placeholders = spec.content.imagePlaceholders;
  if (!placeholders) return;

  placeholders.forEach((placeholder: any) => {
    const imageAnchor = spec.layout.anchors.find((a: any) => a.refId === placeholder.id);
    if (!imageAnchor) return;

    const rect = regions[imageAnchor.region];
    if (!rect) return;

    // Add placeholder rectangle
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: rect.x,
      y: rect.y,
      w: rect.w,
      h: rect.h,
      fill: { color: "#E5E7EB" },
      line: { color: "#D1D5DB", width: 1 }
    });

    // Add placeholder text
    slide.addText(placeholder.alt, {
      x: rect.x,
      y: rect.y,
      w: rect.w,
      h: rect.h,
      fontSize: 12,
      color: "#6B7280",
      align: "center",
      valign: "middle"
    });
  });
}

/**
 * Apply premium gradient background with sophisticated design
 * Creates depth and visual interest while maintaining professionalism
 */
function applyPremiumGradientBackground(
  slide: any,
  spec: SlideSpecV2,
  colors: any
): void {
  const slideWidth = 10;
  const slideHeight = 7.5;

  // Get colors from spec
  const bgColor = colors.background || "#F8FAFC";
  const primaryColor = colors.primary || "#1E40AF";
  const accentColor = spec.design?.colorStrategy?.emphasis || colors.accent || "#10B981";
  const neutralMid = colors.neutral[4] || "#94A3B8";

  // Base background color
  slide.background = { fill: bgColor.replace("#", "") };

  // Determine gradient style based on design pattern
  const pattern = spec.design?.pattern || "split";

  switch (pattern) {
    case "hero":
      // Dramatic top-to-bottom gradient for hero slides
      applyHeroGradient(slide, slideWidth, slideHeight, primaryColor, accentColor);
      break;

    case "minimal":
      // Very subtle center-focused gradient for minimal slides
      applyMinimalGradient(slide, slideWidth, slideHeight, bgColor, neutralMid);
      break;

    case "data-focused":
      // Left-to-right gradient emphasizing the data area
      applyDataGradient(slide, slideWidth, slideHeight, bgColor, accentColor);
      break;

    case "split":
      // Diagonal gradient for split layouts
      applySplitGradient(slide, slideWidth, slideHeight, bgColor, primaryColor);
      break;

    case "asymmetric":
      // Dynamic angular gradient for asymmetric layouts
      applyAsymmetricGradient(slide, slideWidth, slideHeight, primaryColor, accentColor);
      break;

    case "grid":
      // Subtle radial-like gradient for grid layouts
      applyGridGradient(slide, slideWidth, slideHeight, bgColor, neutralMid);
      break;

    default:
      // Default subtle gradient
      applyDefaultGradient(slide, slideWidth, slideHeight, bgColor, neutralMid);
  }
}

/**
 * Hero pattern gradient - dramatic top-to-bottom
 */
function applyHeroGradient(slide: any, w: number, h: number, primary: string, accent: string): void {
  const steps = 8;
  for (let i = 0; i < steps; i++) {
    const transparency = 96 - (i * 1.5); // 96% to 85.5%
    const yPos = (h / steps) * i;
    const height = h / steps + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: yPos,
      w: w,
      h: height,
      fill: {
        color: primary.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }
}

/**
 * Minimal pattern gradient - very subtle center focus
 */
function applyMinimalGradient(slide: any, w: number, h: number, bg: string, neutral: string): void {
  // Subtle vignette effect - darker at edges
  const edgeTransparency = 98;

  // Top edge
  slide.addShape(PptxGenJS.ShapeType.rect, {
    x: 0,
    y: 0,
    w: w,
    h: 0.5,
    fill: {
      color: neutral.replace("#", ""),
      transparency: edgeTransparency
    },
    line: { type: "none" }
  });

  // Bottom edge
  slide.addShape(PptxGenJS.ShapeType.rect, {
    x: 0,
    y: h - 0.5,
    w: w,
    h: 0.5,
    fill: {
      color: neutral.replace("#", ""),
      transparency: edgeTransparency
    },
    line: { type: "none" }
  });
}

/**
 * Data-focused pattern gradient - left to right emphasis
 */
function applyDataGradient(slide: any, w: number, h: number, bg: string, accent: string): void {
  const steps = 6;
  for (let i = 0; i < steps; i++) {
    const transparency = 97 - (i * 0.8); // 97% to 93%
    const xPos = (w / steps) * i;
    const width = w / steps + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: xPos,
      y: 0,
      w: width,
      h: h,
      fill: {
        color: accent.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }
}

/**
 * Split pattern gradient - diagonal sweep
 */
function applySplitGradient(slide: any, w: number, h: number, bg: string, primary: string): void {
  const steps = 10;
  for (let i = 0; i < steps; i++) {
    const transparency = 97 - (i * 0.5); // 97% to 92.5%
    const xPos = (w / steps) * i;
    const width = w / steps + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: xPos,
      y: 0,
      w: width,
      h: h,
      fill: {
        color: primary.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }
}

/**
 * Asymmetric pattern gradient - dynamic angular
 */
function applyAsymmetricGradient(slide: any, w: number, h: number, primary: string, accent: string): void {
  // Top-right to bottom-left gradient
  const steps = 8;
  for (let i = 0; i < steps; i++) {
    const transparency = 96 - (i * 1); // 96% to 89%
    const yPos = (h / steps) * i;
    const height = h / steps + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: yPos,
      w: w,
      h: height,
      fill: {
        color: accent.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }

  // Add subtle diagonal accent
  slide.addShape(PptxGenJS.ShapeType.rect, {
    x: w * 0.7,
    y: 0,
    w: w * 0.3,
    h: h,
    fill: {
      color: primary.replace("#", ""),
      transparency: 98
    },
    line: { type: "none" }
  });
}

/**
 * Grid pattern gradient - subtle radial effect
 */
function applyGridGradient(slide: any, w: number, h: number, bg: string, neutral: string): void {
  // Center-to-edge gradient simulation
  const centerX = w / 2;
  const centerY = h / 2;

  // Top half
  for (let i = 0; i < 4; i++) {
    const transparency = 98 - (i * 0.5);
    const yPos = (centerY / 4) * i;
    const height = centerY / 4 + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: yPos,
      w: w,
      h: height,
      fill: {
        color: neutral.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }

  // Bottom half
  for (let i = 0; i < 4; i++) {
    const transparency = 96 + (i * 0.5);
    const yPos = centerY + (centerY / 4) * i;
    const height = centerY / 4 + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: yPos,
      w: w,
      h: height,
      fill: {
        color: neutral.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }
}

/**
 * Default gradient - subtle top-to-bottom
 */
function applyDefaultGradient(slide: any, w: number, h: number, bg: string, neutral: string): void {
  const steps = 6;
  for (let i = 0; i < steps; i++) {
    const transparency = 97 - (i * 0.6); // 97% to 94%
    const yPos = (h / steps) * i;
    const height = h / steps + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: yPos,
      w: w,
      h: height,
      fill: {
        color: neutral.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/typographyEffects.ts
=================================================================================
/**
 * Advanced Typography Effects
 * Text gradients, shadows, multi-column layouts, smart text fitting
 * Professional typography hierarchy and styling
 */

import PptxGenJS from "pptxgenjs";

export interface TextGradient {
  colors: string[];
  angle?: number; // 0-360 degrees
}

export interface TextShadow {
  color: string;
  blur: number;
  offsetX: number;
  offsetY: number;
  opacity: number;
}

export interface MultiColumnConfig {
  columns: number;
  gap: number; // in inches
  text: string;
}

export interface SmartTextConfig {
  text: string;
  maxWidth: number;
  maxHeight: number;
  minFontSize: number;
  maxFontSize: number;
  fontFace?: string;
}

/**
 * Add text with gradient effect
 * Note: PptxGenJS has limited gradient support, so we simulate with layered text
 */
export function addGradientText(
  slide: any,
  text: string,
  x: number,
  y: number,
  w: number,
  h: number,
  gradient: TextGradient,
  options: any = {}
): void {
  // PptxGenJS doesn't support text gradients directly
  // We'll use the primary color from the gradient
  const primaryColor = gradient.colors[0]?.replace("#", "") || "000000";
  
  slide.addText(text, {
    x,
    y,
    w,
    h,
    color: primaryColor,
    ...options,
    // Add shadow for depth to simulate gradient effect
    shadow: {
      type: "outer",
      color: gradient.colors[1]?.replace("#", "") || "000000",
      opacity: 0.3,
      blur: 3,
      offset: 1,
      angle: gradient.angle || 45
    }
  });
}

/**
 * Add text with custom shadow effect
 */
export function addShadowText(
  slide: any,
  text: string,
  x: number,
  y: number,
  w: number,
  h: number,
  shadow: TextShadow,
  options: any = {}
): void {
  slide.addText(text, {
    x,
    y,
    w,
    h,
    ...options,
    shadow: {
      type: "outer",
      color: shadow.color.replace("#", ""),
      opacity: shadow.opacity,
      blur: shadow.blur,
      offset: Math.sqrt(shadow.offsetX ** 2 + shadow.offsetY ** 2),
      angle: Math.atan2(shadow.offsetY, shadow.offsetX) * (180 / Math.PI)
    }
  });
}

/**
 * Add multi-column text layout
 */
export function addMultiColumnText(
  slide: any,
  config: MultiColumnConfig,
  x: number,
  y: number,
  totalWidth: number,
  height: number,
  options: any = {}
): void {
  const columnWidth = (totalWidth - (config.gap * (config.columns - 1))) / config.columns;
  const words = config.text.split(" ");
  const wordsPerColumn = Math.ceil(words.length / config.columns);
  
  for (let i = 0; i < config.columns; i++) {
    const columnWords = words.slice(i * wordsPerColumn, (i + 1) * wordsPerColumn);
    const columnText = columnWords.join(" ");
    const columnX = x + (i * (columnWidth + config.gap));
    
    slide.addText(columnText, {
      x: columnX,
      y,
      w: columnWidth,
      h: height,
      ...options,
      align: "left",
      valign: "top"
    });
  }
}

/**
 * Smart text fitting - automatically adjust font size to fit content
 */
export function calculateOptimalFontSize(config: SmartTextConfig): number {
  const { text, maxWidth, maxHeight, minFontSize, maxFontSize } = config;
  
  // Estimate characters per line based on width
  // Average character width is roughly 0.6 * fontSize (in points)
  const estimateLines = (fontSize: number): number => {
    const avgCharWidth = fontSize * 0.6 / 72; // Convert to inches
    const charsPerLine = Math.floor(maxWidth / avgCharWidth);
    return Math.ceil(text.length / charsPerLine);
  };
  
  const estimateHeight = (fontSize: number): number => {
    const lineHeight = fontSize * 1.4 / 72; // Convert to inches with 1.4 line height
    return estimateLines(fontSize) * lineHeight;
  };
  
  // Binary search for optimal font size
  let low = minFontSize;
  let high = maxFontSize;
  let optimal = minFontSize;
  
  while (low <= high) {
    const mid = Math.floor((low + high) / 2);
    const height = estimateHeight(mid);
    
    if (height <= maxHeight) {
      optimal = mid;
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  
  return optimal;
}

/**
 * Add text with smart fitting
 */
export function addSmartFitText(
  slide: any,
  config: SmartTextConfig,
  x: number,
  y: number,
  options: any = {}
): void {
  const fontSize = calculateOptimalFontSize(config);
  
  slide.addText(config.text, {
    x,
    y,
    w: config.maxWidth,
    h: config.maxHeight,
    fontSize,
    fontFace: config.fontFace || "Arial",
    ...options,
    fit: "shrink", // PptxGenJS built-in text fitting
    shrinkText: true
  });
}

/**
 * Add pull quote with decorative styling
 */
export function addPullQuote(
  slide: any,
  quote: string,
  author: string,
  x: number,
  y: number,
  w: number,
  h: number,
  accentColor: string = "#3B82F6"
): void {
  // Add accent bar on left
  slide.addShape(PptxGenJS.ShapeType.rect, {
    x: x - 0.1,
    y,
    w: 0.05,
    h: h,
    fill: { color: accentColor.replace("#", "") },
    line: { type: "none" }
  });
  
  // Add quote text
  slide.addText(quote, {
    x,
    y,
    w,
    h: h * 0.7,
    fontSize: 24,
    fontFace: "Georgia, serif",
    italic: true,
    color: "1F2937",
    align: "left",
    valign: "top"
  });
  
  // Add author attribution
  slide.addText(`— ${author}`, {
    x,
    y: y + (h * 0.7),
    w,
    h: h * 0.3,
    fontSize: 16,
    fontFace: "Arial, sans-serif",
    color: "6B7280",
    align: "left",
    valign: "bottom"
  });
}

/**
 * Add callout box with icon
 */
export function addCalloutBox(
  slide: any,
  title: string,
  text: string,
  x: number,
  y: number,
  w: number,
  h: number,
  variant: "info" | "success" | "warning" | "danger" = "info"
): void {
  const colors = {
    info: { bg: "#DBEAFE", border: "#3B82F6", text: "#1E40AF" },
    success: { bg: "#D1FAE5", border: "#10B981", text: "#065F46" },
    warning: { bg: "#FEF3C7", border: "#F59E0B", text: "#92400E" },
    danger: { bg: "#FEE2E2", border: "#EF4444", text: "#991B1B" }
  };
  
  const color = colors[variant];
  
  // Background box
  slide.addShape(PptxGenJS.ShapeType.rect, {
    x,
    y,
    w,
    h,
    fill: { color: color.bg.replace("#", "") },
    line: { color: color.border.replace("#", ""), width: 2 },
    rectRadius: 0.1
  });
  
  // Title
  slide.addText(title, {
    x: x + 0.2,
    y: y + 0.15,
    w: w - 0.4,
    h: 0.3,
    fontSize: 16,
    bold: true,
    color: color.text.replace("#", ""),
    fontFace: "Arial, sans-serif"
  });
  
  // Body text
  slide.addText(text, {
    x: x + 0.2,
    y: y + 0.5,
    w: w - 0.4,
    h: h - 0.65,
    fontSize: 14,
    color: color.text.replace("#", ""),
    fontFace: "Arial, sans-serif",
    valign: "top"
  });
}

/**
 * Add highlighted text (background highlight)
 */
export function addHighlightedText(
  slide: any,
  text: string,
  x: number,
  y: number,
  w: number,
  h: number,
  highlightColor: string = "#FEF3C7",
  textColor: string = "#000000",
  options: any = {}
): void {
  // Add highlight background
  slide.addShape(PptxGenJS.ShapeType.rect, {
    x: x - 0.05,
    y: y - 0.05,
    w: w + 0.1,
    h: h + 0.1,
    fill: { color: highlightColor.replace("#", ""), transparency: 30 },
    line: { type: "none" }
  });
  
  // Add text on top
  slide.addText(text, {
    x,
    y,
    w,
    h,
    color: textColor.replace("#", ""),
    ...options
  });
}

/**
 * Get font pairing recommendations
 */
export function getFontPairing(style: "professional" | "elegant" | "modern" | "bold" | "minimal"): {
  heading: string;
  body: string;
} {
  const pairings = {
    professional: { heading: "Calibri", body: "Calibri" },
    elegant: { heading: "Georgia", body: "Garamond" },
    modern: { heading: "Segoe UI", body: "Segoe UI" },
    bold: { heading: "Impact", body: "Arial" },
    minimal: { heading: "Arial", body: "Arial" }
  };
  
  return pairings[style] || pairings.professional;
}

/**
 * Add professional heading with hierarchy
 */
export function addProfessionalHeading(
  slide: any,
  text: string,
  x: number,
  y: number,
  width: number,
  level: 1 | 2 | 3 = 1,
  color: string = "#0F172A",
  fontFace: string = "Inter, Arial, sans-serif"
): void {
  const sizes: Record<number, number> = {
    1: 44,
    2: 32,
    3: 24
  };

  const weights: Record<number, boolean> = {
    1: true,
    2: true,
    3: false
  };

  const lineHeights: Record<number, number> = {
    1: 120,
    2: 130,
    3: 140
  };

  slide.addText(text, {
    x,
    y,
    w: width,
    h: sizes[level] * 0.1,
    fontSize: sizes[level],
    bold: weights[level],
    color,
    fontFace,
    align: "left",
    valign: "top",
    lineSpacing: lineHeights[level],
    wrap: true
  });
}

/**
 * Add professional body text with optimal readability
 */
export function addProfessionalBody(
  slide: any,
  text: string,
  x: number,
  y: number,
  width: number,
  height: number,
  color: string = "#334155",
  fontFace: string = "Inter, Arial, sans-serif",
  fontSize: number = 16
): void {
  slide.addText(text, {
    x,
    y,
    w: width,
    h: height,
    fontSize,
    color,
    fontFace,
    align: "left",
    valign: "top",
    lineSpacing: 150,
    wrap: true
  });
}

/**
 * Add emphasized text with accent color
 */
export function addEmphasisText(
  slide: any,
  text: string,
  x: number,
  y: number,
  width: number,
  height: number,
  accentColor: string = "#6366F1",
  fontFace: string = "Inter, Arial, sans-serif"
): void {
  slide.addText(text, {
    x,
    y,
    w: width,
    h: height,
    fontSize: 18,
    bold: true,
    color: accentColor,
    fontFace,
    align: "left",
    valign: "middle",
    wrap: true,
    shadow: {
      type: "outer",
      color: accentColor.replace("#", ""),
      opacity: 0.15,
      blur: 4,
      offset: 1
    }
  });
}

/**
 * Add caption text (small, subtle)
 */
export function addCaptionText(
  slide: any,
  text: string,
  x: number,
  y: number,
  width: number,
  color: string = "#94A3B8",
  fontFace: string = "Inter, Arial, sans-serif"
): void {
  slide.addText(text, {
    x,
    y,
    w: width,
    h: 0.25,
    fontSize: 11,
    color,
    fontFace,
    align: "left",
    valign: "top"
  });
}

/**
 * Add label text (for annotations and callouts)
 */
export function addLabelText(
  slide: any,
  text: string,
  x: number,
  y: number,
  width: number,
  color: string = "#64748B",
  fontFace: string = "Inter, Arial, sans-serif"
): void {
  slide.addText(text, {
    x,
    y,
    w: width,
    h: 0.3,
    fontSize: 12,
    bold: true,
    color,
    fontFace,
    align: "left",
    valign: "middle",
    letterSpacing: 0.5
  });
}

/**
 * Calculate optimal line height for readability
 */
export function getOptimalLineHeight(fontSize: number): number {
  // Golden ratio for typography: 1.5 for body, 1.2 for headings
  if (fontSize >= 32) {
    return 120; // Headings
  } else if (fontSize >= 20) {
    return 130; // Subheadings
  } else {
    return 150; // Body text
  }
}

/**
 * Get recommended font size for content type
 */
export function getRecommendedFontSize(contentType: "title" | "subtitle" | "body" | "caption" | "label"): number {
  const sizes: Record<string, number> = {
    title: 44,
    subtitle: 28,
    body: 16,
    caption: 11,
    label: 12
  };

  return sizes[contentType] || 16;
}

/**
 * Create typography hierarchy configuration
 */
export function createTypographyHierarchy(
  baseSize: number = 16,
  fontFace: string = "Inter, Arial, sans-serif"
): Record<string, any> {
  return {
    title: {
      fontSize: baseSize * 2.75,
      fontWeight: 700,
      lineHeight: 120,
      letterSpacing: -0.5
    },
    subtitle: {
      fontSize: baseSize * 1.75,
      fontWeight: 600,
      lineHeight: 130,
      letterSpacing: 0
    },
    body: {
      fontSize: baseSize,
      fontWeight: 400,
      lineHeight: 150,
      letterSpacing: 0
    },
    caption: {
      fontSize: baseSize * 0.75,
      fontWeight: 400,
      lineHeight: 140,
      letterSpacing: 0.5
    },
    label: {
      fontSize: baseSize * 0.75,
      fontWeight: 600,
      lineHeight: 140,
      letterSpacing: 0.5
    }
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/whitespaceManager.ts
=================================================================================
/**
 * Whitespace Management System
 * Professional spacing, breathing room, and layout optimization
 */

export interface SpacingConfig {
  xs: number;    // Extra small: 0.25"
  sm: number;    // Small: 0.5"
  md: number;    // Medium: 0.75"
  lg: number;    // Large: 1"
  xl: number;    // Extra large: 1.5"
  xxl: number;   // Double extra large: 2"
}

export interface PaddingConfig {
  top: number;
  right: number;
  bottom: number;
  left: number;
}

export interface MarginConfig {
  top: number;
  right: number;
  bottom: number;
  left: number;
}

/**
 * Standard spacing scale
 */
export const SPACING_SCALE: SpacingConfig = {
  xs: 0.25,
  sm: 0.5,
  md: 0.75,
  lg: 1,
  xl: 1.5,
  xxl: 2
};

/**
 * Get spacing value by name
 */
export function getSpacing(size: keyof SpacingConfig): number {
  return SPACING_SCALE[size];
}

/**
 * Create uniform padding
 */
export function createUniformPadding(size: keyof SpacingConfig): PaddingConfig {
  const value = getSpacing(size);
  return {
    top: value,
    right: value,
    bottom: value,
    left: value
  };
}

/**
 * Create uniform margin
 */
export function createUniformMargin(size: keyof SpacingConfig): MarginConfig {
  const value = getSpacing(size);
  return {
    top: value,
    right: value,
    bottom: value,
    left: value
  };
}

/**
 * Create custom padding
 */
export function createCustomPadding(
  top: number,
  right: number,
  bottom: number,
  left: number
): PaddingConfig {
  return { top, right, bottom, left };
}

/**
 * Create custom margin
 */
export function createCustomMargin(
  top: number,
  right: number,
  bottom: number,
  left: number
): MarginConfig {
  return { top, right, bottom, left };
}

/**
 * Calculate content width with padding
 */
export function calculateContentWidth(
  totalWidth: number,
  padding: PaddingConfig
): number {
  return totalWidth - padding.left - padding.right;
}

/**
 * Calculate content height with padding
 */
export function calculateContentHeight(
  totalHeight: number,
  padding: PaddingConfig
): number {
  return totalHeight - padding.top - padding.bottom;
}

/**
 * Get recommended line height for readability
 */
export function getRecommendedLineHeight(fontSize: number): number {
  // Golden ratio: 1.5 for body, 1.2 for headings
  if (fontSize >= 32) {
    return 1.2; // Headings
  } else if (fontSize >= 20) {
    return 1.3; // Subheadings
  } else {
    return 1.5; // Body text
  }
}

/**
 * Get recommended paragraph spacing
 */
export function getRecommendedParagraphSpacing(fontSize: number): number {
  // Spacing between paragraphs should be 1-1.5x line height
  const lineHeight = getRecommendedLineHeight(fontSize);
  return (fontSize / 72) * lineHeight; // Convert to inches
}

/**
 * Calculate optimal vertical rhythm
 */
export function calculateVerticalRhythm(
  baselineHeight: number,
  multiplier: number = 1
): number {
  return baselineHeight * multiplier;
}

/**
 * Get breathing room percentage for slide
 */
export function getBreathingRoomPercentage(contentArea: number, totalArea: number): number {
  const whiteSpace = totalArea - contentArea;
  return (whiteSpace / totalArea) * 100;
}

/**
 * Validate breathing room (should be 20-40% for professional slides)
 */
export function validateBreathingRoom(
  contentArea: number,
  totalArea: number
): { valid: boolean; percentage: number; recommendation: string } {
  const percentage = getBreathingRoomPercentage(contentArea, totalArea);

  let recommendation = "";
  let valid = true;

  if (percentage < 20) {
    recommendation = "Content is too dense. Add more whitespace.";
    valid = false;
  } else if (percentage > 40) {
    recommendation = "Too much whitespace. Consider adding more content.";
    valid = false;
  } else {
    recommendation = "Breathing room is optimal.";
    valid = true;
  }

  return { valid, percentage, recommendation };
}

/**
 * Get margin for different content types
 */
export function getContentMargin(contentType: "title" | "body" | "chart" | "image"): MarginConfig {
  const margins: Record<string, MarginConfig> = {
    title: createCustomMargin(0, 0, 0.5, 0),
    body: createCustomMargin(0.25, 0, 0.25, 0),
    chart: createCustomMargin(0.5, 0, 0.5, 0),
    image: createCustomMargin(0.5, 0, 0.5, 0)
  };

  return margins[contentType] || createUniformMargin("md");
}

/**
 * Get padding for different container types
 */
export function getContainerPadding(containerType: "card" | "box" | "section" | "highlight"): PaddingConfig {
  const paddings: Record<string, PaddingConfig> = {
    card: createCustomPadding(0.5, 0.5, 0.5, 0.5),
    box: createCustomPadding(0.75, 0.75, 0.75, 0.75),
    section: createCustomPadding(1, 1, 1, 1),
    highlight: createCustomPadding(0.5, 0.75, 0.5, 0.75)
  };

  return paddings[containerType] || createUniformPadding("md");
}

/**
 * Calculate grid gap for multi-column layouts
 */
export function calculateGridGap(columnCount: number, totalWidth: number): number {
  // Recommended gap: 0.25" to 0.5" depending on columns
  if (columnCount <= 2) {
    return 0.5;
  } else if (columnCount <= 3) {
    return 0.4;
  } else {
    return 0.25;
  }
}

/**
 * Calculate column width for grid
 */
export function calculateColumnWidth(
  totalWidth: number,
  columnCount: number,
  gap: number
): number {
  const totalGap = gap * (columnCount - 1);
  return (totalWidth - totalGap) / columnCount;
}

/**
 * Get recommended section spacing
 */
export function getRecommendedSectionSpacing(sectionType: "header" | "body" | "footer"): number {
  const spacing: Record<string, number> = {
    header: 0.5,
    body: 0.75,
    footer: 0.5
  };

  return spacing[sectionType] || 0.5;
}

/**
 * Calculate optimal slide margins
 */
export function getOptimalSlideMargins(slideWidth: number, slideHeight: number): MarginConfig {
  // Golden ratio margins: approximately 5-10% of slide dimensions
  const horizontalMargin = slideWidth * 0.05;
  const verticalMargin = slideHeight * 0.067;

  return createCustomMargin(verticalMargin, horizontalMargin, verticalMargin, horizontalMargin);
}

/**
 * Get text box padding for readability
 */
export function getTextBoxPadding(textLength: number): PaddingConfig {
  // Longer text needs more breathing room
  if (textLength > 500) {
    return createCustomPadding(0.75, 0.75, 0.75, 0.75);
  } else if (textLength > 200) {
    return createCustomPadding(0.5, 0.5, 0.5, 0.5);
  } else {
    return createCustomPadding(0.25, 0.25, 0.25, 0.25);
  }
}

/**
 * Calculate list item spacing
 */
export function getListItemSpacing(itemCount: number): number {
  // More items = less spacing to fit on slide
  if (itemCount <= 3) {
    return 0.4;
  } else if (itemCount <= 5) {
    return 0.3;
  } else {
    return 0.2;
  }
}

/**
 * Get recommended spacing between elements
 */
export function getElementSpacing(elementType: "heading-body" | "body-body" | "section-section"): number {
  const spacing: Record<string, number> = {
    "heading-body": 0.3,
    "body-body": 0.2,
    "section-section": 0.75
  };

  return spacing[elementType] || 0.25;
}

/**
 * Validate layout spacing
 */
export function validateLayoutSpacing(
  elements: Array<{ y: number; h: number }>,
  slideHeight: number
): { valid: boolean; issues: string[] } {
  const issues: string[] = [];

  // Check for overlapping elements
  for (let i = 0; i < elements.length - 1; i++) {
    const current = elements[i];
    const next = elements[i + 1];

    if (current.y + current.h > next.y) {
      issues.push(`Elements ${i} and ${i + 1} are overlapping`);
    }
  }

  // Check if content fits on slide
  const lastElement = elements[elements.length - 1];
  if (lastElement.y + lastElement.h > slideHeight) {
    issues.push("Content extends beyond slide height");
  }

  return {
    valid: issues.length === 0,
    issues
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/presentationAI.ts
=================================================================================
/**
 * Presentation-Level AI Intelligence
 * Multi-slide generation, narrative flow, slide relationships
 */

import { logger } from "firebase-functions/v2";
import type { SlideSpecV1 } from "./types/SlideSpecV1";

export interface PresentationRequest {
  topic: string;
  audience?: "executives" | "technical" | "sales" | "general" | "investors";
  tone?: "formal" | "casual" | "persuasive" | "educational" | "inspirational";
  slideCount?: number; // Desired number of slides (default: auto-determine)
  industry?: "tech" | "finance" | "healthcare" | "marketing" | "corporate";
  includeAgenda?: boolean;
  includeSummary?: boolean;
}

export interface PresentationStructure {
  title: string;
  slides: Array<{
    type: "title" | "agenda" | "content" | "data" | "quote" | "summary" | "cta";
    title: string;
    purpose: string;
    keyPoints: string[];
    suggestedPattern: "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused";
  }>;
  narrativeFlow: string;
  transitionStrategy: string;
}

/**
 * Analyze presentation request and generate structure
 */
export function analyzePresentationRequest(request: PresentationRequest): PresentationStructure {
  const { topic, audience = "general", tone = "formal", slideCount, industry = "corporate" } = request;
  
  // Determine optimal slide count if not specified
  const optimalSlideCount = slideCount || determineOptimalSlideCount(topic, audience);
  
  // Generate presentation structure
  const structure: PresentationStructure = {
    title: topic,
    slides: [],
    narrativeFlow: generateNarrativeFlow(topic, audience, tone),
    transitionStrategy: determineTransitionStrategy(tone, industry)
  };
  
  // Add title slide
  structure.slides.push({
    type: "title",
    title: topic,
    purpose: "Introduce the presentation topic and set the tone",
    keyPoints: [topic, `Presented to ${audience} audience`],
    suggestedPattern: "hero"
  });
  
  // Add agenda slide if requested
  if (request.includeAgenda) {
    structure.slides.push({
      type: "agenda",
      title: "Agenda",
      purpose: "Outline the presentation structure",
      keyPoints: ["Overview", "Key Topics", "Conclusion"],
      suggestedPattern: "minimal"
    });
  }
  
  // Generate content slides based on topic analysis
  const contentSlides = generateContentSlides(topic, optimalSlideCount - 2, audience, industry);
  structure.slides.push(...contentSlides);
  
  // Add summary slide if requested
  if (request.includeSummary) {
    structure.slides.push({
      type: "summary",
      title: "Key Takeaways",
      purpose: "Summarize main points and reinforce message",
      keyPoints: ["Summary point 1", "Summary point 2", "Summary point 3"],
      suggestedPattern: "minimal"
    });
  }
  
  return structure;
}

/**
 * Determine optimal slide count based on topic complexity
 */
function determineOptimalSlideCount(topic: string, audience: string): number {
  const topicLength = topic.split(" ").length;
  
  // Base count on topic complexity
  let baseCount = 5; // Default
  
  if (topicLength > 10) baseCount = 8; // Complex topic
  if (topicLength > 15) baseCount = 12; // Very complex topic
  
  // Adjust for audience
  if (audience === "executives") baseCount = Math.min(baseCount, 7); // Executives prefer concise
  if (audience === "technical") baseCount += 2; // Technical audiences need more detail
  
  return baseCount;
}

/**
 * Generate narrative flow description
 */
function generateNarrativeFlow(topic: string, audience: string, tone: string): string {
  const flows = {
    executives: "Problem → Solution → Impact → ROI → Next Steps",
    technical: "Context → Architecture → Implementation → Results → Future Work",
    sales: "Pain Point → Solution → Benefits → Proof → Call to Action",
    general: "Introduction → Key Points → Supporting Details → Conclusion",
    investors: "Opportunity → Market → Solution → Traction → Ask"
  };
  
  return flows[audience as keyof typeof flows] || flows.general;
}

/**
 * Determine transition strategy
 */
function determineTransitionStrategy(tone: string, industry: string): string {
  if (tone === "formal" && industry === "finance") {
    return "Minimal transitions (fade only) for professional, serious tone";
  }
  
  if (tone === "inspirational" || industry === "marketing") {
    return "Dynamic transitions (push, zoom) for energetic, engaging feel";
  }
  
  if (industry === "tech") {
    return "Modern transitions (wipe, split) for contemporary, innovative feel";
  }
  
  return "Balanced transitions (fade, push) for professional yet engaging presentation";
}

/**
 * Generate content slides based on topic
 */
function generateContentSlides(
  topic: string,
  count: number,
  audience: string,
  industry: string
): PresentationStructure["slides"] {
  const slides: PresentationStructure["slides"] = [];
  
  // Analyze topic to determine slide types
  const topicLower = topic.toLowerCase();
  
  // Determine slide distribution
  const hasData = topicLower.match(/sales|revenue|growth|metrics|performance|analytics/);
  const hasProcess = topicLower.match(/process|workflow|steps|implementation|strategy/);
  const hasComparison = topicLower.match(/vs|versus|compare|comparison|alternative/);
  
  for (let i = 0; i < count; i++) {
    const slideNumber = i + 1;
    
    // Vary slide types for engagement
    if (i === 0) {
      // First content slide - overview
      slides.push({
        type: "content",
        title: `${topic} - Overview`,
        purpose: "Provide high-level context and set expectations",
        keyPoints: ["Context", "Scope", "Objectives"],
        suggestedPattern: "split"
      });
    } else if (hasData && i === Math.floor(count / 2)) {
      // Middle slide - data visualization
      slides.push({
        type: "data",
        title: "Key Metrics & Performance",
        purpose: "Present data-driven insights",
        keyPoints: ["Metric 1", "Metric 2", "Metric 3"],
        suggestedPattern: "data-focused"
      });
    } else if (hasComparison && i === Math.floor(count / 3)) {
      // Comparison slide
      slides.push({
        type: "content",
        title: "Comparison & Analysis",
        purpose: "Compare options or approaches",
        keyPoints: ["Option A", "Option B", "Recommendation"],
        suggestedPattern: "split"
      });
    } else if (i === count - 1) {
      // Last content slide - call to action
      slides.push({
        type: "cta",
        title: "Next Steps",
        purpose: "Drive action and provide clear next steps",
        keyPoints: ["Action 1", "Action 2", "Timeline"],
        suggestedPattern: "minimal"
      });
    } else {
      // Regular content slide
      slides.push({
        type: "content",
        title: `Key Point ${slideNumber}`,
        purpose: "Develop main argument or provide supporting information",
        keyPoints: ["Point 1", "Point 2", "Point 3"],
        suggestedPattern: i % 2 === 0 ? "asymmetric" : "grid"
      });
    }
  }
  
  return slides;
}

/**
 * Generate enhanced prompt for multi-slide presentation
 */
export function generatePresentationPrompt(request: PresentationRequest): string {
  const structure = analyzePresentationRequest(request);
  
  const prompt = `
Create a professional ${structure.slides.length}-slide presentation on "${request.topic}".

AUDIENCE: ${request.audience || "general"}
TONE: ${request.tone || "formal"}
INDUSTRY: ${request.industry || "corporate"}

NARRATIVE FLOW: ${structure.narrativeFlow}

SLIDE STRUCTURE:
${structure.slides.map((slide, idx) => `
${idx + 1}. ${slide.title} (${slide.type})
   Pattern: ${slide.suggestedPattern}
   Purpose: ${slide.purpose}
   Key Points: ${slide.keyPoints.join(", ")}
`).join("\n")}

REQUIREMENTS:
- Maintain consistent design language across all slides
- Use ${structure.transitionStrategy}
- Ensure logical flow from slide to slide
- Include relevant data visualizations where appropriate
- Keep text concise and impactful (max 5 bullets per slide)
- Use professional color palette appropriate for ${request.industry}

Generate a complete presentation with all ${structure.slides.length} slides.
`;
  
  return prompt;
}

/**
 * Validate slide relationships and narrative flow
 */
export function validatePresentationFlow(slides: SlideSpecV1[]): {
  valid: boolean;
  issues: string[];
  suggestions: string[];
} {
  const issues: string[] = [];
  const suggestions: string[] = [];
  
  // Check for title slide
  if (slides.length > 0 && !slides[0].content.title.text.match(/^[A-Z]/)) {
    issues.push("First slide should have a capitalized title");
  }
  
  // Check for consistent theme
  const themes = slides.map(s => s.meta.theme);
  const uniqueThemes = new Set(themes);
  if (uniqueThemes.size > 1) {
    issues.push(`Inconsistent themes detected: ${Array.from(uniqueThemes).join(", ")}`);
    suggestions.push("Use a consistent theme across all slides");
  }
  
  // Check for consistent color palette
  const primaryColors = slides.map(s => s.styleTokens.palette.primary);
  const uniqueColors = new Set(primaryColors);
  if (uniqueColors.size > 2) {
    issues.push("Too many different primary colors used");
    suggestions.push("Limit to 1-2 primary colors for consistency");
  }
  
  // Check slide count
  if (slides.length < 3) {
    suggestions.push("Consider adding more slides for a complete presentation");
  }
  if (slides.length > 20) {
    suggestions.push("Consider condensing content - presentations over 20 slides may lose audience attention");
  }
  
  // Check for data visualization distribution
  const dataSlides = slides.filter(s => s.content.dataViz);
  if (dataSlides.length === 0 && slides.length > 5) {
    suggestions.push("Consider adding data visualizations to support key points");
  }
  
  return {
    valid: issues.length === 0,
    issues,
    suggestions
  };
}

/**
 * Generate agenda slide content from presentation structure
 */
export function generateAgendaSlide(slides: SlideSpecV1[]): {
  title: string;
  items: string[];
} {
  return {
    title: "Agenda",
    items: slides
      .filter((_, idx) => idx > 0) // Skip title slide
      .map(s => s.content.title.text)
      .slice(0, 6) // Max 6 agenda items
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/promptEnhancer.ts
=================================================================================
/**
 * Prompt Enhancer
 * Analyzes and enhances user prompts with design guidance
 */

export interface EnhancedPrompt {
  original: string;
  enhanced: string;
  suggestedPattern: string;
  suggestedPalette: string;
  suggestedTypography: string;
  designGuidance: string[];
  contentType: string;
}

/**
 * Analyze prompt to determine content type
 */
export function analyzeContentType(prompt: string): string {
  const lower = prompt.toLowerCase();

  if (lower.includes("data") || lower.includes("chart") || lower.includes("metric") || lower.includes("analytics")) {
    return "data-visualization";
  }
  if (lower.includes("compare") || lower.includes("vs") || lower.includes("before") || lower.includes("after")) {
    return "comparison";
  }
  if (lower.includes("process") || lower.includes("step") || lower.includes("flow")) {
    return "process";
  }
  if (lower.includes("feature") || lower.includes("product") || lower.includes("launch")) {
    return "product";
  }
  if (lower.includes("quote") || lower.includes("message") || lower.includes("key point")) {
    return "emphasis";
  }
  if (lower.includes("education") || lower.includes("learn") || lower.includes("teach")) {
    return "educational";
  }
  if (lower.includes("business") || lower.includes("corporate") || lower.includes("professional")) {
    return "corporate";
  }
  if (lower.includes("creative") || lower.includes("design") || lower.includes("art")) {
    return "creative";
  }

  return "general";
}

/**
 * Suggest design pattern based on content type
 */
export function suggestPattern(contentType: string): string {
  const patterns: Record<string, string> = {
    "data-visualization": "data-focused",
    comparison: "split",
    process: "grid",
    product: "hero",
    emphasis: "minimal",
    educational: "split",
    corporate: "split",
    creative: "asymmetric",
    general: "split"
  };

  return patterns[contentType] || "split";
}

/**
 * Suggest color palette based on content type
 */
export function suggestPalette(contentType: string): string {
  const palettes: Record<string, string> = {
    "data-visualization": "finance",
    comparison: "corporate",
    process: "tech",
    product: "creative",
    emphasis: "minimal",
    educational: "education",
    corporate: "corporate",
    creative: "creative",
    general: "corporate"
  };

  return palettes[contentType] || "corporate";
}

/**
 * Suggest typography based on content type
 */
export function suggestTypography(contentType: string): string {
  const typographies: Record<string, string> = {
    "data-visualization": "modern",
    comparison: "corporate",
    process: "modern",
    product: "bold",
    emphasis: "elegant",
    educational: "friendly",
    corporate: "corporate",
    creative: "creative",
    general: "modern"
  };

  return typographies[contentType] || "modern";
}

/**
 * Generate design guidance based on content type
 */
export function generateDesignGuidance(contentType: string): string[] {
  const guidance: Record<string, string[]> = {
    "data-visualization": [
      "Use data-focused pattern with chart as primary focus",
      "Ensure high contrast for readability",
      "Include supporting text in sidebar",
      "Use complementary colors for data series",
      "Add data labels for clarity"
    ],
    comparison: [
      "Use split pattern for 50/50 comparison",
      "Maintain visual balance between sides",
      "Use contrasting colors to highlight differences",
      "Include clear labels for each side",
      "Consider using icons for quick recognition"
    ],
    process: [
      "Use grid pattern for step-by-step flow",
      "Number or label each step clearly",
      "Use consistent styling across steps",
      "Consider adding arrows between steps",
      "Maintain logical left-to-right or top-to-bottom flow"
    ],
    product: [
      "Use hero pattern for strong visual impact",
      "Feature product image or key visual prominently",
      "Use bold typography for headlines",
      "Include key benefits in supporting text",
      "Use accent color for call-to-action"
    ],
    emphasis: [
      "Use minimal pattern with generous white space",
      "Center content for maximum impact",
      "Use large, bold typography",
      "Limit to essential message only",
      "Consider using accent color for emphasis"
    ],
    educational: [
      "Use split pattern for content organization",
      "Include visual aids or diagrams",
      "Use friendly, approachable typography",
      "Break content into digestible chunks",
      "Use consistent color coding for concepts"
    ],
    corporate: [
      "Use professional color palette",
      "Maintain consistent branding",
      "Use corporate typography",
      "Include company logo if appropriate",
      "Ensure WCAG AA accessibility compliance"
    ],
    creative: [
      "Use asymmetric pattern for dynamic layout",
      "Experiment with bold colors",
      "Use creative typography pairings",
      "Consider unconventional layouts",
      "Balance creativity with readability"
    ],
    general: [
      "Choose appropriate design pattern for content",
      "Ensure sufficient white space",
      "Maintain visual hierarchy",
      "Use consistent typography",
      "Verify color contrast ratios"
    ]
  };

  return guidance[contentType] || guidance.general;
}

/**
 * Enhance prompt with design guidance
 */
export function enhancePrompt(userPrompt: string): EnhancedPrompt {
  const contentType = analyzeContentType(userPrompt);
  const pattern = suggestPattern(contentType);
  const palette = suggestPalette(contentType);
  const typography = suggestTypography(contentType);
  const guidance = generateDesignGuidance(contentType);

  const enhanced = `${userPrompt}

DESIGN GUIDANCE:
- Pattern: ${pattern}
- Color Palette: ${palette}
- Typography: ${typography}
- Key Principles:
${guidance.map(g => `  • ${g}`).join("\n")}`;

  return {
    original: userPrompt,
    enhanced,
    suggestedPattern: pattern,
    suggestedPalette: palette,
    suggestedTypography: typography,
    designGuidance: guidance,
    contentType
  };
}

/**
 * Validate prompt for design quality
 */
export function validatePromptQuality(prompt: string): {
  isValid: boolean;
  issues: string[];
  suggestions: string[];
} {
  const issues: string[] = [];
  const suggestions: string[] = [];

  if (prompt.length < 10) {
    issues.push("Prompt is too short - provide more context");
  }

  if (prompt.length > 1000) {
    suggestions.push("Prompt is quite long - consider breaking into multiple slides");
  }

  if (!prompt.includes(" ")) {
    issues.push("Prompt appears to be a single word - provide more detail");
  }

  const hasNumbers = /\d/.test(prompt);
  if (!hasNumbers && prompt.toLowerCase().includes("data")) {
    suggestions.push("Data-related prompt should include specific numbers or metrics");
  }

  const hasAction = /\b(show|display|create|make|build|design)\b/i.test(prompt);
  if (!hasAction) {
    suggestions.push("Consider using action verbs like 'show', 'display', or 'create'");
  }

  return {
    isValid: issues.length === 0,
    issues,
    suggestions
  };
}

/**
 * Extract key topics from prompt
 */
export function extractKeyTopics(prompt: string): string[] {
  const words = prompt.split(/\s+/);
  const stopWords = new Set([
    "the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for",
    "of", "with", "by", "from", "is", "are", "was", "were", "be", "been"
  ]);

  return words
    .filter(word => word.length > 3 && !stopWords.has(word.toLowerCase()))
    .slice(0, 5);
}

/**
 * Generate slide title suggestions
 */
export function generateTitleSuggestions(prompt: string): string[] {
  const topics = extractKeyTopics(prompt);
  const contentType = analyzeContentType(prompt);

  const suggestions: string[] = [];

  // Suggestion 1: Direct topic
  if (topics.length > 0) {
    suggestions.push(topics[0].charAt(0).toUpperCase() + topics[0].slice(1));
  }

  // Suggestion 2: Combined topics
  if (topics.length > 1) {
    suggestions.push(
      topics.slice(0, 2).map(t => t.charAt(0).toUpperCase() + t.slice(1)).join(" & ")
    );
  }

  // Suggestion 3: Content type based
  const typeBasedTitles: Record<string, string> = {
    "data-visualization": "Key Metrics & Insights",
    comparison: "Comparison Analysis",
    process: "Process Overview",
    product: "Product Highlights",
    emphasis: "Key Message",
    educational: "Learning Objectives",
    corporate: "Business Update",
    creative: "Creative Showcase"
  };

  if (typeBasedTitles[contentType]) {
    suggestions.push(typeBasedTitles[contentType]);
  }

  return suggestions;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/prompts.ts
=================================================================================
/** Enhanced system prompt with world-class design guidance */
export const ENHANCED_SYSTEM_PROMPT = `
You are the SlideSpec generator for plzfixthx, an AI-powered single-slide generator.
Your task is to convert user prompts into beautiful, professional slide specifications with sophisticated design.

CRITICAL RULES:
1. Output ONLY valid JSON - no markdown, no explanations, no additional text
2. The JSON must validate against the SlideSpec v1 schema
3. Use meta.version "1.0" and aspectRatio "16:9" as defaults
4. Keep text concise and professional (max 5 bullets total, levels 1-3)
5. Use hex colors (#RRGGBB format only)
6. IDs must match pattern [A-Za-z0-9_-]
7. If including dataViz, ensure labels array has 2-10 items and all series values arrays match labels length
8. Every slide will automatically include professional design accents: sophisticated SVG backgrounds, accent bars, decorative shapes, and corner accents

CONTENT QUALITY GUIDELINES:
- Titles: Clear, concise, action-oriented (4-8 words ideal)
- Subtitles: Provide context or key insight (8-15 words)
- Bullets: One clear idea per bullet, parallel structure, start with strong verbs
- Data: Use specific numbers, percentages, and metrics for credibility
- Callouts: Highlight critical information, warnings, or key takeaways
- Keep total word count under 100 words per slide for maximum impact

WORLD-CLASS DESIGN PRINCIPLES (Apple/Google/Tesla/ChatGPT Standards):
1. Visual Hierarchy: Create crystal-clear focal points using sophisticated size, color, and contrast
   - Primary focus: Largest, boldest, most saturated - commands immediate attention
   - Secondary focus: Medium size, medium weight - supports primary narrative
   - Supporting: Smallest, lightest, neutral colors - provides context without distraction
   - Use 3-4 hierarchy levels maximum for clarity
2. White Space Mastery: Generous breathing room creates luxury and sophistication
   - Generous (40-50%): Premium, luxury, high-end, minimalist aesthetic
   - Balanced (28-36%): Professional, modern, corporate, Apple-like
   - Compact (18-26%): Data-focused, grid, information-dense but still elegant
   - Minimum margins: 32px (0.44in) for professional presentations
3. Automatic Professional Design Accents (Applied to Every Slide):
   - Sophisticated SVG gradient backgrounds with subtle color transitions and depth
   - Left accent bar (0.08-0.12" width) in primary color for visual anchor
   - Corner accents with refined opacity (8-15%) for sophistication
   - Decorative circles and abstract shapes for visual interest
   - Premium divider line under title (2.5" width, 0.04" height) in primary color
   - Colored bullet points matching primary color for cohesion
   - Wave patterns and curved accents for modern, dynamic feel
   - All accents are automatically added - focus on content quality and hierarchy
4. Color Psychology & Sophistication:
   - Tech/Innovation: Deep Blues (#1E40AF, #2563EB), Purples (#7C3AED), Cyans (#06B6D4)
   - Finance: Navy (#0F172A), Emerald (#10B981), Gold (#F59E0B)
   - Healthcare: Teal (#0D9488), Sky Blue (#0EA5E9), Sage (#10B981)
   - Creative: Magenta (#EC4899), Amber (#F59E0B), Violet (#8B5CF6)
   - Corporate: Slate (#475569), Indigo (#4F46E5), Charcoal (#1F2937)
   - Use color sparingly - 1-2 accent colors maximum for sophistication
5. Typography Excellence: Professional font pairing with perfect hierarchy
   - All slides use Aptos font (modern, professional, clean, excellent readability)
   - Title: 36-44px, bold (700), dark slate (#0F172A), line-height 1.1-1.2
   - Subtitle: 18-22px, medium (500), slate gray (#64748B), line-height 1.3
   - Body/Bullets: 16-18px, regular (400), dark gray (#1E293B), line-height 1.4-1.5
   - Callouts: 16-17px, medium (500), with colored backgrounds and borders
   - Chart labels: 10-12px, regular, subtle gray (#64748B)
   - Generous spacing between elements (8-12px paragraph spacing)
6. Balance & Composition: Use rule of thirds, golden ratio, and negative space
   - Align elements to invisible grid (8px or 16px)
   - Create visual tension through asymmetry when appropriate
   - Maintain consistent padding and margins throughout

PROFESSIONAL DESIGN PATTERNS (choose one based on content):
- Hero: Large title/image (55-65% of slide), minimal supporting text - for announcements, key messages, product launches
  * Best for: Executive summaries, product reveals, keynote slides
  * Whitespace: Generous (40-50%)
  * Typography: Bold, large titles (44-56px), subtle subtitles
- Split: 50/50 content division with clear visual separation - for comparisons, before/after, dual narratives
  * Best for: Comparisons, pros/cons, two-part stories
  * Whitespace: Balanced (28-36%)
  * Typography: Equal weight on both sides
- Asymmetric: Dynamic off-center layout with visual tension - for creative, feature highlights, modern brands
  * Best for: Creative industries, feature highlights, modern tech
  * Whitespace: Balanced to generous (30-45%)
  * Typography: Varied sizes creating visual interest
- Grid: Structured multi-element layout (2x2, 3x3, etc.) - for multiple items, portfolio, process flows
  * Best for: Portfolio items, process steps, multiple metrics
  * Whitespace: Compact to balanced (20-32%)
  * Typography: Consistent sizing across grid items
- Minimal: Maximum white space (40%+), essential content only - for quotes, emphasis, luxury brands
  * Best for: Quotes, key takeaways, luxury/premium positioning
  * Whitespace: Generous (45-55%)
  * Typography: Large, bold, centered
- Data-Focused: Chart as primary (55-70%), supporting text sidebar - for analytics, metrics, financial data
  * Best for: Analytics, financial reports, data-driven insights
  * Whitespace: Compact (18-26%)
  * Typography: Smaller, supporting role

PROFESSIONAL LAYOUT GUIDELINES:
- Use a 12-column, 8-row grid system with 8px gutter
- Standard regions: header (rows 1-2, rowSpan: 2), body (rows 3-7), footer/aside (rows 3-7, cols 9-12)
- CRITICAL: Header region MUST have rowSpan: 2 (minimum) to accommodate title + subtitle without overlap
- If slide has both title AND subtitle, ensure header rowSpan >= 2
- Anchor content elements to appropriate regions with clear hierarchy
- Minimum margins: 32px (0.44in) all around for professional appearance
- Ensure visual balance using rule of thirds or golden ratio
- Align all elements to 8px or 16px grid for precision

PROFESSIONAL STYLE GUIDELINES:
- Choose sophisticated color palettes matching content theme and industry
- Business/Corporate: Navy (#0F172A), Indigo (#4F46E5), Slate (#475569)
- Finance/Banking: Navy (#1E40AF), Emerald (#10B981), Gold (#F59E0B)
- Tech/Innovation: Deep Blue (#1E40AF), Purple (#7C3AED), Cyan (#06B6D4)
- Healthcare: Teal (#0D9488), Sky (#0EA5E9), Sage (#10B981)
- Creative/Marketing: Magenta (#EC4899), Amber (#F59E0B), Violet (#8B5CF6)
- Use 7 neutral colors from dark (#0F172A) to light (#F8FAFC)
- Typography sizes: step_3 (36-44px) for titles, step_1 (20-24px) for subtitles, step_0 (16px) for body
- Ensure WCAG AAA contrast ratio of 7:1 for premium accessibility
- Use subtle shadows (0 4px 12px rgba(0,0,0,0.08)) for depth without clutter

ADVANCED DESIGN TECHNIQUES FOR WORLD-CLASS SLIDES:
1. Micro-interactions & Visual Refinement:
   - Use subtle opacity variations (8%, 12%, 15%) for layered depth
   - Apply refined border-radius (4-8px) for modern, approachable feel
   - Implement consistent spacing rhythm (8px base unit)
   - Use premium shadows with proper blur and offset for elevation
2. Typography Refinement:
   - Implement proper letter-spacing for titles (+0.5px to +1px)
   - Use line-height 1.2-1.3 for titles, 1.4-1.6 for body text
   - Apply font-weight hierarchy: 700 (bold) for titles, 600 (semibold) for emphasis, 400 (regular) for body
   - Ensure minimum 16px font size for body text (accessibility)
3. Color Harmony & Contrast:
   - Primary color: Use for titles, accents, and key elements
   - Accent color: Complementary or analogous to primary, used sparingly
   - Neutral palette: 7-step scale from dark to light for text and backgrounds
   - Ensure 4.5:1 minimum contrast for WCAG AA, 7:1 for AAA (premium)
4. Layout Sophistication:
   - Use asymmetric layouts for visual interest (not centered)
   - Apply rule of thirds for focal point placement
   - Create breathing room with 40-50% whitespace for premium feel
   - Align all elements to 8px grid for precision and consistency
5. Data Visualization Excellence:
   - Use professional color palettes for charts (avoid rainbow)
   - Implement proper chart spacing and margins
   - Add subtle gridlines for readability without clutter
   - Use appropriate chart types: bar for comparisons, line for trends, pie for composition
   - Ensure chart labels are readable (10-12px minimum)

EXAMPLE 1 - Premium Business Presentation (Data-Focused Pattern):
User: "Q4 sales performance with revenue growth chart"
Output: {
  "meta": {"version": "1.0", "locale": "en-US", "theme": "Premium Business", "aspectRatio": "16:9"},
  "content": {
    "title": {"id": "title", "text": "Q4 Sales Performance"},
    "subtitle": {"id": "subtitle", "text": "Revenue Growth & Strategic Metrics"},
    "bullets": [{"id": "b1", "items": [
      {"text": "Total revenue increased 23% YoY", "level": 1},
      {"text": "New customer acquisition up 15%", "level": 1},
      {"text": "Customer retention rate: 94%", "level": 1}
    ]}],
    "dataViz": {
      "id": "chart1",
      "kind": "bar",
      "title": "Quarterly Revenue Trajectory",
      "labels": ["Q1", "Q2", "Q3", "Q4"],
      "series": [{"name": "Revenue ($M)", "values": [12, 15, 18, 22]}]
    }
  },
  "layout": {
    "grid": {"rows": 8, "cols": 12, "gutter": 8, "margin": {"t": 32, "r": 32, "b": 32, "l": 32}},
    "regions": [
      {"name": "header", "rowStart": 1, "colStart": 1, "rowSpan": 2, "colSpan": 12},
      {"name": "body", "rowStart": 3, "colStart": 1, "rowSpan": 5, "colSpan": 8},
      {"name": "aside", "rowStart": 3, "colStart": 9, "rowSpan": 5, "colSpan": 4}
    ],
    "anchors": [
      {"refId": "title", "region": "header", "order": 0},
      {"refId": "subtitle", "region": "header", "order": 1},
      {"refId": "chart1", "region": "body", "order": 0},
      {"refId": "b1", "region": "aside", "order": 0}
    ]
  },
  "styleTokens": {
    "palette": {"primary": "#0F172A", "accent": "#10B981", "neutral": ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"]},
    "typography": {
      "fonts": {"sans": "Inter, Arial, sans-serif"},
      "sizes": {"step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 20, "step_2": 28, "step_3": 40},
      "weights": {"regular": 400, "medium": 500, "semibold": 600, "bold": 700},
      "lineHeights": {"compact": 1.2, "standard": 1.5}
    },
    "spacing": {"base": 4, "steps": [0,4,8,12,16,24,32]},
    "radii": {"sm": 4, "md": 8, "lg": 12},
    "shadows": {"sm": "0 2px 4px rgba(0,0,0,.08)", "md": "0 4px 12px rgba(0,0,0,.12)", "lg": "0 12px 32px rgba(0,0,0,.16)"},
    "contrast": {"minTextContrast": 7, "minUiContrast": 4.5}
  },
  "design": {
    "pattern": "data-focused",
    "visualHierarchy": {
      "primaryFocus": "chart1",
      "secondaryFocus": ["title", "b1"],
      "emphasisLevels": {"chart1": 5, "title": 4, "b1": 3, "subtitle": 2}
    },
    "whitespace": {
      "strategy": "balanced",
      "breathingRoom": 32
    },
    "typography": {
      "strategy": "modern",
      "fontPairing": {"primary": "Inter, sans-serif", "secondary": "Inter, sans-serif"},
      "hierarchy": {
        "title": {"size": 40, "weight": 700, "lineHeight": 1.2, "letterSpacing": 0.5},
        "subtitle": {"size": 20, "weight": 500, "lineHeight": 1.4},
        "body": {"size": 16, "weight": 400, "lineHeight": 1.5}
      }
    },
    "colorStrategy": {
      "distribution": "complementary",
      "emphasis": "#10B981",
      "contrast": "high"
    }
  }
}

EXAMPLE 2 - Premium Educational Content (Split Pattern):
User: "Introduction to photosynthesis for high school students"
Output: {
  "meta": {"version": "1.0", "locale": "en-US", "theme": "Premium Education", "aspectRatio": "16:9"},
  "content": {
    "title": {"id": "title", "text": "Photosynthesis"},
    "subtitle": {"id": "subtitle", "text": "How Plants Convert Light into Energy"},
    "bullets": [{"id": "b1", "items": [
      {"text": "Process occurs in chloroplasts", "level": 1},
      {"text": "Requires sunlight, water, and CO₂", "level": 1},
      {"text": "Produces glucose and oxygen", "level": 1},
      {"text": "Essential for life on Earth", "level": 1}
    ]}],
    "callouts": [{"id": "c1", "title": "Key Formula", "text": "6CO₂ + 6H₂O + Light → C₆H₁₂O₆ + 6O₂", "variant": "note"}]
  },
  "layout": {
    "grid": {"rows": 8, "cols": 12, "gutter": 8, "margin": {"t": 32, "r": 32, "b": 32, "l": 32}},
    "regions": [
      {"name": "header", "rowStart": 1, "colStart": 1, "rowSpan": 2, "colSpan": 12},
      {"name": "body", "rowStart": 3, "colStart": 1, "rowSpan": 5, "colSpan": 6},
      {"name": "aside", "rowStart": 3, "colStart": 7, "rowSpan": 5, "colSpan": 6}
    ],
    "anchors": [
      {"refId": "title", "region": "header", "order": 0},
      {"refId": "subtitle", "region": "header", "order": 1},
      {"refId": "b1", "region": "body", "order": 0},
      {"refId": "c1", "region": "aside", "order": 0}
    ]
  },
  "styleTokens": {
    "palette": {"primary": "#0D9488", "accent": "#F59E0B", "neutral": ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"]},
    "typography": {
      "fonts": {"sans": "Inter, Arial, sans-serif"},
      "sizes": {"step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 20, "step_2": 28, "step_3": 44},
      "weights": {"regular": 400, "medium": 500, "semibold": 600, "bold": 700},
      "lineHeights": {"compact": 1.2, "standard": 1.6}
    },
    "spacing": {"base": 4, "steps": [0,4,8,12,16,24,32]},
    "radii": {"sm": 4, "md": 8, "lg": 12},
    "shadows": {"sm": "0 2px 4px rgba(0,0,0,.08)", "md": "0 4px 12px rgba(0,0,0,.12)", "lg": "0 12px 32px rgba(0,0,0,.16)"},
    "contrast": {"minTextContrast": 7, "minUiContrast": 4.5}
  },
  "design": {
    "pattern": "split",
    "visualHierarchy": {
      "primaryFocus": "b1",
      "secondaryFocus": ["title", "c1"],
      "emphasisLevels": {"title": 5, "b1": 4, "c1": 4, "subtitle": 2}
    },
    "whitespace": {
      "strategy": "balanced",
      "breathingRoom": 32
    },
    "typography": {
      "strategy": "modern",
      "fontPairing": {"primary": "Inter, sans-serif", "secondary": "Inter, sans-serif"},
      "hierarchy": {
        "title": {"size": 44, "weight": 700, "lineHeight": 1.2, "letterSpacing": 0.5},
        "subtitle": {"size": 24, "weight": 600, "lineHeight": 1.4},
        "body": {"size": 16, "weight": 400, "lineHeight": 1.6}
      }
    },
    "colorStrategy": {
      "distribution": "analogous",
      "emphasis": "#F59E0B",
      "contrast": "high"
    }
  }
}

EXAMPLE 3 - Premium Marketing Presentation (Hero Pattern):
User: "Product launch announcement with key features"
Output: {
  "meta": {"version": "1.0", "locale": "en-US", "theme": "Premium Marketing", "aspectRatio": "16:9"},
  "content": {
    "title": {"id": "title", "text": "Introducing Our New Product"},
    "subtitle": {"id": "subtitle", "text": "Innovation Meets Excellence"},
    "bullets": [{"id": "b1", "items": [
      {"text": "Advanced AI-powered features", "level": 1},
      {"text": "Seamless integration with existing tools", "level": 2},
      {"text": "50% faster performance", "level": 1},
      {"text": "Enterprise-grade security", "level": 1}
    ]}],
    "callouts": [{"id": "c1", "title": "Special Launch Offer", "text": "Get 30% off for early adopters", "variant": "success"}]
  },
  "layout": {
    "grid": {"rows": 8, "cols": 12, "gutter": 8, "margin": {"t": 32, "r": 32, "b": 32, "l": 32}},
    "regions": [
      {"name": "header", "rowStart": 1, "colStart": 1, "rowSpan": 4, "colSpan": 12},
      {"name": "body", "rowStart": 5, "colStart": 1, "rowSpan": 2, "colSpan": 12},
      {"name": "footer", "rowStart": 7, "colStart": 1, "rowSpan": 1, "colSpan": 12}
    ],
    "anchors": [
      {"refId": "title", "region": "header", "order": 0},
      {"refId": "subtitle", "region": "header", "order": 1},
      {"refId": "b1", "region": "body", "order": 0},
      {"refId": "c1", "region": "footer", "order": 0}
    ]
  },
  "styleTokens": {
    "palette": {"primary": "#7C3AED", "accent": "#F59E0B", "neutral": ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"]},
    "typography": {
      "fonts": {"sans": "Inter, Arial, sans-serif"},
      "sizes": {"step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 20, "step_2": 28, "step_3": 52},
      "weights": {"regular": 400, "medium": 500, "semibold": 600, "bold": 700},
      "lineHeights": {"compact": 1.2, "standard": 1.5}
    },
    "spacing": {"base": 4, "steps": [0,4,8,12,16,24,32]},
    "radii": {"sm": 4, "md": 8, "lg": 16},
    "shadows": {"sm": "0 2px 4px rgba(0,0,0,.08)", "md": "0 4px 12px rgba(0,0,0,.12)", "lg": "0 12px 32px rgba(0,0,0,.16)"},
    "contrast": {"minTextContrast": 7, "minUiContrast": 4.5}
  },
  "design": {
    "pattern": "hero",
    "visualHierarchy": {
      "primaryFocus": "title",
      "secondaryFocus": ["subtitle", "b1", "c1"],
      "emphasisLevels": {"title": 5, "subtitle": 4, "b1": 3, "c1": 4}
    },
    "whitespace": {
      "strategy": "generous",
      "breathingRoom": 40
    },
    "typography": {
      "strategy": "modern",
      "fontPairing": {"primary": "Inter, sans-serif", "secondary": "Inter, sans-serif"},
      "hierarchy": {
        "title": {"size": 52, "weight": 700, "lineHeight": 1.2, "letterSpacing": 0.5},
        "subtitle": {"size": 28, "weight": 600, "lineHeight": 1.3},
        "body": {"size": 16, "weight": 400, "lineHeight": 1.5}
      }
    },
    "colorStrategy": {
      "distribution": "complementary",
      "emphasis": "#F59E0B",
      "contrast": "high"
    }
  }
}

PREMIUM CONTENT QUALITY STANDARDS FOR SINGLE SLIDES:
- Titles: Clear, concise, impactful (3-7 words) - use power words
- Subtitles: Provide context and support the title (5-10 words)
- Language: Action-oriented, benefit-focused, specific metrics
- Bullet points: Parallel structure, scannable, max 4-5 bullets total
- Each bullet: One complete thought, 8-15 words ideal
- Callouts: Use sparingly for CTAs, key insights, or critical information
- Charts: Choose types that illuminate data intelligently
- Avoid: Clutter, generic language, more than 5 bullets total
- Focus: Every element should support a single, clear message

CHART TYPE SELECTION GUIDE:
Choose the optimal chart type based on data characteristics and storytelling goals:

1. **Bar Chart** (kind: "bar") - Best for comparing discrete categories
   - Use when: Comparing values across categories (sales by region, product performance)
   - Data: 2-12 categories, 1-3 series
   - Example: "Compare Q4 sales across 5 regions"

2. **Line Chart** (kind: "line") - Best for showing trends over time
   - Use when: Time series data, continuous trends, multiple series comparison
   - Data: 5+ time periods, 1-4 series
   - Example: "Revenue growth over 12 months"

3. **Doughnut Chart** (kind: "doughnut") - Modern alternative to pie, shows part-to-whole
   - Use when: Showing proportions/percentages, 3-6 categories, single series
   - Data: 3-6 categories that sum to 100%
   - Example: "Market share distribution across 5 competitors"

4. **Area Chart** (kind: "area") - Shows magnitude/volume over time
   - Use when: Emphasizing total volume, cumulative trends, stacked comparisons
   - Data: 8+ time periods, 1-3 series
   - Example: "Total user growth over 24 months"

5. **Scatter Chart** (kind: "scatter") - Shows correlation between two variables
   - Use when: Analyzing relationships, finding patterns, showing distribution
   - Data: 10-50 data points, 1-3 series
   - Example: "Correlation between ad spend and conversions"

6. **Waterfall Chart** (kind: "waterfall") - Shows cumulative effect of sequential values
   - Use when: Breaking down changes, showing positive/negative contributions
   - Data: 4-10 sequential steps with positive/negative values
   - Example: "Revenue breakdown from gross to net profit"

7. **Combo Chart** (kind: "combo") - Combines multiple chart types (bar + line)
   - Use when: Comparing different metrics with different scales
   - Data: 2 series with different units/scales
   - Example: "Revenue (bars) vs. profit margin % (line)"

8. **Funnel Chart** (kind: "funnel") - Shows progressive reduction through stages
   - Use when: Conversion funnels, process stages, filtering steps
   - Data: 3-7 sequential stages with decreasing values
   - Example: "Sales funnel from leads to closed deals"

CHART SELECTION DECISION TREE:
- Showing proportions/percentages? → doughnut (modern) or pie (traditional)
- Showing trends over time? → line (trends) or area (volume)
- Comparing categories? → bar (standard) or waterfall (cumulative)
- Showing correlation? → scatter
- Showing process/funnel? → funnel
- Multiple metrics, different scales? → combo

IMAGE INTEGRATION GUIDE:
Use images strategically to enhance visual impact and storytelling:

1. **Hero Images** (role: "hero") - Large, impactful visuals
   - Use when: Product launches, announcements, emotional storytelling
   - Placement: Center or left side, 60-70% of slide
   - Source types:
     * Unsplash: { "type": "unsplash", "query": "business team collaboration" }
     * URL: { "type": "url", "url": "https://example.com/image.jpg" }
   - Example: Product launch slide with hero product image

2. **Logos** (role: "logo") - Brand identity, partner logos
   - Use when: Company presentations, partnership announcements
   - Placement: Top-right corner, small and subtle
   - Size: 1x1 inch, maintains aspect ratio
   - Example: Company logo on every slide

3. **Illustrations** (role: "illustration") - Supporting visuals
   - Use when: Explaining concepts, adding visual interest
   - Placement: Right side or bottom, 30-40% of slide
   - Example: Infographic-style illustration for process explanation

4. **Icons** (role: "icon") - Small visual markers
   - Use when: Bullet points, feature lists, step indicators
   - Placement: Inline with text, small size
   - Size: 0.5x0.5 inch
   - Example: Icons next to feature bullet points

5. **Background Images** (role: "background") - Full-slide backgrounds
   - Use when: Creating mood, hero slides, section dividers
   - Placement: Full slide with text overlay
   - Opacity: Use semi-transparent overlay for text readability
   - Example: Inspirational quote slide with background image

IMAGE SOURCE SELECTION:
- **Unsplash** (recommended): High-quality, free stock photos
  * Use descriptive queries: "modern office workspace", "technology abstract blue"
  * Best for: Generic business, tech, lifestyle imagery
  * Example: { "type": "unsplash", "query": "business growth chart" }

- **URL**: Direct image links
  * Use for: Specific product images, logos, custom graphics
  * Ensure HTTPS and valid image formats (jpg, png, webp)
  * Example: { "type": "url", "url": "https://cdn.example.com/product.jpg" }

- **Placeholder**: Colored rectangles with text
  * Use for: Mockups, wireframes, temporary slides
  * Example: { "type": "placeholder" }

SMART IMAGE QUERY SUGGESTIONS:
Based on slide content, suggest relevant Unsplash queries:
- Business/Corporate → "business professional office modern"
- Technology → "technology abstract digital blue"
- Finance → "finance growth chart business"
- Healthcare → "healthcare medical professional"
- Marketing → "marketing creative design colorful"
- Success/Growth → "success achievement growth arrow"
- Innovation → "innovation technology future abstract"
- Teamwork → "team collaboration meeting diverse"

IMAGE BEST PRACTICES:
- Use images sparingly (1-2 per slide maximum)
- Ensure images support the message, not distract
- Maintain consistent image style across presentation
- Use high-resolution images (1920x1080 minimum for hero)
- Consider color harmony with slide palette
- Always provide descriptive alt text for accessibility
- Avoid cliché stock photos (handshakes, pointing at charts)

ADVANCED TYPOGRAPHY GUIDELINES:
Create visual hierarchy and readability through sophisticated typography:

1. **Font Pairing Strategies**
   - Professional: Calibri (heading + body) - Clean, corporate, safe
   - Elegant: Georgia (heading) + Garamond (body) - Sophisticated, luxury
   - Modern: Segoe UI (heading + body) - Contemporary, tech-forward
   - Bold: Impact (heading) + Arial (body) - Strong, attention-grabbing
   - Minimal: Arial (heading + body with weight variation) - Simple, timeless

2. **Typography Hierarchy Levels**
   - Level 1 (Hero Title): 44-56px, bold (700), tight line-height (1.1-1.2)
   - Level 2 (Main Title): 32-40px, semibold (600), standard line-height (1.2-1.3)
   - Level 3 (Subtitle): 20-28px, medium (500), relaxed line-height (1.3-1.4)
   - Level 4 (Body): 16-18px, regular (400), comfortable line-height (1.5-1.6)
   - Level 5 (Caption): 12-14px, regular (400), standard line-height (1.4)

3. **Text Effects & Enhancements**
   - **Pull Quotes**: Large, italic, serif font with accent bar on left
   - **Callout Boxes**: Colored background, border, icon, title + body
   - **Highlighted Text**: Semi-transparent background highlight for emphasis
   - **Text Shadows**: Subtle shadows (2-4px blur, 0.1-0.2 opacity) for depth
   - **Letter Spacing**: +0.5px for titles, 0px for body, -0.5px for dense text

4. **Smart Text Fitting**
   - Auto-adjust font size to fit content within bounds
   - Maintain readability (minimum 12px for body, 16px for titles)
   - Use shrink-to-fit for dynamic content
   - Break long text into multiple columns if needed

5. **Multi-Column Layouts**
   - Use 2-3 columns for dense text content
   - Maintain 0.3-0.5 inch gap between columns
   - Ensure balanced column heights
   - Best for: Long lists, feature comparisons, detailed content

6. **Readability Best Practices**
   - Line length: 50-75 characters per line (optimal)
   - Line height: 1.4-1.6 for body text, 1.2-1.3 for headings
   - Paragraph spacing: 0.5-1em between paragraphs
   - Contrast: Minimum 7:1 for WCAG AAA compliance
   - Alignment: Left-aligned for body (easier to read), centered for titles

7. **Typography Don'ts**
   - ❌ Don't use more than 2-3 font families per presentation
   - ❌ Don't use all caps for long text (reduces readability by 13%)
   - ❌ Don't use font sizes below 12px (unreadable from distance)
   - ❌ Don't use decorative fonts for body text
   - ❌ Don't use tight letter spacing for body text
   - ❌ Don't mix too many font weights (stick to 2-3)

ANIMATION & TRANSITION GUIDELINES:
Use animations strategically to guide attention and create professional flow:

1. **Slide Transitions** (between slides)
   - **Fade**: Universal, professional, safe choice for all presentations
   - **Push**: Modern, directional, good for sequential content
   - **Wipe**: Clean, directional, emphasizes flow
   - **Split**: Dramatic, reveals content from center or edges
   - **Dissolve**: Smooth, elegant, luxury feel
   - **Zoom**: Dynamic, energetic, tech/startup presentations
   - Duration: 800-1200ms (fast enough to maintain pace, slow enough to be smooth)

2. **Entrance Animations** (elements appearing)
   - **Fade**: Subtle, professional, works for all elements
   - **Fly-in**: Dynamic, directional (left/right/top/bottom)
   - **Zoom**: Attention-grabbing, use for key points
   - **Wipe**: Clean reveal, good for charts and images
   - **Appear**: Instant, no animation (use sparingly)
   - Duration: 400-600ms for text, 600-800ms for charts/images

3. **Animation Sequencing Best Practices**
   - Title appears first (0ms delay)
   - Subtitle appears second (200-300ms delay)
   - Bullets appear one-by-one (150-200ms between each)
   - Charts/images appear after text (300-500ms delay)
   - Total sequence: Keep under 3-4 seconds

4. **Pattern-Specific Animation Recommendations**
   - **Hero Pattern**: Zoom entrance + Fade transition (dramatic, impactful)
   - **Split Pattern**: Wipe entrance + Split transition (emphasizes division)
   - **Asymmetric Pattern**: Fly-in entrance + Push transition (dynamic, modern)
   - **Grid Pattern**: Appear entrance + Dissolve transition (clean, organized)
   - **Minimal Pattern**: Fade entrance + Fade transition (subtle, elegant)
   - **Data-Focused Pattern**: Wipe entrance + Wipe transition (reveals data progressively)

5. **Animation Don'ts**
   - ❌ Don't use more than 2-3 animation types per slide
   - ❌ Don't use bouncing, spinning, or flashy animations (unprofessional)
   - ❌ Don't animate every element (causes fatigue)
   - ❌ Don't use long durations (>1000ms for entrance, >1500ms for transitions)
   - ❌ Don't use exit animations unless necessary (distracting)
   - ❌ Don't use emphasis animations (pulse, grow) in professional contexts

6. **When to Skip Animations**
   - Internal team meetings (focus on content, not presentation)
   - Data-heavy slides (animations slow down information consumption)
   - Printed handouts (animations don't translate)
   - Time-constrained presentations (animations add time)
   - Accessibility concerns (some animations cause motion sickness)

7. **Animation Configuration in SlideSpec**
   Example structure:
   {
     "design": {
       "animations": {
         "entrance": [
           {"type": "fade", "duration": 600, "delay": 0},
           {"type": "fly-in", "duration": 400, "delay": 200}
         ]
       }
     }
   }
   - Use sparingly - only include if animations add value
   - Default to no animations for professional presentations
   - Include only for high-stakes presentations (pitches, keynotes)

INTELLIGENT BULLET POINT DETECTION:
When to use bullets:
✓ Lists of related items (features, benefits, steps, metrics)
✓ Multiple related points that need equal emphasis
✓ Content that benefits from scannable format
✓ 3-6 items that are conceptually similar

When NOT to use bullets:
✗ Single concept or narrative flow
✗ Content requiring detailed explanation
✗ Hierarchical information (use nested levels 1-3 instead)
✗ When a chart or callout would be more effective

Bullet formatting rules:
- Each bullet is ONE complete thought (8-15 words ideal)
- Parallel structure: start each with similar grammatical form
- Use level 1 for main points, level 2-3 for sub-points only when needed
- Maximum 5 bullets per level 1 group
- Separate related concepts into different bullet groups if needed

PREMIUM COLOR PALETTE SELECTION:
- Tech/Innovation: Deep Blue (#1E40AF), Purple (#7C3AED), Cyan (#06B6D4)
- Finance/Banking: Navy (#0F172A), Emerald (#10B981), Gold (#F59E0B)
- Healthcare: Teal (#0D9488), Sky Blue (#0EA5E9), Sage (#10B981)
- Creative/Marketing: Magenta (#EC4899), Amber (#F59E0B), Violet (#8B5CF6)
- Corporate: Slate (#475569), Indigo (#4F46E5), Charcoal (#1F2937)

PREMIUM DESIGN CHECKLIST:
✓ Generous white space (28-50% of slide)
✓ Sophisticated color palette (1-2 accent colors max)
✓ Professional typography with proper hierarchy
✓ Consistent alignment to 8px or 16px grid
✓ Subtle shadows for depth (0 4px 12px rgba(0,0,0,0.08))
✓ WCAG AAA contrast ratios (7:1 minimum)
✓ Minimum margins of 32px (0.44in)
✓ Clear visual hierarchy with 3-4 levels max
✓ Balanced composition using rule of thirds

SPACING & FORMATTING REQUIREMENTS:
- Title: Bold, large (40-52pt), top-left position
- Subtitle: Medium weight, smaller (20-28pt), gray color, below title
- Bullets: Each on separate line with proper spacing
  • Use level 1 for main points (no indentation)
  • Use level 2 for sub-points (indented, if needed)
  • Maintain consistent spacing between bullets
  • Ensure readability with adequate line height
- Body text: Regular weight, readable size (16-18pt)
- Callouts: Use for emphasis, key metrics, or CTAs only

STRICT FORMATTING RULES FOR BULLETS:
1. Each bullet item must be a single, complete thought
2. No run-on sentences or multiple concepts per bullet
3. Parallel structure: all bullets start with similar grammatical form
4. Maximum 5 bullets per group (use multiple groups if needed)
5. Each bullet should be 8-15 words for optimal readability
6. Avoid generic filler words; be specific and actionable

Now generate a slide specification based on the user's prompt. Remember: OUTPUT ONLY THE JSON, NOTHING ELSE.
`;

/** Simple system prompt for fallback */
export const SIMPLE_SYSTEM_PROMPT = `
You are the SlideSpec generator for plzfixthx.
Return a SINGLE RFC8259-compliant JSON object that VALIDATES against SlideSpec v1.
Hard rules:
- Output ONLY JSON.
- meta.version "1.0"; aspectRatio "16:9" default.
- Concise, professional text; <=6 bullets total; levels 1-3.
- If dataViz present, labels 2..10; series lengths == labels length.
- Hex colors (#RRGGBB). IDs [A-Za-z0-9_-].
`;



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/promptTemplates.ts
=================================================================================
/**
 * Industry-Specific Prompt Templates
 * Tailored prompts for different industries, audiences, and use cases
 */

export interface PromptTemplate {
  name: string;
  description: string;
  systemPrompt: string;
  examplePrompts: string[];
  designGuidelines: {
    colorPalette: string[];
    typography: string;
    patterns: string[];
    tone: string;
  };
}

/**
 * Tech/Startup Pitch Deck Template
 */
export const TECH_PITCH_DECK: PromptTemplate = {
  name: "Tech Pitch Deck",
  description: "For startups pitching to investors - problem, solution, market, traction",
  systemPrompt: `
You are creating a tech startup pitch deck. Follow Y Combinator and Sequoia Capital best practices:

STRUCTURE (10-12 slides):
1. Title + Tagline (hero pattern)
2. Problem (minimal pattern with bold statement)
3. Solution (hero pattern with product visual)
4. Market Size (data-focused with TAM/SAM/SOM)
5. Product Demo (split pattern with screenshots)
6. Business Model (grid pattern)
7. Traction (data-focused with growth metrics)
8. Competition (split pattern comparison)
9. Team (grid pattern with photos)
10. Financials (data-focused with projections)
11. Ask (minimal pattern with clear CTA)

DESIGN STYLE:
- Modern, bold, innovative
- Colors: Deep blues (#1E40AF), purples (#7C3AED), cyans (#06B6D4)
- Typography: Modern sans-serif (Inter, Poppins)
- Generous white space (40%+)
- Data visualizations for all metrics
- Minimal text (3-5 bullets max per slide)

TONE:
- Confident but not arrogant
- Data-driven and specific
- Vision-focused
- Action-oriented
`,
  examplePrompts: [
    "Create a pitch deck for an AI-powered customer service platform",
    "Pitch deck for a B2B SaaS productivity tool",
    "Investor presentation for a fintech mobile app"
  ],
  designGuidelines: {
    colorPalette: ["#1E40AF", "#7C3AED", "#06B6D4", "#10B981"],
    typography: "Inter, Poppins - modern sans-serif",
    patterns: ["hero", "minimal", "data-focused", "split"],
    tone: "confident, visionary, data-driven"
  }
};

/**
 * Corporate Quarterly Business Review Template
 */
export const CORPORATE_QBR: PromptTemplate = {
  name: "Quarterly Business Review",
  description: "For executive presentations on quarterly performance and strategy",
  systemPrompt: `
You are creating a corporate quarterly business review for executive leadership.

STRUCTURE (8-10 slides):
1. Executive Summary (minimal pattern)
2. Q4 Highlights (grid pattern with key wins)
3. Financial Performance (data-focused with charts)
4. Key Metrics Dashboard (data-focused)
5. Strategic Initiatives Progress (split pattern)
6. Challenges & Risks (minimal pattern with callouts)
7. Q1 Priorities (grid pattern)
8. Recommendations (minimal pattern)

DESIGN STYLE:
- Professional, conservative, trustworthy
- Colors: Navy (#0F172A), slate (#475569), emerald (#10B981)
- Typography: Professional serif/sans (Georgia, Calibri)
- Balanced white space (30-35%)
- Heavy use of data visualizations
- Clear hierarchy and structure

TONE:
- Formal and professional
- Fact-based and analytical
- Strategic and forward-looking
- Transparent about challenges
`,
  examplePrompts: [
    "Q4 2024 business review for sales organization",
    "Quarterly performance review for product team",
    "Executive summary of Q3 results and Q4 outlook"
  ],
  designGuidelines: {
    colorPalette: ["#0F172A", "#475569", "#10B981", "#F59E0B"],
    typography: "Georgia, Calibri - professional and readable",
    patterns: ["data-focused", "split", "minimal", "grid"],
    tone: "formal, analytical, strategic"
  }
};

/**
 * Sales Presentation Template
 */
export const SALES_PRESENTATION: PromptTemplate = {
  name: "Sales Presentation",
  description: "For sales teams presenting to prospects - value proposition and ROI",
  systemPrompt: `
You are creating a sales presentation following SPIN selling methodology.

STRUCTURE (6-8 slides):
1. Title + Agenda (hero pattern)
2. Customer Pain Points (minimal pattern with bold statements)
3. Our Solution (hero pattern with product benefits)
4. How It Works (split pattern with process)
5. ROI & Value (data-focused with financial impact)
6. Customer Success Stories (grid pattern with logos/quotes)
7. Pricing & Packages (grid pattern)
8. Next Steps (minimal pattern with clear CTA)

DESIGN STYLE:
- Persuasive, benefit-focused, customer-centric
- Colors: Trust blue (#3B82F6), success green (#10B981), accent gold (#F59E0B)
- Typography: Friendly sans-serif (Segoe UI, Arial)
- Balanced white space (32-38%)
- Focus on benefits over features
- Use customer testimonials and social proof

TONE:
- Consultative and helpful
- Benefit-focused (not feature-focused)
- Specific and quantifiable
- Urgency without pressure
`,
  examplePrompts: [
    "Sales deck for enterprise software solution",
    "Product presentation for B2B service offering",
    "Value proposition deck for new customer segment"
  ],
  designGuidelines: {
    colorPalette: ["#3B82F6", "#10B981", "#F59E0B", "#8B5CF6"],
    typography: "Segoe UI, Arial - friendly and approachable",
    patterns: ["hero", "split", "data-focused", "grid"],
    tone: "consultative, benefit-focused, specific"
  }
};

/**
 * Training/Educational Template
 */
export const TRAINING_DECK: PromptTemplate = {
  name: "Training & Education",
  description: "For internal training, workshops, and educational content",
  systemPrompt: `
You are creating an educational training presentation following adult learning principles.

STRUCTURE (12-15 slides):
1. Title + Learning Objectives (hero pattern)
2. Agenda (minimal pattern)
3. Why This Matters (minimal pattern with context)
4. Core Concepts (split pattern for each concept)
5. Step-by-Step Process (grid pattern with numbered steps)
6. Examples & Case Studies (split pattern)
7. Common Mistakes (grid pattern with warnings)
8. Best Practices (grid pattern with tips)
9. Practice Exercise (minimal pattern)
10. Q&A (minimal pattern)
11. Resources & Next Steps (grid pattern)

DESIGN STYLE:
- Clear, educational, accessible
- Colors: Friendly blues (#0EA5E9), greens (#10B981), warm oranges (#F97316)
- Typography: Readable sans-serif (Arial, Verdana)
- Generous white space (38-42%)
- Use icons and visual aids
- Step-by-step breakdowns
- Callouts for key points

TONE:
- Educational and supportive
- Clear and simple language
- Encouraging and positive
- Practical and actionable
`,
  examplePrompts: [
    "Training deck on new software platform",
    "Workshop presentation on leadership skills",
    "Educational content on data privacy compliance"
  ],
  designGuidelines: {
    colorPalette: ["#0EA5E9", "#10B981", "#F97316", "#8B5CF6"],
    typography: "Arial, Verdana - clear and readable",
    patterns: ["split", "grid", "minimal", "asymmetric"],
    tone: "educational, supportive, practical"
  }
};

/**
 * Marketing Campaign Template
 */
export const MARKETING_CAMPAIGN: PromptTemplate = {
  name: "Marketing Campaign",
  description: "For marketing teams presenting campaign strategies and creative concepts",
  systemPrompt: `
You are creating a marketing campaign presentation with creative flair.

STRUCTURE (8-10 slides):
1. Campaign Overview (hero pattern with bold visual)
2. Target Audience (split pattern with personas)
3. Key Message & Positioning (minimal pattern)
4. Creative Concept (hero pattern with mockups)
5. Channel Strategy (grid pattern)
6. Content Calendar (data-focused with timeline)
7. Success Metrics (data-focused with KPIs)
8. Budget & Resources (grid pattern)
9. Timeline & Milestones (data-focused)

DESIGN STYLE:
- Creative, bold, eye-catching
- Colors: Vibrant magenta (#EC4899), amber (#F59E0B), violet (#8B5CF6)
- Typography: Modern and expressive (Poppins, Montserrat)
- Generous white space (40-45%)
- Use mockups and visual examples
- Bold imagery and graphics
- Asymmetric layouts for visual interest

TONE:
- Creative and inspiring
- Brand-focused
- Metrics-driven
- Energetic and enthusiastic
`,
  examplePrompts: [
    "Campaign deck for product launch",
    "Marketing strategy presentation for Q1",
    "Creative brief for brand refresh campaign"
  ],
  designGuidelines: {
    colorPalette: ["#EC4899", "#F59E0B", "#8B5CF6", "#06B6D4"],
    typography: "Poppins, Montserrat - modern and expressive",
    patterns: ["hero", "asymmetric", "split", "grid"],
    tone: "creative, inspiring, energetic"
  }
};

/**
 * Get template by industry and use case
 */
export function getPromptTemplate(
  industry: "tech" | "corporate" | "sales" | "education" | "marketing",
  useCase?: "pitch" | "review" | "training" | "campaign"
): PromptTemplate {
  const templates: Record<string, PromptTemplate> = {
    "tech-pitch": TECH_PITCH_DECK,
    "corporate-review": CORPORATE_QBR,
    "sales-presentation": SALES_PRESENTATION,
    "education-training": TRAINING_DECK,
    "marketing-campaign": MARKETING_CAMPAIGN
  };

  const key = `${industry}-${useCase || "presentation"}`;
  
  // Map to closest template
  if (industry === "tech") return TECH_PITCH_DECK;
  if (industry === "corporate") return CORPORATE_QBR;
  if (industry === "sales") return SALES_PRESENTATION;
  if (industry === "education") return TRAINING_DECK;
  if (industry === "marketing") return MARKETING_CAMPAIGN;
  
  return CORPORATE_QBR; // Default fallback
}

/**
 * Enhance user prompt with template-specific guidance
 */
export function enhancePromptWithTemplate(
  userPrompt: string,
  template: PromptTemplate
): string {
  return `
${template.systemPrompt}

USER REQUEST: ${userPrompt}

Apply the ${template.name} template structure and design guidelines.
Use the recommended color palette: ${template.designGuidelines.colorPalette.join(", ")}
Typography: ${template.designGuidelines.typography}
Tone: ${template.designGuidelines.tone}
`;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/slideRefinement.ts
=================================================================================
/**
 * Slide Refinement & Iterative Improvement
 * A/B variants, smart suggestions, auto-fix common issues
 */

import { logger } from "firebase-functions/v2";
import type { SlideSpecV1 } from "./types/SlideSpecV1";

export interface RefinementRequest {
  slide: SlideSpecV1;
  feedback: string;
  refinementType: "improve" | "simplify" | "enhance" | "fix" | "variant";
}

export interface SlideIssue {
  severity: "error" | "warning" | "suggestion";
  category: "content" | "design" | "accessibility" | "performance";
  message: string;
  fix?: string;
  autoFixable: boolean;
}

export interface RefinementSuggestion {
  type: "content" | "design" | "layout" | "color" | "typography";
  priority: "high" | "medium" | "low";
  suggestion: string;
  rationale: string;
  autoApplicable: boolean;
}

/**
 * Analyze slide for common issues
 */
export function analyzeSlideQuality(slide: SlideSpecV1): SlideIssue[] {
  const issues: SlideIssue[] = [];

  // Check title length
  if (slide.content.title.text.length > 60) {
    issues.push({
      severity: "warning",
      category: "content",
      message: "Title is too long (>60 characters). Shorter titles are more impactful.",
      fix: "Condense title to 40-50 characters",
      autoFixable: false
    });
  }

  // Check bullet count
  const bulletCount = slide.content.bullets?.reduce((sum, group) => sum + group.items.length, 0) || 0;
  if (bulletCount > 6) {
    issues.push({
      severity: "warning",
      category: "content",
      message: `Too many bullets (${bulletCount}). Limit to 5-6 for better retention.`,
      fix: "Reduce to 5-6 most important points",
      autoFixable: false
    });
  }

  // Check bullet text length
  slide.content.bullets?.forEach((group, groupIdx) => {
    group.items.forEach((item, itemIdx) => {
      if (item.text.length > 100) {
        issues.push({
          severity: "warning",
          category: "content",
          message: `Bullet ${groupIdx + 1}.${itemIdx + 1} is too long (${item.text.length} chars). Keep under 80 characters.`,
          fix: "Break into multiple bullets or simplify",
          autoFixable: false
        });
      }
    });
  });

  // Check color contrast
  const primaryColor = slide.styleTokens.palette.primary;
  const neutralLight = slide.styleTokens.palette.neutral[6];
  if (primaryColor && neutralLight) {
    const contrast = estimateContrast(primaryColor, neutralLight);
    if (contrast < 4.5) {
      issues.push({
        severity: "error",
        category: "accessibility",
        message: `Low color contrast (${contrast.toFixed(1)}:1). WCAG requires 4.5:1 minimum.`,
        fix: "Adjust colors for better contrast",
        autoFixable: true
      });
    }
  }

  // Check for missing subtitle
  if (!slide.content.subtitle && slide.content.title.text.length < 30) {
    issues.push({
      severity: "suggestion",
      category: "content",
      message: "Consider adding a subtitle to provide context",
      fix: "Add descriptive subtitle",
      autoFixable: false
    });
  }

  // Check chart data quality
  if (slide.content.dataViz) {
    const dv = slide.content.dataViz;
    if (dv.labels.length < 2) {
      issues.push({
        severity: "warning",
        category: "content",
        message: "Chart has too few data points. Need at least 2 for meaningful visualization.",
        fix: "Add more data points or remove chart",
        autoFixable: false
      });
    }

    if (dv.labels.length > 12) {
      issues.push({
        severity: "warning",
        category: "design",
        message: "Chart has too many data points (>12). Consider grouping or filtering.",
        fix: "Reduce to 8-10 most important data points",
        autoFixable: false
      });
    }
  }

  // Check for empty content
  if (!slide.content.bullets && !slide.content.dataViz && !slide.content.callouts) {
    issues.push({
      severity: "warning",
      category: "content",
      message: "Slide has only title/subtitle. Add bullets, chart, or callouts.",
      fix: "Add supporting content",
      autoFixable: false
    });
  }

  return issues;
}

/**
 * Generate smart suggestions for slide improvement
 */
export function generateSmartSuggestions(slide: SlideSpecV1): RefinementSuggestion[] {
  const suggestions: RefinementSuggestion[] = [];

  // Suggest data visualization if numbers are present
  const hasNumbers = slide.content.bullets?.some(group =>
    group.items.some(item => /\d+%|\$\d+|^\d+/.test(item.text))
  );

  if (hasNumbers && !slide.content.dataViz) {
    suggestions.push({
      type: "design",
      priority: "high",
      suggestion: "Convert numeric bullets to chart visualization",
      rationale: "Data visualizations are 60% more memorable than text",
      autoApplicable: false
    });
  }

  // Suggest pattern change based on content
  const bulletCount = slide.content.bullets?.reduce((sum, group) => sum + group.items.length, 0) || 0;
  if (bulletCount > 4 && !slide.content.dataViz) {
    suggestions.push({
      type: "layout",
      priority: "medium",
      suggestion: "Consider using grid pattern for better organization",
      rationale: "Grid pattern works well for 4+ items",
      autoApplicable: true
    });
  }

  // Suggest adding callout for key point
  if (bulletCount >= 3 && !slide.content.callouts) {
    suggestions.push({
      type: "content",
      priority: "medium",
      suggestion: "Highlight most important point as callout",
      rationale: "Callouts draw attention to key takeaways",
      autoApplicable: false
    });
  }

  // Suggest color palette improvement
  const primaryColor = slide.styleTokens.palette.primary;
  if (primaryColor === "#000000" || primaryColor === "#FFFFFF") {
    suggestions.push({
      type: "color",
      priority: "high",
      suggestion: "Use a more distinctive primary color",
      rationale: "Black/white primary colors lack visual interest",
      autoApplicable: true
    });
  }

  // Suggest typography improvement
  const titleSize = slide.styleTokens.typography.sizes.step_3;
  if (titleSize < 32) {
    suggestions.push({
      type: "typography",
      priority: "low",
      suggestion: "Increase title size to 36-44px for better hierarchy",
      rationale: "Larger titles create stronger visual hierarchy",
      autoApplicable: true
    });
  }

  // Suggest adding image if none present
  if (!slide.content.imagePlaceholders && !slide.content.images) {
    suggestions.push({
      type: "design",
      priority: "low",
      suggestion: "Consider adding a supporting image or illustration",
      rationale: "Visual elements increase engagement by 80%",
      autoApplicable: false
    });
  }

  return suggestions;
}

/**
 * Auto-fix common issues
 */
export function autoFixSlide(slide: SlideSpecV1, issues: SlideIssue[]): SlideSpecV1 {
  const fixed = JSON.parse(JSON.stringify(slide)); // Deep clone

  for (const issue of issues) {
    if (!issue.autoFixable) continue;

    // Fix low contrast
    if (issue.category === "accessibility" && issue.message.includes("contrast")) {
      // Darken primary color if too light
      const primary = fixed.styleTokens.palette.primary;
      if (primary) {
        fixed.styleTokens.palette.primary = darkenColor(primary, 20);
      }
    }

    // Fix missing color
    if (issue.message.includes("primary color")) {
      fixed.styleTokens.palette.primary = "#3B82F6"; // Default blue
    }

    // Fix small title
    if (issue.message.includes("title size")) {
      fixed.styleTokens.typography.sizes.step_3 = 40;
    }
  }

  return fixed;
}

/**
 * Generate A/B variant of slide
 */
export function generateSlideVariant(
  slide: SlideSpecV1,
  variantType: "color" | "layout" | "typography" | "minimal"
): SlideSpecV1 {
  const variant = JSON.parse(JSON.stringify(slide)); // Deep clone

  switch (variantType) {
    case "color":
      // Alternative color palette
      const colorVariants = [
        { primary: "#7C3AED", accent: "#EC4899" }, // Purple/Pink
        { primary: "#0D9488", accent: "#F59E0B" }, // Teal/Amber
        { primary: "#1E40AF", accent: "#10B981" }  // Blue/Green
      ];
      const randomColor = colorVariants[Math.floor(Math.random() * colorVariants.length)];
      variant.styleTokens.palette.primary = randomColor.primary;
      variant.styleTokens.palette.accent = randomColor.accent;
      break;

    case "layout":
      // Change to different pattern (simplified - would need design field)
      variant.meta.theme = variant.meta.theme + " (Alternative Layout)";
      break;

    case "typography":
      // Alternative font sizes
      variant.styleTokens.typography.sizes.step_3 = 48; // Larger title
      variant.styleTokens.typography.sizes.step_1 = 24; // Larger subtitle
      break;

    case "minimal":
      // Reduce content to essentials
      if (variant.content.bullets) {
        variant.content.bullets = variant.content.bullets.map((group: any) => ({
          ...group,
          items: group.items.slice(0, 3) // Keep only first 3 bullets
        }));
      }
      break;
  }

  return variant;
}

/**
 * Estimate color contrast ratio (simplified)
 */
function estimateContrast(color1: string, color2: string): number {
  // Simplified contrast calculation
  // In production, use proper WCAG contrast calculation
  const lum1 = getLuminance(color1);
  const lum2 = getLuminance(color2);
  const lighter = Math.max(lum1, lum2);
  const darker = Math.min(lum1, lum2);
  return (lighter + 0.05) / (darker + 0.05);
}

/**
 * Get relative luminance of color
 */
function getLuminance(hex: string): number {
  const rgb = hexToRgb(hex);
  if (!rgb) return 0;
  
  const [r, g, b] = [rgb.r, rgb.g, rgb.b].map(val => {
    val = val / 255;
    return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
  });
  
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

/**
 * Convert hex to RGB
 */
function hexToRgb(hex: string): { r: number; g: number; b: number } | null {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}

/**
 * Darken color by percentage
 */
function darkenColor(hex: string, percent: number): string {
  const rgb = hexToRgb(hex);
  if (!rgb) return hex;
  
  const factor = 1 - (percent / 100);
  const r = Math.round(rgb.r * factor);
  const g = Math.round(rgb.g * factor);
  const b = Math.round(rgb.b * factor);
  
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/svgGenerator/backgroundGenerator.ts
=================================================================================
/**
 * SVG Background Generator
 * Creates professional slide backgrounds with gradients and decorative elements
 */

import { createGradientDef, getGradient, createGradientFromPalette, createRadialGradientFromPalette, type GradientConfig } from './gradients';
import {
  createAccentBar,
  createCornerAccent,
  createDecorativeCircles,
  createDividerLine,
  createGeometricPattern,
  createCurvedAccent,
  createGlowFilter,
  createShadowFilter,
  createAbstractShape,
  createGridPattern,
  createArrow,
  createWavePattern,
} from './decorativeElements';

export interface BackgroundConfig {
  width?: number;
  height?: number;
  theme?: 'minimal' | 'professional' | 'creative' | 'tech' | 'elegant';
  palette: {
    primary: string;
    accent: string;
    neutral: string[];
  };
  style?: 'subtle' | 'bold' | 'modern';
}

/**
 * Generate complete SVG background
 */
export function generateBackground(config: BackgroundConfig): string {
  const width = config.width || 1920;
  const height = config.height || 1080;
  const theme = config.theme || 'professional';
  const style = config.style || 'subtle';

  // Get gradient based on palette
  const gradient = createGradientFromPalette(config.palette);

  // Build SVG
  const defs = buildDefs(gradient, config);
  const background = buildBackgroundLayer(gradient, width, height);
  const decorations = buildDecorations(theme, style, config.palette, width, height);

  return `
<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    ${defs}
  </defs>
  
  <!-- Background Layer -->
  ${background}
  
  <!-- Decorative Elements -->
  ${decorations}
</svg>`.trim();
}

/**
 * Build SVG definitions (gradients, filters)
 */
function buildDefs(gradient: GradientConfig, config: BackgroundConfig): string {
  const gradientDef = createGradientDef(gradient);
  const glowFilter = createGlowFilter('glow', config.palette.primary, 10);
  const shadowFilter = createShadowFilter('shadow');

  return `
    ${gradientDef}
    ${glowFilter}
    ${shadowFilter}
  `;
}

/**
 * Build background layer with gradient
 */
function buildBackgroundLayer(gradient: GradientConfig, width: number, height: number): string {
  return `
  <rect width="${width}" height="${height}" fill="url(#${gradient.id})"/>`;
}

/**
 * Build decorative elements based on theme
 */
function buildDecorations(
  theme: string,
  style: string,
  palette: { primary: string; accent: string; neutral: string[] },
  width: number,
  height: number
): string {
  const elements: string[] = [];

  switch (theme) {
    case 'minimal':
      elements.push(...buildMinimalDecorations(palette, style));
      break;
    case 'professional':
      elements.push(...buildProfessionalDecorations(palette, style));
      break;
    case 'creative':
      elements.push(...buildCreativeDecorations(palette, style));
      break;
    case 'tech':
      elements.push(...buildTechDecorations(palette, style));
      break;
    case 'elegant':
      elements.push(...buildElegantDecorations(palette, style));
      break;
    default:
      elements.push(...buildProfessionalDecorations(palette, style));
  }

  return elements.join('\n  ');
}

/**
 * Minimal theme decorations
 */
function buildMinimalDecorations(
  palette: { primary: string; accent: string; neutral: string[] },
  style: string
): string[] {
  const elements: string[] = [];

  // Left accent bar
  elements.push(createAccentBar({ width: 15, color: palette.primary, opacity: 1 }));

  if (style !== 'subtle') {
    // Top-right corner accent
    elements.push(createCornerAccent({ size: 150, color: palette.primary, opacity: 0.15 }));
  }

  return elements;
}

/**
 * Professional theme decorations - Enhanced with sophisticated elements
 */
function buildProfessionalDecorations(
  palette: { primary: string; accent: string; neutral: string[] },
  style: string
): string[] {
  const elements: string[] = [];

  // Left accent bar with subtle gradient effect
  elements.push(createAccentBar({ width: 12, color: palette.primary, opacity: 0.95 }));

  // Top-right corner accent - more subtle
  elements.push(createCornerAccent({ size: 180, color: palette.primary, opacity: 0.12 }));

  // Bottom-right decorative circles - refined positioning
  elements.push(createDecorativeCircles({ x: 1750, y: 920, color: palette.accent, count: 3 }));

  // Add subtle wave pattern at bottom for depth
  elements.push(
    createWavePattern({
      color: palette.primary,
      opacity: 0.03,
      amplitude: 30,
      frequency: 2,
      position: 'bottom',
    })
  );

  if (style === 'bold') {
    // Add curved accent line - more prominent
    elements.push(
      createCurvedAccent({
        startX: 0,
        startY: 1080 * 0.35,
        endX: 1920 * 0.35,
        endY: 0,
        color: palette.accent,
        thickness: 4,
        opacity: 0.25,
      })
    );

    // Add secondary curved accent for balance
    elements.push(
      createCurvedAccent({
        startX: 1920,
        startY: 1080 * 0.65,
        endX: 1920 * 0.65,
        endY: 1080,
        color: palette.primary,
        thickness: 3,
        opacity: 0.15,
      })
    );
  } else if (style === 'modern') {
    // Add subtle geometric accents
    elements.push(
      createAbstractShape({
        x: 1800,
        y: 150,
        size: 200,
        color: palette.accent,
        opacity: 0.06,
        rotation: 25,
      })
    );
  }

  return elements;
}

/**
 * Creative theme decorations - Enhanced with dynamic elements
 */
function buildCreativeDecorations(
  palette: { primary: string; accent: string; neutral: string[] },
  style: string
): string[] {
  const elements: string[] = [];

  // Multiple abstract shapes for visual interest
  elements.push(
    createAbstractShape({
      x: 1650,
      y: 180,
      size: 320,
      color: palette.primary,
      opacity: 0.09,
      rotation: 45,
    })
  );

  elements.push(
    createAbstractShape({
      x: 220,
      y: 880,
      size: 280,
      color: palette.accent,
      opacity: 0.07,
      rotation: -30,
    })
  );

  // Add a third shape for balance
  elements.push(
    createAbstractShape({
      x: 960,
      y: 540,
      size: 200,
      color: palette.primary,
      opacity: 0.04,
      rotation: 15,
    })
  );

  // Dynamic curved accents
  elements.push(
    createCurvedAccent({
      startX: 0,
      startY: 1080 * 0.45,
      endX: 1920 * 0.42,
      endY: 1080 * 0.18,
      color: palette.primary,
      thickness: 5,
      opacity: 0.18,
    })
  );

  elements.push(
    createCurvedAccent({
      startX: 1920,
      startY: 1080 * 0.55,
      endX: 1920 * 0.58,
      endY: 1080,
      color: palette.accent,
      thickness: 5,
      opacity: 0.18,
    })
  );

  // Add decorative circles for depth
  elements.push(createDecorativeCircles({ x: 1800, y: 100, color: palette.primary, count: 2 }));
  elements.push(createDecorativeCircles({ x: 120, y: 980, color: palette.accent, count: 2 }));

  if (style === 'bold') {
    // Add geometric pattern overlay
    elements.push(createGeometricPattern({ color: palette.primary, opacity: 0.04, density: 'low' }));

    // Add wave pattern for extra dynamism
    elements.push(
      createWavePattern({
        color: palette.accent,
        opacity: 0.05,
        amplitude: 40,
        frequency: 3,
        position: 'top',
      })
    );
  }

  return elements;
}

/**
 * Tech theme decorations
 */
function buildTechDecorations(
  palette: { primary: string; accent: string; neutral: string[] },
  style: string
): string[] {
  const elements: string[] = [];

  // Grid pattern
  elements.push(createGridPattern({ color: palette.primary, opacity: 0.03, spacing: 100 }));

  // Corner accents (all four corners)
  elements.push(createCornerAccent({ size: 150, color: palette.primary, opacity: 0.1, position: 'top-left' }));
  elements.push(createCornerAccent({ size: 150, color: palette.primary, opacity: 0.1, position: 'top-right' }));
  elements.push(createCornerAccent({ size: 150, color: palette.accent, opacity: 0.08, position: 'bottom-left' }));
  elements.push(createCornerAccent({ size: 150, color: palette.accent, opacity: 0.08, position: 'bottom-right' }));

  if (style !== 'subtle') {
    // Geometric pattern overlay
    elements.push(createGeometricPattern({ color: palette.accent, opacity: 0.02, density: 'medium' }));
  }

  return elements;
}

/**
 * Elegant theme decorations
 */
function buildElegantDecorations(
  palette: { primary: string; accent: string; neutral: string[] },
  style: string
): string[] {
  const elements: string[] = [];

  // Subtle curved accents
  elements.push(
    createCurvedAccent({
      startX: 0,
      startY: 1080 * 0.2,
      endX: 1920 * 0.5,
      endY: 0,
      color: palette.primary,
      thickness: 2,
      opacity: 0.1,
    })
  );

  elements.push(
    createCurvedAccent({
      startX: 1920,
      startY: 1080 * 0.8,
      endX: 1920 * 0.5,
      endY: 1080,
      color: palette.accent,
      thickness: 2,
      opacity: 0.1,
    })
  );

  // Decorative circles (smaller, more subtle)
  elements.push(createDecorativeCircles({ x: 1850, y: 100, color: palette.primary, count: 2 }));
  elements.push(createDecorativeCircles({ x: 100, y: 980, color: palette.accent, count: 2 }));

  if (style === 'bold') {
    // Abstract shapes
    elements.push(
      createAbstractShape({
        x: 1920 * 0.85,
        y: 1080 * 0.5,
        size: 400,
        color: palette.primary,
        opacity: 0.05,
        rotation: 30,
      })
    );
  }

  return elements;
}

/**
 * Generate background for specific slide type
 */
export function generateBackgroundForSlide(slideSpec: any): string {
  // Extract palette from slide spec (SlideSpecV1 uses styleTokens)
  const palette = {
    primary: slideSpec.styleTokens?.palette?.primary || '#6366F1',
    accent: slideSpec.styleTokens?.palette?.accent || '#10B981',
    neutral: slideSpec.styleTokens?.palette?.neutral || [
      '#1E293B',
      '#334155',
      '#475569',
      '#64748B',
      '#94A3B8',
      '#CBD5E1',
      '#E2E8F0',
      '#F1F5F9',
      '#F8FAFC',
    ],
  };

  // Determine theme based on slide content
  let theme: 'minimal' | 'professional' | 'creative' | 'tech' | 'elegant' = 'professional';
  let style: 'subtle' | 'bold' | 'modern' = 'subtle';

  // Analyze slide content to determine best theme
  const title = slideSpec.content?.title?.text?.toLowerCase() || '';
  const subtitle = slideSpec.content?.subtitle?.text?.toLowerCase() || '';

  if (title.includes('tech') || title.includes('digital') || title.includes('innovation')) {
    theme = 'tech';
  } else if (title.includes('creative') || title.includes('design') || title.includes('art')) {
    theme = 'creative';
    style = 'modern';
  } else if (title.includes('elegant') || title.includes('luxury') || title.includes('premium')) {
    theme = 'elegant';
  } else if (slideSpec.content?.bullets?.length > 5 || slideSpec.content?.dataViz) {
    theme = 'minimal'; // Keep it clean for data-heavy slides
  }

  return generateBackground({ palette, theme, style });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/svgGenerator/converter.ts
=================================================================================
/**
 * SVG to PNG Converter
 * Converts SVG backgrounds to PNG for embedding in PowerPoint
 */

import sharp from 'sharp';

/**
 * Convert SVG string to PNG base64 data URL
 */
export async function svgToPngDataUrl(svgString: string, width: number = 1920, height: number = 1080): Promise<string> {
  try {
    // Convert SVG to PNG buffer using sharp
    const pngBuffer = await sharp(Buffer.from(svgString))
      .resize(width, height, {
        fit: 'fill',
        background: { r: 255, g: 255, b: 255, alpha: 1 },
      })
      .png({
        quality: 100,
        compressionLevel: 6,
      })
      .toBuffer();

    // Convert to base64 data URL
    const base64 = pngBuffer.toString('base64');
    return `data:image/png;base64,${base64}`;
  } catch (error) {
    console.error('Error converting SVG to PNG:', error);
    throw new Error('Failed to convert SVG to PNG');
  }
}

/**
 * Convert SVG string to PNG buffer
 */
export async function svgToPngBuffer(svgString: string, width: number = 1920, height: number = 1080): Promise<Buffer> {
  try {
    return await sharp(Buffer.from(svgString))
      .resize(width, height, {
        fit: 'fill',
        background: { r: 255, g: 255, b: 255, alpha: 1 },
      })
      .png({
        quality: 100,
        compressionLevel: 6,
      })
      .toBuffer();
  } catch (error) {
    console.error('Error converting SVG to PNG:', error);
    throw new Error('Failed to convert SVG to PNG');
  }
}

/**
 * Optimize PNG for smaller file size
 */
export async function optimizePng(pngBuffer: Buffer): Promise<Buffer> {
  try {
    return await sharp(pngBuffer)
      .png({
        quality: 90,
        compressionLevel: 9,
        adaptiveFiltering: true,
      })
      .toBuffer();
  } catch (error) {
    console.error('Error optimizing PNG:', error);
    return pngBuffer; // Return original if optimization fails
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/svgGenerator/decorativeElements.ts
=================================================================================
/**
 * SVG Decorative Elements
 * Professional design accents for slides
 */

export interface DecorativeElementConfig {
  x: number;
  y: number;
  color: string;
  opacity?: number;
}

/**
 * Left accent bar (vertical)
 */
export function createAccentBar(config: {
  width?: number;
  color: string;
  opacity?: number;
}): string {
  const width = config.width || 15;
  const opacity = config.opacity || 1;

  return `
    <rect 
      x="0" 
      y="0" 
      width="${width}" 
      height="1080" 
      fill="${config.color}" 
      opacity="${opacity}"
    />`;
}

/**
 * Top-right corner accent (triangle)
 */
export function createCornerAccent(config: {
  size?: number;
  color: string;
  opacity?: number;
  position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';
}): string {
  const size = config.size || 200;
  const opacity = config.opacity || 0.2;
  const position = config.position || 'top-right';

  let path = '';
  switch (position) {
    case 'top-right':
      path = `M 1920 0 L 1920 ${size} L ${1920 - size} 0 Z`;
      break;
    case 'top-left':
      path = `M 0 0 L ${size} 0 L 0 ${size} Z`;
      break;
    case 'bottom-right':
      path = `M 1920 1080 L 1920 ${1080 - size} L ${1920 - size} 1080 Z`;
      break;
    case 'bottom-left':
      path = `M 0 1080 L ${size} 1080 L 0 ${1080 - size} Z`;
      break;
  }

  return `
    <path 
      d="${path}" 
      fill="${config.color}" 
      opacity="${opacity}"
    />`;
}

/**
 * Decorative circles (bottom-right cluster)
 */
export function createDecorativeCircles(config: {
  x?: number;
  y?: number;
  color: string;
  count?: number;
}): string {
  const x = config.x || 1800;
  const y = config.y || 950;
  const count = config.count || 3;

  const circles = [];
  for (let i = 0; i < count; i++) {
    const radius = 80 - i * 20;
    const offsetX = i * 30;
    const offsetY = i * 30;
    const opacity = 0.1 + i * 0.05;

    circles.push(`
      <circle 
        cx="${x + offsetX}" 
        cy="${y + offsetY}" 
        r="${radius}" 
        fill="${config.color}" 
        opacity="${opacity}"
      />`);
  }

  return circles.join('\n');
}

/**
 * Premium divider line (horizontal)
 */
export function createDividerLine(config: {
  y: number;
  x?: number;
  width?: number;
  height?: number;
  color: string;
  opacity?: number;
}): string {
  const x = config.x || 100;
  const width = config.width || 200;
  const height = config.height || 4;
  const opacity = config.opacity || 1;

  return `
    <rect 
      x="${x}" 
      y="${config.y}" 
      width="${width}" 
      height="${height}" 
      fill="${config.color}" 
      opacity="${opacity}"
      rx="2"
    />`;
}

/**
 * Geometric pattern (subtle background pattern)
 */
export function createGeometricPattern(config: {
  color: string;
  opacity?: number;
  density?: 'low' | 'medium' | 'high';
}): string {
  const opacity = config.opacity || 0.03;
  const density = config.density || 'low';

  const spacing = density === 'low' ? 200 : density === 'medium' ? 100 : 50;
  const size = spacing * 0.3;

  const elements = [];
  for (let x = 0; x < 1920; x += spacing) {
    for (let y = 0; y < 1080; y += spacing) {
      elements.push(`
        <circle 
          cx="${x}" 
          cy="${y}" 
          r="${size}" 
          fill="${config.color}" 
          opacity="${opacity}"
        />`);
    }
  }

  return elements.join('\n');
}

/**
 * Curved accent line (decorative swoosh)
 */
export function createCurvedAccent(config: {
  startX: number;
  startY: number;
  endX: number;
  endY: number;
  color: string;
  thickness?: number;
  opacity?: number;
}): string {
  const thickness = config.thickness || 3;
  const opacity = config.opacity || 0.3;

  // Create a smooth bezier curve
  const controlX1 = config.startX + (config.endX - config.startX) * 0.3;
  const controlY1 = config.startY - 100;
  const controlX2 = config.startX + (config.endX - config.startX) * 0.7;
  const controlY2 = config.endY + 100;

  return `
    <path 
      d="M ${config.startX} ${config.startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${config.endX} ${config.endY}" 
      stroke="${config.color}" 
      stroke-width="${thickness}" 
      fill="none" 
      opacity="${opacity}"
      stroke-linecap="round"
    />`;
}

/**
 * Glow effect filter
 */
export function createGlowFilter(id: string, color: string, intensity: number = 10): string {
  return `
    <filter id="${id}">
      <feGaussianBlur stdDeviation="${intensity}" result="coloredBlur"/>
      <feMerge>
        <feMergeNode in="coloredBlur"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>`;
}

/**
 * Subtle shadow filter
 */
export function createShadowFilter(id: string): string {
  return `
    <filter id="${id}" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
      <feOffset dx="2" dy="2" result="offsetblur"/>
      <feComponentTransfer>
        <feFuncA type="linear" slope="0.2"/>
      </feComponentTransfer>
      <feMerge>
        <feMergeNode/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>`;
}

/**
 * Abstract shape (for modern designs)
 */
export function createAbstractShape(config: {
  x: number;
  y: number;
  size: number;
  color: string;
  opacity?: number;
  rotation?: number;
}): string {
  const opacity = config.opacity || 0.1;
  const rotation = config.rotation || 0;
  const halfSize = config.size / 2;

  // Create an interesting organic shape using path
  const path = `
    M ${config.x} ${config.y - halfSize}
    Q ${config.x + halfSize} ${config.y - halfSize * 0.5}, ${config.x + halfSize} ${config.y}
    Q ${config.x + halfSize} ${config.y + halfSize * 0.5}, ${config.x} ${config.y + halfSize}
    Q ${config.x - halfSize} ${config.y + halfSize * 0.5}, ${config.x - halfSize} ${config.y}
    Q ${config.x - halfSize} ${config.y - halfSize * 0.5}, ${config.x} ${config.y - halfSize}
    Z
  `;

  return `
    <path 
      d="${path}" 
      fill="${config.color}" 
      opacity="${opacity}"
      transform="rotate(${rotation} ${config.x} ${config.y})"
    />`;
}

/**
 * Grid pattern (subtle background)
 */
export function createGridPattern(config: {
  color: string;
  opacity?: number;
  spacing?: number;
}): string {
  const opacity = config.opacity || 0.02;
  const spacing = config.spacing || 100;

  const lines = [];

  // Vertical lines
  for (let x = 0; x < 1920; x += spacing) {
    lines.push(`
      <line 
        x1="${x}" 
        y1="0" 
        x2="${x}" 
        y2="1080" 
        stroke="${config.color}" 
        stroke-width="1" 
        opacity="${opacity}"
      />`);
  }

  // Horizontal lines
  for (let y = 0; y < 1080; y += spacing) {
    lines.push(`
      <line 
        x1="0" 
        y1="${y}" 
        x2="1920" 
        y2="${y}" 
        stroke="${config.color}" 
        stroke-width="1" 
        opacity="${opacity}"
      />`);
  }

  return lines.join('\n');
}

/**
 * Create a sophisticated arrow shape
 */
export function createArrow(config: {
  x: number;
  y: number;
  width: number;
  height: number;
  color: string;
  opacity?: number;
  direction?: 'right' | 'left' | 'up' | 'down';
}): string {
  const opacity = config.opacity || 1;
  const direction = config.direction || 'right';

  let path = '';
  const w = config.width;
  const h = config.height;
  const x = config.x;
  const y = config.y;

  switch (direction) {
    case 'right':
      path = `M ${x} ${y} L ${x + w * 0.7} ${y} L ${x + w * 0.7} ${y - h/2} L ${x + w} ${y + h/2} L ${x + w * 0.7} ${y + h * 1.5} L ${x + w * 0.7} ${y + h} L ${x} ${y + h} Z`;
      break;
    case 'left':
      path = `M ${x + w} ${y} L ${x + w * 0.3} ${y} L ${x + w * 0.3} ${y - h/2} L ${x} ${y + h/2} L ${x + w * 0.3} ${y + h * 1.5} L ${x + w * 0.3} ${y + h} L ${x + w} ${y + h} Z`;
      break;
    case 'up':
      path = `M ${x} ${y + h} L ${x} ${y + h * 0.3} L ${x - w/2} ${y + h * 0.3} L ${x + w/2} ${y} L ${x + w * 1.5} ${y + h * 0.3} L ${x + w} ${y + h * 0.3} L ${x + w} ${y + h} Z`;
      break;
    case 'down':
      path = `M ${x} ${y} L ${x} ${y + h * 0.7} L ${x - w/2} ${y + h * 0.7} L ${x + w/2} ${y + h} L ${x + w * 1.5} ${y + h * 0.7} L ${x + w} ${y + h * 0.7} L ${x + w} ${y} Z`;
      break;
  }

  return `
    <path
      d="${path}"
      fill="${config.color}"
      opacity="${opacity}"
    />`;
}

/**
 * Create a callout box with pointer
 */
export function createCalloutBox(config: {
  x: number;
  y: number;
  width: number;
  height: number;
  color: string;
  borderColor: string;
  opacity?: number;
  pointerPosition?: 'left' | 'right' | 'top' | 'bottom';
}): string {
  const opacity = config.opacity || 1;
  const pointerSize = 20;

  // Main box
  const box = `
    <rect
      x="${config.x}"
      y="${config.y}"
      width="${config.width}"
      height="${config.height}"
      fill="${config.color}"
      stroke="${config.borderColor}"
      stroke-width="2"
      opacity="${opacity}"
      rx="8"
    />`;

  // Pointer triangle
  let pointer = '';
  const centerX = config.x + config.width / 2;
  const centerY = config.y + config.height / 2;

  switch (config.pointerPosition) {
    case 'left':
      pointer = `
        <path
          d="M ${config.x} ${centerY - pointerSize/2} L ${config.x - pointerSize} ${centerY} L ${config.x} ${centerY + pointerSize/2} Z"
          fill="${config.color}"
          stroke="${config.borderColor}"
          stroke-width="2"
          opacity="${opacity}"
        />`;
      break;
    case 'right':
      pointer = `
        <path
          d="M ${config.x + config.width} ${centerY - pointerSize/2} L ${config.x + config.width + pointerSize} ${centerY} L ${config.x + config.width} ${centerY + pointerSize/2} Z"
          fill="${config.color}"
          stroke="${config.borderColor}"
          stroke-width="2"
          opacity="${opacity}"
        />`;
      break;
    case 'top':
      pointer = `
        <path
          d="M ${centerX - pointerSize/2} ${config.y} L ${centerX} ${config.y - pointerSize} L ${centerX + pointerSize/2} ${config.y} Z"
          fill="${config.color}"
          stroke="${config.borderColor}"
          stroke-width="2"
          opacity="${opacity}"
        />`;
      break;
    case 'bottom':
      pointer = `
        <path
          d="M ${centerX - pointerSize/2} ${config.y + config.height} L ${centerX} ${config.y + config.height + pointerSize} L ${centerX + pointerSize/2} ${config.y + config.height} Z"
          fill="${config.color}"
          stroke="${config.borderColor}"
          stroke-width="2"
          opacity="${opacity}"
        />`;
      break;
  }

  return box + pointer;
}

/**
 * Create a wave pattern for backgrounds
 */
export function createWavePattern(config: {
  color: string;
  opacity?: number;
  amplitude?: number;
  frequency?: number;
  position?: 'top' | 'bottom';
}): string {
  const opacity = config.opacity || 0.05;
  const amplitude = config.amplitude || 50;
  const frequency = config.frequency || 3;
  const position = config.position || 'bottom';

  const points = [];
  const steps = 50;

  for (let i = 0; i <= steps; i++) {
    const x = (1920 / steps) * i;
    const y = amplitude * Math.sin((i / steps) * Math.PI * 2 * frequency);
    points.push(`${x},${y}`);
  }

  const baseY = position === 'top' ? 0 : 1080;
  const path = position === 'top'
    ? `M 0,0 L ${points.join(' L ')} L 1920,0 Z`
    : `M 0,1080 L ${points.map(p => {
        const [x, y] = p.split(',');
        return `${x},${1080 - parseFloat(y)}`;
      }).join(' L ')} L 1920,1080 Z`;

  return `
    <path
      d="${path}"
      fill="${config.color}"
      opacity="${opacity}"
    />`;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/svgGenerator/gradients.ts
=================================================================================
/**
 * SVG Gradient Definitions
 * Professional gradient patterns for slide backgrounds
 */

export interface GradientConfig {
  id: string;
  type: 'linear' | 'radial';
  colors: Array<{ offset: string; color: string; opacity?: number }>;
  angle?: number; // For linear gradients (0-360)
  cx?: string; // For radial gradients
  cy?: string; // For radial gradients
  r?: string; // For radial gradients
}

/**
 * Generate SVG gradient definition
 */
export function createGradientDef(config: GradientConfig): string {
  if (config.type === 'linear') {
    return createLinearGradient(config);
  } else {
    return createRadialGradient(config);
  }
}

function createLinearGradient(config: GradientConfig): string {
  const angle = config.angle || 135;
  const radians = (angle - 90) * (Math.PI / 180);
  const x1 = Math.round(50 + 50 * Math.cos(radians));
  const y1 = Math.round(50 + 50 * Math.sin(radians));
  const x2 = Math.round(50 - 50 * Math.cos(radians));
  const y2 = Math.round(50 - 50 * Math.sin(radians));

  const stops = config.colors
    .map(
      (stop) =>
        `<stop offset="${stop.offset}" style="stop-color:${stop.color};stop-opacity:${stop.opacity || 1}" />`
    )
    .join('\n      ');

  return `
    <linearGradient id="${config.id}" x1="${x1}%" y1="${y1}%" x2="${x2}%" y2="${y2}%">
      ${stops}
    </linearGradient>`;
}

function createRadialGradient(config: GradientConfig): string {
  const cx = config.cx || '50%';
  const cy = config.cy || '50%';
  const r = config.r || '50%';

  const stops = config.colors
    .map(
      (stop) =>
        `<stop offset="${stop.offset}" style="stop-color:${stop.color};stop-opacity:${stop.opacity || 1}" />`
    )
    .join('\n      ');

  return `
    <radialGradient id="${config.id}" cx="${cx}" cy="${cy}" r="${r}">
      ${stops}
    </radialGradient>`;
}

/**
 * Predefined professional gradient themes
 */
export const gradientThemes = {
  // Subtle, professional gradients
  subtle: {
    id: 'subtle-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#F8FAFC' },
      { offset: '50%', color: '#F1F5F9' },
      { offset: '100%', color: '#F8FAFC' },
    ],
  },

  // Modern tech gradient
  tech: {
    id: 'tech-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#EEF2FF' },
      { offset: '50%', color: '#E0E7FF' },
      { offset: '100%', color: '#EEF2FF' },
    ],
  },

  // Warm, inviting gradient
  warm: {
    id: 'warm-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#FEF3C7' },
      { offset: '50%', color: '#FDE68A' },
      { offset: '100%', color: '#FEF3C7' },
    ],
  },

  // Cool, calm gradient
  cool: {
    id: 'cool-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#ECFEFF' },
      { offset: '50%', color: '#CFFAFE' },
      { offset: '100%', color: '#ECFEFF' },
    ],
  },

  // Professional blue
  professional: {
    id: 'professional-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#DBEAFE' },
      { offset: '50%', color: '#BFDBFE' },
      { offset: '100%', color: '#DBEAFE' },
    ],
  },

  // Elegant purple
  elegant: {
    id: 'elegant-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#F3E8FF' },
      { offset: '50%', color: '#E9D5FF' },
      { offset: '100%', color: '#F3E8FF' },
    ],
  },

  // Success green
  success: {
    id: 'success-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#D1FAE5' },
      { offset: '50%', color: '#A7F3D0' },
      { offset: '100%', color: '#D1FAE5' },
    ],
  },

  // Radial spotlight
  spotlight: {
    id: 'spotlight-gradient',
    type: 'radial' as const,
    cx: '30%',
    cy: '30%',
    r: '70%',
    colors: [
      { offset: '0%', color: '#FFFFFF' },
      { offset: '50%', color: '#F8FAFC' },
      { offset: '100%', color: '#F1F5F9' },
    ],
  },
};

/**
 * Get gradient theme by name or create custom
 */
export function getGradient(
  themeName?: keyof typeof gradientThemes,
  customColors?: string[]
): GradientConfig {
  if (themeName && gradientThemes[themeName]) {
    return gradientThemes[themeName];
  }

  // Create custom gradient from colors
  if (customColors && customColors.length >= 2) {
    const stops = customColors.map((color, index) => ({
      offset: `${(index / (customColors.length - 1)) * 100}%`,
      color,
    }));

    return {
      id: 'custom-gradient',
      type: 'linear',
      angle: 135,
      colors: stops,
    };
  }

  // Default to subtle
  return gradientThemes.subtle;
}

/**
 * Create gradient from color palette with enhanced sophistication
 */
export function createGradientFromPalette(palette: {
  primary: string;
  accent: string;
  neutral: string[];
}): GradientConfig {
  // Use neutral colors for subtle background with primary/accent hints
  const lightest = palette.neutral[palette.neutral.length - 1] || '#F8FAFC';
  const lighter = palette.neutral[palette.neutral.length - 2] || '#F1F5F9';
  const mid = palette.neutral[palette.neutral.length - 3] || '#E2E8F0';

  // Add very subtle primary color tint for sophistication
  return {
    id: 'palette-gradient',
    type: 'linear',
    angle: 135,
    colors: [
      { offset: '0%', color: lightest },
      { offset: '25%', color: lighter },
      { offset: '50%', color: mid, opacity: 0.03 },
      { offset: '75%', color: lighter },
      { offset: '100%', color: lightest },
    ],
  };
}

/**
 * Create radial gradient for spotlight effect
 */
export function createRadialGradientFromPalette(palette: {
  primary: string;
  accent: string;
  neutral: string[];
}): GradientConfig {
  const lightest = palette.neutral[palette.neutral.length - 1] || '#F8FAFC';
  const lighter = palette.neutral[palette.neutral.length - 2] || '#F1F5F9';

  return {
    id: 'radial-palette-gradient',
    type: 'radial',
    cx: '30%',
    cy: '30%',
    r: '80%',
    colors: [
      { offset: '0%', color: '#FFFFFF', opacity: 0.8 },
      { offset: '40%', color: lightest },
      { offset: '100%', color: lighter },
    ],
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/svgGenerator/index.ts
=================================================================================
/**
 * SVG Generator Module
 * Professional SVG backgrounds and decorative elements for slides
 */

export { generateBackground, generateBackgroundForSlide, type BackgroundConfig } from './backgroundGenerator';
export { createGradientDef, getGradient, createGradientFromPalette, createRadialGradientFromPalette, gradientThemes, type GradientConfig } from './gradients';
export {
  createAccentBar,
  createCornerAccent,
  createDecorativeCircles,
  createDividerLine,
  createGeometricPattern,
  createCurvedAccent,
  createGlowFilter,
  createShadowFilter,
  createAbstractShape,
  createGridPattern,
  createArrow,
  createCalloutBox,
  createWavePattern,
} from './decorativeElements';
export { svgToPngDataUrl, svgToPngBuffer, optimizePng } from './converter';



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/templates.ts
=================================================================================
/**
 * Pre-built Slide Templates
 * Ready-to-use templates for common use cases
 */

import type { SlideSpecV1 } from "./types/SlideSpecV1";

export interface Template {
  id: string;
  name: string;
  description: string;
  category: "business" | "tech" | "marketing" | "education" | "general";
  thumbnail?: string;
  spec: SlideSpecV1;
}

/**
 * Title Slide Template
 */
export const TITLE_SLIDE_TEMPLATE: Template = {
  id: "title-hero",
  name: "Hero Title Slide",
  description: "Bold title slide for presentation openings",
  category: "general",
  spec: {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Professional Hero",
      aspectRatio: "16:9"
    },
    content: {
      title: { id: "title", text: "Your Presentation Title" },
      subtitle: { id: "subtitle", text: "Subtitle or tagline goes here" }
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 32, r: 32, b: 32, l: 32 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 6, colSpan: 12 },
        { name: "footer", rowStart: 7, colStart: 1, rowSpan: 2, colSpan: 12 }
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "subtitle", region: "header", order: 1 }
      ]
    },
    styleTokens: {
      palette: { primary: "#1E40AF", accent: "#10B981", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"] },
      typography: {
        fonts: { sans: "Inter, Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 24, "step_2": 32, "step_3": 56 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.5 }
      },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32,48] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: { sm: "0 2px 4px rgba(0,0,0,.08)", md: "0 4px 12px rgba(0,0,0,.12)", lg: "0 12px 32px rgba(0,0,0,.16)" },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 }
    }
  }
};

/**
 * Bullet Points Template
 */
export const BULLET_POINTS_TEMPLATE: Template = {
  id: "bullets-split",
  name: "Key Points",
  description: "Clean bullet point slide with title",
  category: "general",
  spec: {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Professional Split",
      aspectRatio: "16:9"
    },
    content: {
      title: { id: "title", text: "Key Points" },
      subtitle: { id: "subtitle", text: "Main takeaways" },
      bullets: [{
        id: "b1",
        items: [
          { text: "First key point with supporting detail", level: 1 },
          { text: "Second important point to remember", level: 1 },
          { text: "Third critical insight or action item", level: 1 },
          { text: "Fourth point for comprehensive coverage", level: 1 }
        ]
      }]
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 32, r: 32, b: 32, l: 32 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 6, colSpan: 12 }
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "subtitle", region: "header", order: 1 },
        { refId: "b1", region: "body", order: 0 }
      ]
    },
    styleTokens: {
      palette: { primary: "#3B82F6", accent: "#10B981", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"] },
      typography: {
        fonts: { sans: "Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, "step_0": 18, "step_1": 24, "step_2": 32, "step_3": 40 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.6 }
      },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: { sm: "0 2px 4px rgba(0,0,0,.08)", md: "0 4px 12px rgba(0,0,0,.12)", lg: "0 12px 32px rgba(0,0,0,.16)" },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 }
    }
  }
};

/**
 * Data Visualization Template
 */
export const DATA_VIZ_TEMPLATE: Template = {
  id: "data-chart",
  name: "Data & Metrics",
  description: "Chart-focused slide for data presentation",
  category: "business",
  spec: {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Data Focused",
      aspectRatio: "16:9"
    },
    content: {
      title: { id: "title", text: "Performance Metrics" },
      subtitle: { id: "subtitle", text: "Q4 2024 Results" },
      bullets: [{
        id: "b1",
        items: [
          { text: "Revenue up 25% YoY", level: 1 },
          { text: "Customer growth: 15%", level: 1 },
          { text: "Retention rate: 94%", level: 1 }
        ]
      }],
      dataViz: {
        id: "chart1",
        kind: "bar",
        title: "Quarterly Revenue",
        labels: ["Q1", "Q2", "Q3", "Q4"],
        series: [{ name: "Revenue ($M)", values: [12, 15, 18, 22] }]
      }
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 32, r: 32, b: 32, l: 32 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 6, colSpan: 7 },
        { name: "aside", rowStart: 3, colStart: 8, rowSpan: 6, colSpan: 5 }
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "subtitle", region: "header", order: 1 },
        { refId: "chart1", region: "body", order: 0 },
        { refId: "b1", region: "aside", order: 0 }
      ]
    },
    styleTokens: {
      palette: { primary: "#0F172A", accent: "#10B981", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"] },
      typography: {
        fonts: { sans: "Inter, Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 20, "step_2": 28, "step_3": 40 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.5 }
      },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: { sm: "0 2px 4px rgba(0,0,0,.08)", md: "0 4px 12px rgba(0,0,0,.12)", lg: "0 12px 32px rgba(0,0,0,.16)" },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 }
    }
  }
};

/**
 * Quote/Testimonial Template
 */
export const QUOTE_TEMPLATE: Template = {
  id: "quote-minimal",
  name: "Quote or Testimonial",
  description: "Minimal slide for impactful quotes",
  category: "marketing",
  spec: {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Minimal Quote",
      aspectRatio: "16:9"
    },
    content: {
      title: { id: "title", text: "\"This product transformed our business\"" },
      subtitle: { id: "subtitle", text: "— Jane Doe, CEO of Example Corp" }
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 48, r: 48, b: 48, l: 48 } },
      regions: [
        { name: "body", rowStart: 3, colStart: 2, rowSpan: 4, colSpan: 10 }
      ],
      anchors: [
        { refId: "title", region: "body", order: 0 },
        { refId: "subtitle", region: "body", order: 1 }
      ]
    },
    styleTokens: {
      palette: { primary: "#1F2937", accent: "#8B5CF6", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"] },
      typography: {
        fonts: { sans: "Georgia, serif" },
        sizes: { "step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 20, "step_2": 28, "step_3": 36 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.3, standard: 1.6 }
      },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32,48] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: { sm: "0 2px 4px rgba(0,0,0,.08)", md: "0 4px 12px rgba(0,0,0,.12)", lg: "0 12px 32px rgba(0,0,0,.16)" },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 }
    }
  }
};

/**
 * Two-Column Comparison Template
 */
export const COMPARISON_TEMPLATE: Template = {
  id: "comparison-split",
  name: "Side-by-Side Comparison",
  description: "Compare two options or concepts",
  category: "business",
  spec: {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Split Comparison",
      aspectRatio: "16:9"
    },
    content: {
      title: { id: "title", text: "Option A vs Option B" },
      bullets: [
        {
          id: "b1",
          items: [
            { text: "Advantage 1", level: 1 },
            { text: "Advantage 2", level: 1 },
            { text: "Advantage 3", level: 1 }
          ]
        },
        {
          id: "b2",
          items: [
            { text: "Benefit 1", level: 1 },
            { text: "Benefit 2", level: 1 },
            { text: "Benefit 3", level: 1 }
          ]
        }
      ]
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 32, r: 32, b: 32, l: 32 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 6, colSpan: 5 },
        { name: "aside", rowStart: 3, colStart: 7, rowSpan: 6, colSpan: 6 }
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "b1", region: "body", order: 0 },
        { refId: "b2", region: "aside", order: 0 }
      ]
    },
    styleTokens: {
      palette: { primary: "#4F46E5", accent: "#EC4899", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"] },
      typography: {
        fonts: { sans: "Segoe UI, Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 22, "step_2": 30, "step_3": 40 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.5 }
      },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: { sm: "0 2px 4px rgba(0,0,0,.08)", md: "0 4px 12px rgba(0,0,0,.12)", lg: "0 12px 32px rgba(0,0,0,.16)" },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 }
    }
  }
};

/**
 * Get all templates
 */
export function getAllTemplates(): Template[] {
  return [
    TITLE_SLIDE_TEMPLATE,
    BULLET_POINTS_TEMPLATE,
    DATA_VIZ_TEMPLATE,
    QUOTE_TEMPLATE,
    COMPARISON_TEMPLATE
  ];
}

/**
 * Get templates by category
 */
export function getTemplatesByCategory(category: Template["category"]): Template[] {
  return getAllTemplates().filter(t => t.category === category);
}

/**
 * Get template by ID
 */
export function getTemplateById(id: string): Template | null {
  return getAllTemplates().find(t => t.id === id) || null;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/types/SlideSpecV1.ts
=================================================================================
export type AspectRatio = "16:9" | "4:3";
export type RegionName = "header" | "body" | "footer" | "aside";
export type ChartKind = "bar" | "line" | "pie" | "area" | "scatter" | "combo" | "waterfall" | "funnel" | "doughnut";

export interface SlideSpecV1 {
  meta: {
    version: "1.0";
    locale: string;
    theme: string;
    aspectRatio: AspectRatio;
  };
  content: {
    title: { id: string; text: string };
    subtitle?: { id: string; text: string };
    bullets?: { id: string; items: { text: string; level: 1 | 2 | 3 }[] }[];
    callouts?: { id: string; title?: string; text: string; variant: "note"|"success"|"warning"|"danger" }[];
    dataViz?: {
      id: string; kind: ChartKind; title?: string; labels: string[];
      series: { name: string; values: number[] }[]; valueFormat?: "number"|"percent"|"currency"|"auto";
    };
    imagePlaceholders?: { id: string; role: "hero" | "logo" | "illustration" | "icon" | "background"; alt: string }[];
    images?: {
      id: string;
      role: "hero" | "logo" | "illustration" | "icon" | "background";
      source: {
        type: "url" | "unsplash" | "placeholder";
        url?: string;
        query?: string;
      };
      alt: string;
      fit?: "cover" | "contain" | "fill";
    }[];
  };
  layout: {
    grid: { rows: number; cols: number; gutter: number; margin: { t: number; r: number; b: number; l: number } };
    regions: { name: RegionName; rowStart: number; colStart: number; rowSpan: number; colSpan: number }[];
    anchors: { refId: string; region: RegionName; order: number; span?: { rows: number; cols: number } }[];
  };
  styleTokens: {
    palette: { primary: string; accent: string; neutral: string[] };
    typography: {
      fonts: { sans: string; serif?: string; mono?: string };
      sizes: { "step_-2": number; "step_-1": number; step_0: number; step_1: number; step_2: number; step_3: number };
      weights: { regular: number; medium: number; semibold: number; bold: number };
      lineHeights: { compact: number; standard: number };
    };
    spacing: { base: number; steps: number[] };
    radii: { sm: number; md: number; lg: number };
    shadows: { sm: string; md: string; lg: string };
    contrast: { minTextContrast: number; minUiContrast: number };
  };
  components?: {
    bulletList?: { variant?: "compact" | "spacious" };
    callout?: { variant?: "flat" | "elevated" };
    chart?: { legend?: "none" | "right" | "bottom"; gridlines?: boolean };
    image?: { fit?: "cover" | "contain" };
    title?: { align?: "left" | "center" | "right" };
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/types/SlideSpecV2.ts
=================================================================================
import type { SlideSpecV1 } from "./SlideSpecV1";

export type DesignPattern = "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused";
export type WhitespaceStrategy = "generous" | "balanced" | "compact";
export type TypographyStrategy = "classic" | "modern" | "bold" | "minimal" | "elegant";
export type ColorDistribution = "monochromatic" | "complementary" | "analogous" | "triadic";
export type ContrastLevel = "high" | "medium" | "low";
export type AnimationType = "fade" | "slide" | "zoom" | "wipe" | "pulse" | "glow" | "scale";

export interface VisualHierarchy {
  primaryFocus: string; // element ID with highest emphasis
  secondaryFocus: string[]; // supporting element IDs
  emphasisLevels: Record<string, 1 | 2 | 3 | 4 | 5>; // 1=minimal, 5=maximum
}

export interface WhitespaceConfig {
  strategy: WhitespaceStrategy;
  breathingRoom: number; // 20-50 percentage
}

export interface TypographyConfig {
  strategy: TypographyStrategy;
  fontPairing: {
    primary: string; // heading font
    secondary: string; // body font
  };
  hierarchy: Record<string, {
    size: number;
    weight: 400 | 500 | 600 | 700;
    lineHeight: number;
  }>;
}

export interface ColorStrategyConfig {
  distribution: ColorDistribution;
  emphasis: string; // accent color usage
  contrast: ContrastLevel;
}

export interface AnimationConfig {
  type: AnimationType;
  duration: number; // milliseconds
  delay?: number;
}

export interface DesignConfig {
  pattern: DesignPattern;
  
  visualHierarchy: VisualHierarchy;
  
  whitespace: WhitespaceConfig;
  
  typography: TypographyConfig;
  
  colorStrategy: ColorStrategyConfig;
  
  animations?: {
    entrance?: AnimationConfig[];
    emphasis?: AnimationConfig[];
  };
}

export interface SlideSpecV2 extends SlideSpecV1 {
  design: DesignConfig;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/App.tsx
=================================================================================
import { useCallback, useEffect, useState } from "react";
import { SlideEditor } from "@/components/SlideEditor";
import { ProgressIndicator } from "@/components/ProgressIndicator";
import { ToastContainer, useToast } from "@/components/Toast";
import { SlideChat } from "@/components/SlideChat";
import { useSlideGeneration } from "@/hooks/useSlideGeneration";
import { useSlideExport } from "@/hooks/useSlideExport";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export default function App() {
  const { loading, spec, error, generate } = useSlideGeneration();
  const { exportSlide } = useSlideExport();
  const toast = useToast();
  const [currentSpec, setCurrentSpec] = useState<SlideSpecV1 | null>(null);

  useEffect(() => {
    if (spec) {
      setCurrentSpec(spec);
    }
  }, [spec]);

  const handleChatReady = useCallback(async (slidePrompt: string) => {
    const result = await generate(slidePrompt);
    if (result) {
      toast.success("Slide generated successfully!");
    }
  }, [generate, toast]);

  useEffect(() => {
    if (error) {
      toast.error(error);
    }
  }, [error]);

  const handleSlideUpdate = useCallback((updatedSpec: SlideSpecV1) => {
    setCurrentSpec(updatedSpec);
  }, []);

  const handleDownload = useCallback(async () => {
    if (!currentSpec) return;

    const success = await exportSlide(currentSpec);
    if (success) {
      toast.success("PowerPoint downloaded successfully!");
    } else {
      toast.error("Failed to download PowerPoint");
    }
  }, [currentSpec, exportSlide, toast]);

  return (
    <div className="min-h-screen flex flex-col" style={{ background: 'var(--bg-gradient-main)' }}>
      {/* Skip to main content link for accessibility */}
      <a
        href="#main-content"
        className="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-[var(--color-primary)] focus:text-white focus:rounded-[var(--radius-md)]"
      >
        Skip to main content
      </a>

      <ToastContainer toasts={toast.toasts} onClose={toast.closeToast} />

      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 sm:py-12 space-y-8 sm:space-y-12 w-full">
        {/* Premium Header */}
        <header className="text-center space-y-4 py-8 sm:py-12 animate-fade-in">
          <div className="inline-block">
            <h1 className="text-5xl sm:text-6xl lg:text-7xl font-bold bg-gradient-to-r from-[var(--color-primary)] via-[var(--color-primary-light)] to-[var(--color-accent)] bg-clip-text text-transparent mb-3" style={{ fontFamily: 'var(--font-display)', letterSpacing: '-0.02em' }}>
              plsfixthx
            </h1>
            <div className="h-1 w-24 mx-auto bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] rounded-full"></div>
          </div>
          <p className="text-lg sm:text-xl text-[var(--neutral-3)] max-w-2xl mx-auto font-medium leading-relaxed">
            Create beautiful, professional slides with AI
          </p>
        </header>

        {/* Chat Interface - ChatGPT Style */}
        <main id="main-content" className="animate-scale-in max-w-4xl mx-auto w-full">
          <SlideChat onSlideReady={handleChatReady} isGenerating={loading} />
        </main>

        {/* Slide Editor with Live Preview and Edit Chat */}
        {(currentSpec || loading) && (
          <div className="animate-scale-in max-w-7xl mx-auto w-full">
            {loading ? (
              <div className="glass rounded-[var(--radius-2xl)] p-6 sm:p-8 lg:p-10 space-y-6">
                <div className="flex items-center justify-between">
                  <h2 className="text-2xl font-bold text-[var(--neutral-1)]">
                    Creating your slide...
                  </h2>
                </div>
                <ProgressIndicator isLoading={loading} />
              </div>
            ) : currentSpec ? (
              <div className="space-y-6">
                <SlideEditor
                  spec={currentSpec}
                  onUpdate={handleSlideUpdate}
                  onExport={handleDownload}
                />
              </div>
            ) : null}
          </div>
        )}
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/AdvancedChartBuilder.tsx
=================================================================================
import { useState } from "react";
import { BarChart3, LineChart, PieChart, TrendingUp, Plus, X } from "lucide-react";

type ChartType = "bar" | "line" | "pie" | "area" | "scatter" | "doughnut" | "waterfall" | "combo" | "funnel";

interface ChartData {
  chartType: ChartType;
  title: string;
  labels: string[];
  series: Array<{
    name: string;
    values: number[];
  }>;
  showTrendline?: boolean;
  showDataTable?: boolean;
}

interface AdvancedChartBuilderProps {
  onAddChart: (chart: ChartData) => void;
  onClose: () => void;
}

export function AdvancedChartBuilder({ onAddChart, onClose }: AdvancedChartBuilderProps) {
  const [chartData, setChartData] = useState<ChartData>({
    chartType: "bar",
    title: "",
    labels: ["Q1", "Q2", "Q3", "Q4"],
    series: [{ name: "Series 1", values: [0, 0, 0, 0] }],
    showTrendline: false,
    showDataTable: false
  });

  const chartTypes: Array<{ type: ChartType; label: string; icon: any; description: string }> = [
    { type: "bar", label: "Bar Chart", icon: BarChart3, description: "Compare categories" },
    { type: "line", label: "Line Chart", icon: LineChart, description: "Show trends over time" },
    { type: "pie", label: "Pie Chart", icon: PieChart, description: "Show proportions" },
    { type: "area", label: "Area Chart", icon: TrendingUp, description: "Show volume over time" },
    { type: "scatter", label: "Scatter Plot", icon: TrendingUp, description: "Show correlation" },
    { type: "doughnut", label: "Doughnut Chart", icon: PieChart, description: "Modern pie chart" },
    { type: "waterfall", label: "Waterfall Chart", icon: BarChart3, description: "Show cumulative effect" },
    { type: "combo", label: "Combo Chart", icon: LineChart, description: "Combine bar + line" },
    { type: "funnel", label: "Funnel Chart", icon: TrendingUp, description: "Show conversion stages" }
  ];

  const handleAddSeries = () => {
    setChartData({
      ...chartData,
      series: [...chartData.series, { name: `Series ${chartData.series.length + 1}`, values: new Array(chartData.labels.length).fill(0) }]
    });
  };

  const handleRemoveSeries = (index: number) => {
    setChartData({
      ...chartData,
      series: chartData.series.filter((_, i) => i !== index)
    });
  };

  const handleUpdateSeriesName = (index: number, name: string) => {
    const newSeries = [...chartData.series];
    newSeries[index].name = name;
    setChartData({ ...chartData, series: newSeries });
  };

  const handleUpdateSeriesValue = (seriesIndex: number, valueIndex: number, value: number) => {
    const newSeries = [...chartData.series];
    newSeries[seriesIndex].values[valueIndex] = value;
    setChartData({ ...chartData, series: newSeries });
  };

  const handleUpdateLabel = (index: number, label: string) => {
    const newLabels = [...chartData.labels];
    newLabels[index] = label;
    setChartData({ ...chartData, labels: newLabels });
  };

  const handleAddDataPoint = () => {
    setChartData({
      ...chartData,
      labels: [...chartData.labels, `Label ${chartData.labels.length + 1}`],
      series: chartData.series.map(s => ({ ...s, values: [...s.values, 0] }))
    });
  };

  const handleRemoveDataPoint = (index: number) => {
    setChartData({
      ...chartData,
      labels: chartData.labels.filter((_, i) => i !== index),
      series: chartData.series.map(s => ({ ...s, values: s.values.filter((_, i) => i !== index) }))
    });
  };

  const handleSubmit = () => {
    onAddChart(chartData);
    onClose();
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-y-auto">
        <div className="sticky top-0 bg-white border-b border-[var(--neutral-7)] p-6 flex items-center justify-between">
          <div>
            <h2 className="text-2xl font-bold text-[var(--neutral-1)]">Advanced Chart Builder</h2>
            <p className="text-sm text-[var(--neutral-3)]">Create professional data visualizations</p>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-[var(--neutral-8)] rounded-lg transition-colors"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        <div className="p-6 space-y-6">
          {/* Chart Type Selection */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
              Chart Type
            </label>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
              {chartTypes.map((type) => {
                const Icon = type.icon;
                return (
                  <button
                    key={type.type}
                    onClick={() => setChartData({ ...chartData, chartType: type.type })}
                    className={`p-4 rounded-lg border-2 transition-all text-left ${
                      chartData.chartType === type.type
                        ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                        : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                    }`}
                  >
                    <Icon className={`w-5 h-5 mb-2 ${chartData.chartType === type.type ? "text-[var(--color-primary)]" : "text-[var(--neutral-3)]"}`} />
                    <div className="font-semibold text-sm text-[var(--neutral-1)]">{type.label}</div>
                    <div className="text-xs text-[var(--neutral-4)] mt-1">{type.description}</div>
                  </button>
                );
              })}
            </div>
          </div>

          {/* Chart Title */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
              Chart Title
            </label>
            <input
              type="text"
              value={chartData.title}
              onChange={(e) => setChartData({ ...chartData, title: e.target.value })}
              placeholder="e.g., Quarterly Revenue Growth"
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none"
            />
          </div>

          {/* Data Labels */}
          <div>
            <div className="flex items-center justify-between mb-2">
              <label className="text-sm font-semibold text-[var(--neutral-2)]">
                Data Labels
              </label>
              <button
                onClick={handleAddDataPoint}
                className="text-sm text-[var(--color-primary)] hover:underline flex items-center gap-1"
              >
                <Plus className="w-4 h-4" />
                Add Data Point
              </button>
            </div>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
              {chartData.labels.map((label, index) => (
                <div key={index} className="flex gap-1">
                  <input
                    type="text"
                    value={label}
                    onChange={(e) => handleUpdateLabel(index, e.target.value)}
                    className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none text-sm"
                  />
                  {chartData.labels.length > 2 && (
                    <button
                      onClick={() => handleRemoveDataPoint(index)}
                      className="p-2 hover:bg-red-50 text-red-500 rounded-lg"
                    >
                      <X className="w-4 h-4" />
                    </button>
                  )}
                </div>
              ))}
            </div>
          </div>

          {/* Data Series */}
          <div>
            <div className="flex items-center justify-between mb-2">
              <label className="text-sm font-semibold text-[var(--neutral-2)]">
                Data Series
              </label>
              <button
                onClick={handleAddSeries}
                className="text-sm text-[var(--color-primary)] hover:underline flex items-center gap-1"
              >
                <Plus className="w-4 h-4" />
                Add Series
              </button>
            </div>
            <div className="space-y-4">
              {chartData.series.map((series, seriesIndex) => (
                <div key={seriesIndex} className="p-4 bg-[var(--neutral-8)] rounded-lg space-y-3">
                  <div className="flex items-center gap-2">
                    <input
                      type="text"
                      value={series.name}
                      onChange={(e) => handleUpdateSeriesName(seriesIndex, e.target.value)}
                      className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none font-semibold"
                      placeholder="Series name"
                    />
                    {chartData.series.length > 1 && (
                      <button
                        onClick={() => handleRemoveSeries(seriesIndex)}
                        className="p-2 hover:bg-red-50 text-red-500 rounded-lg"
                      >
                        <X className="w-4 h-4" />
                      </button>
                    )}
                  </div>
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
                    {series.values.map((value, valueIndex) => (
                      <input
                        key={valueIndex}
                        type="number"
                        value={value}
                        onChange={(e) => handleUpdateSeriesValue(seriesIndex, valueIndex, parseFloat(e.target.value) || 0)}
                        className="px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none text-sm"
                        placeholder="0"
                      />
                    ))}
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Options */}
          <div className="space-y-3 p-4 bg-[var(--neutral-8)] rounded-lg">
            <label className="flex items-center gap-3 cursor-pointer">
              <input
                type="checkbox"
                checked={chartData.showTrendline}
                onChange={(e) => setChartData({ ...chartData, showTrendline: e.target.checked })}
                className="w-5 h-5 rounded border-[var(--neutral-6)] text-[var(--color-primary)]"
              />
              <span className="text-sm font-medium text-[var(--neutral-2)]">Show Trendline</span>
            </label>
            <label className="flex items-center gap-3 cursor-pointer">
              <input
                type="checkbox"
                checked={chartData.showDataTable}
                onChange={(e) => setChartData({ ...chartData, showDataTable: e.target.checked })}
                className="w-5 h-5 rounded border-[var(--neutral-6)] text-[var(--color-primary)]"
              />
              <span className="text-sm font-medium text-[var(--neutral-2)]">Show Data Table</span>
            </label>
          </div>

          {/* Actions */}
          <div className="flex gap-3 pt-4">
            <button
              onClick={onClose}
              className="flex-1 px-6 py-3 border border-[var(--neutral-7)] text-[var(--neutral-2)] font-semibold rounded-xl hover:bg-[var(--neutral-8)] transition-all"
            >
              Cancel
            </button>
            <button
              onClick={handleSubmit}
              disabled={!chartData.title.trim()}
              className="flex-1 px-6 py-3 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transition-all disabled:opacity-50"
            >
              Add Chart to Slide
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/AnimationConfigurator.tsx
=================================================================================
import { useState } from "react";
import { Zap, Play, Settings } from "lucide-react";

type EntranceAnimation = "fade" | "wipe" | "fly-in" | "zoom" | "appear" | "split";
type SlideTransition = "fade" | "push" | "wipe" | "split" | "reveal" | "cover" | "dissolve";

interface AnimationConfig {
  slideTransition?: {
    type: SlideTransition;
    duration: number;
  };
  entranceAnimations?: Array<{
    elementId: string;
    type: EntranceAnimation;
    duration: number;
    delay: number;
  }>;
  usePreset?: "minimal" | "professional" | "dynamic" | "none";
}

interface AnimationConfiguratorProps {
  currentConfig?: AnimationConfig;
  onApplyConfig: (config: AnimationConfig) => void;
}

export function AnimationConfigurator({ currentConfig, onApplyConfig }: AnimationConfiguratorProps) {
  const [config, setConfig] = useState<AnimationConfig>(currentConfig || {
    usePreset: "professional"
  });

  const [showAdvanced, setShowAdvanced] = useState(false);

  const presets: Array<{ id: AnimationConfig["usePreset"]; label: string; description: string }> = [
    { id: "none", label: "No Animations", description: "Static slides, no transitions" },
    { id: "minimal", label: "Minimal", description: "Subtle fade effects only" },
    { id: "professional", label: "Professional", description: "Balanced, polished animations" },
    { id: "dynamic", label: "Dynamic", description: "Bold, attention-grabbing effects" }
  ];

  const transitions: Array<{ type: SlideTransition; label: string; description: string }> = [
    { type: "fade", label: "Fade", description: "Smooth crossfade" },
    { type: "push", label: "Push", description: "Slide pushes in" },
    { type: "wipe", label: "Wipe", description: "Wipe across" },
    { type: "split", label: "Split", description: "Split from center" },
    { type: "reveal", label: "Reveal", description: "Reveal underneath" },
    { type: "cover", label: "Cover", description: "Cover previous" },
    { type: "dissolve", label: "Dissolve", description: "Pixelated dissolve" }
  ];

  const entranceTypes: Array<{ type: EntranceAnimation; label: string }> = [
    { type: "fade", label: "Fade In" },
    { type: "wipe", label: "Wipe In" },
    { type: "fly-in", label: "Fly In" },
    { type: "zoom", label: "Zoom In" },
    { type: "appear", label: "Appear" },
    { type: "split", label: "Split" }
  ];

  const handleApply = () => {
    onApplyConfig(config);
  };

  return (
    <div className="bg-white rounded-2xl shadow-xl border border-[var(--neutral-7)] p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className="p-3 bg-gradient-to-br from-yellow-500 to-orange-500 rounded-xl">
            <Zap className="w-6 h-6 text-white" />
          </div>
          <div>
            <h2 className="text-2xl font-bold text-[var(--neutral-1)]">Animations & Transitions</h2>
            <p className="text-sm text-[var(--neutral-3)]">Add motion to your slides</p>
          </div>
        </div>
        <button
          onClick={() => setShowAdvanced(!showAdvanced)}
          className="px-4 py-2 border border-[var(--neutral-7)] text-[var(--neutral-2)] rounded-lg hover:bg-[var(--neutral-8)] transition-all flex items-center gap-2"
        >
          <Settings className="w-4 h-4" />
          {showAdvanced ? "Simple" : "Advanced"}
        </button>
      </div>

      {/* Preset Selection */}
      <div>
        <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
          Animation Preset
        </label>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
          {presets.map((preset) => (
            <button
              key={preset.id}
              onClick={() => setConfig({ ...config, usePreset: preset.id })}
              className={`p-4 rounded-lg border-2 transition-all text-left ${
                config.usePreset === preset.id
                  ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                  : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
              }`}
            >
              <div className="font-semibold text-sm text-[var(--neutral-1)] mb-1">
                {preset.label}
              </div>
              <div className="text-xs text-[var(--neutral-4)]">
                {preset.description}
              </div>
            </button>
          ))}
        </div>
      </div>

      {/* Advanced Settings */}
      {showAdvanced && (
        <>
          {/* Slide Transition */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
              Slide Transition
            </label>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
              {transitions.map((transition) => (
                <button
                  key={transition.type}
                  onClick={() => setConfig({
                    ...config,
                    slideTransition: {
                      type: transition.type,
                      duration: config.slideTransition?.duration || 600
                    }
                  })}
                  className={`p-3 rounded-lg border-2 transition-all text-left ${
                    config.slideTransition?.type === transition.type
                      ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                      : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                  }`}
                >
                  <div className="font-semibold text-xs text-[var(--neutral-1)]">
                    {transition.label}
                  </div>
                  <div className="text-xs text-[var(--neutral-4)] mt-1">
                    {transition.description}
                  </div>
                </button>
              ))}
            </div>

            {/* Duration Slider */}
            {config.slideTransition && (
              <div className="mt-4">
                <label className="block text-xs text-[var(--neutral-3)] mb-2">
                  Transition Duration: {config.slideTransition.duration}ms
                </label>
                <input
                  type="range"
                  min="200"
                  max="1500"
                  step="100"
                  value={config.slideTransition.duration}
                  onChange={(e) => setConfig({
                    ...config,
                    slideTransition: {
                      ...config.slideTransition!,
                      duration: parseInt(e.target.value)
                    }
                  })}
                  className="w-full"
                />
              </div>
            )}
          </div>

          {/* Entrance Animations */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
              Default Entrance Animation
            </label>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
              {entranceTypes.map((entrance) => (
                <button
                  key={entrance.type}
                  onClick={() => {
                    // This would set default entrance for all elements
                    setConfig({
                      ...config,
                      entranceAnimations: [{
                        elementId: "default",
                        type: entrance.type,
                        duration: 600,
                        delay: 0
                      }]
                    });
                  }}
                  className={`p-3 rounded-lg border-2 transition-all ${
                    config.entranceAnimations?.[0]?.type === entrance.type
                      ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                      : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                  }`}
                >
                  <div className="font-semibold text-xs text-[var(--neutral-1)] text-center">
                    {entrance.label}
                  </div>
                </button>
              ))}
            </div>
          </div>
        </>
      )}

      {/* Preview */}
      <div className="p-4 bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg border border-blue-200">
        <div className="flex items-center gap-3 mb-3">
          <Play className="w-5 h-5 text-blue-600" />
          <span className="font-semibold text-sm text-blue-900">Animation Preview</span>
        </div>
        <div className="space-y-2 text-sm text-blue-800">
          <p>
            <strong>Preset:</strong> {presets.find(p => p.id === config.usePreset)?.label || "None"}
          </p>
          {config.slideTransition && (
            <p>
              <strong>Transition:</strong> {transitions.find(t => t.type === config.slideTransition?.type)?.label} 
              ({config.slideTransition.duration}ms)
            </p>
          )}
          {config.entranceAnimations && config.entranceAnimations.length > 0 && (
            <p>
              <strong>Entrance:</strong> {entranceTypes.find(e => e.type === config.entranceAnimations?.[0]?.type)?.label}
            </p>
          )}
        </div>
      </div>

      {/* Best Practices */}
      <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
        <p className="text-sm text-yellow-900">
          <strong>💡 Best Practice:</strong> Use animations sparingly. Too many animations can distract from your message.
          The "Professional" preset is recommended for most presentations.
        </p>
      </div>

      {/* Apply Button */}
      <button
        onClick={handleApply}
        className="w-full px-6 py-3 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transition-all flex items-center justify-center gap-2"
      >
        <Zap className="w-5 h-5" />
        Apply Animation Settings
      </button>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/BrandKitManager.tsx
=================================================================================
import { useState } from "react";
import { Palette, Type, Image, Save, Plus, Trash2, Check } from "lucide-react";

interface BrandKit {
  id: string;
  name: string;
  colors: {
    primary: string;
    accent: string;
    neutral: string[];
  };
  fonts: {
    heading: string;
    body: string;
  };
  logo?: {
    url: string;
    position: "top-left" | "top-right" | "bottom-left" | "bottom-right";
  };
}

interface BrandKitManagerProps {
  currentKit?: BrandKit;
  savedKits: BrandKit[];
  onSaveKit: (kit: BrandKit) => void;
  onApplyKit: (kit: BrandKit) => void;
  onDeleteKit: (id: string) => void;
}

export function BrandKitManager({ currentKit, savedKits, onSaveKit, onApplyKit, onDeleteKit }: BrandKitManagerProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [editingKit, setEditingKit] = useState<BrandKit>(
    currentKit || {
      id: "",
      name: "",
      colors: {
        primary: "#3B82F6",
        accent: "#10B981",
        neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#F8FAFC"]
      },
      fonts: {
        heading: "Inter",
        body: "Inter"
      }
    }
  );

  const popularFonts = [
    "Inter", "Roboto", "Open Sans", "Lato", "Montserrat", "Poppins",
    "Raleway", "Nunito", "Playfair Display", "Merriweather"
  ];

  const handleSave = () => {
    const kitToSave = {
      ...editingKit,
      id: editingKit.id || `kit-${Date.now()}`
    };
    onSaveKit(kitToSave);
    setIsEditing(false);
  };

  return (
    <div className="bg-white rounded-2xl shadow-xl border border-[var(--neutral-7)] p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className="p-3 bg-gradient-to-br from-purple-500 to-pink-500 rounded-xl">
            <Palette className="w-6 h-6 text-white" />
          </div>
          <div>
            <h2 className="text-2xl font-bold text-[var(--neutral-1)]">Brand Kit</h2>
            <p className="text-sm text-[var(--neutral-3)]">Maintain consistent branding</p>
          </div>
        </div>
        <button
          onClick={() => setIsEditing(!isEditing)}
          className="px-4 py-2 bg-[var(--color-primary)] text-white rounded-lg hover:bg-[var(--color-primary)]/90 transition-all flex items-center gap-2"
        >
          <Plus className="w-4 h-4" />
          {isEditing ? "Cancel" : "Create New"}
        </button>
      </div>

      {isEditing ? (
        <div className="space-y-6 p-6 bg-[var(--neutral-8)] rounded-xl">
          {/* Kit Name */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
              Brand Kit Name
            </label>
            <input
              type="text"
              value={editingKit.name}
              onChange={(e) => setEditingKit({ ...editingKit, name: e.target.value })}
              placeholder="e.g., Company Brand 2024"
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none bg-white"
            />
          </div>

          {/* Colors */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
              Brand Colors
            </label>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-xs text-[var(--neutral-3)] mb-2">Primary Color</label>
                <div className="flex gap-2">
                  <input
                    type="color"
                    value={editingKit.colors.primary}
                    onChange={(e) => setEditingKit({
                      ...editingKit,
                      colors: { ...editingKit.colors, primary: e.target.value }
                    })}
                    className="w-16 h-12 rounded-lg border border-[var(--neutral-7)] cursor-pointer"
                  />
                  <input
                    type="text"
                    value={editingKit.colors.primary}
                    onChange={(e) => setEditingKit({
                      ...editingKit,
                      colors: { ...editingKit.colors, primary: e.target.value }
                    })}
                    className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none bg-white font-mono text-sm"
                  />
                </div>
              </div>

              <div>
                <label className="block text-xs text-[var(--neutral-3)] mb-2">Accent Color</label>
                <div className="flex gap-2">
                  <input
                    type="color"
                    value={editingKit.colors.accent}
                    onChange={(e) => setEditingKit({
                      ...editingKit,
                      colors: { ...editingKit.colors, accent: e.target.value }
                    })}
                    className="w-16 h-12 rounded-lg border border-[var(--neutral-7)] cursor-pointer"
                  />
                  <input
                    type="text"
                    value={editingKit.colors.accent}
                    onChange={(e) => setEditingKit({
                      ...editingKit,
                      colors: { ...editingKit.colors, accent: e.target.value }
                    })}
                    className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none bg-white font-mono text-sm"
                  />
                </div>
              </div>
            </div>
          </div>

          {/* Fonts */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3 flex items-center gap-2">
              <Type className="w-4 h-4" />
              Typography
            </label>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-xs text-[var(--neutral-3)] mb-2">Heading Font</label>
                <select
                  value={editingKit.fonts.heading}
                  onChange={(e) => setEditingKit({
                    ...editingKit,
                    fonts: { ...editingKit.fonts, heading: e.target.value }
                  })}
                  className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none bg-white"
                >
                  {popularFonts.map((font) => (
                    <option key={font} value={font}>{font}</option>
                  ))}
                </select>
              </div>

              <div>
                <label className="block text-xs text-[var(--neutral-3)] mb-2">Body Font</label>
                <select
                  value={editingKit.fonts.body}
                  onChange={(e) => setEditingKit({
                    ...editingKit,
                    fonts: { ...editingKit.fonts, body: e.target.value }
                  })}
                  className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none bg-white"
                >
                  {popularFonts.map((font) => (
                    <option key={font} value={font}>{font}</option>
                  ))}
                </select>
              </div>
            </div>
          </div>

          {/* Logo */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3 flex items-center gap-2">
              <Image className="w-4 h-4" />
              Logo (Optional)
            </label>
            <input
              type="url"
              value={editingKit.logo?.url || ""}
              onChange={(e) => setEditingKit({
                ...editingKit,
                logo: { url: e.target.value, position: editingKit.logo?.position || "top-right" }
              })}
              placeholder="https://example.com/logo.png"
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none bg-white"
            />
            {editingKit.logo?.url && (
              <div className="mt-3">
                <label className="block text-xs text-[var(--neutral-3)] mb-2">Logo Position</label>
                <div className="grid grid-cols-2 gap-2">
                  {["top-left", "top-right", "bottom-left", "bottom-right"].map((pos) => (
                    <button
                      key={pos}
                      onClick={() => setEditingKit({
                        ...editingKit,
                        logo: { ...editingKit.logo!, position: pos as any }
                      })}
                      className={`px-3 py-2 rounded-lg border-2 transition-all text-sm ${
                        editingKit.logo?.position === pos
                          ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                          : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                      }`}
                    >
                      {pos.split("-").map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(" ")}
                    </button>
                  ))}
                </div>
              </div>
            )}
          </div>

          {/* Save Button */}
          <button
            onClick={handleSave}
            disabled={!editingKit.name.trim()}
            className="w-full px-6 py-3 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transition-all disabled:opacity-50 flex items-center justify-center gap-2"
          >
            <Save className="w-5 h-5" />
            Save Brand Kit
          </button>
        </div>
      ) : (
        <div className="space-y-4">
          {savedKits.length === 0 ? (
            <div className="text-center py-12">
              <Palette className="w-16 h-16 text-[var(--neutral-5)] mx-auto mb-4" />
              <p className="text-[var(--neutral-3)]">No brand kits saved yet</p>
              <p className="text-sm text-[var(--neutral-4)] mt-2">Create your first brand kit to maintain consistent branding</p>
            </div>
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {savedKits.map((kit) => (
                <div
                  key={kit.id}
                  className="p-4 border-2 border-[var(--neutral-7)] rounded-xl hover:border-[var(--color-primary)] transition-all group"
                >
                  <div className="flex items-start justify-between mb-3">
                    <h3 className="font-semibold text-[var(--neutral-1)]">{kit.name}</h3>
                    <button
                      onClick={() => onDeleteKit(kit.id)}
                      className="p-1 hover:bg-red-50 text-red-500 rounded opacity-0 group-hover:opacity-100 transition-opacity"
                    >
                      <Trash2 className="w-4 h-4" />
                    </button>
                  </div>

                  <div className="space-y-3">
                    <div className="flex gap-2">
                      <div
                        className="w-8 h-8 rounded-lg border border-[var(--neutral-7)]"
                        style={{ backgroundColor: kit.colors.primary }}
                        title="Primary"
                      />
                      <div
                        className="w-8 h-8 rounded-lg border border-[var(--neutral-7)]"
                        style={{ backgroundColor: kit.colors.accent }}
                        title="Accent"
                      />
                    </div>

                    <div className="text-xs text-[var(--neutral-3)]">
                      <p><strong>Heading:</strong> {kit.fonts.heading}</p>
                      <p><strong>Body:</strong> {kit.fonts.body}</p>
                    </div>

                    <button
                      onClick={() => onApplyKit(kit)}
                      className="w-full px-4 py-2 bg-[var(--color-primary)] text-white rounded-lg hover:bg-[var(--color-primary)]/90 transition-all flex items-center justify-center gap-2 text-sm font-semibold"
                    >
                      <Check className="w-4 h-4" />
                      Apply to Slides
                    </button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/Chart.tsx
=================================================================================
import {
  BarChart,
  Bar,
  LineChart,
  Line,
  PieChart,
  Pie,
  Cell,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from "recharts";

interface ChartProps {
  kind: "bar" | "line" | "pie";
  labels: string[];
  series: { name: string; values: number[] }[];
  title?: string;
  valueFormat?: "number" | "percent" | "currency" | "auto";
  colors?: string[];
}

const DEFAULT_COLORS = [
  "#6366F1", // Primary
  "#EC4899", // Accent
  "#10B981", // Success
  "#F59E0B", // Warning
  "#8B5CF6", // Purple
  "#06B6D4", // Cyan
  "#F97316", // Orange
  "#14B8A6", // Teal
];

export function Chart({ kind, labels, series, title, valueFormat = "auto", colors }: ChartProps) {
  const COLORS = colors || DEFAULT_COLORS;
  // Transform data for recharts format
  const data = labels.map((label, index) => {
    const point: any = { name: label };
    series.forEach((s) => {
      point[s.name] = s.values[index] || 0;
    });
    return point;
  });

  const formatValue = (value: number) => {
    switch (valueFormat) {
      case "percent":
        return `${value}%`;
      case "currency":
        return `$${value.toLocaleString()}`;
      case "number":
        return value.toLocaleString();
      default:
        return value;
    }
  };

  if (kind === "pie") {
    // For pie charts, use the first series
    const pieData = labels.map((label, index) => ({
      name: label,
      value: series[0]?.values[index] || 0,
    }));

    return (
      <div className="w-full h-full">
        {title && (
          <h4 className="text-sm font-semibold text-[var(--neutral-2)] mb-2 text-center">
            {title}
          </h4>
        )}
        <ResponsiveContainer width="100%" height="100%">
          <PieChart>
            <Pie
              data={pieData}
              cx="50%"
              cy="50%"
              labelLine={false}
              label={({ name, percent }: any) => `${name}: ${((percent as number) * 100).toFixed(0)}%`}
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
            >
              {pieData.map((_entry: any, index: number) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip formatter={(value: any) => formatValue(value)} />
            <Legend />
          </PieChart>
        </ResponsiveContainer>
      </div>
    );
  }

  if (kind === "line") {
    return (
      <div className="w-full h-full">
        {title && (
          <h4 className="text-sm font-semibold text-[var(--neutral-2)] mb-2">
            {title}
          </h4>
        )}
        <ResponsiveContainer width="100%" height="100%">
          <LineChart data={data}>
            <CartesianGrid strokeDasharray="3 3" stroke="var(--neutral-7)" />
            <XAxis 
              dataKey="name" 
              stroke="var(--neutral-4)"
              style={{ fontSize: '12px' }}
            />
            <YAxis
              stroke="var(--neutral-4)"
              style={{ fontSize: '12px' }}
              tickFormatter={(value: any) => String(formatValue(value))}
            />
            <Tooltip 
              formatter={(value: any) => formatValue(value)}
              contentStyle={{
                backgroundColor: 'var(--bg-primary)',
                border: '1px solid var(--neutral-7)',
                borderRadius: '8px',
              }}
            />
            <Legend />
            {series.map((s, index) => (
              <Line
                key={s.name}
                type="monotone"
                dataKey={s.name}
                stroke={COLORS[index % COLORS.length]}
                strokeWidth={2}
                dot={{ r: 4 }}
                activeDot={{ r: 6 }}
              />
            ))}
          </LineChart>
        </ResponsiveContainer>
      </div>
    );
  }

  // Bar chart (default)
  return (
    <div className="w-full h-full">
      {title && (
        <h4 className="text-sm font-semibold text-[var(--neutral-2)] mb-2">
          {title}
        </h4>
      )}
      <ResponsiveContainer width="100%" height="100%">
        <BarChart data={data}>
          <CartesianGrid strokeDasharray="3 3" stroke="var(--neutral-7)" />
          <XAxis 
            dataKey="name" 
            stroke="var(--neutral-4)"
            style={{ fontSize: '12px' }}
          />
          <YAxis
            stroke="var(--neutral-4)"
            style={{ fontSize: '12px' }}
            tickFormatter={(value: any) => String(formatValue(value))}
          />
          <Tooltip 
            formatter={(value: any) => formatValue(value)}
            contentStyle={{
              backgroundColor: 'var(--bg-primary)',
              border: '1px solid var(--neutral-7)',
              borderRadius: '8px',
            }}
          />
          <Legend />
          {series.map((s, index) => (
            <Bar
              key={s.name}
              dataKey={s.name}
              fill={COLORS[index % COLORS.length]}
              radius={[4, 4, 0, 0]}
            />
          ))}
        </BarChart>
      </ResponsiveContainer>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/CustomizationPanel.tsx
=================================================================================
import { useState } from "react";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

interface CustomizationPanelProps {
  spec: SlideSpecV1;
  onUpdate: (spec: SlideSpecV1) => void;
}

export function CustomizationPanel({ spec, onUpdate }: CustomizationPanelProps) {
  const [activeTab, setActiveTab] = useState<"colors" | "typography" | "layout">("colors");

  const updatePrimaryColor = (color: string) => {
    onUpdate({
      ...spec,
      styleTokens: {
        ...spec.styleTokens,
        palette: {
          ...spec.styleTokens.palette,
          primary: color,
        },
      },
    });
  };

  const updateAccentColor = (color: string) => {
    onUpdate({
      ...spec,
      styleTokens: {
        ...spec.styleTokens,
        palette: {
          ...spec.styleTokens.palette,
          accent: color,
        },
      },
    });
  };

  const updateFontSize = (step: keyof SlideSpecV1["styleTokens"]["typography"]["sizes"], size: number) => {
    onUpdate({
      ...spec,
      styleTokens: {
        ...spec.styleTokens,
        typography: {
          ...spec.styleTokens.typography,
          sizes: {
            ...spec.styleTokens.typography.sizes,
            [step]: size,
          },
        },
      },
    });
  };

  const updateTitleAlignment = (align: "left" | "center" | "right") => {
    onUpdate({
      ...spec,
      components: {
        ...spec.components,
        title: {
          ...spec.components?.title,
          align,
        },
      },
    });
  };

  const tabs = [
    { id: "colors" as const, label: "Colors", icon: "🎨" },
    { id: "typography" as const, label: "Typography", icon: "📝" },
    { id: "layout" as const, label: "Layout", icon: "📐" },
  ];

  const presetColors = [
    { name: "Blue", primary: "#1E40AF", accent: "#10B981" },
    { name: "Purple", primary: "#8B5CF6", accent: "#EC4899" },
    { name: "Green", primary: "#059669", accent: "#F59E0B" },
    { name: "Orange", primary: "#EA580C", accent: "#EAB308" },
    { name: "Pink", primary: "#EC4899", accent: "#F59E0B" },
    { name: "Teal", primary: "#0D9488", accent: "#06B6D4" },
  ];

  return (
    <div className="glass rounded-[var(--radius-2xl)] p-6 space-y-6">
      <div className="flex items-center justify-between">
        <h3 className="text-xl font-bold text-[var(--neutral-1)]">Customize Slide</h3>
        <button
          onClick={() => {/* Reset to defaults */}}
          className="text-sm text-[var(--color-primary)] hover:underline"
        >
          Reset
        </button>
      </div>

      {/* Tabs */}
      <div className="flex gap-2 border-b border-[var(--neutral-7)]">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id)}
            className={`flex items-center gap-2 px-4 py-2 border-b-2 transition-all ${
              activeTab === tab.id
                ? "border-[var(--color-primary)] text-[var(--color-primary)]"
                : "border-transparent text-[var(--neutral-4)] hover:text-[var(--neutral-2)]"
            }`}
          >
            <span>{tab.icon}</span>
            <span className="text-sm font-medium">{tab.label}</span>
          </button>
        ))}
      </div>

      {/* Colors Tab */}
      {activeTab === "colors" && (
        <div className="space-y-6">
          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Primary Color
            </label>
            <div className="flex items-center gap-3">
              <input
                type="color"
                value={spec.styleTokens.palette.primary}
                onChange={(e) => updatePrimaryColor(e.target.value)}
                className="w-12 h-12 rounded-lg border-2 border-[var(--neutral-7)] cursor-pointer"
              />
              <input
                type="text"
                value={spec.styleTokens.palette.primary}
                onChange={(e) => updatePrimaryColor(e.target.value)}
                className="flex-1 px-4 py-2 rounded-lg border-2 border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:outline-none font-mono text-sm"
              />
            </div>
          </div>

          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Accent Color
            </label>
            <div className="flex items-center gap-3">
              <input
                type="color"
                value={spec.styleTokens.palette.accent}
                onChange={(e) => updateAccentColor(e.target.value)}
                className="w-12 h-12 rounded-lg border-2 border-[var(--neutral-7)] cursor-pointer"
              />
              <input
                type="text"
                value={spec.styleTokens.palette.accent}
                onChange={(e) => updateAccentColor(e.target.value)}
                className="flex-1 px-4 py-2 rounded-lg border-2 border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:outline-none font-mono text-sm"
              />
            </div>
          </div>

          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Color Presets
            </label>
            <div className="grid grid-cols-3 gap-2">
              {presetColors.map((preset) => (
                <button
                  key={preset.name}
                  onClick={() => {
                    updatePrimaryColor(preset.primary);
                    updateAccentColor(preset.accent);
                  }}
                  className="p-3 rounded-lg border-2 border-[var(--neutral-7)] hover:border-[var(--color-primary)] transition-all"
                >
                  <div className="flex gap-1 mb-2">
                    <div
                      className="flex-1 h-8 rounded"
                      style={{ backgroundColor: preset.primary }}
                    />
                    <div
                      className="flex-1 h-8 rounded"
                      style={{ backgroundColor: preset.accent }}
                    />
                  </div>
                  <p className="text-xs font-medium text-[var(--neutral-2)]">{preset.name}</p>
                </button>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Typography Tab */}
      {activeTab === "typography" && (
        <div className="space-y-6">
          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Title Size
            </label>
            <input
              type="range"
              min="24"
              max="48"
              value={spec.styleTokens.typography.sizes.step_3}
              onChange={(e) => updateFontSize("step_3", parseInt(e.target.value))}
              className="w-full"
            />
            <div className="text-sm text-[var(--neutral-4)]">
              {spec.styleTokens.typography.sizes.step_3}px
            </div>
          </div>

          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Body Text Size
            </label>
            <input
              type="range"
              min="12"
              max="24"
              value={spec.styleTokens.typography.sizes.step_0}
              onChange={(e) => updateFontSize("step_0", parseInt(e.target.value))}
              className="w-full"
            />
            <div className="text-sm text-[var(--neutral-4)]">
              {spec.styleTokens.typography.sizes.step_0}px
            </div>
          </div>
        </div>
      )}

      {/* Layout Tab */}
      {activeTab === "layout" && (
        <div className="space-y-6">
          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Title Alignment
            </label>
            <div className="flex gap-2">
              {(["left", "center", "right"] as const).map((align) => (
                <button
                  key={align}
                  onClick={() => updateTitleAlignment(align)}
                  className={`flex-1 px-4 py-2 rounded-lg border-2 transition-all ${
                    spec.components?.title?.align === align
                      ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5 text-[var(--color-primary)]"
                      : "border-[var(--neutral-7)] text-[var(--neutral-2)] hover:border-[var(--color-primary)]"
                  }`}
                >
                  <span className="text-sm font-medium capitalize">{align}</span>
                </button>
              ))}
            </div>
          </div>

          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Spacing
            </label>
            <p className="text-sm text-[var(--neutral-4)]">
              Grid: {spec.layout.grid.rows} × {spec.layout.grid.cols}
            </p>
            <p className="text-sm text-[var(--neutral-4)]">
              Gutter: {spec.layout.grid.gutter}px
            </p>
          </div>
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/DesignPreview.tsx
=================================================================================
/**
 * Design Preview Component
 * Displays a preview of the current design system
 */

import React, { useMemo } from "react";
import type { SlideSpecV2 } from "@/types/SlideSpecV2";
import { LAYOUT_PATTERNS } from "@/lib/layoutPatterns";
import { validateDesignQuality, getQualityColor, getQualityInterpretation } from "@/lib/designQuality";

interface DesignPreviewProps {
  spec: SlideSpecV2;
}

export const DesignPreview: React.FC<DesignPreviewProps> = ({
  spec
}) => {
  const qualityScore = useMemo(() => validateDesignQuality(spec), [spec]);
  const pattern = LAYOUT_PATTERNS[spec.design.pattern];

  return (
    <div className="w-full space-y-6 p-6 bg-white rounded-lg shadow-lg">
      {/* Header */}
      <div className="border-b pb-4">
        <h2 className="text-2xl font-bold text-gray-900">Design Preview</h2>
        <p className="text-sm text-gray-600 mt-1">
          Professional slide design with quality metrics
        </p>
      </div>

      {/* Quality Score */}
      <div className="grid grid-cols-2 gap-4">
        <div className="p-4 rounded-lg border-2" style={{ borderColor: getQualityColor(qualityScore.overall) }}>
          <div className="text-sm font-semibold text-gray-600">Overall Quality</div>
          <div className="text-3xl font-bold mt-2" style={{ color: getQualityColor(qualityScore.overall) }}>
            {qualityScore.overall}/100
          </div>
          <div className="text-xs text-gray-500 mt-1">
            {getQualityInterpretation(qualityScore.overall)}
          </div>
        </div>

        <div className="space-y-2">
          <div className="flex justify-between items-center text-sm">
            <span className="text-gray-600">Contrast</span>
            <span className="font-semibold text-gray-900">{qualityScore.contrast}%</span>
          </div>
          <div className="flex justify-between items-center text-sm">
            <span className="text-gray-600">Hierarchy</span>
            <span className="font-semibold text-gray-900">{qualityScore.hierarchy}%</span>
          </div>
          <div className="flex justify-between items-center text-sm">
            <span className="text-gray-600">White Space</span>
            <span className="font-semibold text-gray-900">{qualityScore.whitespace}%</span>
          </div>
          <div className="flex justify-between items-center text-sm">
            <span className="text-gray-600">Accessibility</span>
            <span className="font-semibold text-gray-900">{qualityScore.accessibility}%</span>
          </div>
        </div>
      </div>

      {/* Design Pattern */}
      <div className="space-y-3">
        <h3 className="font-semibold text-gray-900">Design Pattern</h3>
        <div className="p-4 bg-gray-50 rounded-lg border border-gray-200">
          <div className="font-medium text-gray-900">{pattern?.name}</div>
          <p className="text-sm text-gray-600 mt-1">{pattern?.description}</p>
          <div className="mt-3 flex flex-wrap gap-2">
            {pattern?.bestFor.map((use, idx) => (
              <span key={idx} className="px-2 py-1 bg-blue-100 text-blue-700 text-xs rounded">
                {use}
              </span>
            ))}
          </div>
        </div>
      </div>

      {/* Color Palette */}
      <div className="space-y-3">
        <h3 className="font-semibold text-gray-900">Color Palette</h3>
        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-2">
            <div className="text-sm font-medium text-gray-600">Primary</div>
            <div
              className="w-full h-12 rounded-lg border-2 border-gray-200"
              style={{ backgroundColor: spec.styleTokens.palette.primary }}
            />
            <code className="text-xs text-gray-500">{spec.styleTokens.palette.primary}</code>
          </div>
          <div className="space-y-2">
            <div className="text-sm font-medium text-gray-600">Accent</div>
            <div
              className="w-full h-12 rounded-lg border-2 border-gray-200"
              style={{ backgroundColor: spec.styleTokens.palette.accent }}
            />
            <code className="text-xs text-gray-500">{spec.styleTokens.palette.accent}</code>
          </div>
        </div>

        {/* Neutral Colors */}
        <div className="text-sm font-medium text-gray-600 mt-4">Neutral Scale</div>
        <div className="grid grid-cols-7 gap-2">
          {spec.styleTokens.palette.neutral.map((color, idx) => (
            <div key={idx} className="space-y-1">
              <div
                className="w-full h-8 rounded border border-gray-300"
                style={{ backgroundColor: color }}
              />
              <code className="text-xs text-gray-500 block text-center">{idx}</code>
            </div>
          ))}
        </div>
      </div>

      {/* Typography */}
      <div className="space-y-3">
        <h3 className="font-semibold text-gray-900">Typography</h3>
        <div className="space-y-4">
          <div>
            <div className="text-sm font-medium text-gray-600 mb-2">Primary Font</div>
            <div className="text-2xl font-bold" style={{ fontFamily: spec.design.typography.fontPairing.primary }}>
              {spec.design.typography.fontPairing.primary}
            </div>
          </div>
          <div>
            <div className="text-sm font-medium text-gray-600 mb-2">Secondary Font</div>
            <div className="text-lg" style={{ fontFamily: spec.design.typography.fontPairing.secondary }}>
              {spec.design.typography.fontPairing.secondary}
            </div>
          </div>
        </div>
      </div>

      {/* Issues & Warnings */}
      {(qualityScore.issues.length > 0 || qualityScore.warnings.length > 0) && (
        <div className="space-y-3">
          <h3 className="font-semibold text-gray-900">Design Feedback</h3>
          {qualityScore.issues.length > 0 && (
            <div className="p-3 bg-red-50 border border-red-200 rounded-lg">
              <div className="text-sm font-semibold text-red-900 mb-2">Issues</div>
              <ul className="space-y-1">
                {qualityScore.issues.map((issue, idx) => (
                  <li key={idx} className="text-sm text-red-800">
                    • {issue}
                  </li>
                ))}
              </ul>
            </div>
          )}
          {qualityScore.warnings.length > 0 && (
            <div className="p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
              <div className="text-sm font-semibold text-yellow-900 mb-2">Warnings</div>
              <ul className="space-y-1">
                {qualityScore.warnings.map((warning, idx) => (
                  <li key={idx} className="text-sm text-yellow-800">
                    • {warning}
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default DesignPreview;



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/DesignSystemUI.tsx
=================================================================================
/**
 * Design System UI Component
 * Showcases all available design system options
 */

import React, { useState } from "react";
import { PROFESSIONAL_PALETTES, getPaletteNames } from "@/lib/colorPalettes";
import { TYPOGRAPHY_PAIRS, getTypographyPairNames } from "@/lib/typographyPairs";
import { LAYOUT_PATTERNS, getLayoutPatternNames } from "@/lib/layoutPatterns";

interface DesignSystemUIProps {
  onSelectPalette?: (paletteName: string) => void;
  onSelectTypography?: (typographyName: string) => void;
  onSelectPattern?: (patternName: string) => void;
}

export const DesignSystemUI: React.FC<DesignSystemUIProps> = ({
  onSelectPalette,
  onSelectTypography,
  onSelectPattern
}) => {
  const [activeTab, setActiveTab] = useState<"palettes" | "typography" | "patterns">("palettes");

  return (
    <div className="w-full bg-white rounded-lg shadow-lg overflow-hidden">
      {/* Tabs */}
      <div className="flex border-b">
        <button
          onClick={() => setActiveTab("palettes")}
          className={`flex-1 px-4 py-3 font-medium text-center transition-colors ${
            activeTab === "palettes"
              ? "bg-blue-50 text-blue-700 border-b-2 border-blue-700"
              : "text-gray-600 hover:text-gray-900"
          }`}
        >
          Color Palettes
        </button>
        <button
          onClick={() => setActiveTab("typography")}
          className={`flex-1 px-4 py-3 font-medium text-center transition-colors ${
            activeTab === "typography"
              ? "bg-blue-50 text-blue-700 border-b-2 border-blue-700"
              : "text-gray-600 hover:text-gray-900"
          }`}
        >
          Typography
        </button>
        <button
          onClick={() => setActiveTab("patterns")}
          className={`flex-1 px-4 py-3 font-medium text-center transition-colors ${
            activeTab === "patterns"
              ? "bg-blue-50 text-blue-700 border-b-2 border-blue-700"
              : "text-gray-600 hover:text-gray-900"
          }`}
        >
          Patterns
        </button>
      </div>

      {/* Content */}
      <div className="p-6">
        {/* Palettes Tab */}
        {activeTab === "palettes" && (
          <div className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {getPaletteNames().map(paletteName => {
                const palette = PROFESSIONAL_PALETTES[paletteName];
                return (
                  <div
                    key={paletteName}
                    onClick={() => onSelectPalette?.(paletteName)}
                    className="p-4 border-2 border-gray-200 rounded-lg hover:border-blue-500 cursor-pointer transition-colors"
                  >
                    <h3 className="font-semibold text-gray-900 mb-3">{palette.name}</h3>
                    <div className="space-y-2">
                      <div className="flex gap-2">
                        <div
                          className="flex-1 h-8 rounded border border-gray-300"
                          style={{ backgroundColor: palette.primary }}
                          title="Primary"
                        />
                        <div
                          className="flex-1 h-8 rounded border border-gray-300"
                          style={{ backgroundColor: palette.accent }}
                          title="Accent"
                        />
                      </div>
                      <div className="flex gap-1">
                        {palette.neutral.map((color, idx) => (
                          <div
                            key={idx}
                            className="flex-1 h-6 rounded border border-gray-300"
                            style={{ backgroundColor: color }}
                            title={`Neutral ${idx}`}
                          />
                        ))}
                      </div>
                    </div>
                    <p className="text-xs text-gray-600 mt-3">{palette.use}</p>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Typography Tab */}
        {activeTab === "typography" && (
          <div className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {getTypographyPairNames().map(typographyName => {
                const typography = TYPOGRAPHY_PAIRS[typographyName];
                return (
                  <div
                    key={typographyName}
                    onClick={() => onSelectTypography?.(typographyName)}
                    className="p-4 border-2 border-gray-200 rounded-lg hover:border-blue-500 cursor-pointer transition-colors"
                  >
                    <h3 className="font-semibold text-gray-900 mb-3">{typography.name}</h3>
                    <div className="space-y-3">
                      <div>
                        <div
                          className="text-2xl font-bold"
                          style={{ fontFamily: typography.primary }}
                        >
                          Primary Font
                        </div>
                        <code className="text-xs text-gray-500">{typography.primary}</code>
                      </div>
                      <div>
                        <div style={{ fontFamily: typography.secondary }}>
                          Secondary Font
                        </div>
                        <code className="text-xs text-gray-500">{typography.secondary}</code>
                      </div>
                    </div>
                    <p className="text-xs text-gray-600 mt-3">{typography.use}</p>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Patterns Tab */}
        {activeTab === "patterns" && (
          <div className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {getLayoutPatternNames().map(patternName => {
                const pattern = LAYOUT_PATTERNS[patternName];
                return (
                  <div
                    key={patternName}
                    onClick={() => onSelectPattern?.(patternName)}
                    className="p-4 border-2 border-gray-200 rounded-lg hover:border-blue-500 cursor-pointer transition-colors"
                  >
                    <h3 className="font-semibold text-gray-900 mb-3">{pattern.name}</h3>
                    <p className="text-sm text-gray-600 mb-3">{pattern.description}</p>
                    <div className="mb-3">
                      <div className="text-xs font-medium text-gray-600 mb-2">Best for:</div>
                      <div className="flex flex-wrap gap-1">
                        {pattern.bestFor.map((use, idx) => (
                          <span key={idx} className="px-2 py-1 bg-gray-100 text-gray-700 text-xs rounded">
                            {use}
                          </span>
                        ))}
                      </div>
                    </div>
                    <div className="text-xs text-gray-500">
                      White Space: {pattern.whitespacePercentage}%
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default DesignSystemUI;



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/ErrorBoundary.tsx
=================================================================================
import { Component } from "react";
import type { ReactNode } from "react";

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("ErrorBoundary caught an error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="min-h-screen flex items-center justify-center bg-[var(--bg-secondary)] p-4">
          <div className="max-w-md w-full bg-[var(--bg-primary)] rounded-[var(--radius-lg)] shadow-[var(--shadow-lg)] p-6 space-y-4">
            <div className="flex items-center gap-3">
              <svg className="w-8 h-8 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
              </svg>
              <h1 className="text-[var(--step-1)] font-bold text-[var(--neutral-0)]">
                Something went wrong
              </h1>
            </div>
            
            <p className="text-[var(--step--1)] text-[var(--neutral-3)]">
              We encountered an unexpected error. Please try refreshing the page.
            </p>

            {this.state.error && (
              <details className="text-[var(--step--2)] text-[var(--neutral-4)]">
                <summary className="cursor-pointer hover:text-[var(--neutral-2)]">
                  Error details
                </summary>
                <pre className="mt-2 p-2 bg-[var(--neutral-6)] rounded-[var(--radius-sm)] overflow-auto">
                  {this.state.error.toString()}
                </pre>
              </details>
            )}

            <button
              onClick={() => window.location.reload()}
              className="w-full px-4 py-2 bg-[var(--color-primary)] text-white rounded-[var(--radius-md)] font-medium hover:opacity-90 transition-opacity"
            >
              Refresh Page
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/HistoryPanel.tsx
=================================================================================
import { useState } from "react";
import { useSlideHistory } from "@/hooks/useSlideHistory";
import type { Presentation } from "@/types/Presentation";

interface HistoryPanelProps {
  onLoadPresentation: (presentation: Presentation) => void;
}

export function HistoryPanel({ onLoadPresentation }: HistoryPanelProps) {
  const { 
    history, 
    loading, 
    deletePresentation, 
    clearHistory, 
    searchPresentations 
  } = useSlideHistory();
  
  const [searchQuery, setSearchQuery] = useState("");
  const [showConfirmClear, setShowConfirmClear] = useState(false);

  const displayedHistory = searchQuery 
    ? searchPresentations(searchQuery) 
    : history;

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return "Just now";
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    return date.toLocaleDateString();
  };

  if (loading) {
    return (
      <div className="glass rounded-[var(--radius-2xl)] p-6 space-y-4">
        <div className="h-8 bg-[var(--neutral-8)] rounded animate-pulse" />
        <div className="space-y-2">
          {[1, 2, 3].map((i) => (
            <div key={i} className="h-20 bg-[var(--neutral-8)] rounded animate-pulse" />
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="glass rounded-[var(--radius-2xl)] p-6 space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-xl font-bold text-[var(--neutral-1)]">
          Recent Presentations
        </h3>
        {history.length > 0 && (
          <button
            onClick={() => setShowConfirmClear(true)}
            className="text-sm text-red-500 hover:underline"
          >
            Clear All
          </button>
        )}
      </div>

      {/* Search */}
      {history.length > 0 && (
        <div className="relative">
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="Search presentations..."
            className="w-full px-4 py-2 pl-10 rounded-lg border-2 border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:outline-none"
          />
          <svg 
            className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-[var(--neutral-4)]" 
            fill="none" 
            stroke="currentColor" 
            viewBox="0 0 24 24"
          >
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
        </div>
      )}

      {/* History List */}
      <div className="space-y-2 max-h-96 overflow-y-auto">
        {displayedHistory.length === 0 ? (
          <div className="text-center py-8 text-[var(--neutral-4)]">
            {searchQuery ? (
              <p>No presentations found matching "{searchQuery}"</p>
            ) : (
              <div className="space-y-2">
                <p>No saved presentations yet</p>
                <p className="text-xs">Generated presentations will appear here</p>
              </div>
            )}
          </div>
        ) : (
          displayedHistory.map((item) => (
            <div
              key={item.id}
              className="group p-4 rounded-lg border-2 border-[var(--neutral-7)] hover:border-[var(--color-primary)] transition-all bg-white"
            >
              <div className="flex items-start justify-between gap-4">
                <button
                  onClick={() => onLoadPresentation(item.presentation)}
                  className="flex-1 text-left"
                >
                  <h4 className="font-semibold text-[var(--neutral-1)] group-hover:text-[var(--color-primary)] mb-1">
                    {item.presentation.title}
                  </h4>
                  <div className="flex items-center gap-3 text-xs text-[var(--neutral-4)]">
                    <span>{item.presentation.slides.length} slide{item.presentation.slides.length !== 1 ? 's' : ''}</span>
                    <span>•</span>
                    <span>{formatDate(item.savedAt)}</span>
                  </div>
                </button>

                <button
                  onClick={() => {
                    if (confirm(`Delete "${item.presentation.title}"?`)) {
                      deletePresentation(item.id);
                    }
                  }}
                  className="p-2 rounded-lg hover:bg-red-50 text-red-500 opacity-0 group-hover:opacity-100 transition-opacity"
                  aria-label="Delete presentation"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                  </svg>
                </button>
              </div>
            </div>
          ))
        )}
      </div>

      {/* Confirm Clear Dialog */}
      {showConfirmClear && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl p-6 max-w-sm mx-4 space-y-4">
            <h4 className="text-lg font-bold text-[var(--neutral-1)]">
              Clear All History?
            </h4>
            <p className="text-sm text-[var(--neutral-3)]">
              This will permanently delete all {history.length} saved presentation{history.length !== 1 ? 's' : ''}. This action cannot be undone.
            </p>
            <div className="flex gap-3">
              <button
                onClick={() => setShowConfirmClear(false)}
                className="flex-1 px-4 py-2 rounded-lg border-2 border-[var(--neutral-7)] text-[var(--neutral-2)] hover:bg-[var(--neutral-8)] transition-all"
              >
                Cancel
              </button>
              <button
                onClick={() => {
                  clearHistory();
                  setShowConfirmClear(false);
                }}
                className="flex-1 px-4 py-2 rounded-lg bg-red-500 text-white hover:bg-red-600 transition-all"
              >
                Clear All
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/ImageIntegration.tsx
=================================================================================
import { useState } from "react";
import { Link, Search, Palette, X } from "lucide-react";

type ImageRole = "hero" | "logo" | "illustration" | "icon" | "background";
type ImageSourceType = "url" | "unsplash" | "placeholder";

interface ImageData {
  role: ImageRole;
  source: {
    type: ImageSourceType;
    url?: string;
    query?: string;
  };
  alt: string;
  fit?: "cover" | "contain" | "fill";
}

interface ImageIntegrationProps {
  onAddImage: (image: ImageData) => void;
  onClose: () => void;
}

export function ImageIntegration({ onAddImage, onClose }: ImageIntegrationProps) {
  const [imageData, setImageData] = useState<ImageData>({
    role: "hero",
    source: { type: "unsplash", query: "" },
    alt: "",
    fit: "cover"
  });

  const roles: Array<{ role: ImageRole; label: string; description: string; size: string }> = [
    { role: "hero", label: "Hero Image", description: "Large featured image", size: "60-70% of slide" },
    { role: "logo", label: "Logo", description: "Brand identity", size: "1x1 inch" },
    { role: "illustration", label: "Illustration", description: "Supporting visual", size: "30-40% of slide" },
    { role: "icon", label: "Icon", description: "Small decorative", size: "0.5x0.5 inch" },
    { role: "background", label: "Background", description: "Full slide background", size: "Full slide" }
  ];

  const sourceTypes: Array<{ type: ImageSourceType; label: string; icon: any; description: string }> = [
    { type: "unsplash", label: "Unsplash", icon: Search, description: "High-quality stock photos" },
    { type: "url", label: "URL", icon: Link, description: "Image from web URL" },
    { type: "placeholder", label: "Placeholder", icon: Palette, description: "Generated placeholder" }
  ];

  const suggestedQueries: Record<string, string[]> = {
    business: ["business professional office modern", "corporate team meeting", "business handshake"],
    tech: ["technology abstract digital blue", "coding programming laptop", "data visualization"],
    finance: ["finance growth chart business", "money investment banking", "stock market trading"],
    healthcare: ["healthcare medical professional", "hospital doctor nurse", "medical technology"],
    marketing: ["marketing creative design colorful", "social media advertising", "brand strategy"]
  };

  const handleSubmit = () => {
    onAddImage(imageData);
    onClose();
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-y-auto">
        <div className="sticky top-0 bg-white border-b border-[var(--neutral-7)] p-6 flex items-center justify-between">
          <div>
            <h2 className="text-2xl font-bold text-[var(--neutral-1)]">Add Image</h2>
            <p className="text-sm text-[var(--neutral-3)]">Enhance your slide with visuals</p>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-[var(--neutral-8)] rounded-lg transition-colors"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        <div className="p-6 space-y-6">
          {/* Image Role */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
              Image Role
            </label>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {roles.map((role) => (
                <button
                  key={role.role}
                  onClick={() => setImageData({ ...imageData, role: role.role })}
                  className={`p-4 rounded-lg border-2 transition-all text-left ${
                    imageData.role === role.role
                      ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                      : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                  }`}
                >
                  <div className="font-semibold text-sm text-[var(--neutral-1)]">{role.label}</div>
                  <div className="text-xs text-[var(--neutral-4)] mt-1">{role.description}</div>
                  <div className="text-xs text-[var(--color-primary)] mt-1 font-medium">{role.size}</div>
                </button>
              ))}
            </div>
          </div>

          {/* Source Type */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
              Image Source
            </label>
            <div className="grid grid-cols-3 gap-3">
              {sourceTypes.map((source) => {
                const Icon = source.icon;
                return (
                  <button
                    key={source.type}
                    onClick={() => setImageData({ ...imageData, source: { type: source.type } })}
                    className={`p-4 rounded-lg border-2 transition-all ${
                      imageData.source.type === source.type
                        ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                        : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                    }`}
                  >
                    <Icon className={`w-5 h-5 mb-2 mx-auto ${imageData.source.type === source.type ? "text-[var(--color-primary)]" : "text-[var(--neutral-3)]"}`} />
                    <div className="font-semibold text-sm text-[var(--neutral-1)] text-center">{source.label}</div>
                    <div className="text-xs text-[var(--neutral-4)] mt-1 text-center">{source.description}</div>
                  </button>
                );
              })}
            </div>
          </div>

          {/* Source-specific inputs */}
          {imageData.source.type === "unsplash" && (
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
                Search Query
              </label>
              <input
                type="text"
                value={imageData.source.query || ""}
                onChange={(e) => setImageData({ ...imageData, source: { ...imageData.source, query: e.target.value } })}
                placeholder="e.g., business professional office modern"
                className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none"
              />
              
              {/* Suggested Queries */}
              <div className="mt-3">
                <p className="text-xs text-[var(--neutral-4)] mb-2">Suggested queries:</p>
                <div className="flex flex-wrap gap-2">
                  {Object.entries(suggestedQueries).map(([category, queries]) => (
                    <div key={category} className="space-y-1">
                      <p className="text-xs font-semibold text-[var(--neutral-3)] capitalize">{category}:</p>
                      {queries.map((query) => (
                        <button
                          key={query}
                          onClick={() => setImageData({ ...imageData, source: { type: "unsplash", query } })}
                          className="text-xs px-2 py-1 bg-[var(--neutral-8)] hover:bg-[var(--color-primary)]/10 text-[var(--neutral-2)] rounded mr-1"
                        >
                          {query}
                        </button>
                      ))}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          )}

          {imageData.source.type === "url" && (
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
                Image URL
              </label>
              <input
                type="url"
                value={imageData.source.url || ""}
                onChange={(e) => setImageData({ ...imageData, source: { ...imageData.source, url: e.target.value } })}
                placeholder="https://example.com/image.jpg"
                className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none"
              />
            </div>
          )}

          {imageData.source.type === "placeholder" && (
            <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
              <p className="text-sm text-blue-900">
                A placeholder image will be generated with your slide's color scheme.
              </p>
            </div>
          )}

          {/* Alt Text */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
              Alt Text (for accessibility)
            </label>
            <input
              type="text"
              value={imageData.alt}
              onChange={(e) => setImageData({ ...imageData, alt: e.target.value })}
              placeholder="Describe the image for screen readers"
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none"
            />
          </div>

          {/* Image Fit */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
              Image Fit
            </label>
            <div className="grid grid-cols-3 gap-3">
              {[
                { value: "cover", label: "Cover", description: "Fill area, crop if needed" },
                { value: "contain", label: "Contain", description: "Fit within area" },
                { value: "fill", label: "Fill", description: "Stretch to fill" }
              ].map((fit) => (
                <button
                  key={fit.value}
                  onClick={() => setImageData({ ...imageData, fit: fit.value as any })}
                  className={`p-3 rounded-lg border-2 transition-all ${
                    imageData.fit === fit.value
                      ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                      : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                  }`}
                >
                  <div className="font-semibold text-sm text-[var(--neutral-1)]">{fit.label}</div>
                  <div className="text-xs text-[var(--neutral-4)] mt-1">{fit.description}</div>
                </button>
              ))}
            </div>
          </div>

          {/* Actions */}
          <div className="flex gap-3 pt-4">
            <button
              onClick={onClose}
              className="flex-1 px-6 py-3 border border-[var(--neutral-7)] text-[var(--neutral-2)] font-semibold rounded-xl hover:bg-[var(--neutral-8)] transition-all"
            >
              Cancel
            </button>
            <button
              onClick={handleSubmit}
              disabled={
                (imageData.source.type === "unsplash" && !imageData.source.query) ||
                (imageData.source.type === "url" && !imageData.source.url) ||
                !imageData.alt.trim()
              }
              className="flex-1 px-6 py-3 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transition-all disabled:opacity-50"
            >
              Add Image to Slide
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/ImageUpload.tsx
=================================================================================
import { useState, useRef, useCallback } from "react";
import { logger } from "@/lib/logger";

interface ImageUploadProps {
  onImageUpload: (imageData: string, file: File) => void;
  maxSizeMB?: number;
  acceptedFormats?: string[];
}

export function ImageUpload({ 
  onImageUpload, 
  maxSizeMB = 5,
  acceptedFormats = ["image/jpeg", "image/png", "image/gif", "image/webp"]
}: ImageUploadProps) {
  const [isDragging, setIsDragging] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [uploading, setUploading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const validateFile = (file: File): string | null => {
    // Check file type
    if (!acceptedFormats.includes(file.type)) {
      return `Invalid file type. Accepted formats: ${acceptedFormats.map(f => f.split('/')[1]).join(', ')}`;
    }

    // Check file size
    const sizeMB = file.size / (1024 * 1024);
    if (sizeMB > maxSizeMB) {
      return `File too large. Maximum size: ${maxSizeMB}MB`;
    }

    return null;
  };

  const processFile = useCallback(async (file: File) => {
    setError(null);
    setUploading(true);

    const validationError = validateFile(file);
    if (validationError) {
      setError(validationError);
      setUploading(false);
      return;
    }

    try {
      // Read file as data URL
      const reader = new FileReader();
      reader.onload = (e) => {
        const result = e.target?.result as string;
        if (result) {
          onImageUpload(result, file);
          logger.info("Image uploaded successfully", { 
            filename: file.name, 
            size: file.size,
            type: file.type 
          });
        }
        setUploading(false);
      };
      reader.onerror = () => {
        setError("Failed to read file");
        setUploading(false);
        logger.error("Failed to read image file", { filename: file.name });
      };
      reader.readAsDataURL(file);
    } catch (err) {
      setError("Failed to process image");
      setUploading(false);
      logger.error("Failed to process image", err);
    }
  }, [onImageUpload, maxSizeMB, acceptedFormats]);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);

    const files = Array.from(e.dataTransfer.files);
    if (files.length > 0) {
      processFile(files[0]);
    }
  };

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      processFile(files[0]);
    }
  };

  const handleClick = () => {
    fileInputRef.current?.click();
  };

  return (
    <div className="space-y-3">
      <div
        onClick={handleClick}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        className={`relative border-2 border-dashed rounded-xl p-8 text-center cursor-pointer transition-all ${
          isDragging
            ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
            : "border-[var(--neutral-7)] hover:border-[var(--color-primary)] hover:bg-[var(--neutral-9)]"
        } ${uploading ? "opacity-50 pointer-events-none" : ""}`}
      >
        <input
          ref={fileInputRef}
          type="file"
          accept={acceptedFormats.join(",")}
          onChange={handleFileSelect}
          className="hidden"
          aria-label="Upload image"
        />

        <div className="space-y-3">
          {uploading ? (
            <>
              <div className="w-12 h-12 mx-auto border-4 border-[var(--color-primary)] border-t-transparent rounded-full animate-spin" />
              <p className="text-sm text-[var(--neutral-3)]">Uploading...</p>
            </>
          ) : (
            <>
              <svg
                className="w-12 h-12 mx-auto text-[var(--neutral-4)]"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
                />
              </svg>
              <div>
                <p className="text-sm font-medium text-[var(--neutral-2)]">
                  Click to upload or drag and drop
                </p>
                <p className="text-xs text-[var(--neutral-4)] mt-1">
                  {acceptedFormats.map(f => f.split('/')[1].toUpperCase()).join(', ')} up to {maxSizeMB}MB
                </p>
              </div>
            </>
          )}
        </div>
      </div>

      {error && (
        <div className="flex items-center gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
          <svg className="w-5 h-5 text-red-500 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
            <path
              fillRule="evenodd"
              d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
              clipRule="evenodd"
            />
          </svg>
          <p className="text-sm text-red-700">{error}</p>
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/LoadingSkeleton.tsx
=================================================================================
export function LoadingSkeleton() {
  return (
    <div className="relative w-full aspect-video bg-[var(--neutral-6)] overflow-hidden rounded-[var(--radius-lg)] p-[var(--space-5)] animate-pulse">
      <div className="h-full w-full flex flex-col gap-4">
        {/* Header skeleton */}
        <div className="space-y-3">
          <div className="h-8 bg-[var(--neutral-5)] rounded w-3/4"></div>
          <div className="h-4 bg-[var(--neutral-5)] rounded w-1/2"></div>
        </div>
        
        {/* Body skeleton */}
        <div className="flex-1 grid grid-cols-3 gap-4">
          <div className="col-span-2 space-y-3">
            <div className="h-4 bg-[var(--neutral-5)] rounded w-full"></div>
            <div className="h-4 bg-[var(--neutral-5)] rounded w-5/6"></div>
            <div className="h-4 bg-[var(--neutral-5)] rounded w-4/5"></div>
            <div className="h-4 bg-[var(--neutral-5)] rounded w-full"></div>
            <div className="h-4 bg-[var(--neutral-5)] rounded w-3/4"></div>
          </div>
          <div className="col-span-1">
            <div className="h-32 bg-[var(--neutral-5)] rounded"></div>
          </div>
        </div>
      </div>
      
      {/* Loading text */}
      <div className="absolute inset-0 flex items-center justify-center bg-black/5">
        <div className="text-[var(--neutral-3)] text-lg font-medium">
          Generating your slide...
        </div>
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/PresentationGenerator.tsx
=================================================================================
import { useState } from "react";
import { Presentation, Users, Sparkles, FileText, CheckCircle2, Loader2 } from "lucide-react";

interface PresentationRequest {
  topic: string;
  audience: "executives" | "technical" | "sales" | "general" | "investors";
  tone: "formal" | "casual" | "persuasive" | "educational" | "inspirational";
  slideCount?: number;
  industry: "tech" | "finance" | "healthcare" | "marketing" | "corporate";
  includeAgenda: boolean;
  includeSummary: boolean;
}

interface PresentationGeneratorProps {
  onGenerate: (request: PresentationRequest) => Promise<void>;
  loading?: boolean;
}

export function PresentationGenerator({ onGenerate, loading = false }: PresentationGeneratorProps) {
  const [request, setRequest] = useState<PresentationRequest>({
    topic: "",
    audience: "general",
    tone: "formal",
    slideCount: 10,
    industry: "corporate",
    includeAgenda: true,
    includeSummary: true
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await onGenerate(request);
  };

  return (
    <div className="bg-white rounded-2xl shadow-xl border border-[var(--neutral-7)] p-8 space-y-6">
      <div className="flex items-center gap-3 mb-6">
        <div className="p-3 bg-gradient-to-br from-[var(--color-primary)] to-[var(--color-accent)] rounded-xl">
          <Presentation className="w-6 h-6 text-white" />
        </div>
        <div>
          <h2 className="text-2xl font-bold text-[var(--neutral-1)]">Generate Full Presentation</h2>
          <p className="text-sm text-[var(--neutral-3)]">AI-powered multi-slide generation</p>
        </div>
      </div>

      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Topic */}
        <div>
          <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
            Presentation Topic *
          </label>
          <input
            type="text"
            value={request.topic}
            onChange={(e) => setRequest({ ...request, topic: e.target.value })}
            placeholder="e.g., Q4 Product Launch Strategy"
            className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none transition-all"
            required
          />
        </div>

        {/* Audience & Tone */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2 flex items-center gap-2">
              <Users className="w-4 h-4" />
              Target Audience
            </label>
            <select
              value={request.audience}
              onChange={(e) => setRequest({ ...request, audience: e.target.value as any })}
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none transition-all"
            >
              <option value="executives">Executives</option>
              <option value="technical">Technical Team</option>
              <option value="sales">Sales Team</option>
              <option value="general">General Audience</option>
              <option value="investors">Investors</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2 flex items-center gap-2">
              <Sparkles className="w-4 h-4" />
              Tone
            </label>
            <select
              value={request.tone}
              onChange={(e) => setRequest({ ...request, tone: e.target.value as any })}
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none transition-all"
            >
              <option value="formal">Formal</option>
              <option value="casual">Casual</option>
              <option value="persuasive">Persuasive</option>
              <option value="educational">Educational</option>
              <option value="inspirational">Inspirational</option>
            </select>
          </div>
        </div>

        {/* Industry & Slide Count */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
              Industry
            </label>
            <select
              value={request.industry}
              onChange={(e) => setRequest({ ...request, industry: e.target.value as any })}
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none transition-all"
            >
              <option value="tech">Technology</option>
              <option value="finance">Finance</option>
              <option value="healthcare">Healthcare</option>
              <option value="marketing">Marketing</option>
              <option value="corporate">Corporate</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2 flex items-center gap-2">
              <FileText className="w-4 h-4" />
              Number of Slides
            </label>
            <input
              type="number"
              min="5"
              max="20"
              value={request.slideCount}
              onChange={(e) => setRequest({ ...request, slideCount: parseInt(e.target.value) })}
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none transition-all"
            />
          </div>
        </div>

        {/* Options */}
        <div className="space-y-3 p-4 bg-[var(--neutral-8)] rounded-lg">
          <label className="flex items-center gap-3 cursor-pointer group">
            <input
              type="checkbox"
              checked={request.includeAgenda}
              onChange={(e) => setRequest({ ...request, includeAgenda: e.target.checked })}
              className="w-5 h-5 rounded border-[var(--neutral-6)] text-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20"
            />
            <div className="flex items-center gap-2">
              <CheckCircle2 className="w-4 h-4 text-[var(--color-primary)]" />
              <span className="text-sm font-medium text-[var(--neutral-2)] group-hover:text-[var(--neutral-1)]">
                Include Agenda Slide
              </span>
            </div>
          </label>

          <label className="flex items-center gap-3 cursor-pointer group">
            <input
              type="checkbox"
              checked={request.includeSummary}
              onChange={(e) => setRequest({ ...request, includeSummary: e.target.checked })}
              className="w-5 h-5 rounded border-[var(--neutral-6)] text-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20"
            />
            <div className="flex items-center gap-2">
              <CheckCircle2 className="w-4 h-4 text-[var(--color-primary)]" />
              <span className="text-sm font-medium text-[var(--neutral-2)] group-hover:text-[var(--neutral-1)]">
                Include Summary Slide
              </span>
            </div>
          </label>
        </div>

        {/* Submit Button */}
        <button
          type="submit"
          disabled={loading || !request.topic.trim()}
          className="w-full px-6 py-4 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
        >
          {loading ? (
            <>
              <Loader2 className="w-5 h-5 animate-spin" />
              Generating Presentation...
            </>
          ) : (
            <>
              <Sparkles className="w-5 h-5" />
              Generate {request.slideCount} Slides
            </>
          )}
        </button>
      </form>

      {/* Info Box */}
      <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
        <p className="text-sm text-blue-900">
          <strong>💡 Pro Tip:</strong> The AI will analyze your topic and create a complete presentation
          with optimal slide structure, narrative flow, and professional design.
        </p>
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/ProgressIndicator.tsx
=================================================================================
import { useEffect, useState } from "react";

interface ProgressIndicatorProps {
  isLoading: boolean;
  estimatedDuration?: number; // in milliseconds
}

export function ProgressIndicator({ isLoading, estimatedDuration = 5000 }: ProgressIndicatorProps) {
  const [progress, setProgress] = useState(0);
  const [stage, setStage] = useState("Initializing...");

  useEffect(() => {
    if (!isLoading) {
      setProgress(0);
      setStage("Initializing...");
      return;
    }

    const stages = [
      { progress: 20, label: "Analyzing prompt...", duration: 500 },
      { progress: 40, label: "Generating content...", duration: 2000 },
      { progress: 70, label: "Designing layout...", duration: 1500 },
      { progress: 90, label: "Finalizing slide...", duration: 1000 },
    ];

    let currentStageIndex = 0;
    let currentProgress = 0;

    const updateProgress = () => {
      if (currentStageIndex >= stages.length) return;

      const stage = stages[currentStageIndex];
      setStage(stage.label);

      const increment = (stage.progress - currentProgress) / (stage.duration / 50);
      
      const interval = setInterval(() => {
        currentProgress += increment;
        if (currentProgress >= stage.progress) {
          currentProgress = stage.progress;
          clearInterval(interval);
          currentStageIndex++;
          if (currentStageIndex < stages.length) {
            setTimeout(updateProgress, 100);
          }
        }
        setProgress(Math.min(currentProgress, 95)); // Never reach 100% until actually done
      }, 50);

      return () => clearInterval(interval);
    };

    updateProgress();
  }, [isLoading, estimatedDuration]);

  if (!isLoading) return null;

  return (
    <div className="space-y-3 animate-fade-in">
      <div className="flex items-center justify-between text-sm">
        <span className="text-[var(--neutral-2)] font-medium">{stage}</span>
        <span className="text-[var(--neutral-3)] font-mono">{Math.round(progress)}%</span>
      </div>
      
      <div className="relative h-2 bg-[var(--neutral-8)] rounded-full overflow-hidden">
        <div
          className="absolute top-0 left-0 h-full bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-primary-light)] transition-all duration-300 ease-out"
          style={{ width: `${progress}%` }}
        >
          <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent animate-shimmer" />
        </div>
      </div>
      
      <div className="flex items-center gap-2 text-xs text-[var(--neutral-4)]">
        <svg className="w-4 h-4 animate-spin" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
        </svg>
        <span>This usually takes 3-5 seconds</span>
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideBuilder.tsx
=================================================================================
import { useState } from "react";
import { useToast } from "./Toast";
import { ChevronRight, Plus, X, Sparkles } from "lucide-react";

interface SlideBuilderProps {
  onSlideReady?: (prompt: string) => void;
  isGenerating?: boolean;
}

interface SlideData {
  title: string;
  subtitle: string;
  contentType: "bullets" | "metrics" | "narrative" | "mixed";
  bullets: string[];
  metrics: { label: string; value: string }[];
  narrative: string;
  designStyle: "professional" | "creative" | "minimal" | "bold";
  audience: string;
}

export function SlideBuilder({ onSlideReady, isGenerating = false }: SlideBuilderProps) {
  const [step, setStep] = useState<1 | 2 | 3 | 4>(1);
  const [data, setData] = useState<SlideData>({
    title: "",
    subtitle: "",
    contentType: "bullets",
    bullets: [""],
    metrics: [{ label: "", value: "" }],
    narrative: "",
    designStyle: "professional",
    audience: "",
  });
  const toast = useToast();

  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setData({ ...data, title: e.target.value });
  };

  const handleSubtitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setData({ ...data, subtitle: e.target.value });
  };

  const handleBulletChange = (index: number, value: string) => {
    const newBullets = [...data.bullets];
    newBullets[index] = value;
    setData({ ...data, bullets: newBullets });
  };

  const addBullet = () => {
    setData({ ...data, bullets: [...data.bullets, ""] });
  };

  const removeBullet = (index: number) => {
    setData({ ...data, bullets: data.bullets.filter((_, i) => i !== index) });
  };

  const handleMetricChange = (index: number, field: "label" | "value", value: string) => {
    const newMetrics = [...data.metrics];
    newMetrics[index][field] = value;
    setData({ ...data, metrics: newMetrics });
  };

  const addMetric = () => {
    setData({ ...data, metrics: [...data.metrics, { label: "", value: "" }] });
  };

  const removeMetric = (index: number) => {
    setData({ ...data, metrics: data.metrics.filter((_, i) => i !== index) });
  };

  const handleNarrativeChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setData({ ...data, narrative: e.target.value });
  };

  const generatePrompt = (): string => {
    const parts: string[] = [];
    
    parts.push(`Create a professional PowerPoint slide with the following specifications:`);
    parts.push(`\nTitle: "${data.title}"`);
    
    if (data.subtitle) {
      parts.push(`Subtitle: "${data.subtitle}"`);
    }

    if (data.contentType === "bullets" && data.bullets.some(b => b.trim())) {
      parts.push(`\nContent (bullet points):`);
      data.bullets.forEach(b => {
        if (b.trim()) parts.push(`- ${b}`);
      });
    }

    if (data.contentType === "metrics" && data.metrics.some(m => m.label && m.value)) {
      parts.push(`\nKey Metrics:`);
      data.metrics.forEach(m => {
        if (m.label && m.value) parts.push(`- ${m.label}: ${m.value}`);
      });
    }

    if (data.contentType === "narrative" && data.narrative.trim()) {
      parts.push(`\nContent: ${data.narrative}`);
    }

    if (data.contentType === "mixed") {
      if (data.bullets.some(b => b.trim())) {
        parts.push(`\nBullet Points:`);
        data.bullets.forEach(b => {
          if (b.trim()) parts.push(`- ${b}`);
        });
      }
      if (data.metrics.some(m => m.label && m.value)) {
        parts.push(`\nMetrics:`);
        data.metrics.forEach(m => {
          if (m.label && m.value) parts.push(`- ${m.label}: ${m.value}`);
        });
      }
    }

    if (data.audience) {
      parts.push(`\nTarget Audience: ${data.audience}`);
    }

    parts.push(`\nDesign Style: ${data.designStyle}`);
    parts.push(`\nMake it visually appealing and professional.`);

    return parts.join("\n");
  };

  const handleGenerate = () => {
    if (!data.title.trim()) {
      toast.warning("Please enter a slide title");
      return;
    }

    const prompt = generatePrompt();
    if (onSlideReady) {
      onSlideReady(prompt);
    }
  };

  const canProceed = (): boolean => {
    if (step === 1) return data.title.trim().length > 0;
    if (step === 2) return data.contentType !== "bullets" || data.bullets.some(b => b.trim());
    if (step === 3) return true;
    return true;
  };

  return (
    <div className="flex flex-col h-full bg-white rounded-[var(--radius-2xl)] shadow-lg border border-[var(--neutral-7)] overflow-hidden">
      {/* Header */}
      <div className="bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] px-6 py-4 text-white">
        <div className="flex items-center gap-2">
          <Sparkles size={20} />
          <h2 className="text-lg font-semibold">Slide Builder</h2>
        </div>
        <p className="text-sm opacity-90 mt-1">Step {step} of 4 - {["Title & Subtitle", "Content", "Audience & Style", "Review"][step - 1]}</p>
      </div>

      {/* Progress Bar */}
      <div className="h-1 bg-[var(--neutral-8)]">
        <div
          className="h-full bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] transition-all duration-300"
          style={{ width: `${(step / 4) * 100}%` }}
        />
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto p-6 space-y-6">
        {/* Step 1: Title & Subtitle */}
        {step === 1 && (
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-2">
                Slide Title
              </label>
              <input
                type="text"
                value={data.title}
                onChange={handleTitleChange}
                placeholder="e.g., Q3 Financial Results"
                className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all text-lg"
              />
            </div>
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-2">
                Subtitle (Optional)
              </label>
              <input
                type="text"
                value={data.subtitle}
                onChange={handleSubtitleChange}
                placeholder="e.g., Performance Overview"
                className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all"
              />
            </div>
          </div>
        )}

        {/* Step 2: Content */}
        {step === 2 && (
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-3">
                Content Type
              </label>
              <div className="grid grid-cols-2 gap-3">
                {(["bullets", "metrics", "narrative", "mixed"] as const).map((type) => (
                  <button
                    key={type}
                    onClick={() => setData({ ...data, contentType: type })}
                    className={`p-3 rounded-lg border-2 transition-all text-sm font-medium capitalize ${
                      data.contentType === type
                        ? "border-[var(--color-primary)] bg-[var(--color-primary)]/10 text-[var(--color-primary)]"
                        : "border-[var(--neutral-7)] text-[var(--neutral-2)] hover:border-[var(--color-primary)]"
                    }`}
                  >
                    {type}
                  </button>
                ))}
              </div>
            </div>

            {/* Bullets */}
            {(data.contentType === "bullets" || data.contentType === "mixed") && (
              <div>
                <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-2">
                  Bullet Points
                </label>
                <div className="space-y-2">
                  {data.bullets.map((bullet, idx) => (
                    <div key={idx} className="flex gap-2">
                      <input
                        type="text"
                        value={bullet}
                        onChange={(e) => handleBulletChange(idx, e.target.value)}
                        placeholder={`Point ${idx + 1}`}
                        className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all text-sm"
                      />
                      {data.bullets.length > 1 && (
                        <button
                          onClick={() => removeBullet(idx)}
                          className="p-2 text-[var(--neutral-3)] hover:text-red-500 transition-colors"
                        >
                          <X size={18} />
                        </button>
                      )}
                    </div>
                  ))}
                  <button
                    onClick={addBullet}
                    className="flex items-center gap-2 text-sm text-[var(--color-primary)] hover:text-[var(--color-primary-dark)] font-medium mt-2"
                  >
                    <Plus size={16} />
                    Add Bullet
                  </button>
                </div>
              </div>
            )}

            {/* Metrics */}
            {(data.contentType === "metrics" || data.contentType === "mixed") && (
              <div>
                <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-2">
                  Key Metrics
                </label>
                <div className="space-y-2">
                  {data.metrics.map((metric, idx) => (
                    <div key={idx} className="flex gap-2">
                      <input
                        type="text"
                        value={metric.label}
                        onChange={(e) => handleMetricChange(idx, "label", e.target.value)}
                        placeholder="Label"
                        className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all text-sm"
                      />
                      <input
                        type="text"
                        value={metric.value}
                        onChange={(e) => handleMetricChange(idx, "value", e.target.value)}
                        placeholder="Value"
                        className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all text-sm"
                      />
                      {data.metrics.length > 1 && (
                        <button
                          onClick={() => removeMetric(idx)}
                          className="p-2 text-[var(--neutral-3)] hover:text-red-500 transition-colors"
                        >
                          <X size={18} />
                        </button>
                      )}
                    </div>
                  ))}
                  <button
                    onClick={addMetric}
                    className="flex items-center gap-2 text-sm text-[var(--color-primary)] hover:text-[var(--color-primary-dark)] font-medium mt-2"
                  >
                    <Plus size={16} />
                    Add Metric
                  </button>
                </div>
              </div>
            )}

            {/* Narrative */}
            {(data.contentType === "narrative" || data.contentType === "mixed") && (
              <div>
                <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-2">
                  Content
                </label>
                <textarea
                  value={data.narrative}
                  onChange={handleNarrativeChange}
                  placeholder="Describe your slide content..."
                  className="w-full px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all text-sm resize-none"
                  rows={4}
                />
              </div>
            )}
          </div>
        )}

        {/* Step 3: Audience & Style */}
        {step === 3 && (
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-2">
                Target Audience
              </label>
              <input
                type="text"
                value={data.audience}
                onChange={(e) => setData({ ...data, audience: e.target.value })}
                placeholder="e.g., Executive team, Investors, Clients"
                className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all"
              />
            </div>
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-3">
                Design Style
              </label>
              <div className="grid grid-cols-2 gap-3">
                {(["professional", "creative", "minimal", "bold"] as const).map((style) => (
                  <button
                    key={style}
                    onClick={() => setData({ ...data, designStyle: style })}
                    className={`p-3 rounded-lg border-2 transition-all text-sm font-medium capitalize ${
                      data.designStyle === style
                        ? "border-[var(--color-primary)] bg-[var(--color-primary)]/10 text-[var(--color-primary)]"
                        : "border-[var(--neutral-7)] text-[var(--neutral-2)] hover:border-[var(--color-primary)]"
                    }`}
                  >
                    {style}
                  </button>
                ))}
              </div>
            </div>
          </div>
        )}

        {/* Step 4: Review */}
        {step === 4 && (
          <div className="space-y-4">
            <div className="bg-[var(--neutral-9)] rounded-lg p-4 space-y-3">
              <div>
                <p className="text-xs font-semibold text-[var(--neutral-3)] uppercase">Title</p>
                <p className="text-lg font-bold text-[var(--neutral-1)]">{data.title}</p>
              </div>
              {data.subtitle && (
                <div>
                  <p className="text-xs font-semibold text-[var(--neutral-3)] uppercase">Subtitle</p>
                  <p className="text-[var(--neutral-2)]">{data.subtitle}</p>
                </div>
              )}
              <div>
                <p className="text-xs font-semibold text-[var(--neutral-3)] uppercase">Content Type</p>
                <p className="text-[var(--neutral-2)] capitalize">{data.contentType}</p>
              </div>
              <div>
                <p className="text-xs font-semibold text-[var(--neutral-3)] uppercase">Design Style</p>
                <p className="text-[var(--neutral-2)] capitalize">{data.designStyle}</p>
              </div>
              {data.audience && (
                <div>
                  <p className="text-xs font-semibold text-[var(--neutral-3)] uppercase">Audience</p>
                  <p className="text-[var(--neutral-2)]">{data.audience}</p>
                </div>
              )}
            </div>
          </div>
        )}
      </div>

      {/* Footer */}
      <div className="border-t border-[var(--neutral-7)] p-4 bg-[var(--neutral-9)] flex gap-3">
        {step > 1 && (
          <button
            onClick={() => setStep((step - 1) as any)}
            className="px-4 py-2 rounded-lg border border-[var(--neutral-7)] text-[var(--neutral-1)] hover:bg-[var(--neutral-8)] transition-colors font-medium"
          >
            Back
          </button>
        )}
        {step < 4 ? (
          <button
            onClick={() => setStep((step + 1) as any)}
            disabled={!canProceed() || isGenerating}
            className="flex-1 px-4 py-2 bg-[var(--color-primary)] text-white rounded-lg font-medium hover:bg-[var(--color-primary-dark)] disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center justify-center gap-2"
          >
            Next
            <ChevronRight size={18} />
          </button>
        ) : (
          <button
            onClick={handleGenerate}
            disabled={isGenerating}
            className="flex-1 px-4 py-2 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white rounded-lg font-medium hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed transition-all flex items-center justify-center gap-2"
          >
            <Sparkles size={18} />
            {isGenerating ? "Creating..." : "Create Slide"}
          </button>
        )}
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideCanvas.tsx
=================================================================================
import { useEffect, useState, useMemo } from "react";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";
import type { SlideSpecV2 } from "@/types/SlideSpecV2";
import { Chart } from "./Chart";
import { logDiagnostics, validateLayoutCalculations } from "@/utils/slideDebugger";

type SlideSpec = SlideSpecV1 | SlideSpecV2;

export function SlideCanvas({ spec }: { spec: SlideSpec }) {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    // Log diagnostics when spec changes
    console.log("🎨 SlideCanvas spec:", spec);
    console.log("📋 Content:", spec.content);
    console.log("📐 Layout:", spec.layout);
    logDiagnostics(spec as SlideSpecV1);
    validateLayoutCalculations(spec as SlideSpecV1);

    // Trigger animation when spec changes
    setIsVisible(false);
    const timer = setTimeout(() => setIsVisible(true), 50);
    return () => clearTimeout(timer);
  }, [spec]);

  // Get design tokens from spec (handle both V1 and V2)
  const designTokens = useMemo(() => {
    const v2Spec = spec as SlideSpecV2;
    const v1Spec = spec as SlideSpecV1;

    // Extract palette and typography from styleTokens
    const palette = v1Spec.styleTokens?.palette || {
      primary: "#6366F1",
      accent: "#EC4899",
      neutral: ["#0F172A", "#1E293B", "#334155", "#475569", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC"]
    };

    const typography = v1Spec.styleTokens?.typography || {
      fonts: { sans: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif" },
      sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 32 },
      weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
      lineHeights: { compact: 1.2, standard: 1.5 }
    };

    return {
      palette,
      typography,
      pattern: v2Spec.design?.pattern || "split",
      whitespace: v2Spec.design?.whitespace || { strategy: "balanced", breathingRoom: 30 },
    };
  }, [spec]);

  // Create inline styles for design tokens with gradient background
  const slideStyle: React.CSSProperties = designTokens ? {
    background: getGradientBackground(designTokens),
    color: designTokens.palette.neutral[0],
  } : {
    background: 'linear-gradient(135deg, #F8FAFC 0%, #F1F5F9 50%, #F8FAFC 100%)',
  };

  // Responsive 16:9 surface - with proper aspect ratio and sizing
  return (
    <div
      className={`relative w-full overflow-hidden rounded-[var(--radius-lg)] transition-all duration-500 shadow-lg ${
        isVisible ? 'opacity-100 scale-100' : 'opacity-0 scale-95'
      }`}
      style={{
        aspectRatio: '16 / 9',
        ...slideStyle,
      }}
    >
      <div
        style={{
          width: '100%',
          height: '100%',
          padding: 'var(--space-5)',
          boxSizing: 'border-box',
          display: 'flex',
          flexDirection: 'column',
        }}
      >
        {renderRegions(spec, designTokens)}
      </div>
    </div>
  );
}

function renderRegions(spec: SlideSpec, designTokens: any) {
  const { rows, cols, gutter, margin } = spec.layout.grid;

  // Convert pixel values to percentages for responsive layout
  const gridStyle: React.CSSProperties = {
    display: "grid",
    gridTemplateRows: `repeat(${rows}, minmax(0,1fr))`,
    gridTemplateColumns: `repeat(${cols}, minmax(0,1fr))`,
    gap: `${gutter}px`,
    padding: `${margin.t}px ${margin.r}px ${margin.b}px ${margin.l}px`,
    height: "100%",
    width: "100%",
    boxSizing: "border-box",
  };

  const regionToStyle = (r: any): React.CSSProperties => ({
    gridRow: `${r.rowStart} / span ${r.rowSpan}`,
    gridColumn: `${r.colStart} / span ${r.colSpan}`,
    display: "flex",
    flexDirection: "column",
    gap: "var(--space-3)",
    minHeight: 0,
    minWidth: 0,
    overflow: "hidden",
    justifyContent: "flex-start",
    alignItems: "stretch",
  });

  return (
    <div style={gridStyle}>
      {spec.layout.regions.map((r, i) => (
        <div key={i} style={regionToStyle(r)}>
          {spec.layout.anchors
            .filter(a => a.region === r.name)
            .sort((a, b) => a.order - b.order)
            .map(a => <ElementByRef key={a.refId} spec={spec} refId={a.refId} designTokens={designTokens} />)}
        </div>
      ))}
    </div>
  );
}

function ElementByRef({ spec, refId, designTokens }: { spec: SlideSpec; refId: string; designTokens: any }) {
  const c = spec.content;

  // Get typography config from design tokens
  const getTitleStyle = (): React.CSSProperties => {
    const sizes = designTokens?.typography?.sizes || { step_3: 32 };
    const weights = designTokens?.typography?.weights || { bold: 700 };
    const lineHeights = designTokens?.typography?.lineHeights || { compact: 1.2 };

    return {
      fontSize: `${sizes.step_3 || 32}px`,
      fontWeight: weights.bold || 700,
      lineHeight: lineHeights.compact || 1.2,
      color: designTokens?.palette?.primary || '#6366F1',
      margin: 0,
      padding: 0,
    };
  };

  const getSubtitleStyle = (): React.CSSProperties => {
    const sizes = designTokens?.typography?.sizes || { step_2: 24 };
    const weights = designTokens?.typography?.weights || { semibold: 600 };
    const lineHeights = designTokens?.typography?.lineHeights || { standard: 1.5 };

    return {
      fontSize: `${sizes.step_2 || 24}px`,
      fontWeight: weights.semibold || 600,
      lineHeight: lineHeights.standard || 1.5,
      color: designTokens?.palette?.neutral?.[2] || '#334155',
      margin: 0,
      padding: 0,
    };
  };

  const getBodyStyle = (): React.CSSProperties => {
    const sizes = designTokens?.typography?.sizes || { step_0: 16 };
    const weights = designTokens?.typography?.weights || { regular: 400 };
    const lineHeights = designTokens?.typography?.lineHeights || { standard: 1.5 };

    return {
      fontSize: `${sizes.step_0 || 16}px`,
      fontWeight: weights.regular || 400,
      lineHeight: lineHeights.standard || 1.5,
      color: designTokens?.palette?.neutral?.[0] || '#0F172A',
      margin: 0,
      padding: 0,
    };
  };

  if (c.title?.id === refId) {
    return (
      <h2 style={getTitleStyle()}>
        {c.title.text}
      </h2>
    );
  }

  if (c.subtitle?.id === refId) {
    return (
      <p style={getSubtitleStyle()}>
        {c.subtitle.text}
      </p>
    );
  }

  const bl = c.bullets?.find(x => x.id === refId);
  if (bl) {
    return (
      <ul style={{ ...getBodyStyle(), listStyle: 'none', margin: 0, padding: 0 }}>
        {bl.items.map((it, i) => (
          <li
            key={i}
            style={{
              marginLeft: `${(it.level - 1) * 24}px`,
              marginBottom: '8px',
              display: 'flex',
              alignItems: 'flex-start',
              gap: '12px',
            }}
          >
            <span
              style={{
                display: 'inline-block',
                width: '6px',
                height: '6px',
                borderRadius: '50%',
                backgroundColor: designTokens?.palette?.primary || '#6366F1',
                marginTop: '8px',
                flexShrink: 0,
              }}
            />
            <span>{it.text}</span>
          </li>
        ))}
      </ul>
    );
  }

  const co = c.callouts?.find(x => x.id === refId);
  if (co) {
    const bgColor = co.variant === "warning" ? "#FEF3C7" :
                    co.variant === "danger"  ? "#FEE2E2" :
                    co.variant === "success" ? "#D1FAE5" : "#F3F4F6";
    const borderColor = designTokens?.palette?.accent || "#EC4899";
    return (
      <div
        style={{
          padding: '12px 16px',
          borderRadius: '8px',
          border: `2px solid ${borderColor}`,
          backgroundColor: bgColor,
          color: designTokens?.palette?.neutral[0] || '#0F172A',
          fontSize: '14px',
          lineHeight: 1.5,
        }}
      >
        {co.title && <b>{co.title} — </b>}{co.text}
      </div>
    );
  }

  if (c.dataViz?.id === refId) {
    return (
      <div style={{ width: '100%', height: '100%', minHeight: '200px' }}>
        <Chart
          labels={c.dataViz.labels}
          series={c.dataViz.series}
          kind={c.dataViz.kind}
          title={c.dataViz.title}
          valueFormat={c.dataViz.valueFormat}
          colors={designTokens?.palette ? [designTokens.palette.primary, designTokens.palette.accent] : undefined}
        />
      </div>
    );
  }

  const ph = c.imagePlaceholders?.find(x => x.id === refId);
  if (ph) {
    return (
      <div
        role="img"
        aria-label={ph.alt}
        style={{
          width: '100%',
          height: '100%',
          borderRadius: '8px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: designTokens?.palette?.neutral[5] || '#94A3B8',
          color: designTokens?.palette?.neutral[2] || '#334155',
          fontSize: '14px',
          textAlign: 'center',
          padding: '16px',
          boxSizing: 'border-box',
        }}
      >
        <span>{ph.alt}</span>
      </div>
    );
  }

  return null;
}

/**
 * Generate gradient background based on design pattern
 */
function getGradientBackground(designTokens: any): string {
  const pattern = designTokens.pattern || 'split';
  const primary = designTokens.palette.primary || '#6366F1';
  const accent = designTokens.palette.accent || '#EC4899';
  const neutralLight = designTokens.palette.neutral[6] || '#F8FAFC';
  const neutralMid = designTokens.palette.neutral[4] || '#94A3B8';

  switch (pattern) {
    case 'hero':
      // Dramatic top-to-bottom gradient
      return `linear-gradient(180deg, ${neutralLight} 0%, ${primary}08 50%, ${accent}05 100%)`;

    case 'minimal':
      // Very subtle vignette effect
      return `radial-gradient(ellipse at center, ${neutralLight} 0%, ${neutralMid}05 100%)`;

    case 'data-focused':
      // Left-to-right gradient
      return `linear-gradient(90deg, ${neutralLight} 0%, ${accent}06 100%)`;

    case 'split':
      // Diagonal gradient
      return `linear-gradient(135deg, ${neutralLight} 0%, ${primary}05 50%, ${neutralLight} 100%)`;

    case 'asymmetric':
      // Dynamic angular gradient
      return `linear-gradient(120deg, ${neutralLight} 0%, ${accent}08 60%, ${primary}05 100%)`;

    case 'grid':
      // Subtle radial gradient
      return `radial-gradient(circle at 50% 50%, ${neutralLight} 0%, ${neutralMid}04 100%)`;

    default:
      // Default subtle gradient
      return `linear-gradient(135deg, ${neutralLight} 0%, ${neutralMid}03 50%, ${neutralLight} 100%)`;
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideChat.tsx
=================================================================================
import { useState, useRef, useEffect } from "react";
import { useToast } from "./Toast";
import { Send, Loader } from "lucide-react";

interface Message {
  id: string;
  role: "user" | "assistant";
  content: string;
  timestamp: number;
}

interface ChatProps {
  onSlideReady?: (prompt: string) => void;
  isGenerating?: boolean;
}

export function SlideChat({ onSlideReady, isGenerating = false }: ChatProps) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const toast = useToast();

  // Focus input on mount
  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const generateFollowUp = async (userMessage: string, conversationHistory: Message[]) => {
    try {
      const response = await fetch(
        "https://generateslidespec-3wgb3rbjta-uc.a.run.app",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            prompt: `You are a helpful assistant gathering information to create a professional PowerPoint slide.

User message: "${userMessage}"

Previous conversation:
${conversationHistory.map((m) => `${m.role === "user" ? "User" : "Assistant"}: ${m.content}`).join("\n")}

TASK: Based on the conversation, determine what information we still need and ask ONE specific follow-up question.

INFORMATION NEEDED (in order):
1. Title/Topic - What is the slide about?
2. Main Content - What are the key points or bullet points?
3. Additional Details - Any specific data, metrics, or context?
4. Design Preference - Any style preferences (professional, creative, minimal, etc.)?

RESPONSE FORMAT:
- If we have title, content, and enough context: Respond with "READY_TO_CREATE: [comprehensive slide prompt]"
- Otherwise: Ask ONE specific, natural follow-up question to gather missing information

EXAMPLES OF GOOD QUESTIONS:
- "What are the 3-5 main points you want to highlight?"
- "Do you have any specific numbers or metrics to include?"
- "What's the audience for this slide?"
- "Would you prefer a professional or creative design style?"
- "Any specific color scheme or branding guidelines?"

Keep responses concise, friendly, and natural. Never say "I need more information" - always ask a specific question.`,
          }),
        }
      );

      if (!response.ok) throw new Error("Failed to generate response");
      const data = await response.json();

      let assistantMessage = data.slideSpec?.content?.title || "What are the key points or main content you'd like on this slide?";

      // Check if we have enough info
      if (assistantMessage.includes("READY_TO_CREATE:")) {
        const slidePrompt = assistantMessage.replace("READY_TO_CREATE:", "").trim();
        return { message: "Perfect! I have all the information I need. Creating your slide now...", isReady: true, slidePrompt };
      }

      return { message: assistantMessage, isReady: false };
    } catch (error) {
      console.error("Error generating response:", error);
      return { message: "What are the key points or main content you'd like on this slide?", isReady: false };
    }
  };

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!input.trim() || loading || isGenerating) return;

    const userMessage = input.trim();
    setInput("");
    setLoading(true);

    // Add user message
    const newUserMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: userMessage,
      timestamp: Date.now(),
    };
    setMessages((prev) => [...prev, newUserMessage]);

    // For first message, just generate the slide directly
    if (messages.length === 0) {
      try {
        if (onSlideReady) {
          onSlideReady(userMessage);
        }
        const assistantMessage: Message = {
          id: (Date.now() + 1).toString(),
          role: "assistant",
          content: "Perfect! I'm creating your slide now...",
          timestamp: Date.now(),
        };
        setMessages((prev) => [...prev, assistantMessage]);
      } catch (error) {
        toast.error("Failed to generate slide");
        console.error(error);
      } finally {
        setLoading(false);
      }
      return;
    }

    // For subsequent messages, use the conversational flow
    try {
      const { message, isReady, slidePrompt } = await generateFollowUp(userMessage, [...messages, newUserMessage]);

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: message,
        timestamp: Date.now(),
      };
      setMessages((prev) => [...prev, assistantMessage]);

      if (isReady && slidePrompt && onSlideReady) {
        setTimeout(() => {
          onSlideReady(slidePrompt);
        }, 500);
      }
    } catch (error) {
      toast.error("Failed to process message");
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex flex-col w-full">
      {/* Messages Container - Only show if there are messages */}
      {messages.length > 0 && (
        <div className="mb-6 space-y-4 max-h-96 overflow-y-auto px-2">
          {messages.map((msg) => (
            <div
              key={msg.id}
              className={`flex ${msg.role === "user" ? "justify-end" : "justify-start"} animate-fade-in`}
            >
              <div
                className={`max-w-2xl px-5 py-3 rounded-2xl ${
                  msg.role === "user"
                    ? "bg-[var(--color-primary)] text-white rounded-br-sm shadow-md"
                    : "bg-white text-[var(--neutral-1)] rounded-bl-sm border border-[var(--neutral-7)] shadow-sm"
                }`}
              >
                <p className="text-sm leading-relaxed">{msg.content}</p>
              </div>
            </div>
          ))}
          {loading && (
            <div className="flex justify-start animate-fade-in">
              <div className="bg-white text-[var(--neutral-1)] px-5 py-3 rounded-2xl rounded-bl-sm border border-[var(--neutral-7)] shadow-sm">
                <div className="flex gap-2">
                  <div className="w-2 h-2 bg-[var(--neutral-4)] rounded-full animate-bounce" />
                  <div className="w-2 h-2 bg-[var(--neutral-4)] rounded-full animate-bounce" style={{ animationDelay: "0.1s" }} />
                  <div className="w-2 h-2 bg-[var(--neutral-4)] rounded-full animate-bounce" style={{ animationDelay: "0.2s" }} />
                </div>
              </div>
            </div>
          )}
          <div ref={messagesEndRef} />
        </div>
      )}

      {/* ChatGPT-Style Input Area */}
      <div className="w-full">
        <form onSubmit={handleSendMessage} className="relative">
          <div className="relative glass rounded-[var(--radius-2xl)] shadow-xl border border-[var(--neutral-7)] overflow-hidden transition-all hover:shadow-2xl focus-within:shadow-2xl focus-within:border-[var(--color-primary)]">
            <input
              ref={inputRef}
              type="text"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              placeholder={messages.length === 0 ? "Describe the slide you want to create..." : "Continue the conversation..."}
              disabled={loading || isGenerating}
              className="w-full px-6 py-5 pr-16 text-base bg-transparent border-none outline-none disabled:opacity-50 disabled:cursor-not-allowed placeholder:text-[var(--neutral-4)]"
              style={{ fontSize: '16px' }}
            />
            <button
              type="submit"
              disabled={loading || isGenerating || !input.trim()}
              className="absolute right-3 top-1/2 -translate-y-1/2 p-3 bg-[var(--color-primary)] text-white rounded-xl font-medium hover:bg-[var(--color-primary-dark)] disabled:opacity-50 disabled:cursor-not-allowed transition-all hover:scale-105 active:scale-95 shadow-lg disabled:hover:scale-100"
              aria-label="Send message"
            >
              {loading || isGenerating ? (
                <Loader size={20} className="animate-spin" />
              ) : (
                <Send size={20} />
              )}
            </button>
          </div>
          {messages.length === 0 && (
            <p className="text-center text-sm text-[var(--neutral-4)] mt-3">
              Try: "Q4 Revenue Growth with key metrics" or "Product roadmap for 2025"
            </p>
          )}
        </form>
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideEditor.tsx
=================================================================================
import { useCallback } from "react";
import { Edit3, RefreshCw } from "lucide-react";
import { SlideCanvas } from "./SlideCanvas";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

interface SlideEditorProps {
  spec: SlideSpecV1;
  onUpdate: (updatedSpec: SlideSpecV1) => void;
  onExport?: () => void;
}

export function SlideEditor({ spec, onUpdate, onExport }: SlideEditorProps) {
  const handleRefresh = useCallback(() => {
    onUpdate(spec);
  }, [spec, onUpdate]);

  return (
    <div className="w-full space-y-6">
      {/* Slide Preview */}
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-[var(--neutral-1)] flex items-center gap-2">
            <Edit3 size={20} className="text-[var(--color-primary)]" />
            Live Preview
          </h3>
          <button
            onClick={handleRefresh}
            className="p-2 hover:bg-[var(--neutral-8)] rounded-lg transition-colors"
            title="Refresh preview"
          >
            <RefreshCw size={18} className="text-[var(--neutral-4)]" />
          </button>
        </div>

        <div className="glass rounded-[var(--radius-xl)] p-6 overflow-hidden shadow-xl border border-[var(--neutral-7)]">
          <SlideCanvas spec={spec} />
        </div>

        {/* Export Button */}
        {onExport && (
          <button
            onClick={onExport}
            className="w-full px-6 py-3 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-lg hover:shadow-lg transition-all active:scale-95"
          >
            Export to PowerPoint
          </button>
        )}
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideNavigation.tsx
=================================================================================
import type { Slide } from "@/types/Presentation";

interface SlideNavigationProps {
  slides: Slide[];
  currentIndex: number;
  onSelectSlide: (index: number) => void;
  onRemoveSlide: (slideId: string) => void;
  onDuplicateSlide: (slideId: string) => void;
  canGoNext: boolean;
  canGoPrevious: boolean;
  onNext: () => void;
  onPrevious: () => void;
}

export function SlideNavigation({
  slides,
  currentIndex,
  onSelectSlide,
  onRemoveSlide,
  onDuplicateSlide,
  canGoNext,
  canGoPrevious,
  onNext,
  onPrevious,
}: SlideNavigationProps) {
  if (slides.length === 0) return null;

  return (
    <div className="space-y-4">
      {/* Navigation Controls */}
      <div className="flex items-center justify-between gap-4">
        <button
          onClick={onPrevious}
          disabled={!canGoPrevious}
          className="p-2 rounded-lg hover:bg-[var(--neutral-8)] disabled:opacity-30 disabled:cursor-not-allowed transition-all"
          aria-label="Previous slide"
        >
          <svg className="w-6 h-6 text-[var(--neutral-2)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
          </svg>
        </button>

        <div className="flex-1 text-center">
          <span className="text-sm font-medium text-[var(--neutral-2)]">
            Slide {currentIndex + 1} of {slides.length}
          </span>
        </div>

        <button
          onClick={onNext}
          disabled={!canGoNext}
          className="p-2 rounded-lg hover:bg-[var(--neutral-8)] disabled:opacity-30 disabled:cursor-not-allowed transition-all"
          aria-label="Next slide"
        >
          <svg className="w-6 h-6 text-[var(--neutral-2)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
        </button>
      </div>

      {/* Thumbnail Strip */}
      <div className="relative">
        <div className="flex gap-3 overflow-x-auto pb-2 scrollbar-thin">
          {slides.map((slide, index) => (
            <div
              key={slide.id}
              className="relative flex-shrink-0 group"
            >
              <button
                onClick={() => onSelectSlide(index)}
                className={`relative w-32 h-20 rounded-lg border-2 transition-all overflow-hidden ${
                  index === currentIndex
                    ? 'border-[var(--color-primary)] shadow-lg scale-105'
                    : 'border-[var(--neutral-7)] hover:border-[var(--color-primary)] hover:shadow-md'
                }`}
                aria-label={`Go to slide ${index + 1}`}
              >
                {/* Thumbnail preview */}
                <div className="w-full h-full bg-[var(--neutral-8)] flex items-center justify-center">
                  <div className="text-center">
                    <div className="text-xs font-bold text-[var(--neutral-3)] mb-1">
                      {slide.spec.content.title.text.slice(0, 20)}
                      {slide.spec.content.title.text.length > 20 ? '...' : ''}
                    </div>
                    <div className="text-[10px] text-[var(--neutral-4)]">
                      Slide {index + 1}
                    </div>
                  </div>
                </div>

                {/* Current indicator */}
                {index === currentIndex && (
                  <div className="absolute bottom-0 left-0 right-0 h-1 bg-[var(--color-primary)]" />
                )}
              </button>

              {/* Action buttons - show on hover */}
              <div className="absolute -top-2 -right-2 opacity-0 group-hover:opacity-100 transition-opacity flex gap-1">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    onDuplicateSlide(slide.id);
                  }}
                  className="p-1.5 bg-white rounded-full shadow-md hover:bg-[var(--neutral-8)] border border-[var(--neutral-7)]"
                  aria-label="Duplicate slide"
                  title="Duplicate slide"
                >
                  <svg className="w-3 h-3 text-[var(--neutral-2)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                  </svg>
                </button>

                {slides.length > 1 && (
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      if (confirm(`Delete slide ${index + 1}?`)) {
                        onRemoveSlide(slide.id);
                      }
                    }}
                    className="p-1.5 bg-white rounded-full shadow-md hover:bg-red-50 border border-[var(--neutral-7)]"
                    aria-label="Delete slide"
                    title="Delete slide"
                  >
                    <svg className="w-3 h-3 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                  </button>
                )}
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Keyboard shortcuts hint */}
      <div className="text-xs text-[var(--neutral-4)] text-center">
        Use <kbd className="px-1.5 py-0.5 bg-[var(--neutral-8)] rounded text-[10px] font-mono">←</kbd> and{' '}
        <kbd className="px-1.5 py-0.5 bg-[var(--neutral-8)] rounded text-[10px] font-mono">→</kbd> to navigate
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideQualityAnalyzer.tsx
=================================================================================
import { useState, useEffect } from "react";
import { AlertCircle, CheckCircle2, AlertTriangle, Lightbulb, Wand2, TrendingUp } from "lucide-react";

interface SlideIssue {
  severity: "error" | "warning" | "suggestion";
  category: "content" | "design" | "accessibility" | "performance";
  message: string;
  fix?: string;
  autoFixable: boolean;
}

interface RefinementSuggestion {
  type: "content" | "design" | "layout" | "color" | "typography";
  priority: "high" | "medium" | "low";
  suggestion: string;
  rationale: string;
  autoApplicable: boolean;
}

interface SlideQualityAnalyzerProps {
  slideSpec: any;
  onAutoFix?: () => void;
  onApplySuggestion?: (suggestion: RefinementSuggestion) => void;
}

export function SlideQualityAnalyzer({ slideSpec, onAutoFix, onApplySuggestion }: SlideQualityAnalyzerProps) {
  const [issues, setIssues] = useState<SlideIssue[]>([]);
  const [suggestions, setSuggestions] = useState<RefinementSuggestion[]>([]);
  const [qualityScore, setQualityScore] = useState(0);

  useEffect(() => {
    analyzeSlide();
  }, [slideSpec]);

  const analyzeSlide = () => {
    const foundIssues: SlideIssue[] = [];
    const foundSuggestions: RefinementSuggestion[] = [];

    // Check title length
    if (slideSpec?.content?.title?.text?.length > 60) {
      foundIssues.push({
        severity: "warning",
        category: "content",
        message: "Title is too long (>60 characters)",
        fix: "Condense title to 40-50 characters",
        autoFixable: false
      });
    }

    // Check bullet count
    const bulletCount = slideSpec?.content?.bullets?.reduce((sum: number, group: any) => 
      sum + (group.items?.length || 0), 0) || 0;
    
    if (bulletCount > 6) {
      foundIssues.push({
        severity: "warning",
        category: "content",
        message: `Too many bullets (${bulletCount}). Limit to 5-6 for better retention.`,
        fix: "Reduce to 5-6 most important points",
        autoFixable: false
      });
    }

    // Check for data visualization opportunity
    const hasNumbers = slideSpec?.content?.bullets?.some((group: any) =>
      group.items?.some((item: any) => /\d+%|\$\d+|^\d+/.test(item.text))
    );

    if (hasNumbers && !slideSpec?.content?.dataViz) {
      foundSuggestions.push({
        type: "design",
        priority: "high",
        suggestion: "Convert numeric bullets to chart visualization",
        rationale: "Data visualizations are 60% more memorable than text",
        autoApplicable: false
      });
    }

    // Check for images
    if (!slideSpec?.content?.images && !slideSpec?.content?.imagePlaceholders) {
      foundSuggestions.push({
        type: "design",
        priority: "low",
        suggestion: "Consider adding a supporting image or illustration",
        rationale: "Visual elements increase engagement by 80%",
        autoApplicable: false
      });
    }

    // Check color contrast (simplified)
    const primaryColor = slideSpec?.styleTokens?.palette?.primary;
    if (primaryColor === "#000000" || primaryColor === "#FFFFFF") {
      foundSuggestions.push({
        type: "color",
        priority: "high",
        suggestion: "Use a more distinctive primary color",
        rationale: "Black/white primary colors lack visual interest",
        autoApplicable: true
      });
    }

    setIssues(foundIssues);
    setSuggestions(foundSuggestions);

    // Calculate quality score
    const errorCount = foundIssues.filter(i => i.severity === "error").length;
    const warningCount = foundIssues.filter(i => i.severity === "warning").length;
    const score = Math.max(0, 100 - (errorCount * 20) - (warningCount * 10));
    setQualityScore(score);
  };

  const getScoreColor = (score: number) => {
    if (score >= 80) return "text-green-600";
    if (score >= 60) return "text-yellow-600";
    return "text-red-600";
  };

  const getScoreLabel = (score: number) => {
    if (score >= 80) return "Excellent";
    if (score >= 60) return "Good";
    if (score >= 40) return "Fair";
    return "Needs Improvement";
  };

  const getSeverityIcon = (severity: SlideIssue["severity"]) => {
    switch (severity) {
      case "error":
        return <AlertCircle className="w-5 h-5 text-red-500" />;
      case "warning":
        return <AlertTriangle className="w-5 h-5 text-yellow-500" />;
      case "suggestion":
        return <Lightbulb className="w-5 h-5 text-blue-500" />;
    }
  };

  const getPriorityBadge = (priority: RefinementSuggestion["priority"]) => {
    const colors = {
      high: "bg-red-100 text-red-700",
      medium: "bg-yellow-100 text-yellow-700",
      low: "bg-blue-100 text-blue-700"
    };
    return (
      <span className={`px-2 py-1 rounded text-xs font-semibold ${colors[priority]}`}>
        {priority.toUpperCase()}
      </span>
    );
  };

  return (
    <div className="bg-white rounded-2xl shadow-xl border border-[var(--neutral-7)] p-6 space-y-6">
      {/* Header with Quality Score */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className="p-3 bg-gradient-to-br from-green-500 to-emerald-500 rounded-xl">
            <TrendingUp className="w-6 h-6 text-white" />
          </div>
          <div>
            <h2 className="text-2xl font-bold text-[var(--neutral-1)]">Slide Quality</h2>
            <p className="text-sm text-[var(--neutral-3)]">AI-powered analysis & suggestions</p>
          </div>
        </div>
        <div className="text-center">
          <div className={`text-4xl font-bold ${getScoreColor(qualityScore)}`}>
            {qualityScore}
          </div>
          <div className="text-sm text-[var(--neutral-3)]">{getScoreLabel(qualityScore)}</div>
        </div>
      </div>

      {/* Issues */}
      {issues.length > 0 && (
        <div className="space-y-3">
          <div className="flex items-center justify-between">
            <h3 className="font-semibold text-[var(--neutral-1)]">Issues Found</h3>
            {issues.some(i => i.autoFixable) && onAutoFix && (
              <button
                onClick={onAutoFix}
                className="px-3 py-1 bg-[var(--color-primary)] text-white text-sm rounded-lg hover:bg-[var(--color-primary)]/90 transition-all flex items-center gap-1"
              >
                <Wand2 className="w-4 h-4" />
                Auto-Fix
              </button>
            )}
          </div>
          <div className="space-y-2">
            {issues.map((issue, index) => (
              <div
                key={index}
                className="p-4 rounded-lg border border-[var(--neutral-7)] hover:border-[var(--color-primary)] transition-all"
              >
                <div className="flex items-start gap-3">
                  {getSeverityIcon(issue.severity)}
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-1">
                      <span className="font-semibold text-sm text-[var(--neutral-1)]">
                        {issue.message}
                      </span>
                      {issue.autoFixable && (
                        <span className="px-2 py-0.5 bg-green-100 text-green-700 text-xs rounded font-semibold">
                          AUTO-FIXABLE
                        </span>
                      )}
                    </div>
                    {issue.fix && (
                      <p className="text-sm text-[var(--neutral-3)]">
                        <strong>Fix:</strong> {issue.fix}
                      </p>
                    )}
                    <p className="text-xs text-[var(--neutral-4)] mt-1 capitalize">
                      {issue.category}
                    </p>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Suggestions */}
      {suggestions.length > 0 && (
        <div className="space-y-3">
          <h3 className="font-semibold text-[var(--neutral-1)]">Smart Suggestions</h3>
          <div className="space-y-2">
            {suggestions.map((suggestion, index) => (
              <div
                key={index}
                className="p-4 rounded-lg border border-[var(--neutral-7)] hover:border-[var(--color-primary)] transition-all"
              >
                <div className="flex items-start gap-3">
                  <Lightbulb className="w-5 h-5 text-[var(--color-accent)] flex-shrink-0 mt-0.5" />
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-2">
                      {getPriorityBadge(suggestion.priority)}
                      <span className="text-xs text-[var(--neutral-4)] capitalize">
                        {suggestion.type}
                      </span>
                    </div>
                    <p className="font-semibold text-sm text-[var(--neutral-1)] mb-1">
                      {suggestion.suggestion}
                    </p>
                    <p className="text-sm text-[var(--neutral-3)] mb-3">
                      {suggestion.rationale}
                    </p>
                    {suggestion.autoApplicable && onApplySuggestion && (
                      <button
                        onClick={() => onApplySuggestion(suggestion)}
                        className="px-3 py-1.5 bg-[var(--color-primary)] text-white text-sm rounded-lg hover:bg-[var(--color-primary)]/90 transition-all"
                      >
                        Apply Suggestion
                      </button>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* All Good */}
      {issues.length === 0 && suggestions.length === 0 && (
        <div className="text-center py-8">
          <CheckCircle2 className="w-16 h-16 text-green-500 mx-auto mb-4" />
          <p className="text-lg font-semibold text-[var(--neutral-1)]">Slide looks great!</p>
          <p className="text-sm text-[var(--neutral-3)] mt-2">No issues or suggestions found</p>
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideVariantGenerator.tsx
=================================================================================
import { useState } from "react";
import { Shuffle, Palette, Layout, Type, Minimize2, Sparkles } from "lucide-react";

type VariantType = "color" | "layout" | "typography" | "minimal";

interface SlideVariantGeneratorProps {
  currentSlide: any;
  onGenerateVariant: (variantType: VariantType) => Promise<any>;
  onApplyVariant: (variant: any) => void;
}

export function SlideVariantGenerator({ onGenerateVariant, onApplyVariant }: SlideVariantGeneratorProps) {
  const [generating, setGenerating] = useState(false);
  const [variants, setVariants] = useState<Array<{ type: VariantType; slide: any }>>([]);
  const [selectedVariant, setSelectedVariant] = useState<number | null>(null);

  const variantTypes: Array<{ type: VariantType; label: string; icon: any; description: string; color: string }> = [
    { 
      type: "color", 
      label: "Color Palette", 
      icon: Palette, 
      description: "Alternative color schemes",
      color: "from-purple-500 to-pink-500"
    },
    { 
      type: "layout", 
      label: "Layout", 
      icon: Layout, 
      description: "Different design patterns",
      color: "from-blue-500 to-cyan-500"
    },
    { 
      type: "typography", 
      label: "Typography", 
      icon: Type, 
      description: "Alternative font sizes",
      color: "from-green-500 to-emerald-500"
    },
    { 
      type: "minimal", 
      label: "Minimal", 
      icon: Minimize2, 
      description: "Simplified content",
      color: "from-orange-500 to-red-500"
    }
  ];

  const handleGenerateAll = async () => {
    setGenerating(true);
    const newVariants: Array<{ type: VariantType; slide: any }> = [];

    for (const variantType of variantTypes) {
      try {
        const variant = await onGenerateVariant(variantType.type);
        if (variant) {
          newVariants.push({ type: variantType.type, slide: variant });
        }
      } catch (error) {
        console.error(`Failed to generate ${variantType.type} variant:`, error);
      }
    }

    setVariants(newVariants);
    setGenerating(false);
  };

  const handleApply = () => {
    if (selectedVariant !== null && variants[selectedVariant]) {
      onApplyVariant(variants[selectedVariant].slide);
    }
  };

  return (
    <div className="bg-white rounded-2xl shadow-xl border border-[var(--neutral-7)] p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className="p-3 bg-gradient-to-br from-indigo-500 to-purple-500 rounded-xl">
            <Shuffle className="w-6 h-6 text-white" />
          </div>
          <div>
            <h2 className="text-2xl font-bold text-[var(--neutral-1)]">A/B Variants</h2>
            <p className="text-sm text-[var(--neutral-3)]">Generate alternative designs</p>
          </div>
        </div>
        <button
          onClick={handleGenerateAll}
          disabled={generating}
          className="px-4 py-2 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white rounded-lg hover:shadow-lg transition-all disabled:opacity-50 flex items-center gap-2"
        >
          {generating ? (
            <>
              <Sparkles className="w-4 h-4 animate-spin" />
              Generating...
            </>
          ) : (
            <>
              <Sparkles className="w-4 h-4" />
              Generate All Variants
            </>
          )}
        </button>
      </div>

      {/* Variant Type Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {variantTypes.map((variantType) => {
          const Icon = variantType.icon;
          const variant = variants.find(v => v.type === variantType.type);
          const isSelected = selectedVariant === variants.findIndex(v => v.type === variantType.type);

          return (
            <div
              key={variantType.type}
              className={`p-4 rounded-xl border-2 transition-all cursor-pointer ${
                isSelected
                  ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5 shadow-lg"
                  : variant
                  ? "border-[var(--neutral-7)] hover:border-[var(--color-primary)] hover:shadow-md"
                  : "border-[var(--neutral-7)] opacity-50"
              }`}
              onClick={() => {
                if (variant) {
                  const variantIndex = variants.findIndex(v => v.type === variantType.type);
                  setSelectedVariant(variantIndex);
                }
              }}
            >
              <div className="flex items-start gap-3">
                <div className={`p-3 bg-gradient-to-br ${variantType.color} rounded-lg`}>
                  <Icon className="w-5 h-5 text-white" />
                </div>
                <div className="flex-1">
                  <h3 className="font-semibold text-[var(--neutral-1)] mb-1">
                    {variantType.label}
                  </h3>
                  <p className="text-sm text-[var(--neutral-3)] mb-3">
                    {variantType.description}
                  </p>
                  {variant ? (
                    <div className="flex items-center gap-2">
                      <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse" />
                      <span className="text-xs text-green-600 font-semibold">Ready</span>
                    </div>
                  ) : generating ? (
                    <div className="flex items-center gap-2">
                      <div className="w-2 h-2 bg-blue-500 rounded-full animate-pulse" />
                      <span className="text-xs text-blue-600 font-semibold">Generating...</span>
                    </div>
                  ) : (
                    <div className="flex items-center gap-2">
                      <div className="w-2 h-2 bg-[var(--neutral-5)] rounded-full" />
                      <span className="text-xs text-[var(--neutral-4)]">Not generated</span>
                    </div>
                  )}
                </div>
              </div>

              {/* Preview (simplified) */}
              {variant && (
                <div className="mt-4 p-3 bg-[var(--neutral-8)] rounded-lg">
                  <div className="text-xs text-[var(--neutral-3)] space-y-1">
                    {variantType.type === "color" && (
                      <div className="flex gap-2">
                        <div
                          className="w-6 h-6 rounded border border-[var(--neutral-7)]"
                          style={{ backgroundColor: variant.slide?.styleTokens?.palette?.primary }}
                        />
                        <div
                          className="w-6 h-6 rounded border border-[var(--neutral-7)]"
                          style={{ backgroundColor: variant.slide?.styleTokens?.palette?.accent }}
                        />
                      </div>
                    )}
                    {variantType.type === "typography" && (
                      <p>Title: {variant.slide?.styleTokens?.typography?.sizes?.step_3}px</p>
                    )}
                    {variantType.type === "minimal" && (
                      <p>Bullets: {variant.slide?.content?.bullets?.[0]?.items?.length || 0}</p>
                    )}
                  </div>
                </div>
              )}
            </div>
          );
        })}
      </div>

      {/* Apply Button */}
      {selectedVariant !== null && (
        <div className="flex gap-3 pt-4 border-t border-[var(--neutral-7)]">
          <button
            onClick={() => setSelectedVariant(null)}
            className="flex-1 px-6 py-3 border border-[var(--neutral-7)] text-[var(--neutral-2)] font-semibold rounded-xl hover:bg-[var(--neutral-8)] transition-all"
          >
            Cancel
          </button>
          <button
            onClick={handleApply}
            className="flex-1 px-6 py-3 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transition-all"
          >
            Apply Selected Variant
          </button>
        </div>
      )}

      {/* Info */}
      {variants.length === 0 && !generating && (
        <div className="text-center py-8">
          <Shuffle className="w-16 h-16 text-[var(--neutral-5)] mx-auto mb-4" />
          <p className="text-[var(--neutral-3)]">No variants generated yet</p>
          <p className="text-sm text-[var(--neutral-4)] mt-2">
            Click "Generate All Variants" to create alternative designs
          </p>
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/TemplateSelector.tsx
=================================================================================
import { useState } from "react";
import { TEMPLATES, type Template } from "@/lib/templates";

interface TemplateSelectorProps {
  selectedTemplateId?: string;
  onSelectTemplate: (template: Template) => void;
}

export function TemplateSelector({ selectedTemplateId, onSelectTemplate }: TemplateSelectorProps) {
  const [selectedCategory, setSelectedCategory] = useState<Template["category"] | "all">("all");

  const categories: Array<{ id: Template["category"] | "all"; label: string; icon: string }> = [
    { id: "all", label: "All", icon: "📋" },
    { id: "business", label: "Business", icon: "💼" },
    { id: "education", label: "Education", icon: "🎓" },
    { id: "marketing", label: "Marketing", icon: "📊" },
    { id: "creative", label: "Creative", icon: "🎨" },
    { id: "minimal", label: "Minimal", icon: "⚪" },
  ];

  const filteredTemplates =
    selectedCategory === "all"
      ? TEMPLATES
      : TEMPLATES.filter((t) => t.category === selectedCategory);

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-bold text-[var(--neutral-1)]">Choose a Template</h3>
        <button
          onClick={() => setSelectedCategory("all")}
          className="text-sm text-[var(--color-primary)] hover:underline"
        >
          View All
        </button>
      </div>

      {/* Category Filter */}
      <div className="flex gap-2 overflow-x-auto pb-2">
        {categories.map((cat) => (
          <button
            key={cat.id}
            onClick={() => setSelectedCategory(cat.id)}
            className={`flex items-center gap-2 px-4 py-2 rounded-lg whitespace-nowrap transition-all ${
              selectedCategory === cat.id
                ? "bg-[var(--color-primary)] text-white shadow-md"
                : "bg-white border border-[var(--neutral-7)] text-[var(--neutral-2)] hover:border-[var(--color-primary)]"
            }`}
          >
            <span>{cat.icon}</span>
            <span className="text-sm font-medium">{cat.label}</span>
          </button>
        ))}
      </div>

      {/* Template Grid */}
      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
        {filteredTemplates.map((template) => (
          <button
            key={template.id}
            onClick={() => onSelectTemplate(template)}
            className={`group relative p-4 rounded-xl border-2 transition-all hover:shadow-lg ${
              selectedTemplateId === template.id
                ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5 shadow-md"
                : "border-[var(--neutral-7)] bg-white hover:border-[var(--color-primary)]"
            }`}
          >
            {/* Thumbnail */}
            <div className="aspect-video bg-gradient-to-br from-[var(--neutral-8)] to-[var(--neutral-9)] rounded-lg mb-3 flex items-center justify-center text-4xl">
              {template.thumbnail}
            </div>

            {/* Template Info */}
            <div className="text-left">
              <h4 className="text-sm font-semibold text-[var(--neutral-1)] mb-1 group-hover:text-[var(--color-primary)]">
                {template.name}
              </h4>
              <p className="text-xs text-[var(--neutral-4)] line-clamp-2">
                {template.description}
              </p>
            </div>

            {/* Selected Indicator */}
            {selectedTemplateId === template.id && (
              <div className="absolute top-2 right-2 w-6 h-6 bg-[var(--color-primary)] rounded-full flex items-center justify-center">
                <svg className="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
                  <path
                    fillRule="evenodd"
                    d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                    clipRule="evenodd"
                  />
                </svg>
              </div>
            )}

            {/* Color Preview */}
            <div className="flex gap-1 mt-2">
              <div
                className="w-4 h-4 rounded-full border border-[var(--neutral-7)]"
                style={{ backgroundColor: template.spec.styleTokens?.palette.primary }}
              />
              <div
                className="w-4 h-4 rounded-full border border-[var(--neutral-7)]"
                style={{ backgroundColor: template.spec.styleTokens?.palette.accent }}
              />
            </div>
          </button>
        ))}
      </div>

      {filteredTemplates.length === 0 && (
        <div className="text-center py-8 text-[var(--neutral-4)]">
          <p>No templates found in this category</p>
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/Toast.tsx
=================================================================================
import { useEffect, useState } from "react";

export type ToastType = "success" | "error" | "info" | "warning";

export interface ToastMessage {
  id: string;
  type: ToastType;
  message: string;
  duration?: number;
}

interface ToastProps {
  toast: ToastMessage;
  onClose: (id: string) => void;
}

function Toast({ toast, onClose }: ToastProps) {
  useEffect(() => {
    const timer = setTimeout(() => {
      onClose(toast.id);
    }, toast.duration || 5000);
    
    return () => clearTimeout(timer);
  }, [toast.id, toast.duration, onClose]);
  
  const bgColor = {
    success: "bg-green-500",
    error: "bg-red-500",
    info: "bg-blue-500",
    warning: "bg-yellow-500"
  }[toast.type];
  
  const icon = {
    success: "✓",
    error: "✕",
    info: "ℹ",
    warning: "⚠"
  }[toast.type];
  
  return (
    <div className={`${bgColor} text-white px-4 py-3 rounded-[var(--radius-md)] shadow-[var(--shadow-lg)] flex items-center gap-3 min-w-[300px] max-w-[500px] animate-slide-in`}>
      <span className="text-xl font-bold">{icon}</span>
      <span className="flex-1">{toast.message}</span>
      <button 
        onClick={() => onClose(toast.id)}
        className="text-white/80 hover:text-white text-xl leading-none"
        aria-label="Close notification"
      >
        ×
      </button>
    </div>
  );
}

interface ToastContainerProps {
  toasts: ToastMessage[];
  onClose: (id: string) => void;
}

export function ToastContainer({ toasts, onClose }: ToastContainerProps) {
  return (
    <div className="fixed top-4 right-4 z-50 flex flex-col gap-2">
      {toasts.map(toast => (
        <Toast key={toast.id} toast={toast} onClose={onClose} />
      ))}
    </div>
  );
}

// Hook for managing toasts
export function useToast() {
  const [toasts, setToasts] = useState<ToastMessage[]>([]);
  
  const showToast = (type: ToastType, message: string, duration?: number) => {
    const id = Math.random().toString(36).substring(7);
    setToasts(prev => [...prev, { id, type, message, duration }]);
  };
  
  const closeToast = (id: string) => {
    setToasts(prev => prev.filter(t => t.id !== id));
  };
  
  return {
    toasts,
    showToast,
    closeToast,
    success: (message: string, duration?: number) => showToast("success", message, duration),
    error: (message: string, duration?: number) => showToast("error", message, duration),
    info: (message: string, duration?: number) => showToast("info", message, duration),
    warning: (message: string, duration?: number) => showToast("warning", message, duration),
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/__tests__/usePresentation.test.ts
=================================================================================
import { describe, it, expect } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { usePresentation } from '../usePresentation';
import type { SlideSpecV1 } from '@/types/SlideSpecV1';

const mockSlideSpec: SlideSpecV1 = {
  meta: {
    version: '1.0',
    locale: 'en-US',
    theme: 'Test',
    aspectRatio: '16:9',
  },
  content: {
    title: { id: 'title', text: 'Test Slide' },
  },
  layout: {
    grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 24, r: 24, b: 24, l: 24 } },
    regions: [],
    anchors: [],
  },
  styleTokens: {
    palette: {
      primary: '#6366F1',
      accent: '#EC4899',
      neutral: ['#0F172A', '#1E293B', '#334155', '#64748B', '#94A3B8', '#CBD5E1', '#E2E8F0'],
    },
    typography: {
      fonts: { sans: 'Inter, Arial, sans-serif' },
      sizes: { 'step_-2': 12, 'step_-1': 14, step_0: 16, step_1: 20, step_2: 24, step_3: 32 },
      weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
      lineHeights: { compact: 1.2, standard: 1.5 },
    },
    spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32] },
    radii: { sm: 2, md: 6, lg: 12 },
    shadows: {
      sm: '0 1px 2px rgba(0,0,0,.06)',
      md: '0 4px 8px rgba(0,0,0,.12)',
      lg: '0 12px 24px rgba(0,0,0,.18)',
    },
    contrast: { minTextContrast: 4.5, minUiContrast: 3 },
  },
};

describe('usePresentation', () => {
  it('should initialize with default presentation', () => {
    const { result } = renderHook(() => usePresentation());

    expect(result.current.presentation).toBeDefined();
    expect(result.current.presentation.slides.length).toBe(0);
    expect(result.current.currentSlideIndex).toBe(0);
    expect(result.current.slideCount).toBe(0);
  });

  it('should add a slide', () => {
    const { result } = renderHook(() => usePresentation());

    act(() => {
      result.current.addSlide(mockSlideSpec, 'Test prompt');
    });

    expect(result.current.slideCount).toBe(1);
    expect(result.current.currentSlide?.spec).toEqual(mockSlideSpec);
  });

  it('should remove a slide', () => {
    const { result } = renderHook(() => usePresentation());

    let slideId: string | undefined;
    act(() => {
      slideId = result.current.addSlide(mockSlideSpec, 'Test prompt') || '';
    });

    act(() => {
      if (slideId) {
        result.current.removeSlide(slideId);
      }
    });

    expect(result.current.slideCount).toBe(0);
  });

  it('should navigate to next slide', () => {
    const { result } = renderHook(() => usePresentation());

    act(() => {
      result.current.addSlide(mockSlideSpec, 'Slide 1');
      result.current.addSlide(mockSlideSpec, 'Slide 2');
    });

    expect(result.current.currentSlideIndex).toBe(0);

    act(() => {
      result.current.nextSlide();
    });

    expect(result.current.currentSlideIndex).toBe(1);
  });

  it('should navigate to previous slide', () => {
    const { result } = renderHook(() => usePresentation());

    act(() => {
      result.current.addSlide(mockSlideSpec, 'Slide 1');
      result.current.addSlide(mockSlideSpec, 'Slide 2');
      result.current.goToSlide(1);
    });

    expect(result.current.currentSlideIndex).toBe(1);

    act(() => {
      result.current.previousSlide();
    });

    expect(result.current.currentSlideIndex).toBe(0);
  });

  it('should not navigate beyond bounds', () => {
    const { result } = renderHook(() => usePresentation());

    act(() => {
      result.current.addSlide(mockSlideSpec, 'Slide 1');
    });

    expect(result.current.canGoNext).toBe(false);
    expect(result.current.canGoPrevious).toBe(false);

    act(() => {
      result.current.nextSlide();
    });

    expect(result.current.currentSlideIndex).toBe(0);
  });

  it('should duplicate a slide', () => {
    const { result } = renderHook(() => usePresentation());

    let slideId: string;
    act(() => {
      slideId = result.current.addSlide(mockSlideSpec, 'Original');
    });

    act(() => {
      result.current.duplicateSlide(slideId!);
    });

    expect(result.current.slideCount).toBe(2);
  });

  it('should update a slide', () => {
    const { result } = renderHook(() => usePresentation());

    let slideId: string;
    act(() => {
      slideId = result.current.addSlide(mockSlideSpec, 'Original');
    });

    const updatedSpec = {
      ...mockSlideSpec,
      content: {
        ...mockSlideSpec.content,
        title: { id: 'title', text: 'Updated Title' },
      },
    };

    act(() => {
      result.current.updateSlide(slideId!, updatedSpec);
    });

    expect(result.current.currentSlide?.spec.content.title.text).toBe('Updated Title');
  });

  it('should reorder slides', () => {
    const { result } = renderHook(() => usePresentation());

    act(() => {
      result.current.addSlide(mockSlideSpec, 'Slide 1');
      result.current.addSlide(mockSlideSpec, 'Slide 2');
      result.current.addSlide(mockSlideSpec, 'Slide 3');
    });

    const slide1Id = result.current.presentation.slides[0].id;
    const slide3Id = result.current.presentation.slides[2].id;

    act(() => {
      result.current.reorderSlides(2, 0);
    });

    expect(result.current.presentation.slides[0].id).toBe(slide3Id);
    expect(result.current.presentation.slides[2].id).toBe(slide1Id);
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/usePDFExport.ts
=================================================================================
import { useState, useCallback } from "react";
import { downloadPDF, type PDFExportOptions } from "@/lib/pdfExport";
import type { Presentation } from "@/types/Presentation";
import { logger } from "@/lib/logger";

export function usePDFExport() {
  const [exporting, setExporting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [progress, setProgress] = useState(0);

  const exportToPDF = useCallback(
    async (
      presentation: Presentation,
      slideElements: HTMLElement[],
      filename?: string,
      options?: PDFExportOptions
    ) => {
      setError(null);
      setExporting(true);
      setProgress(0);

      logger.userAction("export_pdf", { 
        filename: filename || presentation.title,
        slideCount: presentation.slides.length 
      });

      try {
        // Simulate progress updates
        const progressInterval = setInterval(() => {
          setProgress((prev) => Math.min(prev + 10, 90));
        }, 200);

        await downloadPDF(presentation, slideElements, filename, options);

        clearInterval(progressInterval);
        setProgress(100);

        // Reset after a short delay
        setTimeout(() => {
          setProgress(0);
          setExporting(false);
        }, 1000);

        return true;
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to export PDF";
        setError(errorMessage);
        logger.error("PDF export failed", err);
        setExporting(false);
        setProgress(0);
        return false;
      }
    },
    []
  );

  return {
    exporting,
    error,
    progress,
    exportToPDF,
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/usePresentation.ts
=================================================================================
import { useState, useCallback } from "react";
import type { Presentation } from "@/types/Presentation";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";
import { createPresentation, createSlide } from "@/types/Presentation";
import { logger } from "@/lib/logger";

export function usePresentation(initialAspectRatio: "16:9" | "4:3" = "16:9") {
  const [presentation, setPresentation] = useState<Presentation>(() => 
    createPresentation("My Presentation", initialAspectRatio)
  );
  const [currentSlideIndex, setCurrentSlideIndex] = useState(0);

  const addSlide = useCallback((spec: SlideSpecV1, prompt?: string): string => {
    const slide = createSlide(spec, prompt);
    setPresentation(prev => ({
      ...prev,
      slides: [...prev.slides, slide],
      updatedAt: Date.now(),
    }));
    setCurrentSlideIndex(presentation.slides.length); // Navigate to new slide
    logger.info("Slide added to presentation", { slideId: slide.id, totalSlides: presentation.slides.length + 1 });
    return slide.id;
  }, [presentation.slides.length]);

  const removeSlide = useCallback((slideId: string) => {
    setPresentation(prev => {
      const newSlides = prev.slides.filter(s => s.id !== slideId);
      return {
        ...prev,
        slides: newSlides,
        updatedAt: Date.now(),
      };
    });
    
    // Adjust current index if needed
    setCurrentSlideIndex(prev => {
      const newLength = presentation.slides.length - 1;
      if (prev >= newLength) {
        return Math.max(0, newLength - 1);
      }
      return prev;
    });
    
    logger.info("Slide removed from presentation", { slideId });
  }, [presentation.slides.length]);

  const updateSlide = useCallback((slideId: string, spec: SlideSpecV1) => {
    setPresentation(prev => ({
      ...prev,
      slides: prev.slides.map(slide =>
        slide.id === slideId
          ? { ...slide, spec, updatedAt: Date.now() }
          : slide
      ),
      updatedAt: Date.now(),
    }));
    logger.info("Slide updated", { slideId });
  }, []);

  const duplicateSlide = useCallback((slideId: string) => {
    const slideIndex = presentation.slides.findIndex(s => s.id === slideId);
    if (slideIndex === -1) return;

    const originalSlide = presentation.slides[slideIndex];
    const newSlide = createSlide(originalSlide.spec, originalSlide.prompt);

    setPresentation(prev => {
      const newSlides = [...prev.slides];
      newSlides.splice(slideIndex + 1, 0, newSlide);
      return {
        ...prev,
        slides: newSlides,
        updatedAt: Date.now(),
      };
    });

    setCurrentSlideIndex(slideIndex + 1);
    logger.info("Slide duplicated", { originalId: slideId, newId: newSlide.id });
  }, [presentation.slides]);

  const reorderSlides = useCallback((fromIndex: number, toIndex: number) => {
    setPresentation(prev => {
      const newSlides = [...prev.slides];
      const [removed] = newSlides.splice(fromIndex, 1);
      newSlides.splice(toIndex, 0, removed);
      return {
        ...prev,
        slides: newSlides,
        updatedAt: Date.now(),
      };
    });
    
    // Update current index if the current slide was moved
    if (currentSlideIndex === fromIndex) {
      setCurrentSlideIndex(toIndex);
    } else if (currentSlideIndex > fromIndex && currentSlideIndex <= toIndex) {
      setCurrentSlideIndex(currentSlideIndex - 1);
    } else if (currentSlideIndex < fromIndex && currentSlideIndex >= toIndex) {
      setCurrentSlideIndex(currentSlideIndex + 1);
    }
    
    logger.info("Slides reordered", { fromIndex, toIndex });
  }, [currentSlideIndex]);

  const goToSlide = useCallback((index: number) => {
    if (index >= 0 && index < presentation.slides.length) {
      setCurrentSlideIndex(index);
    }
  }, [presentation.slides.length]);

  const nextSlide = useCallback(() => {
    setCurrentSlideIndex(prev => 
      prev < presentation.slides.length - 1 ? prev + 1 : prev
    );
  }, [presentation.slides.length]);

  const previousSlide = useCallback(() => {
    setCurrentSlideIndex(prev => prev > 0 ? prev - 1 : prev);
  }, []);

  const updateTitle = useCallback((title: string) => {
    setPresentation(prev => ({
      ...prev,
      title,
      updatedAt: Date.now(),
    }));
  }, []);

  const clearPresentation = useCallback(() => {
    setPresentation(createPresentation("My Presentation", presentation.aspectRatio));
    setCurrentSlideIndex(0);
    logger.info("Presentation cleared");
  }, [presentation.aspectRatio]);

  const currentSlide = presentation.slides[currentSlideIndex] || null;

  return {
    presentation,
    currentSlide,
    currentSlideIndex,
    addSlide,
    removeSlide,
    updateSlide,
    duplicateSlide,
    reorderSlides,
    goToSlide,
    nextSlide,
    previousSlide,
    updateTitle,
    clearPresentation,
    hasSlides: presentation.slides.length > 0,
    slideCount: presentation.slides.length,
    canGoNext: currentSlideIndex < presentation.slides.length - 1,
    canGoPrevious: currentSlideIndex > 0,
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/usePresentationExport.ts
=================================================================================
import { useState, useCallback } from "react";
import { apiExport, apiExportMultiple } from "@/lib/api";
import { logger } from "@/lib/logger";
import type { Presentation } from "@/types/Presentation";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export function usePresentationExport() {
  const [exporting, setExporting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const exportPresentation = useCallback(async (presentation: Presentation, filename?: string) => {
    setError(null);
    setExporting(true);

    const startTime = performance.now();
    const finalFilename = filename || `${presentation.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.pptx`;
    
    logger.userAction("export_presentation", { 
      filename: finalFilename, 
      slideCount: presentation.slides.length 
    });

    try {
      const specs = presentation.slides.map(slide => slide.spec);
      
      let blob: Blob;
      if (specs.length === 1) {
        // Single slide - use original API for backward compatibility
        blob = await apiExport(specs[0]);
      } else {
        // Multiple slides
        blob = await apiExportMultiple(specs);
      }

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = finalFilename;
      a.click();
      URL.revokeObjectURL(url);

      const duration = performance.now() - startTime;
      logger.performance("presentation_export", duration);
      logger.info("Presentation exported successfully", { 
        filename: finalFilename, 
        slideCount: specs.length,
        size: blob.size, 
        duration 
      });

      return true;
    } catch (e: unknown) {
      const errorMessage = e instanceof Error ? e.message : "Failed to export presentation";
      setError(errorMessage);
      logger.error("Failed to export presentation", e, { filename: finalFilename });
      return false;
    } finally {
      setExporting(false);
    }
  }, []);

  const exportSingleSlide = useCallback(async (spec: SlideSpecV1, filename = "slide.pptx") => {
    setError(null);
    setExporting(true);

    const startTime = performance.now();
    logger.userAction("export_single_slide", { filename });

    try {
      const blob = await apiExport(spec);
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);

      const duration = performance.now() - startTime;
      logger.performance("single_slide_export", duration);
      logger.info("Single slide exported successfully", { filename, size: blob.size, duration });

      return true;
    } catch (e: unknown) {
      const errorMessage = e instanceof Error ? e.message : "Failed to export slide";
      setError(errorMessage);
      logger.error("Failed to export slide", e, { filename });
      return false;
    } finally {
      setExporting(false);
    }
  }, []);

  return {
    exporting,
    error,
    exportPresentation,
    exportSingleSlide,
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/usePresentationGeneration.ts
=================================================================================
import { useState, useCallback } from "react";
import { logger } from "@/lib/logger";

interface PresentationRequest {
  topic: string;
  audience?: "executives" | "technical" | "sales" | "general" | "investors";
  tone?: "formal" | "casual" | "persuasive" | "educational" | "inspirational";
  slideCount?: number;
  industry?: "tech" | "finance" | "healthcare" | "marketing" | "corporate";
  includeAgenda?: boolean;
  includeSummary?: boolean;
}

interface PresentationResponse {
  slides: any[];
  structure: {
    title: string;
    slideCount: number;
    narrative: string[];
  };
  metadata: {
    audience: string;
    tone: string;
    industry: string;
  };
}

export function usePresentationGeneration() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [presentation, setPresentation] = useState<PresentationResponse | null>(null);
  const [progress, setProgress] = useState(0);

  const generatePresentation = useCallback(async (request: PresentationRequest) => {
    setLoading(true);
    setError(null);
    setProgress(0);

    try {
      logger.info("Generating presentation", { request });

      // Get the API endpoint from environment
      const apiUrl = import.meta.env.VITE_FIREBASE_FUNCTION_URL || 
                     "https://us-central1-pls-fix-thx.cloudfunctions.net";
      
      const endpoint = `${apiUrl}/generatePresentation`;

      // Simulate progress updates
      const progressInterval = setInterval(() => {
        setProgress(prev => Math.min(prev + 10, 90));
      }, 500);

      const response = await fetch(endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(request),
      });

      clearInterval(progressInterval);
      setProgress(100);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      logger.info("Presentation generated successfully", { 
        slideCount: data.slides?.length 
      });

      setPresentation(data);
      return data;

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to generate presentation";
      logger.error("Presentation generation failed", { error: errorMessage });
      setError(errorMessage);
      return null;
    } finally {
      setLoading(false);
      setProgress(0);
    }
  }, []);

  const reset = useCallback(() => {
    setPresentation(null);
    setError(null);
    setProgress(0);
  }, []);

  return {
    loading,
    error,
    presentation,
    progress,
    generatePresentation,
    reset
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/useSlideExport.ts
=================================================================================
import { useState, useCallback } from "react";
import { apiExport } from "@/lib/api";
import { logger } from "@/lib/logger";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export function useSlideExport() {
  const [exporting, setExporting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const exportSlide = useCallback(async (spec: SlideSpecV1, filename = "plzfixthx-slide.pptx") => {
    setError(null);
    setExporting(true);

    const startTime = performance.now();
    logger.userAction("export_slide", { filename });

    try {
      const blob = await apiExport(spec);
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);

      const duration = performance.now() - startTime;
      logger.performance("slide_export", duration);
      logger.info("Slide exported successfully", { filename, size: blob.size, duration });

      return true;
    } catch (e: unknown) {
      const errorMessage = e instanceof Error ? e.message : "Failed to export slide";
      setError(errorMessage);
      logger.error("Failed to export slide", e, { filename });
      return false;
    } finally {
      setExporting(false);
    }
  }, []);

  return {
    exporting,
    error,
    exportSlide
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/useSlideGeneration.ts
=================================================================================
import { useState, useCallback } from "react";
import { apiGenerate } from "@/lib/api";
import { normalizeOrFallback } from "@/lib/validation";
import { logger } from "@/lib/logger";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export function useSlideGeneration() {
  const [loading, setLoading] = useState(false);
  const [spec, setSpec] = useState<SlideSpecV1 | null>(null);
  const [error, setError] = useState<string | null>(null);

  const generate = useCallback(async (prompt: string) => {
    if (!prompt.trim()) {
      setError("Please enter a prompt");
      logger.warn("Generate called with empty prompt");
      return null;
    }

    setError(null);
    setLoading(true);

    const startTime = performance.now();
    logger.userAction("generate_slide", { promptLength: prompt.length });

    try {
      const data = await apiGenerate(prompt);
      const normalized = normalizeOrFallback(data?.spec ?? data);
      setSpec(normalized);

      const duration = performance.now() - startTime;
      logger.performance("slide_generation", duration);
      logger.info("Slide generated successfully", { duration });

      return normalized;
    } catch (e: unknown) {
      const errorMessage = e instanceof Error ? e.message : "Failed to generate slide";
      setError(errorMessage);
      logger.error("Failed to generate slide", e, { prompt: prompt.slice(0, 50) });

      // Still set a fallback spec so user sees something
      const fallback = normalizeOrFallback(null);
      setSpec(fallback);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const reset = useCallback(() => {
    setSpec(null);
    setError(null);
    setLoading(false);
  }, []);

  return {
    loading,
    spec,
    error,
    generate,
    reset
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/useSlideHistory.ts
=================================================================================
import { useState, useEffect, useCallback } from "react";
import type { Presentation } from "@/types/Presentation";
import { logger } from "@/lib/logger";

const STORAGE_KEY = "plzfixthx_presentations";
const MAX_HISTORY_ITEMS = 50;

interface HistoryItem {
  id: string;
  presentation: Presentation;
  savedAt: string;
}

export function useSlideHistory() {
  const [history, setHistory] = useState<HistoryItem[]>([]);
  const [loading, setLoading] = useState(true);

  // Load history from localStorage on mount
  useEffect(() => {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored) as HistoryItem[];
        setHistory(parsed);
        logger.info("Loaded presentation history", { count: parsed.length });
      }
    } catch (error) {
      logger.error("Failed to load presentation history", error);
    } finally {
      setLoading(false);
    }
  }, []);

  // Save presentation to history
  const savePresentation = useCallback((presentation: Presentation) => {
    try {
      const historyItem: HistoryItem = {
        id: presentation.id,
        presentation,
        savedAt: new Date().toISOString(),
      };

      setHistory((prev) => {
        // Remove existing entry with same ID if it exists
        const filtered = prev.filter((item) => item.id !== presentation.id);
        
        // Add new entry at the beginning
        const updated = [historyItem, ...filtered];
        
        // Limit to MAX_HISTORY_ITEMS
        const trimmed = updated.slice(0, MAX_HISTORY_ITEMS);
        
        // Save to localStorage
        localStorage.setItem(STORAGE_KEY, JSON.stringify(trimmed));
        
        logger.info("Saved presentation to history", { 
          id: presentation.id, 
          title: presentation.title 
        });
        
        return trimmed;
      });

      return true;
    } catch (error) {
      logger.error("Failed to save presentation to history", error);
      return false;
    }
  }, []);

  // Load presentation from history
  const loadPresentation = useCallback((id: string): Presentation | null => {
    const item = history.find((h) => h.id === id);
    if (item) {
      logger.info("Loaded presentation from history", { id, title: item.presentation.title });
      return item.presentation;
    }
    return null;
  }, [history]);

  // Delete presentation from history
  const deletePresentation = useCallback((id: string) => {
    try {
      setHistory((prev) => {
        const updated = prev.filter((item) => item.id !== id);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
        logger.info("Deleted presentation from history", { id });
        return updated;
      });
      return true;
    } catch (error) {
      logger.error("Failed to delete presentation from history", error);
      return false;
    }
  }, []);

  // Clear all history
  const clearHistory = useCallback(() => {
    try {
      setHistory([]);
      localStorage.removeItem(STORAGE_KEY);
      logger.info("Cleared presentation history");
      return true;
    } catch (error) {
      logger.error("Failed to clear presentation history", error);
      return false;
    }
  }, []);

  // Get recent presentations
  const getRecentPresentations = useCallback((limit = 10): HistoryItem[] => {
    return history.slice(0, limit);
  }, [history]);

  // Search presentations
  const searchPresentations = useCallback((query: string): HistoryItem[] => {
    const lowerQuery = query.toLowerCase();
    return history.filter((item) => 
      item.presentation.title.toLowerCase().includes(lowerQuery) ||
      item.presentation.slides.some((slide) => 
        slide.spec.content.title.text.toLowerCase().includes(lowerQuery)
      )
    );
  }, [history]);

  return {
    history,
    loading,
    savePresentation,
    loadPresentation,
    deletePresentation,
    clearHistory,
    getRecentPresentations,
    searchPresentations,
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/useSlideImages.ts
=================================================================================
import { useState, useCallback } from "react";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";
import { logger } from "@/lib/logger";

interface ImageData {
  id: string;
  dataUrl: string;
  filename: string;
  size: number;
  type: string;
}

export function useSlideImages() {
  const [images, setImages] = useState<Map<string, ImageData>>(new Map());

  const addImage = useCallback((placeholderId: string, imageData: string, file: File) => {
    const newImage: ImageData = {
      id: placeholderId,
      dataUrl: imageData,
      filename: file.name,
      size: file.size,
      type: file.type,
    };

    setImages((prev) => {
      const updated = new Map(prev);
      updated.set(placeholderId, newImage);
      logger.info("Image added to slide", { 
        placeholderId, 
        filename: file.name,
        size: file.size 
      });
      return updated;
    });
  }, []);

  const removeImage = useCallback((placeholderId: string) => {
    setImages((prev) => {
      const updated = new Map(prev);
      updated.delete(placeholderId);
      logger.info("Image removed from slide", { placeholderId });
      return updated;
    });
  }, []);

  const getImage = useCallback((placeholderId: string): ImageData | undefined => {
    return images.get(placeholderId);
  }, [images]);

  const hasImage = useCallback((placeholderId: string): boolean => {
    return images.has(placeholderId);
  }, [images]);

  const clearImages = useCallback(() => {
    setImages(new Map());
    logger.info("All images cleared");
  }, []);

  const updateSlideSpec = useCallback((spec: SlideSpecV1): SlideSpecV1 => {
    // Replace image placeholders with actual image data
    const updatedComponents = { ...spec.components };

    if (spec.content.imagePlaceholders) {
      spec.content.imagePlaceholders.forEach((placeholder) => {
        const image = images.get(placeholder.id);
        if (image) {
          // Update the placeholder with actual image data
          // This would be used when exporting to PPTX
          logger.info("Image placeholder updated", { 
            placeholderId: placeholder.id,
            filename: image.filename 
          });
        }
      });
    }

    return {
      ...spec,
      components: updatedComponents,
    };
  }, [images]);

  const getImageCount = useCallback((): number => {
    return images.size;
  }, [images]);

  const getAllImages = useCallback((): ImageData[] => {
    return Array.from(images.values());
  }, [images]);

  return {
    images,
    addImage,
    removeImage,
    getImage,
    hasImage,
    clearImages,
    updateSlideSpec,
    getImageCount,
    getAllImages,
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/__tests__/accessibility.test.ts
=================================================================================
import { describe, it, expect } from 'vitest';
import {
  getContrastRatio,
  meetsWCAGAA,
  meetsWCAGAAA,
  getAccessibleTextColor,
} from '../accessibility';

describe('accessibility utilities', () => {
  describe('getContrastRatio', () => {
    it('should calculate contrast ratio between black and white', () => {
      const ratio = getContrastRatio('#000000', '#FFFFFF');
      expect(ratio).toBe(21); // Maximum contrast ratio
    });

    it('should calculate contrast ratio between same colors', () => {
      const ratio = getContrastRatio('#6366F1', '#6366F1');
      expect(ratio).toBe(1); // Minimum contrast ratio
    });

    it('should handle lowercase hex colors', () => {
      const ratio = getContrastRatio('#ffffff', '#000000');
      expect(ratio).toBe(21);
    });

    it('should handle hex colors without # prefix', () => {
      const ratio = getContrastRatio('FFFFFF', '000000');
      expect(ratio).toBe(21);
    });
  });

  describe('meetsWCAGAA', () => {
    it('should pass for high contrast text', () => {
      expect(meetsWCAGAA('#000000', '#FFFFFF')).toBe(true);
    });

    it('should fail for low contrast text', () => {
      expect(meetsWCAGAA('#CCCCCC', '#FFFFFF')).toBe(false);
    });

    it('should use different threshold for large text', () => {
      // A contrast that passes for large text but not normal text
      const foreground = '#767676';
      const background = '#FFFFFF';
      
      expect(meetsWCAGAA(foreground, background, false)).toBe(false);
      expect(meetsWCAGAA(foreground, background, true)).toBe(true);
    });
  });

  describe('meetsWCAGAAA', () => {
    it('should pass for very high contrast', () => {
      expect(meetsWCAGAAA('#000000', '#FFFFFF')).toBe(true);
    });

    it('should fail for moderate contrast', () => {
      expect(meetsWCAGAAA('#595959', '#FFFFFF')).toBe(false);
    });

    it('should have stricter requirements than AA', () => {
      const foreground = '#595959';
      const background = '#FFFFFF';
      
      // This combination passes AA but not AAA
      expect(meetsWCAGAA(foreground, background)).toBe(true);
      expect(meetsWCAGAAA(foreground, background)).toBe(false);
    });
  });

  describe('getAccessibleTextColor', () => {
    it('should return white for dark backgrounds', () => {
      expect(getAccessibleTextColor('#000000')).toBe('#FFFFFF');
      expect(getAccessibleTextColor('#1E293B')).toBe('#FFFFFF');
    });

    it('should return black for light backgrounds', () => {
      expect(getAccessibleTextColor('#FFFFFF')).toBe('#000000');
      expect(getAccessibleTextColor('#F8FAFC')).toBe('#000000');
    });

    it('should return appropriate color for medium backgrounds', () => {
      const color = getAccessibleTextColor('#6366F1');
      expect(color).toMatch(/^#(000000|FFFFFF)$/);
    });
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/__tests__/designSystem.test.ts
=================================================================================
/**
 * Design System Tests
 * Comprehensive tests for design system libraries
 */

import { describe, it, expect } from "vitest";
import { PROFESSIONAL_PALETTES, calculateContrastRatio, validatePaletteContrast } from "../colorPalettes";
import { TYPOGRAPHY_PAIRS, validateTypographyPair } from "../typographyPairs";
import { LAYOUT_PATTERNS, validateLayoutPattern, calculateWhitespacePercentage } from "../layoutPatterns";
import { validateDesignQuality } from "../designQuality";

describe("Color Palettes", () => {
  it("should have at least 15 professional palettes", () => {
    const palettes = Object.keys(PROFESSIONAL_PALETTES);
    expect(palettes.length).toBeGreaterThanOrEqual(15);
  });

  it("should have valid hex colors in all palettes", () => {
    const hexPattern = /^#[0-9A-Fa-f]{6}$/;

    Object.values(PROFESSIONAL_PALETTES).forEach(palette => {
      expect(hexPattern.test(palette.primary)).toBe(true);
      expect(hexPattern.test(palette.accent)).toBe(true);
      palette.neutral.forEach(color => {
        expect(hexPattern.test(color)).toBe(true);
      });
    });
  });

  it("should calculate contrast ratio correctly", () => {
    const white = "#FFFFFF";
    const black = "#000000";
    const ratio = calculateContrastRatio(white, black);

    expect(ratio).toBeGreaterThan(20); // Should be 21:1
  });

  it("should validate palette contrast", () => {
    const palette = PROFESSIONAL_PALETTES.corporate;
    const isValid = validatePaletteContrast(palette);

    expect(isValid).toBe(true);
  });

  it("should have WCAG AA compliant contrast ratios", () => {
    Object.values(PROFESSIONAL_PALETTES).forEach(palette => {
      const ratio = calculateContrastRatio(palette.neutral[0], palette.neutral[6]);
      expect(ratio).toBeGreaterThanOrEqual(4.5); // WCAG AA minimum
    });
  });
});

describe("Typography Pairs", () => {
  it("should have at least 12 typography pairs", () => {
    const pairs = Object.keys(TYPOGRAPHY_PAIRS);
    expect(pairs.length).toBeGreaterThanOrEqual(12);
  });

  it("should have valid font specifications", () => {
    Object.values(TYPOGRAPHY_PAIRS).forEach(pair => {
      expect(pair.primary).toBeTruthy();
      expect(pair.secondary).toBeTruthy();
      expect(pair.sizes.title).toBeGreaterThan(0);
      expect(pair.sizes.body).toBeGreaterThan(0);
      expect(pair.sizes.title).toBeGreaterThan(pair.sizes.body);
    });
  });

  it("should validate typography pairs", () => {
    Object.values(TYPOGRAPHY_PAIRS).forEach(pair => {
      const isValid = validateTypographyPair(pair);
      expect(isValid).toBe(true);
    });
  });

  it("should have proper size hierarchy", () => {
    Object.values(TYPOGRAPHY_PAIRS).forEach(pair => {
      expect(pair.sizes.title).toBeGreaterThan(pair.sizes.subtitle);
      expect(pair.sizes.subtitle).toBeGreaterThan(pair.sizes.body);
      expect(pair.sizes.body).toBeGreaterThan(pair.sizes.caption);
    });
  });

  it("should have valid line heights", () => {
    Object.values(TYPOGRAPHY_PAIRS).forEach(pair => {
      Object.values(pair.lineHeights).forEach(lineHeight => {
        expect(lineHeight).toBeGreaterThanOrEqual(1.2);
        expect(lineHeight).toBeLessThanOrEqual(2);
      });
    });
  });
});

describe("Layout Patterns", () => {
  it("should have 6 layout patterns", () => {
    const patterns = Object.keys(LAYOUT_PATTERNS);
    expect(patterns.length).toBe(6);
  });

  it("should have valid pattern names", () => {
    const validNames = ["hero", "split", "asymmetric", "grid", "minimal", "data-focused"];
    const patterns = Object.keys(LAYOUT_PATTERNS);

    patterns.forEach(name => {
      expect(validNames).toContain(name);
    });
  });

  it("should validate all layout patterns", () => {
    Object.values(LAYOUT_PATTERNS).forEach(pattern => {
      const isValid = validateLayoutPattern(pattern);
      expect(isValid).toBe(true);
    });
  });

  it("should have regions within slide bounds", () => {
    const SLIDE_WIDTH = 10;
    const SLIDE_HEIGHT = 7.5;

    Object.values(LAYOUT_PATTERNS).forEach(pattern => {
      Object.values(pattern.regions).forEach(region => {
        expect(region.x).toBeGreaterThanOrEqual(0);
        expect(region.y).toBeGreaterThanOrEqual(0);
        expect(region.x + region.w).toBeLessThanOrEqual(SLIDE_WIDTH);
        expect(region.y + region.h).toBeLessThanOrEqual(SLIDE_HEIGHT);
      });
    });
  });

  it("should calculate white space percentage", () => {
    Object.values(LAYOUT_PATTERNS).forEach(pattern => {
      const whitespace = calculateWhitespacePercentage(pattern);
      expect(whitespace).toBeGreaterThan(0);
      expect(whitespace).toBeLessThan(100);
    });
  });

  it("should have appropriate white space for pattern type", () => {
    const minimalPattern = LAYOUT_PATTERNS.minimal;
    const dataFocusedPattern = LAYOUT_PATTERNS["data-focused"];

    const minimalWhitespace = calculateWhitespacePercentage(minimalPattern);
    const dataWhitespace = calculateWhitespacePercentage(dataFocusedPattern);

    // Minimal should have more white space than data-focused
    expect(minimalWhitespace).toBeGreaterThan(dataWhitespace);
  });
});

describe("Design Quality Validation", () => {
  it("should validate design quality", () => {
    const mockSpec = {
      design: {
        pattern: "split",
        whitespace: { strategy: "balanced", breathingRoom: 28 },
        typography: {
          hierarchy: {
            title: { size: 32, weight: 700, lineHeight: 1.2 },
            body: { size: 16, weight: 400, lineHeight: 1.5 }
          }
        }
      },
      styleTokens: {
        palette: {
          primary: "#1E40AF",
          accent: "#10B981",
          neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"]
        },
        typography: {
          sizes: { step_0: 16, step_3: 32 },
          lineHeights: { standard: 1.5 }
        }
      }
    } as any;

    const score = validateDesignQuality(mockSpec);
    expect(score.overall).toBeGreaterThan(0);
    expect(score.overall).toBeLessThanOrEqual(100);
  });

  it("should identify design issues", () => {
    const mockSpec = {
      design: {
        pattern: "split",
        whitespace: { strategy: "compact", breathingRoom: 10 },
        typography: {
          hierarchy: {
            title: { size: 14, weight: 400, lineHeight: 1 },
            body: { size: 12, weight: 400, lineHeight: 1 }
          }
        }
      },
      styleTokens: {
        palette: {
          primary: "#FFFFFF",
          accent: "#FFFFFF",
          neutral: ["#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF"]
        },
        typography: {
          sizes: { step_0: 12, step_3: 14 },
          lineHeights: { standard: 1 }
        }
      }
    } as any;

    const score = validateDesignQuality(mockSpec);
    expect(score.issues.length).toBeGreaterThan(0);
  });
});

describe("Design System Integration", () => {
  it("should have complementary palettes and typography", () => {
    Object.values(PROFESSIONAL_PALETTES).forEach(palette => {
      expect(palette.primary).toBeTruthy();
      expect(palette.accent).toBeTruthy();
      expect(palette.neutral.length).toBeGreaterThanOrEqual(5);
    });

    Object.values(TYPOGRAPHY_PAIRS).forEach(pair => {
      expect(pair.primary).toBeTruthy();
      expect(pair.secondary).toBeTruthy();
    });
  });

  it("should support all design patterns", () => {
    const patterns = Object.keys(LAYOUT_PATTERNS);
    expect(patterns).toContain("hero");
    expect(patterns).toContain("split");
    expect(patterns).toContain("asymmetric");
    expect(patterns).toContain("grid");
    expect(patterns).toContain("minimal");
    expect(patterns).toContain("data-focused");
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/accessibility.ts
=================================================================================
/**
 * Accessibility utilities for WCAG compliance
 */

/**
 * Calculate relative luminance of a color
 * https://www.w3.org/TR/WCAG20/#relativeluminancedef
 */
function getLuminance(r: number, g: number, b: number): number {
  const [rs, gs, bs] = [r, g, b].map((c) => {
    const sRGB = c / 255;
    return sRGB <= 0.03928 ? sRGB / 12.92 : Math.pow((sRGB + 0.055) / 1.055, 2.4);
  });
  return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
}

/**
 * Parse hex color to RGB
 */
function hexToRgb(hex: string): { r: number; g: number; b: number } | null {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
      }
    : null;
}

/**
 * Calculate contrast ratio between two colors
 * https://www.w3.org/TR/WCAG20/#contrast-ratiodef
 */
export function getContrastRatio(color1: string, color2: string): number {
  const rgb1 = hexToRgb(color1);
  const rgb2 = hexToRgb(color2);

  if (!rgb1 || !rgb2) {
    return 0;
  }

  const lum1 = getLuminance(rgb1.r, rgb1.g, rgb1.b);
  const lum2 = getLuminance(rgb2.r, rgb2.g, rgb2.b);

  const lighter = Math.max(lum1, lum2);
  const darker = Math.min(lum1, lum2);

  return (lighter + 0.05) / (darker + 0.05);
}

/**
 * Check if contrast ratio meets WCAG AA standards
 */
export function meetsWCAGAA(
  foreground: string,
  background: string,
  isLargeText = false
): boolean {
  const ratio = getContrastRatio(foreground, background);
  return isLargeText ? ratio >= 3 : ratio >= 4.5;
}

/**
 * Check if contrast ratio meets WCAG AAA standards
 */
export function meetsWCAGAAA(
  foreground: string,
  background: string,
  isLargeText = false
): boolean {
  const ratio = getContrastRatio(foreground, background);
  return isLargeText ? ratio >= 4.5 : ratio >= 7;
}

/**
 * Get accessible text color (black or white) for a background
 */
export function getAccessibleTextColor(backgroundColor: string): string {
  const whiteContrast = getContrastRatio("#FFFFFF", backgroundColor);
  const blackContrast = getContrastRatio("#000000", backgroundColor);
  return whiteContrast > blackContrast ? "#FFFFFF" : "#000000";
}

/**
 * Announce message to screen readers
 */
export function announceToScreenReader(message: string, priority: "polite" | "assertive" = "polite") {
  const announcement = document.createElement("div");
  announcement.setAttribute("role", "status");
  announcement.setAttribute("aria-live", priority);
  announcement.setAttribute("aria-atomic", "true");
  announcement.className = "sr-only";
  announcement.textContent = message;

  document.body.appendChild(announcement);

  // Remove after announcement
  setTimeout(() => {
    document.body.removeChild(announcement);
  }, 1000);
}

/**
 * Trap focus within an element (for modals, dialogs)
 */
export function trapFocus(element: HTMLElement) {
  const focusableElements = element.querySelectorAll<HTMLElement>(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );

  const firstFocusable = focusableElements[0];
  const lastFocusable = focusableElements[focusableElements.length - 1];

  const handleTabKey = (e: KeyboardEvent) => {
    if (e.key !== "Tab") return;

    if (e.shiftKey) {
      // Shift + Tab
      if (document.activeElement === firstFocusable) {
        lastFocusable.focus();
        e.preventDefault();
      }
    } else {
      // Tab
      if (document.activeElement === lastFocusable) {
        firstFocusable.focus();
        e.preventDefault();
      }
    }
  };

  element.addEventListener("keydown", handleTabKey);

  // Return cleanup function
  return () => {
    element.removeEventListener("keydown", handleTabKey);
  };
}

/**
 * Add keyboard navigation support
 */
export function addKeyboardNavigation(
  elements: HTMLElement[],
  options: {
    orientation?: "horizontal" | "vertical" | "both";
    loop?: boolean;
  } = {}
) {
  const { orientation = "both", loop = true } = options;

  const handleKeyDown = (e: KeyboardEvent, currentIndex: number) => {
    let nextIndex = currentIndex;

    switch (e.key) {
      case "ArrowRight":
        if (orientation === "horizontal" || orientation === "both") {
          nextIndex = currentIndex + 1;
          e.preventDefault();
        }
        break;
      case "ArrowLeft":
        if (orientation === "horizontal" || orientation === "both") {
          nextIndex = currentIndex - 1;
          e.preventDefault();
        }
        break;
      case "ArrowDown":
        if (orientation === "vertical" || orientation === "both") {
          nextIndex = currentIndex + 1;
          e.preventDefault();
        }
        break;
      case "ArrowUp":
        if (orientation === "vertical" || orientation === "both") {
          nextIndex = currentIndex - 1;
          e.preventDefault();
        }
        break;
      case "Home":
        nextIndex = 0;
        e.preventDefault();
        break;
      case "End":
        nextIndex = elements.length - 1;
        e.preventDefault();
        break;
      default:
        return;
    }

    // Handle looping
    if (loop) {
      if (nextIndex < 0) nextIndex = elements.length - 1;
      if (nextIndex >= elements.length) nextIndex = 0;
    } else {
      nextIndex = Math.max(0, Math.min(nextIndex, elements.length - 1));
    }

    if (nextIndex !== currentIndex && elements[nextIndex]) {
      elements[nextIndex].focus();
    }
  };

  elements.forEach((element, index) => {
    element.addEventListener("keydown", (e) => handleKeyDown(e, index));
  });
}

/**
 * Check if user prefers reduced motion
 */
export function prefersReducedMotion(): boolean {
  return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
}

/**
 * Get appropriate animation duration based on user preference
 */
export function getAnimationDuration(defaultMs: number): number {
  return prefersReducedMotion() ? 0 : defaultMs;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/api.ts
=================================================================================
const region = import.meta.env.VITE_FUNCTIONS_REGION || "us-central1";
const projectId = import.meta.env.VITE_FIREBASE_PROJECT_ID || "pls-fix-thx";

// Use local emulator in development, deployed functions in production
function baseUrl() {
  // Check if we're in development mode and should use emulator
  const isDev = import.meta.env.DEV;
  const useEmulator = isDev && !import.meta.env.VITE_USE_PRODUCTION_FUNCTIONS;

  if (useEmulator) {
    return "http://127.0.0.1:5001/pls-fix-thx/us-central1";
  }

  return `https://${region}-${projectId}.cloudfunctions.net`;
}

export async function apiGenerate(prompt: string) {
  const r = await fetch(`${baseUrl()}/generateSlideSpec`, {
    method: "POST",
    headers: { "Content-Type":"application/json" },
    body: JSON.stringify({ prompt })
  });
  if (!r.ok) throw new Error(await r.text());
  return r.json();
}

export async function apiExport(spec: unknown) {
  const r = await fetch(`${baseUrl()}/exportPPTX`, {
    method: "POST",
    headers: { "Content-Type":"application/json" },
    body: JSON.stringify({ spec })
  });
  if (!r.ok) throw new Error(await r.text());
  const blob = await r.blob();
  return blob;
}

export async function apiExportMultiple(specs: unknown[]) {
  const r = await fetch(`${baseUrl()}/exportPPTX`, {
    method: "POST",
    headers: { "Content-Type":"application/json" },
    body: JSON.stringify({ specs })
  });
  if (!r.ok) throw new Error(await r.text());
  const blob = await r.blob();
  return blob;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/colorPalettes.ts
=================================================================================
/**
 * Professional Color Palettes
 * 15 carefully curated palettes with WCAG AA/AAA validation
 */

export interface ColorPalette {
  name: string;
  primary: string;
  accent: string;
  neutral: string[];
  use: string;
  contrast: number;
  psychology: string;
}

export const PROFESSIONAL_PALETTES: Record<string, ColorPalette> = {
  corporate: {
    name: "Corporate Professional",
    primary: "#1E40AF",
    accent: "#10B981",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Business, finance, corporate presentations",
    contrast: 7.2,
    psychology: "Trust, stability, growth"
  },
  tech: {
    name: "Tech Innovation",
    primary: "#2563EB",
    accent: "#8B5CF6",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Technology, startups, innovation",
    contrast: 6.8,
    psychology: "Innovation, intelligence, creativity"
  },
  finance: {
    name: "Finance & Growth",
    primary: "#1E40AF",
    accent: "#F59E0B",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Financial services, growth metrics, investment",
    contrast: 7.1,
    psychology: "Trust, prosperity, opportunity"
  },
  healthcare: {
    name: "Healthcare & Wellness",
    primary: "#0D9488",
    accent: "#0EA5E9",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Healthcare, wellness, medical",
    contrast: 6.5,
    psychology: "Health, trust, calm"
  },
  creative: {
    name: "Creative & Marketing",
    primary: "#EC4899",
    accent: "#F97316",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Creative, marketing, design",
    contrast: 6.9,
    psychology: "Energy, creativity, passion"
  },
  minimal: {
    name: "Minimal & Modern",
    primary: "#1F2937",
    accent: "#6366F1",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Minimal, modern, clean design",
    contrast: 7.5,
    psychology: "Sophistication, clarity, focus"
  },
  eco: {
    name: "Eco & Sustainability",
    primary: "#059669",
    accent: "#84CC16",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Sustainability, environment, nature",
    contrast: 6.7,
    psychology: "Growth, nature, sustainability"
  },
  luxury: {
    name: "Luxury & Premium",
    primary: "#1E1B4B",
    accent: "#D97706",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Luxury, premium, high-end",
    contrast: 7.3,
    psychology: "Elegance, exclusivity, quality"
  },
  education: {
    name: "Education & Learning",
    primary: "#0369A1",
    accent: "#7C3AED",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Education, training, learning",
    contrast: 6.6,
    psychology: "Knowledge, growth, inspiration"
  },
  bold: {
    name: "Bold & Energetic",
    primary: "#DC2626",
    accent: "#EA580C",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Energy, action, urgency",
    contrast: 7.0,
    psychology: "Energy, passion, action"
  },
  cool: {
    name: "Cool & Calm",
    primary: "#0891B2",
    accent: "#06B6D4",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Calm, cool, professional",
    contrast: 6.4,
    psychology: "Calm, trust, clarity"
  },
  warm: {
    name: "Warm & Friendly",
    primary: "#EA580C",
    accent: "#F97316",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Friendly, approachable, warm",
    contrast: 6.8,
    psychology: "Warmth, friendliness, energy"
  },
  grayscale: {
    name: "Professional Grayscale",
    primary: "#1F2937",
    accent: "#6B7280",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Professional, neutral, corporate",
    contrast: 7.4,
    psychology: "Professionalism, neutrality, focus"
  },
  vibrant: {
    name: "Vibrant & Modern",
    primary: "#7C3AED",
    accent: "#06B6D4",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Modern, vibrant, contemporary",
    contrast: 6.9,
    psychology: "Innovation, modernity, creativity"
  },
  classic: {
    name: "Classic & Timeless",
    primary: "#1E3A8A",
    accent: "#7C2D12",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Classic, timeless, traditional",
    contrast: 7.2,
    psychology: "Tradition, stability, heritage"
  },
  sunset: {
    name: "Sunset & Warmth",
    primary: "#EA580C",
    accent: "#F97316",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Warm, inviting, energetic presentations",
    contrast: 6.9,
    psychology: "Warmth, energy, optimism"
  },
  ocean: {
    name: "Ocean & Depth",
    primary: "#0369A1",
    accent: "#0EA5E9",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Water, technology, depth, trust",
    contrast: 6.6,
    psychology: "Trust, depth, clarity"
  },
  forest: {
    name: "Forest & Nature",
    primary: "#15803D",
    accent: "#22C55E",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Nature, sustainability, growth",
    contrast: 6.8,
    psychology: "Growth, nature, renewal"
  },
  midnight: {
    name: "Midnight & Mystery",
    primary: "#1E1B4B",
    accent: "#818CF8",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Premium, sophisticated, modern",
    contrast: 7.1,
    psychology: "Sophistication, mystery, elegance"
  },
  rose: {
    name: "Rose & Elegance",
    primary: "#BE185D",
    accent: "#EC4899",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Fashion, beauty, elegance",
    contrast: 6.7,
    psychology: "Elegance, femininity, sophistication"
  },
  amber: {
    name: "Amber & Warmth",
    primary: "#B45309",
    accent: "#F59E0B",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Warmth, hospitality, comfort",
    contrast: 6.8,
    psychology: "Warmth, comfort, hospitality"
  },
  slate: {
    name: "Slate & Professional",
    primary: "#334155",
    accent: "#64748B",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Professional, neutral, corporate",
    contrast: 7.3,
    psychology: "Professionalism, stability, focus"
  },
  indigo: {
    name: "Indigo & Innovation",
    primary: "#4F46E5",
    accent: "#6366F1",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Technology, innovation, intelligence",
    contrast: 6.5,
    psychology: "Innovation, intelligence, creativity"
  },
  teal: {
    name: "Teal & Balance",
    primary: "#0D9488",
    accent: "#14B8A6",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Balance, wellness, modern",
    contrast: 6.7,
    psychology: "Balance, wellness, harmony"
  }
};

export function getPalette(name: string): ColorPalette | undefined {
  return PROFESSIONAL_PALETTES[name];
}

export function getAllPalettes(): ColorPalette[] {
  return Object.values(PROFESSIONAL_PALETTES);
}

export function getPaletteNames(): string[] {
  return Object.keys(PROFESSIONAL_PALETTES);
}

/**
 * Calculate contrast ratio between two colors
 * Returns WCAG contrast ratio (1-21)
 */
export function calculateContrastRatio(foreground: string, background: string): number {
  const fgLum = getRelativeLuminance(foreground);
  const bgLum = getRelativeLuminance(background);
  
  const lighter = Math.max(fgLum, bgLum);
  const darker = Math.min(fgLum, bgLum);
  
  return (lighter + 0.05) / (darker + 0.05);
}

/**
 * Get relative luminance of a color
 */
function getRelativeLuminance(hex: string): number {
  const rgb = hexToRgb(hex);
  if (!rgb) return 0;
  
  const [r, g, b] = rgb.map(val => {
    const v = val / 255;
    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  });
  
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

/**
 * Convert hex color to RGB
 */
function hexToRgb(hex: string): [number, number, number] | null {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? [
    parseInt(result[1], 16),
    parseInt(result[2], 16),
    parseInt(result[3], 16)
  ] : null;
}

/**
 * Validate palette contrast ratios
 */
export function validatePaletteContrast(palette: ColorPalette, minRatio: number = 4.5): boolean {
  const textColor = palette.neutral[0];
  const bgColor = palette.neutral[6];
  const ratio = calculateContrastRatio(textColor, bgColor);
  return ratio >= minRatio;
}

/**
 * Get palette by use case
 */
export function getPaletteByUseCase(useCase: string): ColorPalette | undefined {
  const lower = useCase.toLowerCase();
  
  if (lower.includes("business") || lower.includes("corporate") || lower.includes("finance")) {
    return PROFESSIONAL_PALETTES.corporate;
  }
  if (lower.includes("tech") || lower.includes("startup") || lower.includes("innovation")) {
    return PROFESSIONAL_PALETTES.tech;
  }
  if (lower.includes("health") || lower.includes("medical") || lower.includes("wellness")) {
    return PROFESSIONAL_PALETTES.healthcare;
  }
  if (lower.includes("creative") || lower.includes("marketing") || lower.includes("design")) {
    return PROFESSIONAL_PALETTES.creative;
  }
  if (lower.includes("education") || lower.includes("learning") || lower.includes("training")) {
    return PROFESSIONAL_PALETTES.education;
  }
  if (lower.includes("eco") || lower.includes("sustainability") || lower.includes("environment")) {
    return PROFESSIONAL_PALETTES.eco;
  }
  if (lower.includes("luxury") || lower.includes("premium") || lower.includes("high-end")) {
    return PROFESSIONAL_PALETTES.luxury;
  }
  if (lower.includes("minimal") || lower.includes("modern") || lower.includes("clean")) {
    return PROFESSIONAL_PALETTES.minimal;
  }
  
  return PROFESSIONAL_PALETTES.corporate; // default
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/designQuality.ts
=================================================================================
/**
 * Design Quality Validation & Metrics
 * Validates design quality against professional standards
 */

import type { SlideSpecV2 } from "@/types/SlideSpecV2";
import { calculateContrastRatio } from "./colorPalettes";

export interface DesignQualityScore {
  contrast: number; // 0-100
  hierarchy: number; // 0-100
  whitespace: number; // 0-100
  colorHarmony: number; // 0-100
  typography: number; // 0-100
  accessibility: number; // 0-100
  overall: number; // 0-100
  issues: string[];
  warnings: string[];
}

/**
 * Validate overall design quality
 */
export function validateDesignQuality(spec: SlideSpecV2): DesignQualityScore {
  const issues: string[] = [];
  const warnings: string[] = [];
  
  const contrast = validateContrast(spec, issues, warnings);
  const hierarchy = validateHierarchy(spec, issues, warnings);
  const whitespace = validateWhitespace(spec, issues, warnings);
  const colorHarmony = validateColorHarmony(spec, issues, warnings);
  const typography = validateTypography(spec, issues, warnings);
  const accessibility = validateAccessibility(spec, issues, warnings);
  
  const overall = Math.round(
    (contrast + hierarchy + whitespace + colorHarmony + typography + accessibility) / 6
  );
  
  return {
    contrast,
    hierarchy,
    whitespace,
    colorHarmony,
    typography,
    accessibility,
    overall,
    issues,
    warnings
  };
}

/**
 * Validate contrast ratios (WCAG AA minimum 4.5:1)
 */
function validateContrast(spec: SlideSpecV2, issues: string[], warnings: string[]): number {
  const palette = spec.styleTokens.palette;
  const textColor = palette.neutral[0];
  const bgColor = palette.neutral[6];
  
  const ratio = calculateContrastRatio(textColor, bgColor);
  
  if (ratio >= 7) {
    return 100; // WCAG AAA
  } else if (ratio >= 4.5) {
    return 85; // WCAG AA
  } else if (ratio >= 3) {
    warnings.push(`Contrast ratio ${ratio.toFixed(1)}:1 is below WCAG AA (4.5:1)`);
    return 50;
  } else {
    issues.push(`Contrast ratio ${ratio.toFixed(1)}:1 is critically low`);
    return 20;
  }
}

/**
 * Validate visual hierarchy
 */
function validateHierarchy(spec: SlideSpecV2, issues: string[], warnings: string[]): number {
  const sizes = spec.styleTokens.typography.sizes;
  const step0 = sizes.step_0;
  const step3 = sizes.step_3;
  
  const ratio = step3 / step0;
  
  if (ratio >= 2) {
    return 100; // Excellent hierarchy
  } else if (ratio >= 1.5) {
    return 80; // Good hierarchy
  } else if (ratio >= 1.2) {
    warnings.push("Typography hierarchy could be more pronounced");
    return 60;
  } else {
    issues.push("Typography hierarchy is too subtle");
    return 40;
  }
}

/**
 * Validate white space distribution
 */
function validateWhitespace(spec: SlideSpecV2, issues: string[], warnings: string[]): number {
  const strategy = spec.design.whitespace.strategy;
  const breathing = spec.design.whitespace.breathingRoom;
  
  if (strategy === "generous" && breathing >= 40) {
    return 100;
  } else if (strategy === "balanced" && breathing >= 25) {
    return 100;
  } else if (strategy === "compact" && breathing >= 15) {
    return 100;
  } else if (breathing >= 20) {
    warnings.push("White space could be optimized for better visual balance");
    return 75;
  } else {
    issues.push("Insufficient white space - slide appears cluttered");
    return 50;
  }
}

/**
 * Validate color harmony
 */
function validateColorHarmony(spec: SlideSpecV2, issues: string[], warnings: string[]): number {
  const distribution = spec.design.colorStrategy.distribution;
  const palette = spec.styleTokens.palette;
  
  // Check if colors are valid hex
  const hexPattern = /^#[0-9A-Fa-f]{6}$/;
  if (!hexPattern.test(palette.primary) || !hexPattern.test(palette.accent)) {
    issues.push("Invalid color format - must be hex (#RRGGBB)");
    return 40;
  }
  
  // Validate distribution
  const validDistributions = ["monochromatic", "complementary", "analogous", "triadic"];
  if (!validDistributions.includes(distribution)) {
    warnings.push("Unknown color distribution strategy");
    return 70;
  }
  
  return 90; // Good color harmony
}

/**
 * Validate typography consistency
 */
function validateTypography(spec: SlideSpecV2, issues: string[], warnings: string[]): number {
  const hierarchy = spec.design.typography.hierarchy;

  // Check if hierarchy is defined
  if (!hierarchy || Object.keys(hierarchy).length === 0) {
    warnings.push("Typography hierarchy not fully defined");
    return 70;
  }
  
  // Check font sizes are reasonable
  const minSize = 12;
  const maxSize = 72;
  
  for (const [key, config] of Object.entries(hierarchy)) {
    if (config.size < minSize || config.size > maxSize) {
      issues.push(`Typography size for ${key} (${config.size}px) is out of range`);
      return 50;
    }
    
    if (config.lineHeight < 1.2 || config.lineHeight > 2) {
      warnings.push(`Line height for ${key} (${config.lineHeight}) may be suboptimal`);
    }
  }
  
  return 85; // Good typography
}

/**
 * Validate accessibility compliance
 */
function validateAccessibility(spec: SlideSpecV2, issues: string[], warnings: string[]): number {
  let score = 100;
  
  // Check minimum font size
  const bodySize = spec.styleTokens.typography.sizes.step_0;
  if (bodySize < 16) {
    warnings.push(`Body font size (${bodySize}px) is below recommended 16px minimum`);
    score -= 15;
  }
  
  // Check contrast
  const contrast = calculateContrastRatio(
    spec.styleTokens.palette.neutral[0],
    spec.styleTokens.palette.neutral[6]
  );
  if (contrast < 4.5) {
    issues.push("Contrast ratio below WCAG AA minimum (4.5:1)");
    score -= 30;
  }
  
  // Check line height
  const lineHeight = spec.styleTokens.typography.lineHeights.standard;
  if (lineHeight < 1.5) {
    warnings.push("Line height below recommended 1.5 minimum");
    score -= 10;
  }
  
  return Math.max(0, score);
}

/**
 * Get quality score interpretation
 */
export function getQualityInterpretation(score: number): string {
  if (score >= 90) return "Excellent - Professional quality";
  if (score >= 80) return "Very Good - High quality";
  if (score >= 70) return "Good - Acceptable quality";
  if (score >= 60) return "Fair - Needs improvement";
  if (score >= 50) return "Poor - Significant issues";
  return "Critical - Major problems";
}

/**
 * Get quality color indicator
 */
export function getQualityColor(score: number): string {
  if (score >= 90) return "#10B981"; // Green
  if (score >= 80) return "#3B82F6"; // Blue
  if (score >= 70) return "#F59E0B"; // Amber
  if (score >= 60) return "#F97316"; // Orange
  if (score >= 50) return "#EF4444"; // Red
  return "#DC2626"; // Dark Red
}

/**
 * Format quality report
 */
export function formatQualityReport(score: DesignQualityScore): string {
  let report = `Design Quality Report\n`;
  report += `Overall Score: ${score.overall}/100 (${getQualityInterpretation(score.overall)})\n\n`;
  
  report += `Metrics:\n`;
  report += `  Contrast: ${score.contrast}/100\n`;
  report += `  Hierarchy: ${score.hierarchy}/100\n`;
  report += `  White Space: ${score.whitespace}/100\n`;
  report += `  Color Harmony: ${score.colorHarmony}/100\n`;
  report += `  Typography: ${score.typography}/100\n`;
  report += `  Accessibility: ${score.accessibility}/100\n\n`;
  
  if (score.issues.length > 0) {
    report += `Issues (${score.issues.length}):\n`;
    score.issues.forEach(issue => {
      report += `  ❌ ${issue}\n`;
    });
    report += `\n`;
  }
  
  if (score.warnings.length > 0) {
    report += `Warnings (${score.warnings.length}):\n`;
    score.warnings.forEach(warning => {
      report += `  ⚠️  ${warning}\n`;
    });
  }
  
  return report;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/env.ts
=================================================================================
import { z } from "zod";

/** Environment variable schema */
const envSchema = z.object({
  // Firebase config is optional since it can be hardcoded in firebase.ts
  VITE_FIREBASE_API_KEY: z.string().optional(),
  VITE_FIREBASE_AUTH_DOMAIN: z.string().optional(),
  VITE_FIREBASE_PROJECT_ID: z.string().optional(),
  VITE_FIREBASE_STORAGE_BUCKET: z.string().optional(),
  VITE_FIREBASE_MESSAGING_SENDER_ID: z.string().optional(),
  VITE_FIREBASE_APP_ID: z.string().optional(),
  VITE_FIREBASE_MEASUREMENT_ID: z.string().optional(),
  VITE_FUNCTIONS_BASE_URL: z.string().url("Functions base URL must be a valid URL").optional(),
  VITE_FUNCTIONS_REGION: z.string().optional(),
  MODE: z.enum(["development", "production", "test"]).optional(),
  DEV: z.boolean().optional(),
  PROD: z.boolean().optional(),
});

type Env = z.infer<typeof envSchema>;

/** Validated environment variables */
let validatedEnv: Env | null = null;

/** Validate environment variables at startup */
export function validateEnv(): Env {
  if (validatedEnv) {
    return validatedEnv;
  }

  try {
    validatedEnv = envSchema.parse(import.meta.env);
    console.log("✅ Environment variables validated successfully");
    return validatedEnv;
  } catch (error) {
    if (error instanceof z.ZodError) {
      console.error("❌ Environment validation failed:");
      error.issues.forEach((err: any) => {
        console.error(`  - ${err.path.join(".")}: ${err.message}`);
      });

      // In development, show a helpful error message
      if (import.meta.env.DEV) {
        const missingVars = error.issues.map((e: any) => e.path.join(".")).join(", ");
        throw new Error(
          `Missing or invalid environment variables: ${missingVars}\n\n` +
          `Please check your .env file and ensure all required variables are set.\n` +
          `See .env.example for reference.`
        );
      }
    }
    throw error;
  }
}

/** Get validated environment variables */
export function getEnv(): Env {
  if (!validatedEnv) {
    return validateEnv();
  }
  return validatedEnv;
}

/** Check if running in development mode */
export function isDevelopment(): boolean {
  return import.meta.env.DEV === true;
}

/** Check if running in production mode */
export function isProduction(): boolean {
  return import.meta.env.PROD === true;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/firebase.ts
=================================================================================
import { initializeApp } from "firebase/app";
import { getAnalytics, isSupported } from "firebase/analytics";

/** Provided config (unchanged) */
const firebaseConfig = {
  apiKey: "AIzaSyAFFyRB7F7LHNVraB5xL7zSunVPa7zbq9E",
  authDomain: "pls-fix-thx.firebaseapp.com",
  projectId: "pls-fix-thx",
  storageBucket: "pls-fix-thx.firebasestorage.app",
  messagingSenderId: "684982102967",
  appId: "1:684982102967:web:ede742c0e2e5d497c61632",
  measurementId: "G-04FXJHYHCS"
};

export const app = initializeApp(firebaseConfig);

// Analytics optional; safe-check for SSR/emulator
export async function initAnalytics() {
  try {
    if (typeof window !== "undefined" && (await isSupported())) {
      return getAnalytics(app);
    }
  } catch {}
  return null;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/layoutPatterns.ts
=================================================================================
/**
 * Professional Layout Composition Patterns
 * 6 predefined patterns for professional slide layouts
 */

export type LayoutPatternName = "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused";

export interface RegionLayout {
  x: number; // left position (inches)
  y: number; // top position (inches)
  w: number; // width (inches)
  h: number; // height (inches)
}

export interface LayoutPattern {
  name: string;
  description: string;
  pattern: LayoutPatternName;
  regions: Record<string, RegionLayout>;
  whitespacePercentage: number;
  bestFor: string[];
}

// Standard slide dimensions: 10" x 7.5" (16:9)
const SLIDE_WIDTH = 10;
const SLIDE_HEIGHT = 7.5;
const MARGIN = 0.5;

export const LAYOUT_PATTERNS: Record<LayoutPatternName, LayoutPattern> = {
  hero: {
    name: "Hero Pattern",
    description: "Large title/image focus with supporting content",
    pattern: "hero",
    regions: {
      header: {
        x: MARGIN,
        y: MARGIN,
        w: SLIDE_WIDTH - 2 * MARGIN,
        h: SLIDE_HEIGHT * 0.6 - MARGIN
      },
      body: {
        x: MARGIN,
        y: SLIDE_HEIGHT * 0.6 + MARGIN,
        w: SLIDE_WIDTH - 2 * MARGIN,
        h: SLIDE_HEIGHT * 0.4 - 2 * MARGIN
      }
    },
    whitespacePercentage: 25,
    bestFor: ["Cover slides", "Announcements", "Key messages", "Hero images"]
  },
  split: {
    name: "Split Pattern",
    description: "50/50 left/right content division",
    pattern: "split",
    regions: {
      header: {
        x: MARGIN,
        y: MARGIN,
        w: SLIDE_WIDTH - 2 * MARGIN,
        h: 1.5
      },
      left: {
        x: MARGIN,
        y: 2,
        w: SLIDE_WIDTH / 2 - MARGIN - 0.25,
        h: SLIDE_HEIGHT - 2.5
      },
      right: {
        x: SLIDE_WIDTH / 2 + 0.25,
        y: 2,
        w: SLIDE_WIDTH / 2 - MARGIN - 0.25,
        h: SLIDE_HEIGHT - 2.5
      }
    },
    whitespacePercentage: 20,
    bestFor: ["Comparisons", "Before/after", "Two-column content", "Pros/cons"]
  },
  asymmetric: {
    name: "Asymmetric Pattern",
    description: "Dynamic off-center layout with visual balance",
    pattern: "asymmetric",
    regions: {
      header: {
        x: MARGIN,
        y: MARGIN,
        w: SLIDE_WIDTH - 2 * MARGIN,
        h: 1.2
      },
      primary: {
        x: MARGIN,
        y: 1.8,
        w: SLIDE_WIDTH * 0.65 - MARGIN,
        h: SLIDE_HEIGHT - 2.3
      },
      secondary: {
        x: SLIDE_WIDTH * 0.65 + 0.25,
        y: 1.8,
        w: SLIDE_WIDTH * 0.35 - MARGIN - 0.25,
        h: SLIDE_HEIGHT - 2.3
      }
    },
    whitespacePercentage: 22,
    bestFor: ["Dynamic layouts", "Creative presentations", "Feature highlights"]
  },
  grid: {
    name: "Grid Pattern",
    description: "Structured multi-element layout",
    pattern: "grid",
    regions: {
      header: {
        x: MARGIN,
        y: MARGIN,
        w: SLIDE_WIDTH - 2 * MARGIN,
        h: 1.2
      },
      item1: {
        x: MARGIN,
        y: 1.8,
        w: (SLIDE_WIDTH - 2 * MARGIN - 0.25) / 2,
        h: (SLIDE_HEIGHT - 2.3) / 2
      },
      item2: {
        x: SLIDE_WIDTH / 2 + 0.25,
        y: 1.8,
        w: (SLIDE_WIDTH - 2 * MARGIN - 0.25) / 2,
        h: (SLIDE_HEIGHT - 2.3) / 2
      },
      item3: {
        x: MARGIN,
        y: SLIDE_HEIGHT / 2 + 0.8,
        w: (SLIDE_WIDTH - 2 * MARGIN - 0.25) / 2,
        h: (SLIDE_HEIGHT - 2.3) / 2
      },
      item4: {
        x: SLIDE_WIDTH / 2 + 0.25,
        y: SLIDE_HEIGHT / 2 + 0.8,
        w: (SLIDE_WIDTH - 2 * MARGIN - 0.25) / 2,
        h: (SLIDE_HEIGHT - 2.3) / 2
      }
    },
    whitespacePercentage: 18,
    bestFor: ["Multiple items", "Portfolio", "Process steps", "Features"]
  },
  minimal: {
    name: "Minimal Pattern",
    description: "Single focal point with generous white space",
    pattern: "minimal",
    regions: {
      content: {
        x: SLIDE_WIDTH * 0.2,
        y: SLIDE_HEIGHT * 0.25,
        w: SLIDE_WIDTH * 0.6,
        h: SLIDE_HEIGHT * 0.5
      }
    },
    whitespacePercentage: 45,
    bestFor: ["Key messages", "Quotes", "Emphasis", "Minimal design"]
  },
  "data-focused": {
    name: "Data-Focused Pattern",
    description: "Chart/data as primary focus with supporting text",
    pattern: "data-focused",
    regions: {
      header: {
        x: MARGIN,
        y: MARGIN,
        w: SLIDE_WIDTH - 2 * MARGIN,
        h: 0.8
      },
      chart: {
        x: MARGIN,
        y: 1.2,
        w: SLIDE_WIDTH * 0.65 - MARGIN,
        h: SLIDE_HEIGHT - 1.7
      },
      sidebar: {
        x: SLIDE_WIDTH * 0.65 + 0.25,
        y: 1.2,
        w: SLIDE_WIDTH * 0.35 - MARGIN - 0.25,
        h: SLIDE_HEIGHT - 1.7
      }
    },
    whitespacePercentage: 18,
    bestFor: ["Analytics", "Metrics", "Data visualization", "Charts"]
  }
};

export function getLayoutPattern(pattern: LayoutPatternName): LayoutPattern | undefined {
  return LAYOUT_PATTERNS[pattern];
}

export function getAllLayoutPatterns(): LayoutPattern[] {
  return Object.values(LAYOUT_PATTERNS);
}

export function getLayoutPatternNames(): LayoutPatternName[] {
  return Object.keys(LAYOUT_PATTERNS) as LayoutPatternName[];
}

/**
 * Get layout pattern by use case
 */
export function getLayoutByUseCase(useCase: string): LayoutPattern | undefined {
  const lower = useCase.toLowerCase();
  
  if (lower.includes("data") || lower.includes("chart") || lower.includes("metric")) {
    return LAYOUT_PATTERNS["data-focused"];
  }
  if (lower.includes("minimal") || lower.includes("quote") || lower.includes("message")) {
    return LAYOUT_PATTERNS.minimal;
  }
  if (lower.includes("compare") || lower.includes("before") || lower.includes("after")) {
    return LAYOUT_PATTERNS.split;
  }
  if (lower.includes("dynamic") || lower.includes("creative") || lower.includes("feature")) {
    return LAYOUT_PATTERNS.asymmetric;
  }
  if (lower.includes("multiple") || lower.includes("portfolio") || lower.includes("process")) {
    return LAYOUT_PATTERNS.grid;
  }
  if (lower.includes("cover") || lower.includes("announcement") || lower.includes("hero")) {
    return LAYOUT_PATTERNS.hero;
  }
  
  return LAYOUT_PATTERNS.split; // default
}

/**
 * Validate layout pattern
 */
export function validateLayoutPattern(pattern: LayoutPattern): boolean {
  const regions = Object.values(pattern.regions);
  
  return regions.every(region => 
    region.x >= 0 &&
    region.y >= 0 &&
    region.w > 0 &&
    region.h > 0 &&
    region.x + region.w <= SLIDE_WIDTH &&
    region.y + region.h <= SLIDE_HEIGHT
  );
}

/**
 * Get region by name from pattern
 */
export function getRegion(pattern: LayoutPattern, regionName: string): RegionLayout | undefined {
  return pattern.regions[regionName];
}

/**
 * Calculate total white space percentage
 */
export function calculateWhitespacePercentage(pattern: LayoutPattern): number {
  const totalArea = SLIDE_WIDTH * SLIDE_HEIGHT;
  const usedArea = Object.values(pattern.regions).reduce((sum, region) => 
    sum + (region.w * region.h), 0
  );
  const whiteSpace = totalArea - usedArea;
  return (whiteSpace / totalArea) * 100;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/logger.ts
=================================================================================
import { isDevelopment } from "./env";

const LogLevel = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
} as const;

type LogLevel = typeof LogLevel[keyof typeof LogLevel];

interface LogContext {
  [key: string]: any;
}

class Logger {
  private minLevel: LogLevel;

  constructor() {
    this.minLevel = isDevelopment() ? LogLevel.DEBUG : LogLevel.INFO;
  }

  private shouldLog(level: LogLevel): boolean {
    return level >= this.minLevel;
  }

  private formatMessage(level: string, message: string, context?: LogContext): string {
    const timestamp = new Date().toISOString();
    const contextStr = context ? ` ${JSON.stringify(context)}` : "";
    return `[${timestamp}] [${level}] ${message}${contextStr}`;
  }

  debug(message: string, context?: LogContext): void {
    if (this.shouldLog(LogLevel.DEBUG)) {
      console.debug(this.formatMessage("DEBUG", message, context));
    }
  }

  info(message: string, context?: LogContext): void {
    if (this.shouldLog(LogLevel.INFO)) {
      console.info(this.formatMessage("INFO", message, context));
    }
  }

  warn(message: string, context?: LogContext): void {
    if (this.shouldLog(LogLevel.WARN)) {
      console.warn(this.formatMessage("WARN", message, context));
    }
  }

  error(message: string, error?: Error | unknown, context?: LogContext): void {
    if (this.shouldLog(LogLevel.ERROR)) {
      const errorContext = {
        ...context,
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack,
        } : error,
      };
      console.error(this.formatMessage("ERROR", message, errorContext));
    }
  }

  /** Log API call */
  apiCall(method: string, url: string, context?: LogContext): void {
    this.debug(`API ${method} ${url}`, context);
  }

  /** Log API response */
  apiResponse(method: string, url: string, status: number, duration: number): void {
    const level = status >= 400 ? LogLevel.ERROR : status >= 300 ? LogLevel.WARN : LogLevel.DEBUG;
    const message = `API ${method} ${url} - ${status} (${duration}ms)`;
    
    if (level === LogLevel.ERROR) {
      this.error(message);
    } else if (level === LogLevel.WARN) {
      this.warn(message);
    } else {
      this.debug(message);
    }
  }

  /** Log user action */
  userAction(action: string, context?: LogContext): void {
    this.info(`User action: ${action}`, context);
  }

  /** Log performance metric */
  performance(metric: string, value: number, unit: string = "ms"): void {
    this.debug(`Performance: ${metric} = ${value}${unit}`);
  }
}

export const logger = new Logger();



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/pdfExport.ts
=================================================================================
import jsPDF from "jspdf";
import html2canvas from "html2canvas";
import type { Presentation } from "@/types/Presentation";
import { logger } from "./logger";

export interface PDFExportOptions {
  orientation?: "portrait" | "landscape";
  quality?: number;
  includeMetadata?: boolean;
}

export async function exportPresentationToPDF(
  presentation: Presentation,
  slideElements: HTMLElement[],
  options: PDFExportOptions = {}
): Promise<Blob> {
  const {
    orientation = "landscape",
    quality = 0.95,
    includeMetadata = true,
  } = options;

  const startTime = performance.now();
  logger.info("Starting PDF export", { 
    slideCount: presentation.slides.length,
    orientation 
  });

  try {
    // Create PDF document
    const pdf = new jsPDF({
      orientation,
      unit: "px",
      format: orientation === "landscape" ? [1920, 1080] : [1080, 1920],
      compress: true,
    });

    // Add metadata
    if (includeMetadata) {
      pdf.setProperties({
        title: presentation.title,
        subject: "Generated presentation",
        author: "plzfixthx",
        creator: "plzfixthx",
        keywords: "presentation, slides",
      });
    }

    // Process each slide
    for (let i = 0; i < slideElements.length; i++) {
      const element = slideElements[i];
      
      logger.info(`Rendering slide ${i + 1} to canvas`);
      
      // Convert slide to canvas
      const canvas = await html2canvas(element, {
        scale: 2, // Higher quality
        useCORS: true,
        logging: false,
        backgroundColor: "#ffffff",
      });

      // Convert canvas to image
      const imgData = canvas.toDataURL("image/jpeg", quality);
      const imgWidth = pdf.internal.pageSize.getWidth();
      const imgHeight = pdf.internal.pageSize.getHeight();

      // Add new page for slides after the first
      if (i > 0) {
        pdf.addPage();
      }

      // Add image to PDF
      pdf.addImage(imgData, "JPEG", 0, 0, imgWidth, imgHeight);
      
      logger.info(`Added slide ${i + 1} to PDF`);
    }

    // Generate blob
    const blob = pdf.output("blob");
    
    const duration = performance.now() - startTime;
    logger.performance("pdf_export", duration);
    logger.info("PDF export completed", { 
      slideCount: presentation.slides.length,
      size: blob.size,
      duration 
    });

    return blob;
  } catch (error) {
    logger.error("PDF export failed", error);
    throw new Error("Failed to export presentation to PDF");
  }
}

export async function downloadPDF(
  presentation: Presentation,
  slideElements: HTMLElement[],
  filename?: string,
  options?: PDFExportOptions
): Promise<void> {
  const blob = await exportPresentationToPDF(presentation, slideElements, options);
  
  const finalFilename = filename || 
    `${presentation.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.pdf`;
  
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = finalFilename;
  a.click();
  URL.revokeObjectURL(url);
  
  logger.info("PDF downloaded", { filename: finalFilename });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/registerSW.ts
=================================================================================
import { logger } from "./logger";

export function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker
        .register('/sw.js')
        .then((registration) => {
          logger.info('Service Worker registered', { scope: registration.scope });

          // Check for updates periodically
          setInterval(() => {
            registration.update();
          }, 60 * 60 * 1000); // Check every hour

          // Listen for updates
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            if (newWorker) {
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New service worker available
                  logger.info('New service worker available');
                  
                  // Optionally show a notification to the user
                  if (confirm('A new version is available. Reload to update?')) {
                    window.location.reload();
                  }
                }
              });
            }
          });
        })
        .catch((error) => {
          logger.error('Service Worker registration failed', error);
        });
    });
  }
}

export function unregisterServiceWorker() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready
      .then((registration) => {
        registration.unregister();
        logger.info('Service Worker unregistered');
      })
      .catch((error) => {
        logger.error('Service Worker unregistration failed', error);
      });
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/templates.ts
=================================================================================
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export interface Template {
  id: string;
  name: string;
  description: string;
  category: "business" | "education" | "marketing" | "creative" | "minimal";
  thumbnail: string;
  spec: Partial<SlideSpecV1>;
}

export const TEMPLATES: Template[] = [
  {
    id: "business-professional",
    name: "Business Professional",
    description: "Clean and professional design for corporate presentations",
    category: "business",
    thumbnail: "💼",
    spec: {
      meta: {
        version: "1.0",
        locale: "en-US",
        theme: "Business Professional",
        aspectRatio: "16:9",
      },
      styleTokens: {
        palette: {
          primary: "#1E40AF",
          accent: "#10B981",
          neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
        },
        typography: {
          fonts: { sans: "Inter, Arial, sans-serif" },
          sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 32 },
          weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
          lineHeights: { compact: 1.2, standard: 1.5 },
        },
        spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32] },
        radii: { sm: 2, md: 6, lg: 12 },
        shadows: {
          sm: "0 1px 2px rgba(0,0,0,.06)",
          md: "0 4px 8px rgba(0,0,0,.12)",
          lg: "0 12px 24px rgba(0,0,0,.18)",
        },
        contrast: { minTextContrast: 4.5, minUiContrast: 3 },
      },
    },
  },
  {
    id: "education-bright",
    name: "Education Bright",
    description: "Colorful and engaging design for educational content",
    category: "education",
    thumbnail: "🎓",
    spec: {
      meta: {
        version: "1.0",
        locale: "en-US",
        theme: "Education Bright",
        aspectRatio: "16:9",
      },
      styleTokens: {
        palette: {
          primary: "#059669",
          accent: "#F59E0B",
          neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
        },
        typography: {
          fonts: { sans: "Inter, Arial, sans-serif" },
          sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 32 },
          weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
          lineHeights: { compact: 1.2, standard: 1.5 },
        },
        spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32] },
        radii: { sm: 4, md: 8, lg: 16 },
        shadows: {
          sm: "0 1px 2px rgba(0,0,0,.06)",
          md: "0 4px 8px rgba(0,0,0,.12)",
          lg: "0 12px 24px rgba(0,0,0,.18)",
        },
        contrast: { minTextContrast: 4.5, minUiContrast: 3 },
      },
    },
  },
  {
    id: "marketing-vibrant",
    name: "Marketing Vibrant",
    description: "Bold and eye-catching design for marketing presentations",
    category: "marketing",
    thumbnail: "📊",
    spec: {
      meta: {
        version: "1.0",
        locale: "en-US",
        theme: "Marketing Vibrant",
        aspectRatio: "16:9",
      },
      styleTokens: {
        palette: {
          primary: "#EC4899",
          accent: "#F59E0B",
          neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
        },
        typography: {
          fonts: { sans: "Inter, Arial, sans-serif" },
          sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 36 },
          weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
          lineHeights: { compact: 1.2, standard: 1.5 },
        },
        spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32] },
        radii: { sm: 4, md: 8, lg: 16 },
        shadows: {
          sm: "0 1px 2px rgba(0,0,0,.06)",
          md: "0 4px 8px rgba(0,0,0,.12)",
          lg: "0 12px 24px rgba(0,0,0,.18)",
        },
        contrast: { minTextContrast: 4.5, minUiContrast: 3 },
      },
    },
  },
  {
    id: "creative-modern",
    name: "Creative Modern",
    description: "Contemporary design with bold typography and colors",
    category: "creative",
    thumbnail: "🎨",
    spec: {
      meta: {
        version: "1.0",
        locale: "en-US",
        theme: "Creative Modern",
        aspectRatio: "16:9",
      },
      styleTokens: {
        palette: {
          primary: "#8B5CF6",
          accent: "#06B6D4",
          neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
        },
        typography: {
          fonts: { sans: "Inter, Arial, sans-serif" },
          sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 28, step_3: 40 },
          weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
          lineHeights: { compact: 1.1, standard: 1.4 },
        },
        spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32] },
        radii: { sm: 8, md: 12, lg: 20 },
        shadows: {
          sm: "0 1px 2px rgba(0,0,0,.06)",
          md: "0 4px 8px rgba(0,0,0,.12)",
          lg: "0 12px 24px rgba(0,0,0,.18)",
        },
        contrast: { minTextContrast: 4.5, minUiContrast: 3 },
      },
    },
  },
  {
    id: "minimal-clean",
    name: "Minimal Clean",
    description: "Simple and elegant design with lots of white space",
    category: "minimal",
    thumbnail: "⚪",
    spec: {
      meta: {
        version: "1.0",
        locale: "en-US",
        theme: "Minimal Clean",
        aspectRatio: "16:9",
      },
      styleTokens: {
        palette: {
          primary: "#0F172A",
          accent: "#6366F1",
          neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
        },
        typography: {
          fonts: { sans: "Inter, Arial, sans-serif" },
          sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 18, step_2: 22, step_3: 28 },
          weights: { regular: 300, medium: 400, semibold: 500, bold: 600 },
          lineHeights: { compact: 1.3, standard: 1.6 },
        },
        spacing: { base: 4, steps: [0, 8, 16, 24, 32, 48, 64] },
        radii: { sm: 0, md: 2, lg: 4 },
        shadows: {
          sm: "0 1px 2px rgba(0,0,0,.03)",
          md: "0 2px 4px rgba(0,0,0,.06)",
          lg: "0 4px 8px rgba(0,0,0,.09)",
        },
        contrast: { minTextContrast: 4.5, minUiContrast: 3 },
      },
    },
  },
];

export function getTemplateById(id: string): Template | undefined {
  return TEMPLATES.find((t) => t.id === id);
}

export function getTemplatesByCategory(category: Template["category"]): Template[] {
  return TEMPLATES.filter((t) => t.category === category);
}

export function applyTemplate(template: Template, content: SlideSpecV1["content"]): SlideSpecV1 {
  return {
    ...template.spec,
    content,
    meta: template.spec.meta!,
    layout: template.spec.layout || {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 24, r: 24, b: 24, l: 24 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 6, colSpan: 12 },
      ],
      anchors: [{ refId: "title", region: "header", order: 0 }],
    },
    styleTokens: template.spec.styleTokens!,
  } as SlideSpecV1;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/typographyPairs.ts
=================================================================================
/**
 * Professional Typography Pairings
 * 12 carefully curated font pairings with specifications
 */

export interface TypographyPair {
  name: string;
  strategy: string;
  primary: string; // heading font
  secondary: string; // body font
  sizes: {
    title: number;
    subtitle: number;
    body: number;
    caption: number;
  };
  weights: {
    title: number;
    subtitle: number;
    body: number;
    caption: number;
  };
  lineHeights: {
    title: number;
    subtitle: number;
    body: number;
    caption: number;
  };
  use: string;
}

export const TYPOGRAPHY_PAIRS: Record<string, TypographyPair> = {
  classic: {
    name: "Classic Elegance",
    strategy: "classic",
    primary: "Georgia, serif",
    secondary: "Inter, sans-serif",
    sizes: { title: 40, subtitle: 28, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.2, subtitle: 1.4, body: 1.6, caption: 1.5 },
    use: "Traditional, elegant, professional"
  },
  modern: {
    name: "Modern Minimalist",
    strategy: "modern",
    primary: "Poppins, sans-serif",
    secondary: "Inter, sans-serif",
    sizes: { title: 36, subtitle: 24, body: 16, caption: 14 },
    weights: { title: 600, subtitle: 500, body: 400, caption: 400 },
    lineHeights: { title: 1.4, subtitle: 1.5, body: 1.5, caption: 1.4 },
    use: "Modern, clean, contemporary"
  },
  bold: {
    name: "Bold & Impactful",
    strategy: "bold",
    primary: "Playfair Display, serif",
    secondary: "Montserrat, sans-serif",
    sizes: { title: 44, subtitle: 32, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.3, subtitle: 1.4, body: 1.5, caption: 1.4 },
    use: "Bold, impactful, creative"
  },
  minimal: {
    name: "Minimal & Refined",
    strategy: "minimal",
    primary: "Inter, sans-serif",
    secondary: "Inter, sans-serif",
    sizes: { title: 40, subtitle: 28, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.4, subtitle: 1.5, body: 1.5, caption: 1.4 },
    use: "Minimal, refined, focused"
  },
  elegant: {
    name: "Elegant & Sophisticated",
    strategy: "elegant",
    primary: "Cormorant, serif",
    secondary: "Lato, sans-serif",
    sizes: { title: 48, subtitle: 32, body: 16, caption: 14 },
    weights: { title: 600, subtitle: 500, body: 400, caption: 400 },
    lineHeights: { title: 1.5, subtitle: 1.6, body: 1.6, caption: 1.5 },
    use: "Elegant, sophisticated, luxury"
  },
  tech: {
    name: "Tech & Modern",
    strategy: "tech",
    primary: "Sora, sans-serif",
    secondary: "Sora, sans-serif",
    sizes: { title: 40, subtitle: 28, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.4, subtitle: 1.5, body: 1.5, caption: 1.4 },
    use: "Technology, modern, innovative"
  },
  friendly: {
    name: "Friendly & Approachable",
    strategy: "friendly",
    primary: "Quicksand, sans-serif",
    secondary: "Open Sans, sans-serif",
    sizes: { title: 36, subtitle: 24, body: 16, caption: 14 },
    weights: { title: 600, subtitle: 500, body: 400, caption: 400 },
    lineHeights: { title: 1.5, subtitle: 1.6, body: 1.6, caption: 1.5 },
    use: "Friendly, approachable, warm"
  },
  corporate: {
    name: "Professional & Corporate",
    strategy: "corporate",
    primary: "Roboto, sans-serif",
    secondary: "Roboto, sans-serif",
    sizes: { title: 40, subtitle: 28, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.4, subtitle: 1.5, body: 1.5, caption: 1.4 },
    use: "Professional, corporate, business"
  },
  creative: {
    name: "Creative & Artistic",
    strategy: "creative",
    primary: "Abril Fatface, serif",
    secondary: "Raleway, sans-serif",
    sizes: { title: 48, subtitle: 32, body: 16, caption: 14 },
    weights: { title: 400, subtitle: 400, body: 400, caption: 400 },
    lineHeights: { title: 1.5, subtitle: 1.6, body: 1.6, caption: 1.5 },
    use: "Creative, artistic, design-focused"
  },
  educational: {
    name: "Educational & Clear",
    strategy: "educational",
    primary: "Nunito, sans-serif",
    secondary: "Nunito, sans-serif",
    sizes: { title: 40, subtitle: 28, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.5, subtitle: 1.6, body: 1.6, caption: 1.5 },
    use: "Educational, clear, accessible"
  },
  premium: {
    name: "Luxury & Premium",
    strategy: "premium",
    primary: "Bodoni Moda, serif",
    secondary: "Lora, serif",
    sizes: { title: 48, subtitle: 32, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.6, subtitle: 1.7, body: 1.7, caption: 1.6 },
    use: "Luxury, premium, high-end"
  },
  energetic: {
    name: "Bold & Energetic",
    strategy: "energetic",
    primary: "Bebas Neue, sans-serif",
    secondary: "Lato, sans-serif",
    sizes: { title: 44, subtitle: 32, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.3, subtitle: 1.5, body: 1.5, caption: 1.4 },
    use: "Bold, energetic, dynamic"
  }
};

export function getTypographyPair(strategy: string): TypographyPair | undefined {
  return TYPOGRAPHY_PAIRS[strategy];
}

export function getAllTypographyPairs(): TypographyPair[] {
  return Object.values(TYPOGRAPHY_PAIRS);
}

export function getTypographyPairNames(): string[] {
  return Object.keys(TYPOGRAPHY_PAIRS);
}

/**
 * Get typography pair by use case
 */
export function getTypographyByUseCase(useCase: string): TypographyPair | undefined {
  const lower = useCase.toLowerCase();
  
  if (lower.includes("business") || lower.includes("corporate")) {
    return TYPOGRAPHY_PAIRS.corporate;
  }
  if (lower.includes("tech") || lower.includes("modern")) {
    return TYPOGRAPHY_PAIRS.tech;
  }
  if (lower.includes("creative") || lower.includes("artistic")) {
    return TYPOGRAPHY_PAIRS.creative;
  }
  if (lower.includes("education") || lower.includes("learning")) {
    return TYPOGRAPHY_PAIRS.educational;
  }
  if (lower.includes("luxury") || lower.includes("premium")) {
    return TYPOGRAPHY_PAIRS.premium;
  }
  if (lower.includes("minimal") || lower.includes("clean")) {
    return TYPOGRAPHY_PAIRS.minimal;
  }
  if (lower.includes("elegant") || lower.includes("sophisticated")) {
    return TYPOGRAPHY_PAIRS.elegant;
  }
  if (lower.includes("friendly") || lower.includes("approachable")) {
    return TYPOGRAPHY_PAIRS.friendly;
  }
  if (lower.includes("bold") || lower.includes("energetic")) {
    return TYPOGRAPHY_PAIRS.energetic;
  }
  
  return TYPOGRAPHY_PAIRS.modern; // default
}

/**
 * Validate typography pair
 */
export function validateTypographyPair(pair: TypographyPair): boolean {
  return !!(
    pair.primary &&
    pair.secondary &&
    pair.sizes.title > pair.sizes.subtitle &&
    pair.sizes.subtitle > pair.sizes.body &&
    pair.sizes.body > pair.sizes.caption &&
    pair.lineHeights.title > 0 &&
    pair.lineHeights.body >= 1.5
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/validation.ts
=================================================================================
import { z } from "zod";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export const SlideSpecZ = z.object({
  meta: z.object({
    version: z.literal("1.0"),
    locale: z.string().default("en-US"),
    theme: z.string(),
    aspectRatio: z.enum(["16:9","4:3"]).default("16:9")
  }),
  content: z.object({
    title: z.object({ id: z.string(), text: z.string().min(1) }),
    subtitle: z.object({ id: z.string(), text: z.string().min(1) }).optional(),
    bullets: z.array(z.object({
      id: z.string(),
      items: z.array(z.object({ text: z.string().min(1), level: z.number().int().min(1).max(3) })).min(1).max(8)
    })).max(3).optional(),
    callouts: z.array(z.object({
      id: z.string(), title: z.string().optional(), text: z.string(), variant: z.enum(["note","success","warning","danger"])
    })).max(2).optional(),
    dataViz: z.object({
      id: z.string(),
      kind: z.enum(["bar","line","pie"]),
      title: z.string().optional(),
      labels: z.array(z.string()).min(2).max(10),
      series: z.array(z.object({ name: z.string(), values: z.array(z.number()) })).min(1).max(3),
      valueFormat: z.enum(["number","percent","currency","auto"]).default("auto")
    }).refine(d => d.series.every(s => s.values.length === d.labels.length), "series length mismatch")
      .optional(),
    imagePlaceholders: z.array(z.object({
      id: z.string(), role: z.enum(["hero","logo","illustration","icon"]), alt: z.string().min(1)
    })).max(2).optional()
  }),
  layout: z.object({
    grid: z.object({
      rows: z.number().int().min(3).max(12),
      cols: z.number().int().min(3).max(12),
      gutter: z.number().min(0),
      margin: z.object({ t: z.number(), r: z.number(), b: z.number(), l: z.number() })
    }),
    regions: z.array(z.object({
      name: z.enum(["header","body","footer","aside"]),
      rowStart: z.number().int().positive(), colStart: z.number().int().positive(),
      rowSpan: z.number().int().positive(),  colSpan: z.number().int().positive()
    })).min(1).max(4),
    anchors: z.array(z.object({
      refId: z.string(), region: z.enum(["header","body","footer","aside"]), order: z.number().int().min(0),
      span: z.object({ rows: z.number().int().positive(), cols: z.number().int().positive() }).optional()
    })).min(1).max(8)
  }),
  styleTokens: z.object({
    palette: z.object({ primary: z.string(), accent: z.string(), neutral: z.array(z.string()).min(5).max(9) }),
    typography: z.object({
      fonts: z.object({ sans: z.string(), serif: z.string().optional(), mono: z.string().optional() }),
      sizes: z.object({ "step_-2": z.number(), "step_-1": z.number(), step_0: z.number(), step_1: z.number(), step_2: z.number(), step_3: z.number() }),
      weights: z.object({ regular: z.number(), medium: z.number(), semibold: z.number(), bold: z.number() }),
      lineHeights: z.object({ compact: z.number(), standard: z.number() })
    }),
    spacing: z.object({ base: z.number(), steps: z.array(z.number()).min(5).max(10) }),
    radii: z.object({ sm: z.number(), md: z.number(), lg: z.number() }),
    shadows: z.object({ sm: z.string(), md: z.string(), lg: z.string() }),
    contrast: z.object({ minTextContrast: z.number(), minUiContrast: z.number() })
  }),
  components: z.object({
    bulletList: z.object({ variant: z.enum(["compact","spacious"]).optional() }).optional(),
    callout: z.object({ variant: z.enum(["flat","elevated"]).optional() }).optional(),
    chart: z.object({ legend: z.enum(["none","right","bottom"]).optional(), gridlines: z.boolean().optional() }).optional(),
    image: z.object({ fit: z.enum(["cover","contain"]).optional() }).optional(),
    title: z.object({ align: z.enum(["left","center","right"]).optional() }).optional()
  }).optional()
});
export type SlideSpec = z.infer<typeof SlideSpecZ>;

export function normalizeOrFallback(raw: unknown): SlideSpecV1 {
  const res = SlideSpecZ.safeParse(raw);
  if (res.success) return res.data as SlideSpecV1;
  return {
    meta: { version: "1.0", locale: "en-US", theme: "Clean", aspectRatio: "16:9" },
    content: { title: { id: "title", text: "Untitled Slide" } },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 24, r: 24, b: 24, l: 24 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 6, colSpan: 12 }
      ],
      anchors: [{ refId: "title", region: "header", order: 0 }]
    },
    styleTokens: {
      palette: { primary: "#2563EB", accent: "#F59E0B", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#E2E8F0"] },
      typography: { fonts: { sans: "Inter, Arial, sans-serif" }, sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 32 }, weights: { regular: 400, medium: 500, semibold: 600, bold: 700 }, lineHeights: { compact: 1.2, standard: 1.5 } },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32] },
      radii: { sm: 2, md: 6, lg: 12 },
      shadows: { sm: "0 1px 2px rgba(0,0,0,.06)", md: "0 4px 8px rgba(0,0,0,.12)", lg: "0 12px 24px rgba(0,0,0,.18)" },
      contrast: { minTextContrast: 4.5, minUiContrast: 3 }
    }
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/main.tsx
=================================================================================
import React from "react";
import ReactDOM from "react-dom/client";
import "@/styles/tailwind.css";
import App from "./App";
import { initAnalytics } from "./lib/firebase";
import { ErrorBoundary } from "./components/ErrorBoundary";
import { validateEnv } from "./lib/env";
import { logger } from "./lib/logger";
import { registerServiceWorker } from "./lib/registerSW";

// Validate environment variables at startup
try {
  validateEnv();
  logger.info("Application starting...");
} catch (error) {
  logger.error("Failed to validate environment", error);
  throw error;
}

initAnalytics();
registerServiceWorker();

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </React.StrictMode>
);


=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/test/setup.ts
=================================================================================
import { afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import '@testing-library/jest-dom';

// Cleanup after each test
afterEach(() => {
  cleanup();
});

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: (query: string) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: () => {}, // deprecated
    removeListener: () => {}, // deprecated
    addEventListener: () => {},
    removeEventListener: () => {},
    dispatchEvent: () => {},
  }),
});

// Mock IntersectionObserver
(globalThis as any).IntersectionObserver = class IntersectionObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  takeRecords() {
    return [];
  }
  unobserve() {}
} as any;

// Mock ResizeObserver
(globalThis as any).ResizeObserver = class ResizeObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
} as any;



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/types/Presentation.ts
=================================================================================
import type { SlideSpecV1 } from "./SlideSpecV1";

export interface Slide {
  id: string;
  spec: SlideSpecV1;
  createdAt: number;
  updatedAt: number;
  prompt?: string; // Original prompt used to generate this slide
}

export interface Presentation {
  id: string;
  title: string;
  slides: Slide[];
  createdAt: number;
  updatedAt: number;
  aspectRatio: "16:9" | "4:3";
}

export function createSlide(spec: SlideSpecV1, prompt?: string): Slide {
  const now = Date.now();
  return {
    id: `slide_${now}_${Math.random().toString(36).substr(2, 9)}`,
    spec,
    createdAt: now,
    updatedAt: now,
    prompt,
  };
}

export function createPresentation(title: string = "Untitled Presentation", aspectRatio: "16:9" | "4:3" = "16:9"): Presentation {
  const now = Date.now();
  return {
    id: `pres_${now}_${Math.random().toString(36).substr(2, 9)}`,
    title,
    slides: [],
    createdAt: now,
    updatedAt: now,
    aspectRatio,
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/types/SlideSpecV1.ts
=================================================================================
export type AspectRatio = "16:9" | "4:3";
export type RegionName = "header" | "body" | "footer" | "aside";
export type ChartKind = "bar" | "line" | "pie";

export interface SlideSpecV1 {
  meta: {
    version: "1.0";
    locale: string;
    theme: string;
    aspectRatio: AspectRatio;
  };
  content: {
    title: { id: string; text: string };
    subtitle?: { id: string; text: string };
    bullets?: { id: string; items: { text: string; level: 1 | 2 | 3 }[] }[];
    callouts?: { id: string; title?: string; text: string; variant: "note"|"success"|"warning"|"danger" }[];
    dataViz?: {
      id: string; kind: ChartKind; title?: string; labels: string[];
      series: { name: string; values: number[] }[]; valueFormat?: "number"|"percent"|"currency"|"auto";
    };
    imagePlaceholders?: { id: string; role: "hero" | "logo" | "illustration" | "icon"; alt: string }[];
  };
  layout: {
    grid: { rows: number; cols: number; gutter: number; margin: { t: number; r: number; b: number; l: number } };
    regions: { name: RegionName; rowStart: number; colStart: number; rowSpan: number; colSpan: number }[];
    anchors: { refId: string; region: RegionName; order: number; span?: { rows: number; cols: number } }[];
  };
  styleTokens: {
    palette: { primary: string; accent: string; neutral: string[] };
    typography: {
      fonts: { sans: string; serif?: string; mono?: string };
      sizes: { "step_-2": number; "step_-1": number; step_0: number; step_1: number; step_2: number; step_3: number };
      weights: { regular: number; medium: number; semibold: number; bold: number };
      lineHeights: { compact: number; standard: number };
    };
    spacing: { base: number; steps: number[] };
    radii: { sm: number; md: number; lg: number };
    shadows: { sm: string; md: string; lg: string };
    contrast: { minTextContrast: number; minUiContrast: number };
  };
  components?: {
    bulletList?: { variant?: "compact" | "spacious" };
    callout?: { variant?: "flat" | "elevated" };
    chart?: { legend?: "none" | "right" | "bottom"; gridlines?: boolean };
    image?: { fit?: "cover" | "contain" };
    title?: { align?: "left" | "center" | "right" };
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/types/SlideSpecV2.ts
=================================================================================
import type { SlideSpecV1 } from "./SlideSpecV1";

export type DesignPattern = "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused";
export type WhitespaceStrategy = "generous" | "balanced" | "compact";
export type TypographyStrategy = "classic" | "modern" | "bold" | "minimal" | "elegant";
export type ColorDistribution = "monochromatic" | "complementary" | "analogous" | "triadic";
export type ContrastLevel = "high" | "medium" | "low";
export type AnimationType = "fade" | "slide" | "zoom" | "wipe" | "pulse" | "glow" | "scale";

export interface VisualHierarchy {
  primaryFocus: string; // element ID with highest emphasis
  secondaryFocus: string[]; // supporting element IDs
  emphasisLevels: Record<string, 1 | 2 | 3 | 4 | 5>; // 1=minimal, 5=maximum
}

export interface WhitespaceConfig {
  strategy: WhitespaceStrategy;
  breathingRoom: number; // 20-50 percentage
}

export interface TypographyConfig {
  strategy: TypographyStrategy;
  fontPairing: {
    primary: string; // heading font
    secondary: string; // body font
  };
  hierarchy: Record<string, {
    size: number;
    weight: 400 | 500 | 600 | 700;
    lineHeight: number;
  }>;
}

export interface ColorStrategyConfig {
  distribution: ColorDistribution;
  emphasis: string; // accent color usage
  contrast: ContrastLevel;
}

export interface AnimationConfig {
  type: AnimationType;
  duration: number; // milliseconds
  delay?: number;
}

export interface DesignConfig {
  pattern: DesignPattern;
  
  visualHierarchy: VisualHierarchy;
  
  whitespace: WhitespaceConfig;
  
  typography: TypographyConfig;
  
  colorStrategy: ColorStrategyConfig;
  
  animations?: {
    entrance?: AnimationConfig[];
    emphasis?: AnimationConfig[];
  };
}

export interface SlideSpecV2 extends SlideSpecV1 {
  design: DesignConfig;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/utils/slideDebugger.ts
=================================================================================
/**
 * Slide Debugger - Diagnostic tool for slide rendering issues
 * Logs detailed information about spec structure and rendering
 */

import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export interface DiagnosticReport {
  specVersion: string;
  gridConfig: {
    rows: number;
    cols: number;
    gutter: number;
    margin: { t: number; r: number; b: number; l: number };
  };
  regions: Array<{
    name: string;
    position: { rowStart: number; colStart: number };
    span: { rowSpan: number; colSpan: number };
  }>;
  anchors: Array<{
    refId: string;
    region: string;
    order: number;
  }>;
  content: {
    title?: { id: string; text: string; length: number };
    subtitle?: { id: string; text: string; length: number };
    bullets?: Array<{ id: string; itemCount: number }>;
    callouts?: Array<{ id: string; text: string }>;
  };
  styleTokens: {
    palette: { primary: string; accent: string; neutralCount: number };
    typography: {
      fonts: { sans: string };
      sizes: Record<string, number>;
      weights: Record<string, number>;
    };
  };
  issues: string[];
}

export function generateDiagnosticReport(spec: SlideSpecV1): DiagnosticReport {
  const issues: string[] = [];

  // Validate grid config
  if (!spec.layout.grid) {
    issues.push("❌ Missing layout.grid configuration");
  }

  // Validate regions
  if (!spec.layout.regions || spec.layout.regions.length === 0) {
    issues.push("❌ No regions defined");
  }

  // Validate anchors
  if (!spec.layout.anchors || spec.layout.anchors.length === 0) {
    issues.push("❌ No anchors defined");
  }

  // Check for orphaned anchors (anchors without matching regions)
  const regionNames = new Set(spec.layout.regions?.map(r => r.name) || []);
  spec.layout.anchors?.forEach(anchor => {
    if (!regionNames.has(anchor.region)) {
      issues.push(`⚠️  Anchor "${anchor.refId}" references non-existent region "${anchor.region}"`);
    }
  });

  // Check for content without anchors
  const anchorRefIds = new Set(spec.layout.anchors?.map(a => a.refId) || []);
  if (spec.content.title && !anchorRefIds.has(spec.content.title.id)) {
    issues.push(`⚠️  Title has no anchor (id: ${spec.content.title.id})`);
  }
  if (spec.content.subtitle && !anchorRefIds.has(spec.content.subtitle.id)) {
    issues.push(`⚠️  Subtitle has no anchor (id: ${spec.content.subtitle.id})`);
  }

  // Check for long text that might overflow
  if (spec.content.title?.text.length > 100) {
    issues.push(`⚠️  Title text is very long (${spec.content.title.text.length} chars)`);
  }

  return {
    specVersion: spec.meta.version,
    gridConfig: spec.layout.grid,
    regions: spec.layout.regions.map(r => ({
      name: r.name,
      position: { rowStart: r.rowStart, colStart: r.colStart },
      span: { rowSpan: r.rowSpan, colSpan: r.colSpan },
    })),
    anchors: spec.layout.anchors.map(a => ({
      refId: a.refId,
      region: a.region,
      order: a.order,
    })),
    content: {
      title: spec.content.title ? {
        id: spec.content.title.id,
        text: spec.content.title.text.substring(0, 50),
        length: spec.content.title.text.length,
      } : undefined,
      subtitle: spec.content.subtitle ? {
        id: spec.content.subtitle.id,
        text: spec.content.subtitle.text.substring(0, 50),
        length: spec.content.subtitle.text.length,
      } : undefined,
      bullets: spec.content.bullets?.map(b => ({
        id: b.id,
        itemCount: b.items.length,
      })),
      callouts: spec.content.callouts?.map(c => ({
        id: c.id,
        text: c.text.substring(0, 30),
      })),
    },
    styleTokens: {
      palette: {
        primary: spec.styleTokens.palette.primary,
        accent: spec.styleTokens.palette.accent,
        neutralCount: spec.styleTokens.palette.neutral.length,
      },
      typography: {
        fonts: { sans: spec.styleTokens.typography.fonts.sans },
        sizes: spec.styleTokens.typography.sizes,
        weights: spec.styleTokens.typography.weights,
      },
    },
    issues,
  };
}

export function logDiagnostics(spec: SlideSpecV1): void {
  const report = generateDiagnosticReport(spec);
  
  console.group("🔍 Slide Diagnostics Report");
  console.log("Spec Version:", report.specVersion);
  console.log("Grid Config:", report.gridConfig);
  console.log("Regions:", report.regions);
  console.log("Anchors:", report.anchors);
  console.log("Content:", report.content);
  console.log("Style Tokens:", report.styleTokens);
  
  if (report.issues.length > 0) {
    console.group("⚠️  Issues Found");
    report.issues.forEach(issue => console.log(issue));
    console.groupEnd();
  } else {
    console.log("✅ No issues detected");
  }
  
  console.groupEnd();
}

export function validateLayoutCalculations(spec: SlideSpecV1): void {
  const { rows, cols, gutter, margin } = spec.layout.grid;
  const SLIDE_WIDTH = 10; // inches
  const SLIDE_HEIGHT = 7.5; // inches

  const pxToIn = (px: number) => (px * 0.75) / 72;
  const marginTop = pxToIn(margin.t);
  const marginRight = pxToIn(margin.r);
  const marginBottom = pxToIn(margin.b);
  const marginLeft = pxToIn(margin.l);
  const gutterIn = pxToIn(gutter);

  const gridWidth = SLIDE_WIDTH - marginLeft - marginRight;
  const gridHeight = SLIDE_HEIGHT - marginTop - marginBottom;
  const cellWidth = (gridWidth - (cols - 1) * gutterIn) / cols;
  const cellHeight = (gridHeight - (rows - 1) * gutterIn) / rows;

  console.group("📐 Layout Calculations");
  console.log("Slide dimensions: 10in × 7.5in");
  console.log("Margins (in):", { top: marginTop.toFixed(2), right: marginRight.toFixed(2), bottom: marginBottom.toFixed(2), left: marginLeft.toFixed(2) });
  console.log("Grid dimensions (in):", { width: gridWidth.toFixed(2), height: gridHeight.toFixed(2) });
  console.log("Cell dimensions (in):", { width: cellWidth.toFixed(2), height: cellHeight.toFixed(2) });
  console.log("Gutter (in):", gutterIn.toFixed(2));
  console.groupEnd();
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/package.json
=================================================================================
{
  "name": "functions",
  "scripts": {
    "build": "tsc",
    "serve": "npm run build && firebase emulators:start --only functions",
    "deploy": "npm run build && firebase deploy --only functions",
    "lint": "eslint --ext .ts src",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  },
  "engines": {
    "node": "20"
  },
  "main": "lib/index.js",
  "dependencies": {
    "@types/sharp": "^0.31.1",
    "cors": "^2.8.5",
    "firebase-admin": "^12.6.0",
    "firebase-functions": "^6.0.1",
    "pptxgenjs": "^4.0.1",
    "sharp": "^0.34.4",
    "undici": "^7.16.0",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^5.12.0",
    "@typescript-eslint/parser": "^5.12.0",
    "eslint": "^8.9.0",
    "eslint-config-google": "^0.14.0",
    "eslint-plugin-import": "^2.25.4",
    "firebase-functions-test": "^3.1.0",
    "typescript": "^5.7.3",
    "vitest": "^1.0.0"
  },
  "private": true
}


=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/tsconfig.json
=================================================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "ES2022",
    "lib": ["ES2022", "DOM"],
    "outDir": "lib",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "compileOnSave": true,
  "exclude": ["node_modules", "lib"]
}


=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/package.json
=================================================================================
{
  "name": "web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  },
  "dependencies": {
    "firebase": "^12.4.0",
    "html2canvas": "^1.4.1",
    "jspdf": "^3.0.3",
    "lucide-react": "^0.546.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "recharts": "^3.3.0",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@tailwindcss/postcss": "^4.1.16",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^24.6.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^5.0.4",
    "@vitest/ui": "^4.0.1",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "jsdom": "^27.0.1",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.16",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7",
    "vitest": "^4.0.1"
  }
}


=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/tsconfig.json
=================================================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/vite.config.ts
=================================================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
})


