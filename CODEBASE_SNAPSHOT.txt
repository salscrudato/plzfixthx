=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/aiHelpers.ts
=================================================================================
import * as logger from "firebase-functions/logger";
import { fetch as undiciFetch } from "undici";
import { z } from "zod";
import { ENHANCED_SYSTEM_PROMPT } from "./prompts";

/** Retry with exponential backoff */
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries = 3,
  baseDelay = 1000
): Promise<T> {
  let lastError: Error | undefined;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      
      if (attempt < maxRetries - 1) {
        const delay = baseDelay * Math.pow(2, attempt);
        logger.warn(`Attempt ${attempt + 1} failed, retrying in ${delay}ms...`, { error: lastError.message });
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw lastError || new Error("Max retries exceeded");
}

/** Call OpenAI-compatible API with retry logic */
export async function callAIWithRetry(
  prompt: string,
  apiKey: string,
  baseUrl: string,
  model: string,
  schema: z.ZodType
): Promise<unknown> {
  return retryWithBackoff(async () => {
    const response = await undiciFetch(`${baseUrl}/chat/completions`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        temperature: 0.3,
        response_format: { type: "json_object" },
        messages: [
          { role: "system", content: ENHANCED_SYSTEM_PROMPT },
          { role: "user", content: `User prompt:\n<<<${prompt}>>>` }
        ]
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`AI API error ${response.status}: ${errorText}`);
    }

    const data: any = await response.json();
    const content = data?.choices?.[0]?.message?.content;
    
    if (!content) {
      throw new Error("No content in AI response");
    }

    let parsed: unknown;
    try {
      parsed = JSON.parse(content);
    } catch (e) {
      throw new Error(`Failed to parse AI response as JSON: ${e}`);
    }

    const validationResult = schema.safeParse(parsed);
    if (!validationResult.success) {
      const errorDetails = validationResult.error.issues.map((issue: any) =>
        `${issue.path.join('.')}: ${issue.message}`
      ).join(', ');

      logger.error("Schema validation failed", {
        errors: validationResult.error.issues,
        errorDetails,
        aiResponse: JSON.stringify(parsed, null, 2)
      });
      throw new Error(`Schema validation failed: ${errorDetails}`);
    }

    logger.info("Schema validation successful");

    return validationResult.data;
  }, 3, 1000);
}

/** Validate and sanitize user prompt */
export function sanitizePrompt(prompt: string, maxLength = 800): string {
  if (!prompt || typeof prompt !== 'string') {
    throw new Error("Prompt must be a non-empty string");
  }

  const trimmed = prompt.trim();
  if (trimmed.length === 0) {
    throw new Error("Prompt cannot be empty");
  }

  if (trimmed.length > maxLength) {
    return trimmed.slice(0, maxLength);
  }

  return trimmed;
}

/** Check for inappropriate content (basic filter) */
export function moderateContent(prompt: string): { safe: boolean; reason?: string } {
  const lowerPrompt = prompt.toLowerCase();
  
  // Basic inappropriate content detection
  const inappropriatePatterns = [
    /\b(hack|exploit|vulnerability|inject|xss|sql\s*injection)\b/i,
    /\b(porn|xxx|nsfw|explicit)\b/i,
    /\b(violence|weapon|bomb|terror)\b/i
  ];

  for (const pattern of inappropriatePatterns) {
    if (pattern.test(lowerPrompt)) {
      return {
        safe: false,
        reason: "Content may contain inappropriate or unsafe material"
      };
    }
  }

  return { safe: true };
}

/** Post-process and enhance AI-generated slide spec */
export function enhanceSlideSpec(spec: any): any {
  // Ensure all required fields are present
  if (!spec.meta) {
    spec.meta = {
      version: "1.0",
      locale: "en-US",
      theme: "Professional",
      aspectRatio: "16:9"
    };
  }

  // Ensure content has at least a title
  if (!spec.content?.title?.text) {
    if (!spec.content) spec.content = {};
    spec.content.title = {
      id: "title",
      text: "Untitled Slide"
    };
  }

  // Limit bullet points to 6 total
  if (spec.content?.bullets) {
    spec.content.bullets.forEach((bulletGroup: any) => {
      if (bulletGroup.items && bulletGroup.items.length > 6) {
        bulletGroup.items = bulletGroup.items.slice(0, 6);
      }
    });
  }

  // Validate chart data if present
  if (spec.content?.dataViz) {
    const viz = spec.content.dataViz;
    if (viz.labels && viz.series) {
      const labelCount = viz.labels.length;
      // Ensure all series have matching value counts
      viz.series.forEach((s: any) => {
        if (s.values.length !== labelCount) {
          // Pad or trim to match
          if (s.values.length < labelCount) {
            s.values = [...s.values, ...Array(labelCount - s.values.length).fill(0)];
          } else {
            s.values = s.values.slice(0, labelCount);
          }
        }
      });
    }
  }

  // Ensure color palette is valid
  if (spec.styleTokens?.palette) {
    const palette = spec.styleTokens.palette;
    // Validate hex colors
    const hexPattern = /^#[0-9A-Fa-f]{6}$/;
    if (palette.primary && !hexPattern.test(palette.primary)) {
      palette.primary = "#6366F1"; // Default primary
    }
    if (palette.accent && !hexPattern.test(palette.accent)) {
      palette.accent = "#EC4899"; // Default accent
    }
  }

  // FIX LAYOUT ISSUES
  spec = fixLayoutIssues(spec);

  return spec;
}

/**
 * Fix common layout issues in generated specs
 */
function fixLayoutIssues(spec: any): any {
  logger.info("fixLayoutIssues called", {
    hasLayout: !!spec.layout,
    hasRegions: !!spec.layout?.regions,
    hasAnchors: !!spec.layout?.anchors,
    hasTitle: !!spec.content?.title?.text,
    hasSubtitle: !!spec.content?.subtitle?.text
  });

  if (!spec.layout?.regions || !spec.layout?.anchors) {
    logger.warn("No layout regions or anchors found");
    return spec;
  }

  const hasSubtitle = !!spec.content?.subtitle?.text;
  const hasTitle = !!spec.content?.title?.text;

  // Find header region
  const headerRegion = spec.layout.regions.find((r: any) => r.name === "header");

  logger.info("Header region check", {
    headerRegionExists: !!headerRegion,
    headerRowSpan: headerRegion?.rowSpan,
    hasTitle,
    hasSubtitle
  });

  if (headerRegion && hasTitle && hasSubtitle) {
    // If header has both title and subtitle but only 1 row, expand it to 2 rows
    if (headerRegion.rowSpan === 1) {
      logger.info("Expanding header region from 1 to 2 rows for title + subtitle");
      headerRegion.rowSpan = 2;

      // Adjust body region if it exists
      const bodyRegion = spec.layout.regions.find((r: any) => r.name === "body");
      if (bodyRegion && bodyRegion.rowStart === 2) {
        logger.info("Adjusting body region");
        bodyRegion.rowStart = 3;
        bodyRegion.rowSpan = Math.max(1, bodyRegion.rowSpan - 1);
      }

      // Adjust aside region if it exists
      const asideRegion = spec.layout.regions.find((r: any) => r.name === "aside");
      if (asideRegion && asideRegion.rowStart === 2) {
        logger.info("Adjusting aside region");
        asideRegion.rowStart = 3;
        asideRegion.rowSpan = Math.max(1, asideRegion.rowSpan - 1);
      }
    }
  }

  // Validate all anchors have corresponding regions
  const regionNames = new Set(spec.layout.regions.map((r: any) => r.name));
  spec.layout.anchors = spec.layout.anchors.filter((a: any) => {
    if (!regionNames.has(a.region)) {
      logger.warn(`Removing anchor ${a.refId} with non-existent region ${a.region}`);
      return false;
    }
    return true;
  });

  return spec;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/designValidator.ts
=================================================================================
/**
 * Design Validator
 * Validates design specifications against professional standards
 */

import type { SlideSpecV2 } from "./types/SlideSpecV2";

export interface ValidationResult {
  isValid: boolean;
  score: number;
  errors: ValidationError[];
  warnings: ValidationWarning[];
  recommendations: string[];
}

export interface ValidationError {
  field: string;
  message: string;
  severity: "critical" | "high" | "medium";
}

export interface ValidationWarning {
  field: string;
  message: string;
}

/**
 * Validate complete slide specification
 */
export function validateSlideSpec(spec: SlideSpecV2): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];
  const recommendations: string[] = [];

  // Validate structure
  validateStructure(spec, errors);

  // Validate colors
  validateColors(spec, errors, warnings);

  // Validate typography
  validateTypography(spec, errors, warnings);

  // Validate layout
  validateLayout(spec, errors, warnings);

  // Validate design pattern
  validateDesignPattern(spec, errors, warnings);

  // Validate accessibility
  validateAccessibility(spec, errors, warnings, recommendations);

  // Validate content
  validateContent(spec, errors, warnings);

  const score = calculateValidationScore(errors, warnings);

  return {
    isValid: errors.length === 0,
    score,
    errors,
    warnings,
    recommendations
  };
}

/**
 * Validate basic structure
 */
function validateStructure(spec: SlideSpecV2, errors: ValidationError[]): void {
  if (!spec.meta) {
    errors.push({
      field: "meta",
      message: "Missing meta information",
      severity: "critical"
    });
  }

  if (!spec.content) {
    errors.push({
      field: "content",
      message: "Missing content",
      severity: "critical"
    });
  }

  if (!spec.layout) {
    errors.push({
      field: "layout",
      message: "Missing layout configuration",
      severity: "critical"
    });
  }

  if (!spec.styleTokens) {
    errors.push({
      field: "styleTokens",
      message: "Missing style tokens",
      severity: "critical"
    });
  }

  if (!spec.design) {
    errors.push({
      field: "design",
      message: "Missing design configuration",
      severity: "high"
    });
  }
}

/**
 * Validate colors
 */
function validateColors(
  spec: SlideSpecV2,
  errors: ValidationError[],
  warnings: ValidationWarning[]
): void {
  const hexPattern = /^#[0-9A-Fa-f]{6}$/;
  const palette = spec.styleTokens.palette;

  if (!hexPattern.test(palette.primary)) {
    errors.push({
      field: "palette.primary",
      message: "Invalid primary color format (must be #RRGGBB)",
      severity: "high"
    });
  }

  if (!hexPattern.test(palette.accent)) {
    errors.push({
      field: "palette.accent",
      message: "Invalid accent color format (must be #RRGGBB)",
      severity: "high"
    });
  }

  if (!Array.isArray(palette.neutral) || palette.neutral.length < 5) {
    errors.push({
      field: "palette.neutral",
      message: "Neutral palette must have at least 5 colors",
      severity: "high"
    });
  }

  palette.neutral?.forEach((color: string, idx: number) => {
    if (!hexPattern.test(color)) {
      warnings.push({
        field: `palette.neutral[${idx}]`,
        message: `Invalid neutral color format at index ${idx}`
      });
    }
  });
}

/**
 * Validate typography
 */
function validateTypography(
  spec: SlideSpecV2,
  errors: ValidationError[],
  warnings: ValidationWarning[]
): void {
  const typography = spec.styleTokens.typography;

  if (!typography.fonts || !typography.fonts.sans) {
    errors.push({
      field: "typography.fonts",
      message: "Missing sans-serif font definition",
      severity: "high"
    });
  }

  if (!typography.sizes) {
    errors.push({
      field: "typography.sizes",
      message: "Missing typography sizes",
      severity: "high"
    });
  }

  if (!typography.weights) {
    errors.push({
      field: "typography.weights",
      message: "Missing typography weights",
      severity: "high"
    });
  }

  // Check size hierarchy
  const sizes = typography.sizes;
  if (sizes.step_3 && sizes.step_0 && sizes.step_3 <= sizes.step_0) {
    warnings.push({
      field: "typography.sizes",
      message: "Title size should be larger than body size"
    });
  }

  // Check line heights
  const lineHeights = typography.lineHeights;
  if (lineHeights.standard && (lineHeights.standard < 1.4 || lineHeights.standard > 2)) {
    warnings.push({
      field: "typography.lineHeights",
      message: "Standard line height should be between 1.4 and 2"
    });
  }
}

/**
 * Validate layout
 */
function validateLayout(
  spec: SlideSpecV2,
  errors: ValidationError[],
  warnings: ValidationWarning[]
): void {
  const layout = spec.layout;

  if (!layout.grid) {
    errors.push({
      field: "layout.grid",
      message: "Missing grid configuration",
      severity: "high"
    });
    return;
  }

  if (!layout.regions || layout.regions.length === 0) {
    errors.push({
      field: "layout.regions",
      message: "No layout regions defined",
      severity: "high"
    });
  }

  if (!layout.anchors || layout.anchors.length === 0) {
    warnings.push({
      field: "layout.anchors",
      message: "No content anchors defined"
    });
  }
}

/**
 * Validate design pattern
 */
function validateDesignPattern(
  spec: SlideSpecV2,
  errors: ValidationError[],
  warnings: ValidationWarning[]
): void {
  const validPatterns = ["hero", "split", "asymmetric", "grid", "minimal", "data-focused"];

  if (!spec.design.pattern || !validPatterns.includes(spec.design.pattern)) {
    errors.push({
      field: "design.pattern",
      message: `Invalid design pattern. Must be one of: ${validPatterns.join(", ")}`,
      severity: "high"
    });
  }

  if (!spec.design.visualHierarchy) {
    warnings.push({
      field: "design.visualHierarchy",
      message: "Visual hierarchy not defined"
    });
  }

  if (!spec.design.whitespace) {
    warnings.push({
      field: "design.whitespace",
      message: "Whitespace strategy not defined"
    });
  }
}

/**
 * Validate accessibility
 */
function validateAccessibility(
  spec: SlideSpecV2,
  errors: ValidationError[],
  warnings: ValidationWarning[],
  recommendations: string[]
): void {
  const sizes = spec.styleTokens.typography.sizes;

  if (sizes.step_0 < 14) {
    warnings.push({
      field: "typography.sizes.step_0",
      message: "Body font size is below recommended 14px minimum"
    });
  }

  if (sizes.step_0 < 12) {
    errors.push({
      field: "typography.sizes.step_0",
      message: "Body font size is below accessibility minimum of 12px",
      severity: "medium"
    });
  }

  const lineHeight = spec.styleTokens.typography.lineHeights.standard;
  if (lineHeight < 1.5) {
    recommendations.push("Increase line height to at least 1.5 for better readability");
  }

  recommendations.push("Ensure all text has sufficient contrast (WCAG AA: 4.5:1 minimum)");
  recommendations.push("Test with screen readers for semantic structure");
}

/**
 * Validate content
 */
function validateContent(
  spec: SlideSpecV2,
  errors: ValidationError[],
  warnings: ValidationWarning[]
): void {
  const content = spec.content;

  if (!content.title || !content.title.text) {
    warnings.push({
      field: "content.title",
      message: "No title text provided"
    });
  }

  if (content.title?.text && content.title.text.length > 100) {
    warnings.push({
      field: "content.title",
      message: "Title is very long (>100 characters)"
    });
  }

  if (content.bullets && content.bullets[0]) {
    const bulletCount = content.bullets[0].items.length;
    if (bulletCount > 6) {
      warnings.push({
        field: "content.bullets",
        message: `Too many bullet points (${bulletCount}). Recommended maximum is 6.`
      });
    }
  }
}

/**
 * Calculate validation score
 */
function calculateValidationScore(
  errors: ValidationError[],
  warnings: ValidationWarning[]
): number {
  let score = 100;

  // Deduct for errors
  const criticalErrors = errors.filter(e => e.severity === "critical").length;
  const highErrors = errors.filter(e => e.severity === "high").length;
  const mediumErrors = errors.filter(e => e.severity === "medium").length;

  score -= criticalErrors * 20;
  score -= highErrors * 10;
  score -= mediumErrors * 5;

  // Deduct for warnings
  score -= warnings.length * 2;

  return Math.max(0, score);
}

/**
 * Get validation summary
 */
export function getValidationSummary(result: ValidationResult): string {
  let summary = `Validation Score: ${result.score}/100\n`;
  summary += `Status: ${result.isValid ? "‚úì Valid" : "‚úó Invalid"}\n\n`;

  if (result.errors.length > 0) {
    summary += `Errors (${result.errors.length}):\n`;
    result.errors.forEach(error => {
      summary += `  [${error.severity.toUpperCase()}] ${error.field}: ${error.message}\n`;
    });
    summary += "\n";
  }

  if (result.warnings.length > 0) {
    summary += `Warnings (${result.warnings.length}):\n`;
    result.warnings.forEach(warning => {
      summary += `  ${warning.field}: ${warning.message}\n`;
    });
    summary += "\n";
  }

  if (result.recommendations.length > 0) {
    summary += `Recommendations:\n`;
    result.recommendations.forEach(rec => {
      summary += `  ‚Ä¢ ${rec}\n`;
    });
  }

  return summary;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/errorHandler.ts
=================================================================================
/**
 * Enhanced Error Handler
 * Provides comprehensive error handling, logging, and recovery strategies
 */

import { logger } from "firebase-functions/v2";

export class AppError extends Error {
  constructor(
    public code: string,
    public message: string,
    public statusCode: number = 500,
    public details?: Record<string, any>
  ) {
    super(message);
    this.name = "AppError";
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: Record<string, any>) {
    super("VALIDATION_ERROR", message, 400, details);
    this.name = "ValidationError";
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string, details?: Record<string, any>) {
    super("NOT_FOUND", `${resource} not found`, 404, details);
    this.name = "NotFoundError";
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string = "Unauthorized", details?: Record<string, any>) {
    super("UNAUTHORIZED", message, 401, details);
    this.name = "UnauthorizedError";
  }
}

export class RateLimitError extends AppError {
  constructor(message: string = "Rate limit exceeded", details?: Record<string, any>) {
    super("RATE_LIMIT", message, 429, details);
    this.name = "RateLimitError";
  }
}

export class TimeoutError extends AppError {
  constructor(operation: string, details?: Record<string, any>) {
    super("TIMEOUT", `${operation} timed out`, 504, details);
    this.name = "TimeoutError";
  }
}

/**
 * Error logger with context
 */
export function logError(
  error: Error | AppError,
  context: Record<string, any> = {}
): void {
  const errorInfo: Record<string, any> = {
    name: error.name,
    message: error.message,
    stack: error.stack,
    ...context
  };

  if (error instanceof AppError) {
    errorInfo.code = error.code;
    errorInfo.statusCode = error.statusCode;
    if (error.details) {
      errorInfo.details = error.details;
    }
  }

  logger.error("Error occurred", errorInfo);
}

/**
 * Safe error response for API
 */
export function getSafeErrorResponse(error: Error | AppError): {
  error: string;
  code?: string;
  statusCode: number;
} {
  if (error instanceof AppError) {
    return {
      error: error.message,
      code: error.code,
      statusCode: error.statusCode
    };
  }

  // Don't expose internal error details
  return {
    error: "An unexpected error occurred",
    statusCode: 500
  };
}

/**
 * Wrap async function with error handling
 */
export async function withErrorHandling<T>(
  fn: () => Promise<T>,
  context: Record<string, any> = {}
): Promise<T> {
  try {
    return await fn();
  } catch (error) {
    logError(error as Error, context);
    throw error;
  }
}

/**
 * Wrap sync function with error handling
 */
export function withErrorHandlingSync<T>(
  fn: () => T,
  context: Record<string, any> = {}
): T {
  try {
    return fn();
  } catch (error) {
    logError(error as Error, context);
    throw error;
  }
}

/**
 * Validate required fields
 */
export function validateRequired(
  obj: Record<string, any>,
  fields: string[]
): void {
  const missing = fields.filter(field => !obj[field]);
  if (missing.length > 0) {
    throw new ValidationError(`Missing required fields: ${missing.join(", ")}`, {
      missing
    });
  }
}

/**
 * Validate field types
 */
export function validateTypes(
  obj: Record<string, any>,
  schema: Record<string, string>
): void {
  const errors: Record<string, string> = {};

  for (const [field, expectedType] of Object.entries(schema)) {
    const value = obj[field];
    const actualType = typeof value;

    if (actualType !== expectedType) {
      errors[field] = `Expected ${expectedType}, got ${actualType}`;
    }
  }

  if (Object.keys(errors).length > 0) {
    throw new ValidationError("Type validation failed", errors);
  }
}

/**
 * Validate string length
 */
export function validateStringLength(
  value: string,
  minLength: number,
  maxLength: number,
  fieldName: string = "value"
): void {
  if (value.length < minLength || value.length > maxLength) {
    throw new ValidationError(
      `${fieldName} must be between ${minLength} and ${maxLength} characters`,
      { fieldName, minLength, maxLength, actualLength: value.length }
    );
  }
}

/**
 * Validate email format
 */
export function validateEmail(email: string): void {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    throw new ValidationError("Invalid email format", { email });
  }
}

/**
 * Validate URL format
 */
export function validateUrl(url: string): void {
  try {
    new URL(url);
  } catch {
    throw new ValidationError("Invalid URL format", { url });
  }
}

/**
 * Validate JSON
 */
export function validateJSON(jsonString: string): Record<string, any> {
  try {
    return JSON.parse(jsonString);
  } catch (error) {
    throw new ValidationError("Invalid JSON format", {
      error: (error as Error).message
    });
  }
}

/**
 * Create timeout promise
 */
export function createTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number,
  operationName: string = "Operation"
): Promise<T> {
  return Promise.race([
    promise,
    new Promise<T>((_, reject) =>
      setTimeout(
        () => reject(new TimeoutError(operationName)),
        timeoutMs
      )
    )
  ]);
}

/**
 * Retry with exponential backoff and error handling
 */
export async function retryWithErrorHandling<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  initialDelay: number = 100,
  context: Record<string, any> = {}
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      if (attempt < maxRetries - 1) {
        const delay = initialDelay * Math.pow(2, attempt);
        logger.warn(`Retry attempt ${attempt + 1}/${maxRetries}`, {
          ...context,
          delay,
          error: (error as Error).message
        });
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  logError(lastError || new Error("Max retries exceeded"), context);
  throw lastError || new Error("Max retries exceeded");
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/imageHelpers.ts
=================================================================================
/**
 * Image Helpers
 * Fetch, process, and embed images from various sources
 */

import { logger } from "firebase-functions/v2";

export interface ImageSource {
  type: "url" | "unsplash" | "placeholder";
  url?: string;
  query?: string;
  alt?: string;
}

export interface ProcessedImage {
  data: Buffer;
  mimeType: string;
  width: number;
  height: number;
}

/**
 * Fetch image from URL
 */
export async function fetchImageFromUrl(url: string): Promise<ProcessedImage | null> {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      logger.warn(`Failed to fetch image from ${url}: ${response.status}`);
      return null;
    }

    const contentType = response.headers.get("content-type") || "image/jpeg";
    const arrayBuffer = await response.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Basic validation
    if (buffer.length === 0) {
      logger.warn(`Empty image data from ${url}`);
      return null;
    }

    // Estimate dimensions (actual dimensions would require image processing library)
    // For now, use default dimensions
    return {
      data: buffer,
      mimeType: contentType,
      width: 1920,
      height: 1080
    };
  } catch (error) {
    logger.error(`Error fetching image from ${url}:`, error);
    return null;
  }
}

/**
 * Fetch image from Unsplash
 * Uses Unsplash API to get high-quality stock photos
 */
export async function fetchImageFromUnsplash(
  query: string,
  width: number = 1920,
  height: number = 1080
): Promise<ProcessedImage | null> {
  try {
    // Unsplash Source API (no API key required for basic usage)
    // For production, use official Unsplash API with proper attribution
    const unsplashUrl = `https://source.unsplash.com/${width}x${height}/?${encodeURIComponent(query)}`;
    
    logger.info(`Fetching Unsplash image for query: ${query}`);
    return await fetchImageFromUrl(unsplashUrl);
  } catch (error) {
    logger.error(`Error fetching Unsplash image for query "${query}":`, error);
    return null;
  }
}

/**
 * Generate placeholder image data URL
 * Creates a simple colored rectangle as placeholder
 */
export function generatePlaceholderImage(
  width: number = 1920,
  height: number = 1080,
  color: string = "#E5E7EB",
  text: string = "Image Placeholder"
): string {
  // Generate SVG placeholder
  const svg = `
    <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="${color}"/>
      <text x="50%" y="50%" font-family="Arial, sans-serif" font-size="48" 
            fill="#6B7280" text-anchor="middle" dominant-baseline="middle">
        ${text}
      </text>
    </svg>
  `;
  
  return `data:image/svg+xml;base64,${Buffer.from(svg).toString("base64")}`;
}

/**
 * Process image source and return image data
 */
export async function processImageSource(source: ImageSource): Promise<ProcessedImage | string | null> {
  switch (source.type) {
    case "url":
      if (!source.url) {
        logger.warn("URL image source missing url property");
        return null;
      }
      return await fetchImageFromUrl(source.url);

    case "unsplash":
      if (!source.query) {
        logger.warn("Unsplash image source missing query property");
        return null;
      }
      return await fetchImageFromUnsplash(source.query);

    case "placeholder":
      return generatePlaceholderImage(1920, 1080, "#E5E7EB", source.alt || "Image");

    default:
      logger.warn(`Unknown image source type: ${source.type}`);
      return null;
  }
}

/**
 * Validate image URL
 */
export function isValidImageUrl(url: string): boolean {
  try {
    const parsed = new URL(url);
    const validProtocols = ["http:", "https:"];
    const validExtensions = [".jpg", ".jpeg", ".png", ".gif", ".webp", ".svg"];
    
    if (!validProtocols.includes(parsed.protocol)) {
      return false;
    }

    const pathname = parsed.pathname.toLowerCase();
    return validExtensions.some(ext => pathname.endsWith(ext)) || pathname.includes("/image");
  } catch {
    return false;
  }
}

/**
 * Get optimal image dimensions for slide layout
 */
export function getOptimalImageDimensions(
  role: "hero" | "logo" | "illustration" | "icon" | "background",
  slideWidth: number = 10,
  slideHeight: number = 7.5
): { width: number; height: number; x: number; y: number; w: number; h: number } {
  switch (role) {
    case "hero":
      // Large hero image - 60% of slide width, centered
      return {
        width: 1920,
        height: 1080,
        x: slideWidth * 0.05,
        y: slideHeight * 0.15,
        w: slideWidth * 0.9,
        h: slideHeight * 0.7
      };

    case "logo":
      // Small logo - top right corner
      return {
        width: 400,
        height: 400,
        x: slideWidth - 1.5,
        y: 0.5,
        w: 1,
        h: 1
      };

    case "illustration":
      // Medium illustration - right side
      return {
        width: 1200,
        height: 1200,
        x: slideWidth * 0.55,
        y: slideHeight * 0.2,
        w: slideWidth * 0.4,
        h: slideHeight * 0.6
      };

    case "icon":
      // Small icon - inline with content
      return {
        width: 200,
        height: 200,
        x: 0.5,
        y: 2,
        w: 0.5,
        h: 0.5
      };

    case "background":
      // Full slide background
      return {
        width: 1920,
        height: 1080,
        x: 0,
        y: 0,
        w: slideWidth,
        h: slideHeight
      };

    default:
      // Default medium size
      return {
        width: 1200,
        height: 800,
        x: slideWidth * 0.1,
        y: slideHeight * 0.2,
        w: slideWidth * 0.8,
        h: slideHeight * 0.6
      };
  }
}

/**
 * Extract dominant color from image URL (simplified)
 * In production, use image processing library to analyze actual image
 */
export function estimateDominantColor(imageUrl: string): string {
  // Simple heuristic based on URL keywords
  const url = imageUrl.toLowerCase();
  
  if (url.includes("blue") || url.includes("ocean") || url.includes("sky")) return "#3B82F6";
  if (url.includes("green") || url.includes("nature") || url.includes("forest")) return "#10B981";
  if (url.includes("red") || url.includes("fire") || url.includes("sunset")) return "#EF4444";
  if (url.includes("purple") || url.includes("violet")) return "#8B5CF6";
  if (url.includes("orange") || url.includes("autumn")) return "#F59E0B";
  if (url.includes("pink") || url.includes("rose")) return "#EC4899";
  
  // Default neutral
  return "#64748B";
}

/**
 * Suggest Unsplash search queries based on slide content
 */
export function suggestImageQuery(
  title: string,
  subtitle?: string,
  contentType?: string
): string {
  const text = `${title} ${subtitle || ""}`.toLowerCase();
  
  // Business/Corporate
  if (text.match(/business|corporate|office|meeting|team/)) {
    return "business professional office";
  }
  
  // Technology
  if (text.match(/tech|software|digital|ai|data|cloud/)) {
    return "technology abstract modern";
  }
  
  // Finance
  if (text.match(/finance|money|investment|revenue|profit/)) {
    return "finance business growth";
  }
  
  // Healthcare
  if (text.match(/health|medical|care|wellness/)) {
    return "healthcare medical professional";
  }
  
  // Marketing
  if (text.match(/marketing|brand|campaign|social/)) {
    return "marketing creative design";
  }
  
  // Growth/Success
  if (text.match(/growth|success|achievement|goal/)) {
    return "success growth achievement";
  }
  
  // Innovation
  if (text.match(/innovation|future|transform|disrupt/)) {
    return "innovation technology future";
  }
  
  // Default
  return "business professional modern";
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/index.ts
=================================================================================
import * as logger from "firebase-functions/logger";
import corsLib from "cors";
import { setGlobalOptions } from "firebase-functions/v2";
import { onRequest } from "firebase-functions/v2/https";
import { defineSecret } from "firebase-functions/params";
import { getApp } from "firebase-admin/app";
import { initializeApp } from "firebase-admin/app";
import { z } from "zod";
import PptxGenJS from "pptxgenjs";

// For external calls
import { fetch as undiciFetch } from "undici";

// Import AI helpers
import { callAIWithRetry, sanitizePrompt, moderateContent, enhanceSlideSpec } from "./aiHelpers";
import { ENHANCED_SYSTEM_PROMPT } from "./prompts";
import { generatePresentationPrompt, analyzePresentationRequest, validatePresentationFlow } from "./presentationAI";
import type { PresentationRequest } from "./presentationAI";

// Import PPTX builders
import { buildProfessionalSlide } from "./pptxBuilder";
import { buildMinimalSlide } from "./pptxBuilder/minimalBuilder";
import { buildHybridSlide } from "./pptxBuilder/hybridBuilder";
import { buildPremiumSlide } from "./pptxBuilder/premiumBuilder";
import { buildLayoutSlide } from "./pptxBuilder/layoutBuilder";

// Define secrets
const AI_API_KEY = defineSecret("AI_API_KEY");
const AI_BASE_URL = defineSecret("AI_BASE_URL");
const AI_MODEL = defineSecret("AI_MODEL");

setGlobalOptions({ region: "us-central1", memory: "512MiB", cpu: 1, timeoutSeconds: 60 });

// Admin init (idempotent)
try { getApp(); } catch { initializeApp(); }

const cors = corsLib({ origin: true }); // simple permissive CORS for MVP

/** SlideSpec schema (lean) */
const SlideSpecZ = z.object({
  meta: z.object({
    version: z.literal("1.0"),
    locale: z.string().default("en-US"),
    theme: z.string(),
    aspectRatio: z.enum(["16:9","4:3"]).default("16:9")
  }),
  content: z.object({
    title: z.object({ id: z.string(), text: z.string().min(1) }),
    subtitle: z.object({ id: z.string(), text: z.string().min(1) }).optional(),
    bullets: z.array(z.object({
      id: z.string(),
      items: z.array(z.object({ text: z.string(), level: z.number().int().min(1).max(3) })).min(1).max(8)
    })).max(3).optional(),
    callouts: z.array(z.object({
      id: z.string(), title: z.string().optional(), text: z.string(), variant: z.enum(["note","success","warning","danger"])
    })).max(2).optional(),
    dataViz: z.object({
      id: z.string(),
      kind: z.enum(["bar","line","pie"]),
      title: z.string().optional(),
      labels: z.array(z.string()).min(2).max(10),
      series: z.array(z.object({ name: z.string(), values: z.array(z.number()) })).min(1).max(3)
    }).optional(),
    imagePlaceholders: z.array(z.object({
      id: z.string(), role: z.enum(["hero","logo","illustration","icon"]), alt: z.string()
    })).max(2).optional()
  }),
  layout: z.object({
    grid: z.object({
      rows: z.number().int().min(3).max(12),
      cols: z.number().int().min(3).max(12),
      gutter: z.number().min(0),
      margin: z.object({ t: z.number(), r: z.number(), b: z.number(), l: z.number() })
    }),
    regions: z.array(z.object({
      name: z.enum(["header","body","footer","aside"]),
      rowStart: z.number().int().positive(), colStart: z.number().int().positive(),
      rowSpan: z.number().int().positive(),  colSpan: z.number().int().positive()
    })).min(1).max(4),
    anchors: z.array(z.object({
      refId: z.string(), region: z.enum(["header","body","footer","aside"]), order: z.number().int().min(0),
      span: z.object({ rows: z.number().int().positive(), cols: z.number().int().positive() }).optional()
    })).min(1).max(8)
  }),
  styleTokens: z.object({
    palette: z.object({ primary: z.string(), accent: z.string(), neutral: z.array(z.string()).min(5).max(9) }),
    typography: z.object({
      fonts: z.object({ sans: z.string(), serif: z.string().optional(), mono: z.string().optional() }),
      sizes: z.object({ "step_-2": z.number(), "step_-1": z.number(), step_0: z.number(), step_1: z.number(), step_2: z.number(), step_3: z.number() }),
      weights: z.object({ regular: z.number(), medium: z.number(), semibold: z.number(), bold: z.number() }),
      lineHeights: z.object({ compact: z.number(), standard: z.number() })
    }),
    spacing: z.object({ base: z.number(), steps: z.array(z.number()).min(5).max(10) }),
    radii: z.object({ sm: z.number(), md: z.number(), lg: z.number() }),
    shadows: z.object({ sm: z.string(), md: z.string(), lg: z.string() }),
    contrast: z.object({ minTextContrast: z.number(), minUiContrast: z.number() })
  }),
  components: z.object({
    bulletList: z.object({ variant: z.enum(["compact","spacious"]).optional() }).optional(),
    callout: z.object({ variant: z.enum(["flat","elevated"]).optional() }).optional(),
    chart: z.object({ legend: z.enum(["none","right","bottom"]).optional(), gridlines: z.boolean().optional() }).optional(),
    image: z.object({ fit: z.enum(["cover","contain"]).optional() }).optional(),
    title: z.object({ align: z.enum(["left","center","right"]).optional() }).optional()
  }).optional()
});
type SlideSpec = z.infer<typeof SlideSpecZ>;

/** System prompt (JSON-only) */
const SYSTEM_PROMPT = `
You are the SlideSpec generator for plzfixthx.
Return a SINGLE RFC8259-compliant JSON object that VALIDATES against SlideSpec v1.
Hard rules:
- Output ONLY JSON.
- meta.version "1.0"; aspectRatio "16:9" default.
- Concise, professional text; <=6 bullets total; levels 1-3.
- If dataViz present, labels 2..10; series lengths == labels length.
- Hex colors (#RRGGBB). IDs [A-Za-z0-9_-].
`;

/** Offline fallback SlideSpec (no AI) */
function fallbackSpec(prompt: string): SlideSpec {
  return {
    meta: { version: "1.0", locale: "en-US", theme: "Clean", aspectRatio: "16:9" },
    content: {
      title: { id: "title", text: prompt?.trim() ? prompt : "AI-Powered Slide in Seconds" },
      subtitle: { id: "subtitle", text: "plzfixthx ‚Äî preview & export" },
      bullets: [{ id: "b1", items: [
        { text: "Type a prompt; get a polished slide", level: 1 },
        { text: "Live preview in browser", level: 1 },
        { text: "Download a .pptx", level: 1 }
      ]}],
      callouts: [{ id: "c1", text: "Preview ‚â§ 3s, Export ‚â§ 10s", variant: "success" }]
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 24, r: 24, b: 24, l: 24 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body",   rowStart: 3, colStart: 1, rowSpan: 5, colSpan: 8 },
        { name: "aside",  rowStart: 3, colStart: 9, rowSpan: 5, colSpan: 4 }
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "subtitle", region: "header", order: 1 },
        { refId: "b1", region: "body", order: 0 },
        { refId: "c1", region: "aside", order: 0 }
      ]
    },
    styleTokens: {
      palette: { primary: "#2563EB", accent: "#F59E0B", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#E2E8F0"] },
      typography: {
        fonts: { sans: "Inter, Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 32 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.5 }
      },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32] },
      radii: { sm: 2, md: 6, lg: 12 },
      shadows: { sm: "0 1px 2px rgba(0,0,0,.06)", md: "0 4px 8px rgba(0,0,0,.12)", lg: "0 12px 24px rgba(0,0,0,.18)" },
      contrast: { minTextContrast: 4.5, minUiContrast: 3 }
    }
  };
}


/** AI adapter (OpenAI-compatible HTTP). Returns SlideSpec or throws. */
async function callVendor(prompt: string): Promise<SlideSpec> {
  const key = AI_API_KEY.value() ?? "";
  const base = AI_BASE_URL.value() || "https://api.openai.com/v1";
  const model = AI_MODEL.value() || "gpt-4o-mini"; // any JSON-capable chat model

  if (!key) {
    logger.warn("AI_API_KEY not set ‚Äî using fallback");
    return fallbackSpec(prompt);
  }

  // Use enhanced AI calling with retry logic
  const result = await callAIWithRetry(prompt, key, base, model, SlideSpecZ);

  // Post-process and enhance the result
  const enhanced = enhanceSlideSpec(result);

  return enhanced as SlideSpec;
}

/** POST /generateSlideSpec {prompt} -> {spec} */
export const generateSlideSpec = onRequest({ cors: false, secrets: [AI_API_KEY, AI_BASE_URL, AI_MODEL] }, (req, res) => {
  cors(req, res, async () => {
    if (req.method !== "POST") return res.status(405).send("Method Not Allowed");

    try {
      // Sanitize and validate prompt
      const rawPrompt = (req.body?.prompt ?? "").toString();
      const prompt = sanitizePrompt(rawPrompt, 800);

      // Content moderation
      const moderation = moderateContent(prompt);
      if (!moderation.safe) {
        return res.status(400).json({
          error: moderation.reason || "Content not allowed",
          spec: fallbackSpec("Content moderation failed")
        });
      }

      // Generate slide spec
      const spec = await callVendor(prompt);
      res.status(200).json({ spec });
    } catch (e: any) {
      logger.error("Error generating slide spec", { error: e.message, stack: e.stack });

      // Return fallback spec on error
      const fallback = fallbackSpec(req.body?.prompt || "");
      res.status(200).json({
        spec: fallback,
        warning: "Using fallback due to error: " + e.message
      });
    }
  });
});

/** POST /exportPPTX {spec} or {specs: []} -> .pptx binary */
export const exportPPTX = onRequest({ cors: false }, (req, res) => {
  cors(req, res, async () => {
    if (req.method !== "POST") return res.status(405).send("Method Not Allowed");
    try {
      // Support both single spec and array of specs
      const body = req.body;
      let specs: any[];

      if (body?.specs && Array.isArray(body.specs)) {
        // Multiple slides
        specs = body.specs.map((s: any) => SlideSpecZ.parse(s));
      } else if (body?.spec) {
        // Single slide (backward compatibility)
        specs = [SlideSpecZ.parse(body.spec)];
      } else {
        throw new Error("Missing spec or specs in request body");
      }

      const buf = await buildPptx(specs);
      res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.presentationml.presentation");
      res.setHeader("Content-Disposition", `attachment; filename="plzfixthx-presentation.pptx"`);
      res.status(200).send(Buffer.from(buf));
    } catch (e: any) {
      logger.error(e);
      res.status(400).send(`Export error: ${e.message || String(e)}`);
    }
  });
});

/** PPTX builder - supports single or multiple slides */
async function buildPptx(specs: SlideSpec | SlideSpec[]): Promise<ArrayBuffer> {
  const specsArray = Array.isArray(specs) ? specs : [specs];
  if (specsArray.length === 0) {
    throw new Error("No slides to export");
  }

  const pptx = new PptxGenJS();
  const firstSpec = specsArray[0];
  pptx.layout = firstSpec.meta.aspectRatio === "4:3" ? "LAYOUT_4x3" : "LAYOUT_16x9";

  // Build each slide
  for (const spec of specsArray) {
    await buildSlide(pptx, spec);
  }

  return pptx.write({ outputType: "arraybuffer" }) as Promise<ArrayBuffer>;
}

/** Build a single slide */
async function buildSlide(pptx: PptxGenJS, spec: SlideSpec): Promise<void> {
  logger.info("üèóÔ∏è buildSlide called", {
    hasTitle: !!spec.content.title,
    hasSubtitle: !!spec.content.subtitle,
    hasLayout: !!spec.layout,
  });

  try {
    // Use layout builder first - respects spec's layout grid system
    logger.info("üìê Attempting layout builder...");
    await buildLayoutSlide(pptx, spec as any);
    logger.info("‚úÖ Layout builder succeeded");
    return;
  } catch (e) {
    logger.error("‚ùå Layout slide builder failed, falling back to minimal", { error: String(e) });
    // Fallback to minimal builder if layout fails
    try {
      logger.info("üìê Attempting minimal builder...");
      await buildMinimalSlide(pptx, spec as any);
      logger.info("‚úÖ Minimal builder succeeded");
      return;
    } catch (minimalError) {
      logger.error("‚ùå Minimal slide builder also failed, falling back to premium", { error: String(minimalError) });
      // Final fallback to premium builder
      try {
        logger.info("üìê Attempting premium builder...");
        await buildPremiumSlide(pptx, spec as any);
        logger.info("‚úÖ Premium builder succeeded");
      } catch (fallbackError) {
        logger.error("‚ùå Premium slide builder also failed", { error: String(fallbackError) });
        throw fallbackError;
      }
    }
  }
}

/** Legacy basic builder - kept for reference */
async function buildSlideBasic(pptx: PptxGenJS, spec: SlideSpec): Promise<void> {
  const slide = pptx.addSlide();

  // Helpers
  const pxToIn = (px: number) => (px * 0.75) / 72;
  const { rows, cols, gutter, margin } = spec.layout.grid;
  const slideW = pptx.presLayout.width;
  const slideH = pptx.presLayout.height;
  const pad = { t: pxToIn(margin.t), r: pxToIn(margin.r), b: pxToIn(margin.b), l: pxToIn(margin.l) };
  const gridW = slideW - pad.l - pad.r;
  const gridH = slideH - pad.t - pad.b;
  const cellW = (gridW - ((cols - 1) * pxToIn(gutter))) / cols;
  const cellH = (gridH - ((rows - 1) * pxToIn(gutter))) / rows;

  const regionRect = (r: any) => ({
    x: pad.l + (r.colStart - 1) * (cellW + pxToIn(gutter)),
    y: pad.t + (r.rowStart - 1) * (cellH + pxToIn(gutter)),
    w: r.colSpan * cellW + (r.colSpan - 1) * pxToIn(gutter),
    h: r.rowSpan * cellH + (r.rowSpan - 1) * pxToIn(gutter)
  });
  const regions: Record<string, any> = {};
  spec.layout.regions.forEach(r => { regions[r.name] = regionRect(r); });

  const fonts = spec.styleTokens.typography.fonts;
  const sizes = spec.styleTokens.typography.sizes;
  const colorText = spec.styleTokens.palette.neutral[0];

  // Title
  const tA = spec.layout.anchors.find(a => a.refId === spec.content.title.id);
  if (tA) {
    const rect = regions[tA.region];
    slide.addText(spec.content.title.text, {
      x: rect.x, y: rect.y, w: rect.w, h: 1,
      fontFace: fonts.sans, fontSize: sizes.step_3 * 0.75, bold: true, color: colorText, align: spec.components?.title?.align || "left"
    });
  }

  // Subtitle
  const sub = spec.content.subtitle;
  if (sub) {
    const a = spec.layout.anchors.find(x => x.refId === sub.id);
    if (a) {
      const rect = regions[a.region];
      slide.addText(sub.text, { x: rect.x, y: rect.y + 0.7, w: rect.w, h: 0.7, fontFace: fonts.sans, fontSize: sizes.step_1 * 0.75, color: colorText });
    }
  }

  // Bullets (first list)
  const bl = spec.content.bullets?.[0];
  if (bl) {
    const a = spec.layout.anchors.find(x => x.refId === bl.id);
    if (a) {
      const rect = regions[a.region];
      slide.addText(
        bl.items.map(it => ({ text: it.text, options: { bullet: true, indentLevel: it.level - 1 } })),
        { x: rect.x, y: rect.y, w: rect.w, h: rect.h, fontFace: fonts.sans, fontSize: sizes.step_0 * 0.75, color: colorText, wrap: true }
      );
    }
  }

  // Callout (first)
  const co = spec.content.callouts?.[0];
  if (co) {
    const a = spec.layout.anchors.find(x => x.refId === co.id);
    if (a) {
      const rect = regions[a.region];
      slide.addShape(pptx.ShapeType.roundRect, {
        x: rect.x, y: rect.y, w: rect.w, h: 1.2,
        fill: { color: "FFFFFF" }, line: { color: spec.styleTokens.palette.accent },
        shadow: { type: "outer", color: "000000", opacity: 0.08, blur: 4, offset: 2 }
      });
      slide.addText(`${co.title ? co.title + " ‚Äî " : ""}${co.text}`, {
        x: rect.x + 0.1, y: rect.y + 0.15, w: rect.w - 0.2, h: 0.9,
        fontFace: fonts.sans, fontSize: sizes.step_0 * 0.75, color: colorText
      });
    }
  }

  // Chart (naive)
  const dv = spec.content.dataViz;
  if (dv) {
    const a = spec.layout.anchors.find(x => x.refId === dv.id);
    if (a) {
      const rect = regions[a.region];
      const chartData = dv.series.map(s => ({ name: s.name, labels: dv.labels, values: s.values }));
      const type = dv.kind === "pie" ? pptx.ChartType.pie : dv.kind === "line" ? pptx.ChartType.line : pptx.ChartType.bar;
      slide.addChart(type, chartData, { x: rect.x, y: rect.y, w: rect.w, h: rect.h, showLegend: true });
    }
  }
}

/**
 * Generate Full Presentation
 * Creates a complete multi-slide presentation with narrative flow
 */
export const generatePresentation = onRequest(
  { cors: ["*"], secrets: [AI_API_KEY, AI_BASE_URL, AI_MODEL] },
  async (req, res) => {
    return cors(req, res, async () => {
      try {
        if (req.method !== "POST") {
          res.status(405).json({ error: "Method not allowed" });
          return;
        }

        const body = req.body as PresentationRequest;

        if (!body.topic) {
          res.status(400).json({ error: "Missing required field: topic" });
          return;
        }

        logger.info("Generating presentation", { topic: body.topic, audience: body.audience });

        // Analyze request and generate structure
        const structure = analyzePresentationRequest(body);

        // Generate enhanced prompt for full presentation
        const enhancedPrompt = generatePresentationPrompt(body);

        // Call AI to generate all slides
        const aiResponse = await callAIWithRetry(
          enhancedPrompt,
          AI_API_KEY.value(),
          AI_BASE_URL.value(),
          AI_MODEL.value() || "gpt-4",
          z.any() // Accept any response format for multi-slide
        );

        // Parse AI response - expecting array of slide specs
        let slideSpecs: any[];
        try {
          const parsed = JSON.parse(String(aiResponse));
          slideSpecs = Array.isArray(parsed) ? parsed : [parsed];
        } catch (parseError) {
          logger.error("Failed to parse AI response", { error: String(parseError) });
          res.status(500).json({ error: "Invalid AI response format" });
          return;
        }

        // Validate and enhance each slide
        const validatedSlides = slideSpecs.map(spec => {
          try {
            const validated = SlideSpecZ.parse(spec);
            return enhanceSlideSpec(validated);
          } catch (validationError) {
            logger.warn("Slide validation failed, using fallback", { error: String(validationError) });
            return spec; // Use as-is if validation fails
          }
        });

        // Validate presentation flow
        const flowValidation = validatePresentationFlow(validatedSlides);
        if (!flowValidation.valid) {
          logger.warn("Presentation flow issues detected", { issues: flowValidation.issues });
        }

        res.status(200).json({
          presentation: {
            title: body.topic,
            slideCount: validatedSlides.length,
            slides: validatedSlides,
            structure: structure,
            flowValidation: flowValidation
          }
        });

      } catch (error) {
        logger.error("Error generating presentation", { error: String(error) });
        res.status(500).json({ error: "Failed to generate presentation" });
      }
    });
  }
);

// Export performance and error handling utilities
export * from "./performanceOptimizer";
export * from "./errorHandler";



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/performanceOptimizer.ts
=================================================================================
/**
 * Performance Optimizer
 * Handles caching, memoization, and performance monitoring
 */

import { logger } from "firebase-functions/v2";

interface CacheEntry<T> {
  value: T;
  timestamp: number;
  ttl: number;
}

class PerformanceCache {
  private cache: Map<string, CacheEntry<any>> = new Map();
  private readonly defaultTTL = 5 * 60 * 1000; // 5 minutes

  /**
   * Get cached value if not expired
   */
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    const isExpired = Date.now() - entry.timestamp > entry.ttl;
    if (isExpired) {
      this.cache.delete(key);
      return null;
    }

    return entry.value as T;
  }

  /**
   * Set cache value with TTL
   */
  set<T>(key: string, value: T, ttl: number = this.defaultTTL): void {
    this.cache.set(key, {
      value,
      timestamp: Date.now(),
      ttl
    });
  }

  /**
   * Clear all cache
   */
  clear(): void {
    this.cache.clear();
  }

  /**
   * Get cache size
   */
  size(): number {
    return this.cache.size;
  }
}

/**
 * Performance metrics tracker
 */
class PerformanceMetrics {
  private metrics: Map<string, number[]> = new Map();

  /**
   * Record metric value
   */
  record(name: string, value: number): void {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name)!.push(value);
  }

  /**
   * Get average for metric
   */
  getAverage(name: string): number {
    const values = this.metrics.get(name);
    if (!values || values.length === 0) return 0;
    return values.reduce((a, b) => a + b, 0) / values.length;
  }

  /**
   * Get max for metric
   */
  getMax(name: string): number {
    const values = this.metrics.get(name);
    if (!values || values.length === 0) return 0;
    return Math.max(...values);
  }

  /**
   * Get min for metric
   */
  getMin(name: string): number {
    const values = this.metrics.get(name);
    if (!values || values.length === 0) return 0;
    return Math.min(...values);
  }

  /**
   * Get all metrics summary
   */
  getSummary(): Record<string, { avg: number; min: number; max: number; count: number }> {
    const summary: Record<string, any> = {};
    for (const [name, values] of this.metrics.entries()) {
      summary[name] = {
        avg: this.getAverage(name),
        min: this.getMin(name),
        max: this.getMax(name),
        count: values.length
      };
    }
    return summary;
  }

  /**
   * Clear metrics
   */
  clear(): void {
    this.metrics.clear();
  }
}

/**
 * Measure execution time of async function
 */
export async function measureAsync<T>(
  name: string,
  fn: () => Promise<T>,
  metrics?: PerformanceMetrics
): Promise<T> {
  const start = Date.now();
  try {
    const result = await fn();
    const duration = Date.now() - start;
    if (metrics) {
      metrics.record(name, duration);
    }
    logger.info(`‚è±Ô∏è ${name} completed in ${duration}ms`);
    return result;
  } catch (error) {
    const duration = Date.now() - start;
    logger.error(`‚ùå ${name} failed after ${duration}ms`, { error });
    throw error;
  }
}

/**
 * Measure execution time of sync function
 */
export function measureSync<T>(
  name: string,
  fn: () => T,
  metrics?: PerformanceMetrics
): T {
  const start = Date.now();
  try {
    const result = fn();
    const duration = Date.now() - start;
    if (metrics) {
      metrics.record(name, duration);
    }
    logger.info(`‚è±Ô∏è ${name} completed in ${duration}ms`);
    return result;
  } catch (error) {
    const duration = Date.now() - start;
    logger.error(`‚ùå ${name} failed after ${duration}ms`, { error });
    throw error;
  }
}

/**
 * Retry logic with exponential backoff
 */
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  initialDelay: number = 100
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      if (attempt < maxRetries - 1) {
        const delay = initialDelay * Math.pow(2, attempt);
        logger.warn(`Retry attempt ${attempt + 1}/${maxRetries} after ${delay}ms`, { error });
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError || new Error("Max retries exceeded");
}

/**
 * Debounce function calls
 */
export function debounce<T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout | null = null;

  return (...args: Parameters<T>) => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      fn(...args);
      timeoutId = null;
    }, delay);
  };
}

/**
 * Memoize function results
 */
export function memoize<T extends (...args: any[]) => any>(fn: T): T {
  const cache = new Map<string, any>();

  return ((...args: Parameters<T>) => {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn(...args);
    cache.set(key, result);
    return result;
  }) as T;
}

/**
 * Batch operations for efficiency
 */
export class BatchProcessor<T, R> {
  private queue: T[] = [];
  private processing = false;
  private readonly batchSize: number;
  private readonly processor: (batch: T[]) => Promise<R[]>;

  constructor(batchSize: number, processor: (batch: T[]) => Promise<R[]>) {
    this.batchSize = batchSize;
    this.processor = processor;
  }

  /**
   * Add item to batch
   */
  async add(item: T): Promise<R[] | null> {
    this.queue.push(item);
    if (this.queue.length >= this.batchSize) {
      return this.flush();
    }
    return null;
  }

  /**
   * Process all queued items
   */
  async flush(): Promise<R[] | null> {
    if (this.queue.length === 0 || this.processing) {
      return null;
    }

    this.processing = true;
    try {
      const batch = this.queue.splice(0, this.batchSize);
      const results = await this.processor(batch);
      return results;
    } finally {
      this.processing = false;
    }
  }

  /**
   * Get queue size
   */
  size(): number {
    return this.queue.length;
  }
}

// Export singleton instances
export const performanceCache = new PerformanceCache();
export const performanceMetrics = new PerformanceMetrics();



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/__tests__/designAccents.test.ts
=================================================================================
/**
 * Tests for Design Accents
 * Validates that all design accent functions work correctly
 */

import { describe, it, expect, beforeEach, vi } from "vitest";
import {
  addGradientOverlay,
  addCornerFlourish,
  addLineAccent,
  addDotPattern,
  addWaveAccent,
  addContentShadow,
  addFrameAccent,
  addConnectorLine
} from "../designAccents";

describe("Design Accents", () => {
  let mockSlide: any;

  beforeEach(() => {
    mockSlide = {
      addShape: vi.fn()
    };
  });

  describe("addGradientOverlay", () => {
    it("should add gradient overlay with default parameters", () => {
      addGradientOverlay(mockSlide, "#6366F1", "#EC4899");
      expect(mockSlide.addShape).toHaveBeenCalled();
      expect(mockSlide.addShape.mock.calls.length).toBeGreaterThan(0);
    });

    it("should add gradient overlay with custom opacity", () => {
      addGradientOverlay(mockSlide, "#6366F1", "#EC4899", 0.1);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add gradient overlay with different directions", () => {
      addGradientOverlay(mockSlide, "#6366F1", "#EC4899", 0.05, "top-to-bottom");
      addGradientOverlay(mockSlide, "#6366F1", "#EC4899", 0.05, "left-to-right");
      addGradientOverlay(mockSlide, "#6366F1", "#EC4899", 0.05, "diagonal");
      expect(mockSlide.addShape.mock.calls.length).toBeGreaterThan(0);
    });
  });

  describe("addCornerFlourish", () => {
    it("should add corner flourish to top-left", () => {
      addCornerFlourish(mockSlide, "top-left", "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add corner flourish to top-right", () => {
      addCornerFlourish(mockSlide, "top-right", "#EC4899");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add corner flourish to bottom-left", () => {
      addCornerFlourish(mockSlide, "bottom-left", "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add corner flourish to bottom-right", () => {
      addCornerFlourish(mockSlide, "bottom-right", "#EC4899");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add corner flourish with custom size", () => {
      addCornerFlourish(mockSlide, "top-right", "#6366F1", 0.5);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });

  describe("addLineAccent", () => {
    it("should add line accent to top", () => {
      addLineAccent(mockSlide, "top", "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add line accent to bottom", () => {
      addLineAccent(mockSlide, "bottom", "#EC4899");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add line accent to left", () => {
      addLineAccent(mockSlide, "left", "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add line accent to right", () => {
      addLineAccent(mockSlide, "right", "#EC4899");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add line accent with custom thickness", () => {
      addLineAccent(mockSlide, "top", "#6366F1", 0.12);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });

  describe("addDotPattern", () => {
    it("should add sparse dot pattern", () => {
      addDotPattern(mockSlide, "#6366F1", "sparse");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add moderate dot pattern", () => {
      addDotPattern(mockSlide, "#EC4899", "moderate");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add dense dot pattern", () => {
      addDotPattern(mockSlide, "#6366F1", "dense");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add dot pattern with custom opacity", () => {
      addDotPattern(mockSlide, "#6366F1", "sparse", 0.2);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });

  describe("addWaveAccent", () => {
    it("should add wave accent with default height", () => {
      addWaveAccent(mockSlide, "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add wave accent with custom height", () => {
      addWaveAccent(mockSlide, "#EC4899", 0.8);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });

  describe("addContentShadow", () => {
    it("should add content shadow with default parameters", () => {
      addContentShadow(mockSlide, 0.5, 0.5, 2, 1);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add content shadow with custom color", () => {
      addContentShadow(mockSlide, 0.5, 0.5, 2, 1, "FF0000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add content shadow with custom blur", () => {
      addContentShadow(mockSlide, 0.5, 0.5, 2, 1, "000000", 12);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });

  describe("addFrameAccent", () => {
    it("should add frame accent", () => {
      addFrameAccent(mockSlide, 0.5, 0.5, 2, 1, "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
      // Should create 4 borders (top, right, bottom, left)
      expect(mockSlide.addShape.mock.calls.length).toBe(4);
    });

    it("should add frame accent with custom thickness", () => {
      addFrameAccent(mockSlide, 0.5, 0.5, 2, 1, "#EC4899", 0.08);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });

  describe("addConnectorLine", () => {
    it("should add connector line between two points", () => {
      addConnectorLine(mockSlide, 0, 0, 2, 2, "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add connector line with custom thickness", () => {
      addConnectorLine(mockSlide, 0, 0, 2, 2, "#EC4899", 0.08);
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add horizontal connector line", () => {
      addConnectorLine(mockSlide, 0, 1, 5, 1, "#6366F1");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add vertical connector line", () => {
      addConnectorLine(mockSlide, 2, 0, 2, 5, "#EC4899");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/__tests__/enhancedAnimations.test.ts
=================================================================================
import { describe, it, expect } from "vitest";
import {
  createAnimation,
  getRecommendedAnimation,
  getAnimationDuration,
  createStaggerConfig,
  getEasingCurve,
  calculateSequenceTiming,
  getAnimationPreset,
  validateAnimationConfig,
  getAnimationMetadata,
  type AnimationType,
  type AnimationConfig
} from "../enhancedAnimations";

describe("Enhanced Animations", () => {
  describe("createAnimation", () => {
    it("should create animation with default values", () => {
      const animation = createAnimation("fade-in");
      expect(animation.type).toBe("fade-in");
      expect(animation.duration).toBe(500);
      expect(animation.delay).toBe(0);
      expect(animation.easing).toBe("ease-out");
    });

    it("should create animation with custom values", () => {
      const animation = createAnimation("slide-in-left", 800, 200, "ease-in");
      expect(animation.type).toBe("slide-in-left");
      expect(animation.duration).toBe(800);
      expect(animation.delay).toBe(200);
      expect(animation.easing).toBe("ease-in");
    });
  });

  describe("getRecommendedAnimation", () => {
    it("should return fade-in for title", () => {
      const animation = getRecommendedAnimation("title");
      expect(animation.type).toBe("fade-in");
      expect(animation.duration).toBe(600);
    });

    it("should return fade-in for subtitle", () => {
      const animation = getRecommendedAnimation("subtitle");
      expect(animation.type).toBe("fade-in");
      expect(animation.duration).toBe(500);
      expect(animation.delay).toBe(200);
    });

    it("should return slide-in-left for bullet", () => {
      const animation = getRecommendedAnimation("bullet");
      expect(animation.type).toBe("slide-in-left");
      expect(animation.duration).toBe(400);
      expect(animation.delay).toBe(300);
    });

    it("should return zoom-in for chart", () => {
      const animation = getRecommendedAnimation("chart");
      expect(animation.type).toBe("zoom-in");
      expect(animation.duration).toBe(700);
      expect(animation.delay).toBe(400);
    });

    it("should return fade-in for image", () => {
      const animation = getRecommendedAnimation("image");
      expect(animation.type).toBe("fade-in");
      expect(animation.duration).toBe(500);
      expect(animation.delay).toBe(300);
    });
  });

  describe("getAnimationDuration", () => {
    it("should return 300ms for simple animation", () => {
      expect(getAnimationDuration("simple")).toBe(300);
    });

    it("should return 500ms for moderate animation", () => {
      expect(getAnimationDuration("moderate")).toBe(500);
    });

    it("should return 800ms for complex animation", () => {
      expect(getAnimationDuration("complex")).toBe(800);
    });
  });

  describe("createStaggerConfig", () => {
    it("should create stagger config with defaults", () => {
      const config = createStaggerConfig();
      expect(config.enabled).toBe(true);
      expect(config.delay).toBe(100);
      expect(config.direction).toBe("forward");
    });

    it("should create stagger config with custom values", () => {
      const config = createStaggerConfig(false, 200, "backward");
      expect(config.enabled).toBe(false);
      expect(config.delay).toBe(200);
      expect(config.direction).toBe("backward");
    });
  });

  describe("getEasingCurve", () => {
    it("should return ease-in curve", () => {
      const curve = getEasingCurve("ease-in");
      expect(curve).toBe("cubic-bezier(0.42, 0, 1, 1)");
    });

    it("should return ease-out curve", () => {
      const curve = getEasingCurve("ease-out");
      expect(curve).toBe("cubic-bezier(0, 0, 0.58, 1)");
    });

    it("should return ease-in-out curve", () => {
      const curve = getEasingCurve("ease-in-out");
      expect(curve).toBe("cubic-bezier(0.42, 0, 0.58, 1)");
    });

    it("should return linear curve", () => {
      const curve = getEasingCurve("linear");
      expect(curve).toBe("linear");
    });
  });

  describe("calculateSequenceTiming", () => {
    it("should calculate forward timing", () => {
      const timings = calculateSequenceTiming(3, 0, 100, "forward");
      expect(timings).toEqual([0, 100, 200]);
    });

    it("should calculate backward timing", () => {
      const timings = calculateSequenceTiming(3, 0, 100, "backward");
      expect(timings).toEqual([0, 100, 200]);
    });

    it("should calculate with base delay", () => {
      const timings = calculateSequenceTiming(3, 200, 100, "forward");
      expect(timings).toEqual([200, 300, 400]);
    });

    it("should calculate random timing", () => {
      const timings = calculateSequenceTiming(3, 0, 100, "random");
      expect(timings.length).toBe(3);
      timings.forEach(t => {
        expect(t).toBeGreaterThanOrEqual(0);
        expect(t).toBeLessThanOrEqual(300);
      });
    });
  });

  describe("getAnimationPreset", () => {
    it("should return entrance preset", () => {
      const preset = getAnimationPreset("entrance");
      expect(preset.length).toBe(4);
      expect(preset[0].type).toBe("fade-in");
    });

    it("should return emphasis preset", () => {
      const preset = getAnimationPreset("emphasis");
      expect(preset.length).toBe(3);
      expect(preset[0].type).toBe("pulse");
    });

    it("should return exit preset", () => {
      const preset = getAnimationPreset("exit");
      expect(preset.length).toBe(3);
      expect(preset[0].type).toBe("fade-out");
    });

    it("should return transition preset", () => {
      const preset = getAnimationPreset("transition");
      expect(preset.length).toBe(3);
      expect(preset[0].type).toBe("fade-in");
    });
  });

  describe("validateAnimationConfig", () => {
    it("should validate correct config", () => {
      const config: AnimationConfig = {
        type: "fade-in",
        duration: 500,
        delay: 0
      };
      const result = validateAnimationConfig(config);
      expect(result.valid).toBe(true);
      expect(result.errors.length).toBe(0);
    });

    it("should reject negative duration", () => {
      const config: AnimationConfig = {
        type: "fade-in",
        duration: -100,
        delay: 0
      };
      const result = validateAnimationConfig(config);
      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    it("should reject negative delay", () => {
      const config: AnimationConfig = {
        type: "fade-in",
        duration: 500,
        delay: -100
      };
      const result = validateAnimationConfig(config);
      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    it("should accept valid repeat count", () => {
      const config: AnimationConfig = {
        type: "fade-in",
        duration: 500,
        delay: 0,
        repeat: 2
      };
      const result = validateAnimationConfig(config);
      expect(result.valid).toBe(true);
    });
  });

  describe("getAnimationMetadata", () => {
    it("should return metadata for fade-in", () => {
      const metadata = getAnimationMetadata("fade-in");
      expect(metadata.name).toBe("Fade In");
      expect(metadata.category).toBe("entrance");
      expect(metadata.duration).toBe(500);
    });

    it("should return metadata for pulse", () => {
      const metadata = getAnimationMetadata("pulse");
      expect(metadata.name).toBe("Pulse");
      expect(metadata.category).toBe("emphasis");
      expect(metadata.duration).toBe(600);
    });

    it("should return metadata for zoom-out", () => {
      const metadata = getAnimationMetadata("zoom-out");
      expect(metadata.name).toBe("Zoom Out");
      expect(metadata.category).toBe("exit");
      expect(metadata.duration).toBe(600);
    });

    it("should have description for all animations", () => {
      const animations: AnimationType[] = [
        "fade-in", "slide-in-left", "zoom-in", "pulse", "bounce-in"
      ];
      animations.forEach(anim => {
        const metadata = getAnimationMetadata(anim);
        expect(metadata.description).toBeTruthy();
        expect(metadata.description.length).toBeGreaterThan(0);
      });
    });
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/__tests__/iconLibrary.test.ts
=================================================================================
import { describe, it, expect, beforeEach, vi } from "vitest";
import { addIcon, type IconType } from "../iconLibrary";

describe("Icon Library", () => {
  let mockSlide: any;

  beforeEach(() => {
    mockSlide = {
      addShape: vi.fn(),
      addText: vi.fn()
    };
  });

  describe("addIcon", () => {
    it("should add a checkmark icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "checkmark", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a cross icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "cross", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an arrow-right icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "arrow-right", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an arrow-left icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "arrow-left", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an arrow-up icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "arrow-up", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an arrow-down icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "arrow-down", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a star icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "star", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a heart icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "heart", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a lightbulb icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "lightbulb", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a target icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "target", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a chart icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "chart", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a settings icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "settings", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a user icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "user", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a users icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "users", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a lock icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "lock", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an unlock icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "unlock", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a download icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "download", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an upload icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "upload", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a search icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "search", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a bell icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "bell", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a mail icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "mail", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a phone icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "phone", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a calendar icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "calendar", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a clock icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "clock", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a folder icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "folder", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a file icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "file", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a trash icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "trash", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add an edit icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "edit", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a copy icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "copy", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a share icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "share", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a play icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "play", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a pause icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "pause", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a stop icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "stop", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a volume icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "volume", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a wifi icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "wifi", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should add a battery icon", () => {
      addIcon(mockSlide, 1, 1, 0.5, "battery", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should use default color if not provided", () => {
      addIcon(mockSlide, 1, 1, 0.5, "checkmark");
      expect(mockSlide.addShape).toHaveBeenCalled();
    });

    it("should handle different sizes", () => {
      addIcon(mockSlide, 1, 1, 0.25, "star", "#000000");
      addIcon(mockSlide, 1, 1, 0.5, "star", "#000000");
      addIcon(mockSlide, 1, 1, 1, "star", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalledTimes(3);
    });

    it("should handle different positions", () => {
      addIcon(mockSlide, 0, 0, 0.5, "star", "#000000");
      addIcon(mockSlide, 5, 5, 0.5, "star", "#000000");
      addIcon(mockSlide, 10, 7.5, 0.5, "star", "#000000");
      expect(mockSlide.addShape).toHaveBeenCalledTimes(3);
    });

    it("should handle different colors", () => {
      addIcon(mockSlide, 1, 1, 0.5, "star", "#FF0000");
      addIcon(mockSlide, 1, 1, 0.5, "star", "#00FF00");
      addIcon(mockSlide, 1, 1, 0.5, "star", "#0000FF");
      expect(mockSlide.addShape).toHaveBeenCalledTimes(3);
    });
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/__tests__/professionalTemplates.test.ts
=================================================================================
import { describe, it, expect } from "vitest";
import {
  getAllTemplates,
  getTemplate,
  getTemplatesByUseCase,
  getTemplateLayout,
  getRecommendedTemplate,
  validateTemplate,
  createCustomTemplate,
  getTemplateStats,
  TITLE_SLIDE_TEMPLATE,
  CONTENT_SLIDE_TEMPLATE,
  TWO_COLUMN_TEMPLATE,
  THREE_COLUMN_TEMPLATE,
  DATA_VIZ_TEMPLATE,
  IMAGE_FOCUS_TEMPLATE,
  TIMELINE_TEMPLATE,
  CENTERED_FOCUS_TEMPLATE,
  SIDEBAR_TEMPLATE,
  STACKED_TEMPLATE,
  MINIMAL_TEMPLATE,
  FULL_BLEED_TEMPLATE
} from "../professionalTemplates";

describe("Professional Templates", () => {
  describe("getAllTemplates", () => {
    it("should return all templates", () => {
      const templates = getAllTemplates();
      expect(templates.length).toBe(12);
    });

    it("should include title slide template", () => {
      const templates = getAllTemplates();
      expect(templates).toContainEqual(TITLE_SLIDE_TEMPLATE);
    });

    it("should include content slide template", () => {
      const templates = getAllTemplates();
      expect(templates).toContainEqual(CONTENT_SLIDE_TEMPLATE);
    });
  });

  describe("getTemplate", () => {
    it("should get template by name", () => {
      const template = getTemplate("Title Slide");
      expect(template).toEqual(TITLE_SLIDE_TEMPLATE);
    });

    it("should be case insensitive", () => {
      const template = getTemplate("title slide");
      expect(template).toEqual(TITLE_SLIDE_TEMPLATE);
    });

    it("should return undefined for unknown template", () => {
      const template = getTemplate("Unknown Template");
      expect(template).toBeUndefined();
    });

    it("should get content slide template", () => {
      const template = getTemplate("Content Slide");
      expect(template).toEqual(CONTENT_SLIDE_TEMPLATE);
    });

    it("should get two column template", () => {
      const template = getTemplate("Two Column");
      expect(template).toEqual(TWO_COLUMN_TEMPLATE);
    });
  });

  describe("getTemplatesByUseCase", () => {
    it("should find templates by use case", () => {
      const templates = getTemplatesByUseCase("comparison");
      expect(templates.length).toBeGreaterThan(0);
      expect(templates).toContainEqual(TWO_COLUMN_TEMPLATE);
    });

    it("should be case insensitive", () => {
      const templates = getTemplatesByUseCase("COMPARISON");
      expect(templates.length).toBeGreaterThan(0);
    });

    it("should find chart templates", () => {
      const templates = getTemplatesByUseCase("chart");
      expect(templates.length).toBeGreaterThan(0);
    });

    it("should find chart templates", () => {
      const templates = getTemplatesByUseCase("charts");
      expect(templates.length).toBeGreaterThan(0);
    });
  });

  describe("getTemplateLayout", () => {
    it("should return professional layout", () => {
      const layout = getTemplateLayout("professional");
      expect(layout.title.fontSize).toBe(44);
      expect(layout.title.bold).toBe(true);
      expect(layout.body.fontSize).toBe(16);
    });

    it("should return modern layout", () => {
      const layout = getTemplateLayout("modern");
      expect(layout.title.fontSize).toBe(48);
      expect(layout.subtitle.bold).toBe(true);
    });

    it("should return minimal layout", () => {
      const layout = getTemplateLayout("minimal");
      expect(layout.title.fontSize).toBe(40);
      expect(layout.body.fontSize).toBe(14);
    });

    it("should return bold layout", () => {
      const layout = getTemplateLayout("bold");
      expect(layout.title.fontSize).toBe(52);
      expect(layout.title.color).toBe("#DC2626");
    });

    it("should default to professional layout", () => {
      const layout = getTemplateLayout("unknown");
      expect(layout.title.fontSize).toBe(44);
    });
  });

  describe("getRecommendedTemplate", () => {
    it("should recommend title slide for title content", () => {
      const template = getRecommendedTemplate("title");
      expect(template).toEqual(TITLE_SLIDE_TEMPLATE);
    });

    it("should recommend content slide for content", () => {
      const template = getRecommendedTemplate("content");
      expect(template).toEqual(CONTENT_SLIDE_TEMPLATE);
    });

    it("should recommend two column for comparison", () => {
      const template = getRecommendedTemplate("comparison");
      expect(template).toEqual(TWO_COLUMN_TEMPLATE);
    });

    it("should recommend data viz for data", () => {
      const template = getRecommendedTemplate("data");
      expect(template).toEqual(DATA_VIZ_TEMPLATE);
    });

    it("should recommend image focus for image", () => {
      const template = getRecommendedTemplate("image");
      expect(template).toEqual(IMAGE_FOCUS_TEMPLATE);
    });

    it("should recommend timeline for process", () => {
      const template = getRecommendedTemplate("process");
      expect(template).toEqual(TIMELINE_TEMPLATE);
    });
  });

  describe("validateTemplate", () => {
    it("should validate correct template", () => {
      const result = validateTemplate(TITLE_SLIDE_TEMPLATE);
      expect(result.valid).toBe(true);
      expect(result.errors.length).toBe(0);
    });

    it("should reject template without name", () => {
      const template = { ...TITLE_SLIDE_TEMPLATE, name: "" };
      const result = validateTemplate(template);
      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    it("should reject template without pattern", () => {
      const template = { ...TITLE_SLIDE_TEMPLATE, pattern: "" };
      const result = validateTemplate(template);
      expect(result.valid).toBe(false);
    });

    it("should reject template without color scheme", () => {
      const template = { ...TITLE_SLIDE_TEMPLATE, colorScheme: "" };
      const result = validateTemplate(template);
      expect(result.valid).toBe(false);
    });

    it("should reject template without typography", () => {
      const template = { ...TITLE_SLIDE_TEMPLATE, typography: "" };
      const result = validateTemplate(template);
      expect(result.valid).toBe(false);
    });
  });

  describe("createCustomTemplate", () => {
    it("should create custom template", () => {
      const template = createCustomTemplate(
        "Custom",
        "A custom template",
        "split",
        "tech",
        "modern",
        "Custom use case"
      );
      expect(template.name).toBe("Custom");
      expect(template.description).toBe("A custom template");
      expect(template.pattern).toBe("split");
      expect(template.colorScheme).toBe("tech");
      expect(template.typography).toBe("modern");
      expect(template.useCase).toBe("Custom use case");
    });

    it("should create valid custom template", () => {
      const template = createCustomTemplate(
        "Custom",
        "A custom template",
        "split",
        "tech",
        "modern",
        "Custom use case"
      );
      const result = validateTemplate(template);
      expect(result.valid).toBe(true);
    });
  });

  describe("getTemplateStats", () => {
    it("should return template statistics", () => {
      const stats = getTemplateStats();
      expect(stats.total).toBe(12);
      expect(stats.byPattern).toBeDefined();
      expect(stats.byColorScheme).toBeDefined();
    });

    it("should count patterns correctly", () => {
      const stats = getTemplateStats();
      expect(stats.byPattern["split"]).toBeGreaterThan(0);
      expect(stats.byPattern["hero"]).toBeGreaterThan(0);
    });

    it("should count color schemes correctly", () => {
      const stats = getTemplateStats();
      expect(stats.byColorScheme["corporate"]).toBeGreaterThan(0);
      expect(stats.byColorScheme["minimal"]).toBeGreaterThan(0);
    });
  });

  describe("Template Constants", () => {
    it("should have title slide template", () => {
      expect(TITLE_SLIDE_TEMPLATE.name).toBe("Title Slide");
      expect(TITLE_SLIDE_TEMPLATE.pattern).toBe("hero");
    });

    it("should have content slide template", () => {
      expect(CONTENT_SLIDE_TEMPLATE.name).toBe("Content Slide");
      expect(CONTENT_SLIDE_TEMPLATE.pattern).toBe("split");
    });

    it("should have two column template", () => {
      expect(TWO_COLUMN_TEMPLATE.name).toBe("Two Column");
      expect(TWO_COLUMN_TEMPLATE.pattern).toBe("comparison");
    });

    it("should have three column template", () => {
      expect(THREE_COLUMN_TEMPLATE.name).toBe("Three Column");
      expect(THREE_COLUMN_TEMPLATE.pattern).toBe("three-column");
    });

    it("should have data viz template", () => {
      expect(DATA_VIZ_TEMPLATE.name).toBe("Data Visualization");
      expect(DATA_VIZ_TEMPLATE.pattern).toBe("data-focused");
    });

    it("should have image focus template", () => {
      expect(IMAGE_FOCUS_TEMPLATE.name).toBe("Image Focus");
      expect(IMAGE_FOCUS_TEMPLATE.pattern).toBe("asymmetric");
    });

    it("should have timeline template", () => {
      expect(TIMELINE_TEMPLATE.name).toBe("Timeline");
      expect(TIMELINE_TEMPLATE.pattern).toBe("timeline");
    });

    it("should have centered focus template", () => {
      expect(CENTERED_FOCUS_TEMPLATE.name).toBe("Centered Focus");
      expect(CENTERED_FOCUS_TEMPLATE.pattern).toBe("centered");
    });

    it("should have sidebar template", () => {
      expect(SIDEBAR_TEMPLATE.name).toBe("Sidebar");
      expect(SIDEBAR_TEMPLATE.pattern).toBe("sidebar");
    });

    it("should have stacked template", () => {
      expect(STACKED_TEMPLATE.name).toBe("Stacked");
      expect(STACKED_TEMPLATE.pattern).toBe("stacked");
    });

    it("should have minimal template", () => {
      expect(MINIMAL_TEMPLATE.name).toBe("Minimal");
      expect(MINIMAL_TEMPLATE.pattern).toBe("minimal");
    });

    it("should have full bleed template", () => {
      expect(FULL_BLEED_TEMPLATE.name).toBe("Full Bleed");
      expect(FULL_BLEED_TEMPLATE.pattern).toBe("full-bleed");
    });
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/__tests__/whitespaceManager.test.ts
=================================================================================
import { describe, it, expect } from "vitest";
import {
  getSpacing,
  createUniformPadding,
  createUniformMargin,
  createCustomPadding,
  createCustomMargin,
  calculateContentWidth,
  calculateContentHeight,
  getRecommendedLineHeight,
  getRecommendedParagraphSpacing,
  calculateVerticalRhythm,
  getBreathingRoomPercentage,
  validateBreathingRoom,
  getContentMargin,
  getContainerPadding,
  calculateGridGap,
  calculateColumnWidth,
  getRecommendedSectionSpacing,
  getOptimalSlideMargins,
  getTextBoxPadding,
  getListItemSpacing,
  getElementSpacing,
  validateLayoutSpacing,
  SPACING_SCALE
} from "../whitespaceManager";

describe("Whitespace Manager", () => {
  describe("getSpacing", () => {
    it("should return correct spacing values", () => {
      expect(getSpacing("xs")).toBe(0.25);
      expect(getSpacing("sm")).toBe(0.5);
      expect(getSpacing("md")).toBe(0.75);
      expect(getSpacing("lg")).toBe(1);
      expect(getSpacing("xl")).toBe(1.5);
      expect(getSpacing("xxl")).toBe(2);
    });
  });

  describe("createUniformPadding", () => {
    it("should create uniform padding", () => {
      const padding = createUniformPadding("md");
      expect(padding.top).toBe(0.75);
      expect(padding.right).toBe(0.75);
      expect(padding.bottom).toBe(0.75);
      expect(padding.left).toBe(0.75);
    });
  });

  describe("createUniformMargin", () => {
    it("should create uniform margin", () => {
      const margin = createUniformMargin("lg");
      expect(margin.top).toBe(1);
      expect(margin.right).toBe(1);
      expect(margin.bottom).toBe(1);
      expect(margin.left).toBe(1);
    });
  });

  describe("createCustomPadding", () => {
    it("should create custom padding", () => {
      const padding = createCustomPadding(0.5, 1, 0.5, 1);
      expect(padding.top).toBe(0.5);
      expect(padding.right).toBe(1);
      expect(padding.bottom).toBe(0.5);
      expect(padding.left).toBe(1);
    });
  });

  describe("createCustomMargin", () => {
    it("should create custom margin", () => {
      const margin = createCustomMargin(0.25, 0.5, 0.25, 0.5);
      expect(margin.top).toBe(0.25);
      expect(margin.right).toBe(0.5);
      expect(margin.bottom).toBe(0.25);
      expect(margin.left).toBe(0.5);
    });
  });

  describe("calculateContentWidth", () => {
    it("should calculate content width with padding", () => {
      const padding = createCustomPadding(0, 0.5, 0, 0.5);
      const width = calculateContentWidth(10, padding);
      expect(width).toBe(9);
    });

    it("should handle zero padding", () => {
      const padding = createCustomPadding(0, 0, 0, 0);
      const width = calculateContentWidth(10, padding);
      expect(width).toBe(10);
    });
  });

  describe("calculateContentHeight", () => {
    it("should calculate content height with padding", () => {
      const padding = createCustomPadding(0.5, 0, 0.5, 0);
      const height = calculateContentHeight(7.5, padding);
      expect(height).toBe(6.5);
    });
  });

  describe("getRecommendedLineHeight", () => {
    it("should return 1.2 for large headings", () => {
      expect(getRecommendedLineHeight(44)).toBe(1.2);
    });

    it("should return 1.3 for subheadings", () => {
      expect(getRecommendedLineHeight(24)).toBe(1.3);
    });

    it("should return 1.5 for body text", () => {
      expect(getRecommendedLineHeight(16)).toBe(1.5);
    });
  });

  describe("getRecommendedParagraphSpacing", () => {
    it("should calculate paragraph spacing", () => {
      const spacing = getRecommendedParagraphSpacing(16);
      expect(spacing).toBeGreaterThan(0);
    });
  });

  describe("calculateVerticalRhythm", () => {
    it("should calculate vertical rhythm", () => {
      const rhythm = calculateVerticalRhythm(0.5, 2);
      expect(rhythm).toBe(1);
    });

    it("should use default multiplier", () => {
      const rhythm = calculateVerticalRhythm(0.5);
      expect(rhythm).toBe(0.5);
    });
  });

  describe("getBreathingRoomPercentage", () => {
    it("should calculate breathing room percentage", () => {
      const percentage = getBreathingRoomPercentage(50, 100);
      expect(percentage).toBe(50);
    });

    it("should handle full content", () => {
      const percentage = getBreathingRoomPercentage(100, 100);
      expect(percentage).toBe(0);
    });

    it("should handle empty content", () => {
      const percentage = getBreathingRoomPercentage(0, 100);
      expect(percentage).toBe(100);
    });
  });

  describe("validateBreathingRoom", () => {
    it("should validate optimal breathing room", () => {
      const result = validateBreathingRoom(60, 100);
      expect(result.valid).toBe(true);
      expect(result.percentage).toBe(40);
    });

    it("should reject too dense content", () => {
      const result = validateBreathingRoom(90, 100);
      expect(result.valid).toBe(false);
      expect(result.percentage).toBe(10);
    });

    it("should reject too much whitespace", () => {
      const result = validateBreathingRoom(30, 100);
      expect(result.valid).toBe(false);
      expect(result.percentage).toBe(70);
    });
  });

  describe("getContentMargin", () => {
    it("should return margin for title", () => {
      const margin = getContentMargin("title");
      expect(margin.bottom).toBe(0.5);
    });

    it("should return margin for body", () => {
      const margin = getContentMargin("body");
      expect(margin.top).toBe(0.25);
    });

    it("should return margin for chart", () => {
      const margin = getContentMargin("chart");
      expect(margin.top).toBe(0.5);
    });

    it("should return margin for image", () => {
      const margin = getContentMargin("image");
      expect(margin.top).toBe(0.5);
    });
  });

  describe("getContainerPadding", () => {
    it("should return padding for card", () => {
      const padding = getContainerPadding("card");
      expect(padding.top).toBe(0.5);
    });

    it("should return padding for box", () => {
      const padding = getContainerPadding("box");
      expect(padding.top).toBe(0.75);
    });

    it("should return padding for section", () => {
      const padding = getContainerPadding("section");
      expect(padding.top).toBe(1);
    });

    it("should return padding for highlight", () => {
      const padding = getContainerPadding("highlight");
      expect(padding.top).toBe(0.5);
    });
  });

  describe("calculateGridGap", () => {
    it("should return 0.5 for 2 columns", () => {
      expect(calculateGridGap(2, 10)).toBe(0.5);
    });

    it("should return 0.4 for 3 columns", () => {
      expect(calculateGridGap(3, 10)).toBe(0.4);
    });

    it("should return 0.25 for 4+ columns", () => {
      expect(calculateGridGap(4, 10)).toBe(0.25);
    });
  });

  describe("calculateColumnWidth", () => {
    it("should calculate column width", () => {
      const width = calculateColumnWidth(10, 2, 0.5);
      expect(width).toBe(4.75);
    });

    it("should handle multiple columns", () => {
      const width = calculateColumnWidth(10, 3, 0.4);
      expect(width).toBeCloseTo(3.067, 2);
    });
  });

  describe("getRecommendedSectionSpacing", () => {
    it("should return spacing for header", () => {
      expect(getRecommendedSectionSpacing("header")).toBe(0.5);
    });

    it("should return spacing for body", () => {
      expect(getRecommendedSectionSpacing("body")).toBe(0.75);
    });

    it("should return spacing for footer", () => {
      expect(getRecommendedSectionSpacing("footer")).toBe(0.5);
    });
  });

  describe("getOptimalSlideMargins", () => {
    it("should calculate optimal margins", () => {
      const margins = getOptimalSlideMargins(10, 7.5);
      expect(margins.top).toBeCloseTo(0.5);
      expect(margins.left).toBeCloseTo(0.5);
    });
  });

  describe("getTextBoxPadding", () => {
    it("should return padding for short text", () => {
      const padding = getTextBoxPadding(100);
      expect(padding.top).toBe(0.25);
    });

    it("should return padding for medium text", () => {
      const padding = getTextBoxPadding(300);
      expect(padding.top).toBe(0.5);
    });

    it("should return padding for long text", () => {
      const padding = getTextBoxPadding(600);
      expect(padding.top).toBe(0.75);
    });
  });

  describe("getListItemSpacing", () => {
    it("should return spacing for 3 items", () => {
      expect(getListItemSpacing(3)).toBe(0.4);
    });

    it("should return spacing for 5 items", () => {
      expect(getListItemSpacing(5)).toBe(0.3);
    });

    it("should return spacing for 6+ items", () => {
      expect(getListItemSpacing(6)).toBe(0.2);
    });
  });

  describe("getElementSpacing", () => {
    it("should return spacing for heading-body", () => {
      expect(getElementSpacing("heading-body")).toBe(0.3);
    });

    it("should return spacing for body-body", () => {
      expect(getElementSpacing("body-body")).toBe(0.2);
    });

    it("should return spacing for section-section", () => {
      expect(getElementSpacing("section-section")).toBe(0.75);
    });
  });

  describe("validateLayoutSpacing", () => {
    it("should validate non-overlapping elements", () => {
      const elements = [
        { y: 0, h: 1 },
        { y: 1.5, h: 1 },
        { y: 3, h: 1 }
      ];
      const result = validateLayoutSpacing(elements, 7.5);
      expect(result.valid).toBe(true);
      expect(result.issues.length).toBe(0);
    });

    it("should detect overlapping elements", () => {
      const elements = [
        { y: 0, h: 2 },
        { y: 1, h: 1 }
      ];
      const result = validateLayoutSpacing(elements, 7.5);
      expect(result.valid).toBe(false);
      expect(result.issues.length).toBeGreaterThan(0);
    });

    it("should detect content exceeding slide height", () => {
      const elements = [
        { y: 0, h: 5 },
        { y: 5, h: 3 }
      ];
      const result = validateLayoutSpacing(elements, 7.5);
      expect(result.valid).toBe(false);
    });
  });

  describe("SPACING_SCALE", () => {
    it("should have all spacing values", () => {
      expect(SPACING_SCALE.xs).toBe(0.25);
      expect(SPACING_SCALE.sm).toBe(0.5);
      expect(SPACING_SCALE.md).toBe(0.75);
      expect(SPACING_SCALE.lg).toBe(1);
      expect(SPACING_SCALE.xl).toBe(1.5);
      expect(SPACING_SCALE.xxl).toBe(2);
    });
  });
});


=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/advancedPatterns.ts
=================================================================================
/**
 * Advanced Design Patterns for Professional Slides
 * Implements hero, split, asymmetric, grid, minimal, and data-focused layouts
 */

import PptxGenJS from "pptxgenjs";
import type { SlideSpecV1 } from "../types/SlideSpecV1";
import {
  addAccentBar,
  addDecorativeCircle,
  addPremiumDivider,
  addCornerAccent,
  addStatBlock,
  addFeatureHighlight,
  addArrow
} from "./premiumComponents";

const SLIDE_WIDTH = 10;
const SLIDE_HEIGHT = 7.5;

export type DesignPattern = "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused";

/**
 * Apply design pattern to slide
 */
export function applyDesignPattern(
  slide: any,
  spec: SlideSpecV1,
  pattern: DesignPattern
): void {
  const palette = spec.styleTokens.palette;
  const primaryColor = palette.primary.replace("#", "");
  const accentColor = palette.accent.replace("#", "");

  switch (pattern) {
    case "hero":
      applyHeroPattern(slide, spec, primaryColor, accentColor);
      break;
    case "split":
      applySplitPattern(slide, spec, primaryColor, accentColor);
      break;
    case "asymmetric":
      applyAsymmetricPattern(slide, spec, primaryColor, accentColor);
      break;
    case "grid":
      applyGridPattern(slide, spec, primaryColor, accentColor);
      break;
    case "minimal":
      applyMinimalPattern(slide, spec, primaryColor, accentColor);
      break;
    case "data-focused":
      applyDataFocusedPattern(slide, spec, primaryColor, accentColor);
      break;
  }
}

/**
 * Hero Pattern: Large title/image (55-65% of slide), minimal supporting text
 * Best for: Executive summaries, product reveals, keynote slides
 */
function applyHeroPattern(slide: any, spec: SlideSpecV1, primaryColor: string, accentColor: string): void {
  // Large accent bar on left
  addAccentBar(slide, {
    position: "left",
    color: primaryColor,
    thickness: 0.15
  });

  // Top accent bar
  addAccentBar(slide, {
    position: "top",
    color: accentColor,
    thickness: 0.06
  });

  // Large decorative circles for visual interest
  addDecorativeCircle(slide, 8.0, 6.0, 1.2, primaryColor, 0.08);
  addDecorativeCircle(slide, 9.0, 7.0, 0.8, accentColor, 0.1);

  // Corner accents
  addCornerAccent(slide, "top-right", accentColor, 0.25);
  addCornerAccent(slide, "bottom-left", primaryColor, 0.2);
}

/**
 * Split Pattern: 50/50 content division with clear visual separation
 * Best for: Comparisons, pros/cons, two-part stories
 */
function applySplitPattern(slide: any, spec: SlideSpecV1, primaryColor: string, accentColor: string): void {
  // Vertical divider in center
  slide.addShape("rect", {
    x: SLIDE_WIDTH / 2 - 0.05,
    y: 0.5,
    w: 0.1,
    h: SLIDE_HEIGHT - 1,
    fill: { color: primaryColor, transparency: 80 },
    line: { type: "none" }
  });

  // Left accent bar
  addAccentBar(slide, {
    position: "left",
    color: primaryColor,
    thickness: 0.08
  });

  // Right accent bar
  addAccentBar(slide, {
    position: "right",
    color: accentColor,
    thickness: 0.08
  });

  // Corner accents
  addCornerAccent(slide, "top-left", primaryColor, 0.15);
  addCornerAccent(slide, "bottom-right", accentColor, 0.15);
}

/**
 * Asymmetric Pattern: Dynamic off-center layout with visual tension
 * Best for: Creative industries, feature highlights, modern tech
 */
function applyAsymmetricPattern(slide: any, spec: SlideSpecV1, primaryColor: string, accentColor: string): void {
  // Diagonal accent bar
  slide.addShape("rect", {
    x: 0,
    y: 0,
    w: SLIDE_WIDTH,
    h: 0.08,
    fill: { color: primaryColor },
    line: { type: "none" }
  });

  // Asymmetric accent shapes
  addDecorativeCircle(slide, 7.5, 1.0, 1.5, accentColor, 0.1);
  addDecorativeCircle(slide, 0.5, 5.5, 1.0, primaryColor, 0.08);

  // Corner accent
  addCornerAccent(slide, "top-right", accentColor, 0.3);
}

/**
 * Grid Pattern: Structured multi-element layout (2x2, 3x3, etc.)
 * Best for: Portfolio items, process steps, multiple metrics
 */
function applyGridPattern(slide: any, spec: SlideSpecV1, primaryColor: string, accentColor: string): void {
  // Top accent bar
  addAccentBar(slide, {
    position: "top",
    color: primaryColor,
    thickness: 0.08
  });

  // Left accent bar
  addAccentBar(slide, {
    position: "left",
    color: accentColor,
    thickness: 0.08
  });

  // Grid lines (subtle)
  const gridColor = primaryColor;
  slide.addShape("rect", {
    x: SLIDE_WIDTH / 2 - 0.02,
    y: 1.0,
    w: 0.04,
    h: SLIDE_HEIGHT - 1.5,
    fill: { color: gridColor, transparency: 90 },
    line: { type: "none" }
  });

  slide.addShape("rect", {
    x: 0.5,
    y: SLIDE_HEIGHT / 2 - 0.02,
    w: SLIDE_WIDTH - 1,
    h: 0.04,
    fill: { color: gridColor, transparency: 90 },
    line: { type: "none" }
  });

  // Corner accents
  addCornerAccent(slide, "top-right", accentColor, 0.15);
  addCornerAccent(slide, "bottom-left", primaryColor, 0.15);
}

/**
 * Minimal Pattern: Maximum white space (40%+), essential content only
 * Best for: Quotes, key takeaways, luxury/premium positioning
 */
function applyMinimalPattern(slide: any, spec: SlideSpecV1, primaryColor: string, accentColor: string): void {
  // Subtle top accent bar
  addAccentBar(slide, {
    position: "top",
    color: primaryColor,
    thickness: 0.04
  });

  // Single corner accent for sophistication
  addCornerAccent(slide, "bottom-right", accentColor, 0.12);

  // Minimal decorative element
  addDecorativeCircle(slide, 0.3, 0.4, 0.4, primaryColor, 0.05);
}

/**
 * Data-Focused Pattern: Chart as primary (55-70%), supporting text sidebar
 * Best for: Analytics, financial reports, data-driven insights
 */
function applyDataFocusedPattern(slide: any, spec: SlideSpecV1, primaryColor: string, accentColor: string): void {
  // Left accent bar - strong visual anchor
  addAccentBar(slide, {
    position: "left",
    color: primaryColor,
    thickness: 0.12
  });

  // Top accent bar
  addAccentBar(slide, {
    position: "top",
    color: accentColor,
    thickness: 0.05
  });

  // Vertical divider between chart and sidebar
  slide.addShape("rect", {
    x: 6.8,
    y: 1.0,
    w: 0.08,
    h: SLIDE_HEIGHT - 1.5,
    fill: { color: primaryColor, transparency: 85 },
    line: { type: "none" }
  });

  // Corner accents
  addCornerAccent(slide, "top-right", accentColor, 0.2);
  addCornerAccent(slide, "bottom-left", primaryColor, 0.15);

  // Decorative elements
  addDecorativeCircle(slide, 8.5, 6.5, 0.7, accentColor, 0.08);
}

/**
 * Get recommended pattern based on content type
 */
export function getRecommendedPattern(spec: SlideSpecV1): DesignPattern {
  const content = spec.content;

  // If has chart, use data-focused
  if (content.dataViz) {
    return "data-focused";
  }

  // If has multiple callouts, use grid
  if (content.callouts && content.callouts.length > 2) {
    return "grid";
  }

  // If has many bullets, use split
  if (content.bullets && content.bullets[0]?.items.length > 4) {
    return "split";
  }

  // If short content, use minimal
  const totalWords = (content.title?.text || "").split(" ").length +
                     (content.subtitle?.text || "").split(" ").length +
                     (content.bullets?.[0]?.items || []).reduce((sum, item) => sum + item.text.split(" ").length, 0);

  if (totalWords < 30) {
    return "minimal";
  }

  // Default to split
  return "split";
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/advancedShapes.ts
=================================================================================
/**
 * Advanced Shapes and Visual Elements for Premium PowerPoint Slides
 * Provides sophisticated decorative and functional elements
 * Inspired by Apple, Google, Tesla, and ChatGPT design systems
 */

import PptxGenJS from "pptxgenjs";

/**
 * Add a directional arrow with professional styling
 */
export function addDirectionalArrow(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  direction: "right" | "left" | "up" | "down",
  color: string,
  thickness: number = 3
): void {
  const arrowShapes: Record<string, string> = {
    right: "rightArrow",
    left: "leftArrow",
    up: "upArrow",
    down: "downArrow"
  };

  slide.addShape(arrowShapes[direction], {
    x,
    y,
    w: width,
    h: height,
    fill: { color },
    line: { type: "none" },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.1,
      blur: 4,
      offset: 2
    }
  });
}

/**
 * Add a curved connector between two points
 */
export function addCurvedConnector(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string,
  thickness: number = 2
): void {
  // Use a curved connector shape
  slide.addShape("curve", {
    x: Math.min(x1, x2),
    y: Math.min(y1, y2),
    w: Math.abs(x2 - x1) || 0.1,
    h: Math.abs(y2 - y1) || 0.1,
    line: { color, width: thickness },
    fill: { type: "none" }
  });
}

/**
 * Add a professional progress bar
 */
export function addProgressBar(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  percentage: number,
  color: string,
  backgroundColor: string = "#E5E7EB"
): void {
  // Background bar
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: backgroundColor },
    line: { type: "none" }
  });

  // Progress fill
  const fillWidth = (width * Math.min(percentage, 100)) / 100;
  slide.addShape("roundRect", {
    x,
    y,
    w: fillWidth,
    h: height,
    fill: { color },
    line: { type: "none" }
  });

  // Percentage text
  slide.addText(`${Math.round(percentage)}%`, {
    x: x + width + 0.1,
    y: y - 0.05,
    w: 0.4,
    h: height + 0.1,
    fontSize: 11,
    bold: true,
    color,
    align: "left",
    valign: "middle"
  });
}

/**
 * Add a numbered step indicator
 */
export function addStepIndicator(
  slide: any,
  x: number,
  y: number,
  stepNumber: number,
  totalSteps: number,
  color: string,
  size: number = 0.4
): void {
  // Circle background
  slide.addShape("ellipse", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.12,
      blur: 6,
      offset: 2
    }
  });

  // Step number
  slide.addText(stepNumber.toString(), {
    x,
    y,
    w: size,
    h: size,
    fontSize: 16,
    bold: true,
    color: "#FFFFFF",
    align: "center",
    valign: "middle",
    fontFace: "Inter, Arial, sans-serif"
  });
}

/**
 * Add a comparison box with two columns
 */
export function addComparisonBox(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  leftLabel: string,
  rightLabel: string,
  leftColor: string,
  rightColor: string
): void {
  const halfWidth = width / 2;
  const dividerX = x + halfWidth;

  // Left box
  slide.addShape("rect", {
    x,
    y,
    w: halfWidth - 0.05,
    h: height,
    fill: { color: leftColor, transparency: 90 },
    line: { color: leftColor, width: 2 }
  });

  // Right box
  slide.addShape("rect", {
    x: dividerX + 0.05,
    y,
    w: halfWidth - 0.05,
    h: height,
    fill: { color: rightColor, transparency: 90 },
    line: { color: rightColor, width: 2 }
  });

  // Left label
  slide.addText(leftLabel, {
    x,
    y: y + height + 0.1,
    w: halfWidth,
    h: 0.3,
    fontSize: 12,
    bold: true,
    color: leftColor,
    align: "center"
  });

  // Right label
  slide.addText(rightLabel, {
    x: dividerX,
    y: y + height + 0.1,
    w: halfWidth,
    h: 0.3,
    fontSize: 12,
    bold: true,
    color: rightColor,
    align: "center"
  });
}

/**
 * Add a highlight badge with icon-like appearance
 */
export function addHighlightBadge(
  slide: any,
  x: number,
  y: number,
  text: string,
  color: string,
  backgroundColor: string = "#FFFFFF"
): void {
  const width = 1.5;
  const height = 0.4;

  // Badge background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: backgroundColor },
    line: { color, width: 2 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.1,
      blur: 4,
      offset: 1
    }
  });

  // Badge text
  slide.addText(text, {
    x,
    y,
    w: width,
    h: height,
    fontSize: 11,
    bold: true,
    color,
    align: "center",
    valign: "middle",
    fontFace: "Inter, Arial, sans-serif"
  });
}

/**
 * Add a subtle background shape for emphasis
 */
export function addEmphasisBackground(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  color: string,
  opacity: number = 0.08,
  borderRadius: number = 0.15
): void {
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color, transparency: Math.round((1 - opacity) * 100) },
    line: { type: "none" }
  });
}

/**
 * Add a vertical divider line
 */
export function addVerticalDivider(
  slide: any,
  x: number,
  y: number,
  height: number,
  color: string = "#E5E7EB",
  thickness: number = 0.02
): void {
  slide.addShape("rect", {
    x,
    y,
    w: thickness,
    h: height,
    fill: { color },
    line: { type: "none" }
  });
}

/**
 * Add a horizontal divider line
 */
export function addHorizontalDivider(
  slide: any,
  x: number,
  y: number,
  width: number,
  color: string = "#E5E7EB",
  thickness: number = 0.02
): void {
  slide.addShape("rect", {
    x,
    y,
    w: width,
    h: thickness,
    fill: { color },
    line: { type: "none" }
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/animations.ts
=================================================================================
/**
 * Slide Animations & Transitions
 * Entrance, exit, emphasis animations and slide transitions
 */

import PptxGenJS from "pptxgenjs";

export type EntranceAnimation = 
  | "fade" 
  | "wipe" 
  | "fly-in" 
  | "zoom" 
  | "appear" 
  | "split" 
  | "dissolve"
  | "box"
  | "checkerboard"
  | "blinds"
  | "random-bars";

export type ExitAnimation = 
  | "fade" 
  | "wipe" 
  | "fly-out" 
  | "zoom" 
  | "disappear";

export type EmphasisAnimation = 
  | "pulse" 
  | "color-pulse" 
  | "grow-shrink" 
  | "spin" 
  | "transparency"
  | "bold-flash"
  | "underline";

export type SlideTransition = 
  | "fade" 
  | "push" 
  | "wipe" 
  | "split" 
  | "reveal" 
  | "cover"
  | "uncover"
  | "flash"
  | "dissolve"
  | "random-bars"
  | "checkerboard"
  | "blinds"
  | "clock"
  | "ripple"
  | "honeycomb"
  | "glitter"
  | "vortex"
  | "shred"
  | "switch"
  | "flip"
  | "gallery"
  | "cube"
  | "doors"
  | "box"
  | "comb"
  | "zoom"
  | "random";

export interface AnimationConfig {
  type: EntranceAnimation | ExitAnimation | EmphasisAnimation;
  duration?: number; // milliseconds (default: 500)
  delay?: number; // milliseconds (default: 0)
  direction?: "left" | "right" | "top" | "bottom" | "center";
}

export interface TransitionConfig {
  type: SlideTransition;
  duration?: number; // milliseconds (default: 1000)
  direction?: "left" | "right" | "top" | "bottom";
}

/**
 * Apply entrance animation to slide element
 * Note: PptxGenJS has limited animation support, this is a best-effort implementation
 */
export function applyEntranceAnimation(
  slide: any,
  elementId: string,
  animation: AnimationConfig
): void {
  // PptxGenJS doesn't have full animation API yet
  // This is a placeholder for future implementation
  // For now, we'll document the animation intent in slide notes
  
  const animationNote = `Animation: ${animation.type} (${animation.duration || 500}ms, delay: ${animation.delay || 0}ms)`;
  
  // Store animation metadata (would be used by rendering engine)
  if (!slide._animations) {
    slide._animations = [];
  }
  
  slide._animations.push({
    elementId,
    type: "entrance",
    animation: animation.type,
    duration: animation.duration || 500,
    delay: animation.delay || 0,
    direction: animation.direction
  });
}

/**
 * Apply exit animation to slide element
 */
export function applyExitAnimation(
  slide: any,
  elementId: string,
  animation: AnimationConfig
): void {
  if (!slide._animations) {
    slide._animations = [];
  }
  
  slide._animations.push({
    elementId,
    type: "exit",
    animation: animation.type,
    duration: animation.duration || 500,
    delay: animation.delay || 0,
    direction: animation.direction
  });
}

/**
 * Apply emphasis animation to slide element
 */
export function applyEmphasisAnimation(
  slide: any,
  elementId: string,
  animation: AnimationConfig
): void {
  if (!slide._animations) {
    slide._animations = [];
  }
  
  slide._animations.push({
    elementId,
    type: "emphasis",
    animation: animation.type,
    duration: animation.duration || 500,
    delay: animation.delay || 0
  });
}

/**
 * Apply slide transition
 */
export function applySlideTransition(
  slide: any,
  transition: TransitionConfig
): void {
  // Map our transition types to PptxGenJS transition types
  const transitionMap: Record<string, string> = {
    "fade": "fade",
    "push": "push",
    "wipe": "wipe",
    "split": "split",
    "reveal": "reveal",
    "cover": "cover",
    "uncover": "uncover",
    "flash": "flash",
    "dissolve": "dissolve",
    "random-bars": "randomBars",
    "checkerboard": "checkerboard",
    "blinds": "blinds",
    "clock": "clock",
    "ripple": "ripple",
    "honeycomb": "honeycomb",
    "glitter": "glitter",
    "vortex": "vortex",
    "shred": "shred",
    "switch": "switch",
    "flip": "flip",
    "gallery": "gallery",
    "cube": "cube",
    "doors": "doors",
    "box": "box",
    "comb": "comb",
    "zoom": "zoom",
    "random": "random"
  };

  const pptxTransition = transitionMap[transition.type] || "fade";
  
  // Apply transition using PptxGenJS API
  slide.transition = {
    type: pptxTransition,
    duration: (transition.duration || 1000) / 1000, // Convert to seconds
    direction: transition.direction
  };
}

/**
 * Create animation sequence for multiple elements
 */
export function createAnimationSequence(
  slide: any,
  sequence: Array<{
    elementId: string;
    animation: AnimationConfig;
    order: number;
  }>
): void {
  // Sort by order
  const sorted = sequence.sort((a, b) => a.order - b.order);
  
  // Apply animations with calculated delays
  let cumulativeDelay = 0;
  
  for (const item of sorted) {
    const animationWithDelay = {
      ...item.animation,
      delay: cumulativeDelay + (item.animation.delay || 0)
    };
    
    applyEntranceAnimation(slide, item.elementId, animationWithDelay);
    
    // Add duration to cumulative delay for next item
    cumulativeDelay += (item.animation.duration || 500);
  }
}

/**
 * Get recommended animation based on slide pattern
 */
export function getRecommendedAnimation(
  pattern: "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused"
): {
  entrance: EntranceAnimation;
  transition: SlideTransition;
} {
  const recommendations = {
    hero: {
      entrance: "zoom" as EntranceAnimation,
      transition: "fade" as SlideTransition
    },
    split: {
      entrance: "wipe" as EntranceAnimation,
      transition: "split" as SlideTransition
    },
    asymmetric: {
      entrance: "fly-in" as EntranceAnimation,
      transition: "push" as SlideTransition
    },
    grid: {
      entrance: "appear" as EntranceAnimation,
      transition: "dissolve" as SlideTransition
    },
    minimal: {
      entrance: "fade" as EntranceAnimation,
      transition: "fade" as SlideTransition
    },
    "data-focused": {
      entrance: "wipe" as EntranceAnimation,
      transition: "wipe" as SlideTransition
    }
  };
  
  return recommendations[pattern] || recommendations.minimal;
}

/**
 * Apply professional animation preset to slide
 */
export function applyProfessionalAnimationPreset(
  slide: any,
  pattern: "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused",
  elementIds: {
    title?: string;
    subtitle?: string;
    bullets?: string[];
    chart?: string;
    image?: string;
  }
): void {
  const recommended = getRecommendedAnimation(pattern);
  
  // Apply slide transition
  applySlideTransition(slide, {
    type: recommended.transition,
    duration: 800
  });
  
  // Create animation sequence
  const sequence: Array<{
    elementId: string;
    animation: AnimationConfig;
    order: number;
  }> = [];
  
  let order = 0;
  
  // Title appears first
  if (elementIds.title) {
    sequence.push({
      elementId: elementIds.title,
      animation: {
        type: recommended.entrance,
        duration: 600,
        delay: 0
      },
      order: order++
    });
  }
  
  // Subtitle appears second
  if (elementIds.subtitle) {
    sequence.push({
      elementId: elementIds.subtitle,
      animation: {
        type: "fade",
        duration: 500,
        delay: 200
      },
      order: order++
    });
  }
  
  // Bullets appear one by one
  if (elementIds.bullets) {
    for (const bulletId of elementIds.bullets) {
      sequence.push({
        elementId: bulletId,
        animation: {
          type: "fly-in",
          duration: 400,
          delay: 150,
          direction: "left"
        },
        order: order++
      });
    }
  }
  
  // Chart appears
  if (elementIds.chart) {
    sequence.push({
      elementId: elementIds.chart,
      animation: {
        type: "wipe",
        duration: 800,
        delay: 0,
        direction: "bottom"
      },
      order: order++
    });
  }
  
  // Image appears
  if (elementIds.image) {
    sequence.push({
      elementId: elementIds.image,
      animation: {
        type: "zoom",
        duration: 600,
        delay: 0
      },
      order: order++
    });
  }
  
  createAnimationSequence(slide, sequence);
}

/**
 * Export animation metadata for web preview
 */
export function exportAnimationMetadata(slide: any): any {
  return {
    animations: slide._animations || [],
    transition: slide.transition || null
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/chartBuilder.ts
=================================================================================
/**
 * Enhanced Chart Builder
 * Creates professional, styled charts with design tokens
 */

import PptxGenJS from "pptxgenjs";

export interface ChartConfig {
  title?: string;
  subtitle?: string;
  labels: string[];
  series: Array<{
    name: string;
    values: number[];
  }>;
  colors?: string[];
  showLegend?: boolean;
  showDataLabels?: boolean;
  chartType: "bar" | "line" | "pie" | "area" | "scatter" | "combo" | "waterfall" | "funnel" | "doughnut";
  // Advanced options
  showTrendline?: boolean;
  showDataTable?: boolean;
  annotations?: Array<{
    text: string;
    x: number;
    y: number;
  }>;
  // Combo chart specific
  comboTypes?: Array<"bar" | "line" | "area">;
  // Waterfall specific
  waterfallConnectors?: boolean;
}

/**
 * Build a premium professional bar chart with advanced styling
 */
export function buildBarChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  const chartData = config.series.map(s => ({
    name: s.name,
    labels: config.labels,
    values: s.values
  }));

  // Premium color palette for charts - vibrant, modern, professional
  const premiumColors = config.colors || [
    "#3B82F6",  // Bright blue - primary
    "#10B981",  // Emerald - success
    "#F59E0B",  // Amber - warning
    "#8B5CF6",  // Purple - creative
    "#EC4899",  // Magenta - accent
    "#06B6D4",  // Cyan - tech
    "#EF4444",  // Red - alert
    "#14B8A6"   // Teal - calm
  ];

  const chartOptions: any = {
    x,
    y,
    w,
    h,
    chartColors: premiumColors,
    showLegend: config.showLegend !== false,
    legendPos: "b" as const,
    dataLabelFontSize: config.showDataLabels ? 12 : 0,
    dataLabelPosition: "ctr" as const,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    dataLabelFontBold: true,
    barDir: "bar" as const,
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    chartGridLine: { style: "solid", color: "#E5E7EB", size: 0.75 },
    showValue: config.showDataLabels !== false,
    barGapWidthPercent: 120,
    catAxisLabelFontSize: 12,
    catAxisLabelColor: "#475569",
    catAxisLabelFontFace: "Inter, Arial, sans-serif",
    valAxisLabelFontSize: 12,
    valAxisLabelColor: "#475569",
    valAxisLabelFontFace: "Inter, Arial, sans-serif",
    legendFontSize: 12,
    legendFontFace: "Inter, Arial, sans-serif",
    legendColor: "#475569",
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.05,
      blur: 4,
      offset: 2
    }
  };

  slide.addChart(PptxGenJS.ChartType.bar, chartData, chartOptions);
}

/**
 * Build a premium professional line chart with advanced styling
 */
export function buildLineChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  const chartData = config.series.map(s => ({
    name: s.name,
    labels: config.labels,
    values: s.values
  }));

  // Premium color palette for charts - vibrant, modern, professional
  const premiumColors = config.colors || [
    "#3B82F6",  // Bright blue - primary
    "#10B981",  // Emerald - success
    "#F59E0B",  // Amber - warning
    "#8B5CF6",  // Purple - creative
    "#EC4899",  // Magenta - accent
    "#06B6D4",  // Cyan - tech
    "#EF4444",  // Red - alert
    "#14B8A6"   // Teal - calm
  ];

  const chartOptions: any = {
    x,
    y,
    w,
    h,
    chartColors: premiumColors,
    showLegend: config.showLegend !== false,
    legendPos: "b" as const,
    dataLabelFontSize: config.showDataLabels ? 12 : 0,
    dataLabelPosition: "ctr" as const,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    dataLabelFontBold: true,
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    lineSmooth: true,
    chartGridLine: { style: "solid", color: "#E5E7EB", size: 0.75 },
    showValue: config.showDataLabels !== false,
    catAxisLabelFontSize: 12,
    catAxisLabelColor: "#475569",
    catAxisLabelFontFace: "Inter, Arial, sans-serif",
    valAxisLabelFontSize: 12,
    valAxisLabelColor: "#475569",
    valAxisLabelFontFace: "Inter, Arial, sans-serif",
    legendFontSize: 12,
    legendFontFace: "Inter, Arial, sans-serif",
    legendColor: "#475569",
    lineSize: 3,
    lineDataSymbol: "circle",
    lineDataSymbolSize: 6,
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.05,
      blur: 4,
      offset: 2
    }
  };

  slide.addChart(PptxGenJS.ChartType.line, chartData, chartOptions);
}

/**
 * Build a premium professional pie chart with advanced styling
 */
export function buildPieChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  const chartData = [
    {
      name: config.series[0]?.name || "Data",
      labels: config.labels,
      values: config.series[0]?.values || []
    }
  ];

  // Premium color palette for pie charts - vibrant, modern, professional
  const premiumColors = config.colors || [
    "#3B82F6",  // Bright blue - primary
    "#10B981",  // Emerald - success
    "#F59E0B",  // Amber - warning
    "#8B5CF6",  // Purple - creative
    "#EC4899",  // Magenta - accent
    "#06B6D4",  // Cyan - tech
    "#EF4444",  // Red - alert
    "#14B8A6",  // Teal - calm
    "#F97316",  // Orange - energy
    "#A855F7"   // Violet - luxury
  ];

  const chartOptions: any = {
    x,
    y,
    w,
    h,
    chartColors: premiumColors,
    showLegend: config.showLegend !== false,
    legendPos: "r" as const,
    dataLabelFontSize: config.showDataLabels ? 12 : 0,
    dataLabelPosition: "ctr" as const,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    dataLabelFontBold: true,
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    showValue: config.showDataLabels !== false,
    legendFontSize: 12,
    legendFontFace: "Inter, Arial, sans-serif",
    legendColor: "#475569",
    pieHole: 0,
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 6,
      offset: 3
    }
  };

  slide.addChart(PptxGenJS.ChartType.pie, chartData, chartOptions);
}

/**
 * Build a premium professional area chart with advanced styling
 */
export function buildAreaChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  const chartData = config.series.map(s => ({
    name: s.name,
    labels: config.labels,
    values: s.values
  }));

  // Premium color palette for area charts with transparency - vibrant, modern
  const premiumColors = config.colors || [
    "#3B82F6",  // Bright blue - primary
    "#10B981",  // Emerald - success
    "#F59E0B",  // Amber - warning
    "#8B5CF6",  // Purple - creative
    "#EC4899",  // Magenta - accent
    "#06B6D4",  // Cyan - tech
    "#EF4444",  // Red - alert
    "#14B8A6"   // Teal - calm
  ];

  const chartOptions: any = {
    x,
    y,
    w,
    h,
    chartColors: premiumColors,
    showLegend: config.showLegend !== false,
    legendPos: "b" as const,
    dataLabelFontSize: config.showDataLabels ? 12 : 0,
    dataLabelPosition: "ctr" as const,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    dataLabelFontBold: true,
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    lineSmooth: true,
    chartGridLine: { style: "solid", color: "#E5E7EB", size: 0.75 },
    showValue: config.showDataLabels !== false,
    catAxisLabelFontSize: 12,
    catAxisLabelColor: "#475569",
    catAxisLabelFontFace: "Inter, Arial, sans-serif",
    valAxisLabelFontSize: 12,
    valAxisLabelColor: "#475569",
    valAxisLabelFontFace: "Inter, Arial, sans-serif",
    legendFontSize: 12,
    legendFontFace: "Inter, Arial, sans-serif",
    legendColor: "#475569",
    lineSize: 2,
    fillOpacity: 30,
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.05,
      blur: 4,
      offset: 2
    }
  };

  slide.addChart(PptxGenJS.ChartType.area, chartData, chartOptions);
}

/**
 * Build a premium professional scatter chart with advanced styling
 */
export function buildScatterChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  const chartData = config.series.map(s => ({
    name: s.name,
    labels: config.labels,
    values: s.values
  }));

  const premiumColors = config.colors || [
    "#3B82F6", "#10B981", "#F59E0B", "#8B5CF6", "#EC4899", "#06B6D4", "#EF4444", "#14B8A6"
  ];

  const chartOptions: any = {
    x, y, w, h,
    chartColors: premiumColors,
    showLegend: config.showLegend !== false,
    legendPos: "b" as const,
    dataLabelFontSize: config.showDataLabels ? 10 : 0,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    chartGridLine: { style: "solid", color: "#E5E7EB", size: 0.75 },
    catAxisLabelFontSize: 12,
    catAxisLabelColor: "#475569",
    valAxisLabelFontSize: 12,
    valAxisLabelColor: "#475569",
    lineDataSymbol: "circle",
    lineDataSymbolSize: 8,
    lineSize: 0, // No connecting lines for scatter
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 4,
      offset: 2
    }
  };

  slide.addChart(PptxGenJS.ChartType.scatter, chartData, chartOptions);
}

/**
 * Build a doughnut chart (pie chart with hole)
 */
export function buildDoughnutChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  const chartData = [
    {
      name: config.series[0]?.name || "Data",
      labels: config.labels,
      values: config.series[0]?.values || []
    }
  ];

  const premiumColors = config.colors || [
    "#3B82F6", "#10B981", "#F59E0B", "#8B5CF6", "#EC4899", "#06B6D4", "#EF4444", "#14B8A6", "#F97316", "#A855F7"
  ];

  const chartOptions: any = {
    x, y, w, h,
    chartColors: premiumColors,
    showLegend: config.showLegend !== false,
    legendPos: "r" as const,
    dataLabelFontSize: config.showDataLabels ? 12 : 0,
    dataLabelPosition: "ctr" as const,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    dataLabelFontBold: true,
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    showValue: config.showDataLabels !== false,
    legendFontSize: 12,
    legendFontFace: "Inter, Arial, sans-serif",
    legendColor: "#475569",
    pieHole: 0.5, // 50% hole for doughnut effect
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 6,
      offset: 3
    }
  };

  slide.addChart(PptxGenJS.ChartType.pie, chartData, chartOptions);
}

/**
 * Build a waterfall chart showing cumulative effect
 */
export function buildWaterfallChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  // Waterfall charts show cumulative values
  // We'll use a bar chart with custom colors for positive/negative
  const values = config.series[0]?.values || [];
  const colors: string[] = [];

  // Color code: green for positive, red for negative, blue for total
  values.forEach((val, idx) => {
    if (idx === values.length - 1) {
      colors.push("#3B82F6"); // Blue for total
    } else if (val >= 0) {
      colors.push("#10B981"); // Green for positive
    } else {
      colors.push("#EF4444"); // Red for negative
    }
  });

  const chartData = [{
    name: config.series[0]?.name || "Values",
    labels: config.labels,
    values: values
  }];

  const chartOptions: any = {
    x, y, w, h,
    chartColors: colors,
    showLegend: false,
    dataLabelFontSize: config.showDataLabels ? 12 : 0,
    dataLabelPosition: "outEnd" as const,
    dataLabelColor: "#0F172A",
    dataLabelFontFace: "Inter, Arial, sans-serif",
    dataLabelFontBold: true,
    barDir: "bar" as const,
    showTitle: !!config.title,
    title: config.title || "",
    titleFontSize: 20,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: "#0F172A",
    chartGridLine: { style: "solid", color: "#E5E7EB", size: 0.75 },
    showValue: config.showDataLabels !== false,
    barGapWidthPercent: 150,
    catAxisLabelFontSize: 12,
    catAxisLabelColor: "#475569",
    valAxisLabelFontSize: 12,
    valAxisLabelColor: "#475569",
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.05,
      blur: 4,
      offset: 2
    }
  };

  slide.addChart(PptxGenJS.ChartType.bar, chartData, chartOptions);
}

/**
 * Build chart based on type
 */
export function buildChart(
  slide: any,
  config: ChartConfig,
  x: number,
  y: number,
  w: number,
  h: number
): void {
  switch (config.chartType) {
    case "bar":
      buildBarChart(slide, config, x, y, w, h);
      break;
    case "line":
      buildLineChart(slide, config, x, y, w, h);
      break;
    case "pie":
      buildPieChart(slide, config, x, y, w, h);
      break;
    case "area":
      buildAreaChart(slide, config, x, y, w, h);
      break;
    case "scatter":
      buildScatterChart(slide, config, x, y, w, h);
      break;
    case "doughnut":
      buildDoughnutChart(slide, config, x, y, w, h);
      break;
    case "waterfall":
      buildWaterfallChart(slide, config, x, y, w, h);
      break;
    case "combo":
      // Combo charts use multiple series with different types
      // For now, use line chart as fallback
      buildLineChart(slide, config, x, y, w, h);
      break;
    case "funnel":
      // Funnel charts are similar to bar charts but with decreasing widths
      // Use bar chart as fallback for now
      buildBarChart(slide, config, x, y, w, h);
      break;
    default:
      buildBarChart(slide, config, x, y, w, h);
  }
}

/**
 * Validate chart config
 */
export function validateChartConfig(config: ChartConfig): boolean {
  if (!config.labels || config.labels.length === 0) {
    return false;
  }

  if (!config.series || config.series.length === 0) {
    return false;
  }

  for (const series of config.series) {
    if (series.values.length !== config.labels.length) {
      return false;
    }
  }

  return true;
}

/**
 * Get recommended chart type for data
 */
export function getRecommendedChartType(
  dataPoints: number,
  seriesCount: number,
  hasNegativeValues: boolean = false,
  isCumulative: boolean = false
): "bar" | "line" | "pie" | "area" | "scatter" | "doughnut" | "waterfall" {
  // Waterfall for cumulative/sequential data with positive and negative values
  if (isCumulative && hasNegativeValues) {
    return "waterfall";
  }

  // Doughnut for single series with few categories (better than pie for modern look)
  if (seriesCount === 1 && dataPoints <= 6) {
    return "doughnut";
  }

  // Scatter for correlation analysis (multiple series, moderate data points)
  if (seriesCount >= 2 && dataPoints >= 5 && dataPoints <= 20) {
    return "scatter";
  }

  // Line for time series or trends (many data points)
  if (seriesCount > 1 && dataPoints > 10) {
    return "line";
  }

  // Area for showing volume/magnitude over time
  if (dataPoints > 15) {
    return "area";
  }

  // Bar as default for comparisons
  return "bar";
}

/**
 * Format chart data for display
 */
export function formatChartData(
  labels: string[],
  values: number[]
): Array<{ label: string; value: number }> {
  return labels.map((label, index) => ({
    label,
    value: values[index] || 0
  }));
}

/**
 * Calculate chart statistics
 */
export function calculateChartStats(values: number[]) {
  const sum = values.reduce((a, b) => a + b, 0);
  const avg = sum / values.length;
  const max = Math.max(...values);
  const min = Math.min(...values);

  return { sum, avg, max, min };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/designAccents.ts
=================================================================================
/**
 * Professional Design Accents
 * Subtle, sophisticated visual elements that enhance slide quality
 * Inspired by Apple, Google, Tesla, and ChatGPT design systems
 */

import PptxGenJS from "pptxgenjs";

const SLIDE_WIDTH = 10;
const SLIDE_HEIGHT = 7.5;

/**
 * Add a subtle gradient overlay for depth
 */
export function addGradientOverlay(
  slide: any,
  startColor: string,
  endColor: string,
  opacity: number = 0.05,
  direction: "top-to-bottom" | "left-to-right" | "diagonal" = "diagonal"
): void {
  const colors = [startColor, endColor];
  
  // Create gradient effect using semi-transparent rectangles
  const steps = 10;
  for (let i = 0; i < steps; i++) {
    const transparency = 100 - (opacity * 100 * (i / steps));
    const color = i < steps / 2 ? startColor : endColor;
    
    let x = 0, y = 0, w = SLIDE_WIDTH, h = SLIDE_HEIGHT;
    
    if (direction === "top-to-bottom") {
      y = (SLIDE_HEIGHT / steps) * i;
      h = SLIDE_HEIGHT / steps;
    } else if (direction === "left-to-right") {
      x = (SLIDE_WIDTH / steps) * i;
      w = SLIDE_WIDTH / steps;
    } else {
      // Diagonal
      x = (SLIDE_WIDTH / steps) * i;
      y = (SLIDE_HEIGHT / steps) * i;
      w = SLIDE_WIDTH / steps;
      h = SLIDE_HEIGHT / steps;
    }
    
    slide.addShape("rect", {
      x, y, w, h,
      fill: { color: color.replace("#", ""), transparency },
      line: { type: "none" }
    });
  }
}

/**
 * Add subtle corner flourish
 */
export function addCornerFlourish(
  slide: any,
  corner: "top-left" | "top-right" | "bottom-left" | "bottom-right",
  color: string,
  size: number = 0.3
): void {
  const cleanColor = color.replace("#", "");
  let x = 0, y = 0;
  
  switch (corner) {
    case "top-right":
      x = SLIDE_WIDTH - size;
      y = 0;
      break;
    case "bottom-left":
      x = 0;
      y = SLIDE_HEIGHT - size;
      break;
    case "bottom-right":
      x = SLIDE_WIDTH - size;
      y = SLIDE_HEIGHT - size;
      break;
    case "top-left":
    default:
      x = 0;
      y = 0;
  }
  
  // Main accent shape
  slide.addShape("roundRect", {
    x, y, w: size, h: size,
    fill: { color: cleanColor, transparency: 85 },
    line: { type: "none" }
  });
  
  // Smaller accent dot
  const dotSize = size * 0.4;
  const dotX = corner.includes("right") ? x + size - dotSize : x;
  const dotY = corner.includes("bottom") ? y + size - dotSize : y;
  
  slide.addShape("ellipse", {
    x: dotX, y: dotY, w: dotSize, h: dotSize,
    fill: { color: cleanColor, transparency: 70 },
    line: { type: "none" }
  });
}

/**
 * Add subtle line accent with gradient effect
 */
export function addLineAccent(
  slide: any,
  position: "top" | "bottom" | "left" | "right",
  color: string,
  thickness: number = 0.08
): void {
  const cleanColor = color.replace("#", "");
  let x = 0, y = 0, w = SLIDE_WIDTH, h = thickness;
  
  switch (position) {
    case "bottom":
      y = SLIDE_HEIGHT - thickness;
      break;
    case "left":
      w = thickness;
      h = SLIDE_HEIGHT;
      break;
    case "right":
      x = SLIDE_WIDTH - thickness;
      w = thickness;
      h = SLIDE_HEIGHT;
      break;
    case "top":
    default:
      break;
  }
  
  slide.addShape("rect", {
    x, y, w, h,
    fill: { color: cleanColor, transparency: 80 },
    line: { type: "none" }
  });
}

/**
 * Add subtle dot pattern for visual interest
 */
export function addDotPattern(
  slide: any,
  color: string,
  density: "sparse" | "moderate" | "dense" = "sparse",
  opacity: number = 0.1
): void {
  const cleanColor = color.replace("#", "");
  const dotSize = 0.08;
  
  const spacing = density === "sparse" ? 1.5 : density === "moderate" ? 1.0 : 0.6;
  const transparency = 100 - (opacity * 100);
  
  for (let x = 0; x < SLIDE_WIDTH; x += spacing) {
    for (let y = 0; y < SLIDE_HEIGHT; y += spacing) {
      // Random offset for organic feel
      const offsetX = (Math.random() - 0.5) * 0.2;
      const offsetY = (Math.random() - 0.5) * 0.2;
      
      slide.addShape("ellipse", {
        x: x + offsetX,
        y: y + offsetY,
        w: dotSize,
        h: dotSize,
        fill: { color: cleanColor, transparency },
        line: { type: "none" }
      });
    }
  }
}

/**
 * Add subtle wave pattern at bottom
 */
export function addWaveAccent(
  slide: any,
  color: string,
  height: number = 0.5
): void {
  const cleanColor = color.replace("#", "");
  const waveY = SLIDE_HEIGHT - height;
  
  // Create wave effect with curved shapes
  const waveSegments = 8;
  const segmentWidth = SLIDE_WIDTH / waveSegments;
  
  for (let i = 0; i < waveSegments; i++) {
    const x = i * segmentWidth;
    const curveHeight = Math.sin((i / waveSegments) * Math.PI) * (height * 0.5);
    
    slide.addShape("rect", {
      x,
      y: waveY + curveHeight,
      w: segmentWidth,
      h: height - curveHeight,
      fill: { color: cleanColor, transparency: 85 },
      line: { type: "none" }
    });
  }
}

/**
 * Add subtle shadow effect to content area
 */
export function addContentShadow(
  slide: any,
  x: number,
  y: number,
  w: number,
  h: number,
  color: string = "000000",
  blur: number = 8
): void {
  slide.addShape("rect", {
    x: x + 0.05,
    y: y + 0.05,
    w,
    h,
    fill: { color, transparency: 95 },
    line: { type: "none" },
    shadow: {
      type: "outer",
      color,
      opacity: 0.15,
      blur,
      offset: 4
    }
  });
}

/**
 * Add subtle frame/border accent
 */
export function addFrameAccent(
  slide: any,
  x: number,
  y: number,
  w: number,
  h: number,
  color: string,
  thickness: number = 0.06
): void {
  const cleanColor = color.replace("#", "");
  
  // Top border
  slide.addShape("rect", {
    x, y, w, h: thickness,
    fill: { color: cleanColor, transparency: 80 },
    line: { type: "none" }
  });
  
  // Right border
  slide.addShape("rect", {
    x: x + w - thickness, y, w: thickness, h,
    fill: { color: cleanColor, transparency: 80 },
    line: { type: "none" }
  });
  
  // Bottom border
  slide.addShape("rect", {
    x, y: y + h - thickness, w, h: thickness,
    fill: { color: cleanColor, transparency: 80 },
    line: { type: "none" }
  });
  
  // Left border
  slide.addShape("rect", {
    x, y, w: thickness, h,
    fill: { color: cleanColor, transparency: 80 },
    line: { type: "none" }
  });
}

/**
 * Add subtle connecting line between elements
 */
export function addConnectorLine(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string,
  thickness: number = 0.04
): void {
  const cleanColor = color.replace("#", "");
  const dx = x2 - x1;
  const dy = y2 - y1;
  const length = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx) * (180 / Math.PI);
  
  slide.addShape("rect", {
    x: x1,
    y: y1 - thickness / 2,
    w: length,
    h: thickness,
    fill: { color: cleanColor, transparency: 85 },
    line: { type: "none" },
    rotate: angle
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/designTokenMapper.ts
=================================================================================
/**
 * Design Token Mapper
 * Maps design tokens to PptxGenJS options for consistent styling
 */

export interface MappedColors {
  primary: string;
  accent: string;
  neutral: string[];
  text: string;
  background: string;
}

export interface MappedTypography {
  title: {
    fontFace: string;
    fontSize: number;
    bold: boolean;
    lineHeight: number;
    color?: string;
  };
  subtitle: {
    fontFace: string;
    fontSize: number;
    bold: boolean;
    lineHeight: number;
    color?: string;
  };
  body: {
    fontFace: string;
    fontSize: number;
    bold: boolean;
    lineHeight: number;
    color?: string;
  };
  caption: {
    fontFace: string;
    fontSize: number;
    bold: boolean;
    lineHeight: number;
    color?: string;
  };
}

export interface MappedShadows {
  sm: {
    type: "outer" | "inner";
    blur: number;
    offset: number;
    opacity: number;
  };
  md: {
    type: "outer" | "inner";
    blur: number;
    offset: number;
    opacity: number;
  };
  lg: {
    type: "outer" | "inner";
    blur: number;
    offset: number;
    opacity: number;
  };
}

/**
 * Map color palette to PptxGenJS format with premium color standards
 */
export function mapColorPalette(palette: any): MappedColors {
  // Premium neutral palette from dark to light
  const premiumNeutral = palette.neutral || [
    "#0F172A", // Charcoal - text
    "#1E293B", // Dark slate
    "#334155", // Slate
    "#64748B", // Medium slate
    "#94A3B8", // Light slate
    "#CBD5E1", // Lighter slate
    "#F8FAFC"  // Almost white - background
  ];

  return {
    primary: palette.primary || "#1E40AF", // Premium navy blue
    accent: palette.accent || "#10B981",   // Premium emerald
    neutral: premiumNeutral,
    text: premiumNeutral[0],
    background: premiumNeutral[6]
  };
}

/**
 * Map typography tokens to PptxGenJS format with premium standards
 */
export function mapTypography(tokens: any): MappedTypography {
  // Premium font pairings for professional presentations
  const fonts = tokens.fonts || {
    sans: "Inter, Arial, sans-serif",
    serif: "Georgia, serif",
    mono: "Courier New, monospace"
  };

  const sizes = tokens.sizes || {
    step_4: 56,   // Hero title - larger for impact
    step_3: 44,   // Premium title size - increased
    step_2: 32,   // Subtitle - more prominent
    step_1: 24,   // Secondary - better hierarchy
    step_0: 18,   // Body - more readable
    "step_-1": 16, // Caption - clearer
    "step_-2": 14  // Small - still legible
  };

  const weights = tokens.weights || {
    bold: 700,
    semibold: 600,
    medium: 500,
    regular: 400,
    light: 300
  };

  const lineHeights = tokens.lineHeights || {
    tight: 1.15,    // Slightly more breathing room
    compact: 1.25,  // Better readability
    standard: 1.6,  // Optimal for body text
    relaxed: 1.8    // Maximum comfort
  };

  return {
    title: {
      fontFace: fonts.sans,
      fontSize: sizes.step_3,
      bold: true,
      lineHeight: lineHeights.compact,
      color: "#0F172A"
    },
    subtitle: {
      fontFace: fonts.sans,
      fontSize: sizes.step_2,
      bold: false,
      lineHeight: 1.4,
      color: "#334155"
    },
    body: {
      fontFace: fonts.sans,
      fontSize: sizes.step_0,
      bold: false,
      lineHeight: lineHeights.standard,
      color: "#1E293B"
    },
    caption: {
      fontFace: fonts.sans,
      fontSize: sizes["step_-1"],
      bold: false,
      lineHeight: lineHeights.standard,
      color: "#64748B"
    }
  };
}

/**
 * Map shadows to PptxGenJS format with premium depth
 */
export function mapShadows(tokens: any): MappedShadows {
  return {
    sm: {
      type: "outer",
      blur: 4,
      offset: 2,
      opacity: 0.08  // Subtle, premium
    },
    md: {
      type: "outer",
      blur: 12,
      offset: 4,
      opacity: 0.12  // Professional depth
    },
    lg: {
      type: "outer",
      blur: 32,
      offset: 8,
      opacity: 0.16  // Elevated, sophisticated
    }
  };
}

/**
 * Map spacing tokens with premium standards
 */
export function mapSpacing(tokens: any): Record<string, number> {
  const base = tokens.base || 4;
  const steps = tokens.steps || [0, 4, 8, 12, 16, 24, 32];

  return {
    xs: steps[0] || 0,
    sm: steps[1] || 4,
    md: steps[2] || 8,
    lg: steps[3] || 12,
    xl: steps[4] || 16,
    "2xl": steps[5] || 24,
    "3xl": steps[6] || 32,
    "4xl": 48,  // Premium breathing room
    "5xl": 64   // Luxury spacing
  };
}

/**
 * Map border radius tokens with premium standards
 */
export function mapRadii(tokens: any): Record<string, number> {
  const radii = tokens.radii || { sm: 4, md: 8, lg: 12 };

  return {
    sm: radii.sm || 4,      // Subtle rounding
    md: radii.md || 8,      // Standard
    lg: radii.lg || 12,     // Generous
    xl: (radii.lg || 12) * 1.5,  // Extra generous
    "2xl": (radii.lg || 12) * 2,  // Premium
    full: 9999              // Fully rounded
  };
}

/**
 * Convert pixels to inches (for PptxGenJS)
 */
export function pxToIn(px: number): number {
  return (px * 0.75) / 72;
}

/**
 * Convert inches to pixels
 */
export function inToPx(inches: number): number {
  return (inches * 72) / 0.75;
}

/**
 * Get text options from typography config
 */
export function getTextOptions(
  typography: MappedTypography,
  colors: MappedColors,
  level: "title" | "subtitle" | "body" | "caption" = "body"
) {
  const config = typography[level];

  return {
    fontFace: config.fontFace,
    fontSize: config.fontSize,
    bold: config.bold,
    color: colors.text,
    align: "left" as const,
    valign: "middle" as const,
    wrap: true,
    lineSpacing: config.lineHeight * 100
  };
}

/**
 * Get shape options with shadow
 */
export function getShapeOptions(
  colors: MappedColors,
  shadows: MappedShadows,
  shadowLevel: "sm" | "md" | "lg" = "md"
) {
  const shadow = shadows[shadowLevel];

  return {
    fill: { color: colors.background },
    line: { color: colors.accent, width: 1 },
    shadow: {
      type: shadow.type,
      color: "000000",
      opacity: shadow.opacity,
      blur: shadow.blur,
      offset: shadow.offset
    }
  };
}

/**
 * Get advanced typography configuration for premium presentations
 */
export function getAdvancedTypography(theme: string = "professional"): any {
  const typographyThemes: Record<string, any> = {
    professional: {
      fontPairing: {
        primary: "Inter, Arial, sans-serif",
        secondary: "Inter, Arial, sans-serif"
      },
      hierarchy: {
        hero: { size: 56, weight: 700, lineHeight: 1.1, letterSpacing: -0.5 },
        title: { size: 40, weight: 700, lineHeight: 1.2, letterSpacing: 0 },
        subtitle: { size: 28, weight: 500, lineHeight: 1.4, letterSpacing: 0.2 },
        body: { size: 16, weight: 400, lineHeight: 1.5, letterSpacing: 0 },
        caption: { size: 14, weight: 400, lineHeight: 1.5, letterSpacing: 0.1 }
      }
    },
    elegant: {
      fontPairing: {
        primary: "Georgia, serif",
        secondary: "Inter, Arial, sans-serif"
      },
      hierarchy: {
        hero: { size: 52, weight: 700, lineHeight: 1.15, letterSpacing: -0.3 },
        title: { size: 36, weight: 700, lineHeight: 1.25, letterSpacing: 0 },
        subtitle: { size: 24, weight: 400, lineHeight: 1.5, letterSpacing: 0.1 },
        body: { size: 16, weight: 400, lineHeight: 1.6, letterSpacing: 0 },
        caption: { size: 13, weight: 400, lineHeight: 1.5, letterSpacing: 0.05 }
      }
    },
    modern: {
      fontPairing: {
        primary: "Inter, Arial, sans-serif",
        secondary: "Inter, Arial, sans-serif"
      },
      hierarchy: {
        hero: { size: 60, weight: 800, lineHeight: 1.0, letterSpacing: -1 },
        title: { size: 44, weight: 700, lineHeight: 1.15, letterSpacing: -0.5 },
        subtitle: { size: 32, weight: 600, lineHeight: 1.3, letterSpacing: 0 },
        body: { size: 16, weight: 400, lineHeight: 1.5, letterSpacing: 0 },
        caption: { size: 14, weight: 500, lineHeight: 1.4, letterSpacing: 0.2 }
      }
    }
  };

  return typographyThemes[theme] || typographyThemes.professional;
}

/**
 * Validate design tokens
 */
export function validateDesignTokens(tokens: any): boolean {
  if (!tokens.palette || !tokens.typography) {
    return false;
  }

  const palette = tokens.palette;
  const hexPattern = /^#[0-9A-Fa-f]{6}$/;

  if (!hexPattern.test(palette.primary) || !hexPattern.test(palette.accent)) {
    return false;
  }

  if (!Array.isArray(palette.neutral) || palette.neutral.length < 5) {
    return false;
  }

  return true;
}

/**
 * Get complete design token map
 */
export function getCompleteTokenMap(tokens: any) {
  return {
    colors: mapColorPalette(tokens.palette),
    typography: mapTypography(tokens.typography),
    shadows: mapShadows(tokens.shadows),
    spacing: mapSpacing(tokens.spacing),
    radii: mapRadii(tokens.radii)
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/enhancedAnimations.ts
=================================================================================
/**
 * Enhanced Animations for Professional PowerPoint Slides
 * Sophisticated entrance, emphasis, and exit animations
 * Inspired by Apple Keynote and Google Slides
 */

import PptxGenJS from "pptxgenjs";

export type AnimationType = 
  | "fade-in" | "fade-out"
  | "slide-in-left" | "slide-in-right" | "slide-in-top" | "slide-in-bottom"
  | "slide-out-left" | "slide-out-right" | "slide-out-top" | "slide-out-bottom"
  | "zoom-in" | "zoom-out"
  | "scale-up" | "scale-down"
  | "rotate-in" | "rotate-out"
  | "bounce-in" | "bounce-out"
  | "flip-in" | "flip-out"
  | "pulse" | "glow" | "shake" | "swing"
  | "grow" | "shrink"
  | "color-flash" | "bold-flash"
  | "spin-clockwise" | "spin-counter-clockwise";

export interface AnimationConfig {
  type: AnimationType;
  duration: number; // milliseconds
  delay: number; // milliseconds
  easing?: "ease-in" | "ease-out" | "ease-in-out" | "linear";
  repeat?: number; // number of times to repeat
  direction?: "left" | "right" | "top" | "bottom" | "center";
}

export interface StaggerConfig {
  enabled: boolean;
  delay: number; // milliseconds between each element
  direction?: "forward" | "backward" | "random";
}

/**
 * Create an animation configuration with sensible defaults
 */
export function createAnimation(
  type: AnimationType,
  duration: number = 500,
  delay: number = 0,
  easing: "ease-in" | "ease-out" | "ease-in-out" | "linear" = "ease-out"
): AnimationConfig {
  return {
    type,
    duration,
    delay,
    easing
  };
}

/**
 * Get recommended animation for content type
 */
export function getRecommendedAnimation(contentType: "title" | "subtitle" | "bullet" | "chart" | "image"): AnimationConfig {
  const animations: Record<string, AnimationConfig> = {
    title: createAnimation("fade-in", 600, 0),
    subtitle: createAnimation("fade-in", 500, 200),
    bullet: createAnimation("slide-in-left", 400, 300),
    chart: createAnimation("zoom-in", 700, 400),
    image: createAnimation("fade-in", 500, 300)
  };

  return animations[contentType] || createAnimation("fade-in", 500, 0);
}

/**
 * Get animation duration based on complexity
 */
export function getAnimationDuration(complexity: "simple" | "moderate" | "complex"): number {
  const durations: Record<string, number> = {
    simple: 300,
    moderate: 500,
    complex: 800
  };

  return durations[complexity] || 500;
}

/**
 * Create a stagger configuration for sequential animations
 */
export function createStaggerConfig(
  enabled: boolean = true,
  delay: number = 100,
  direction: "forward" | "backward" | "random" = "forward"
): StaggerConfig {
  return {
    enabled,
    delay,
    direction
  };
}

/**
 * Get easing function curve
 */
export function getEasingCurve(easing: string): string {
  const curves: Record<string, string> = {
    "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
    "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
    "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)",
    "linear": "linear"
  };

  return curves[easing] || curves["ease-out"];
}

/**
 * Calculate animation timing for a sequence
 */
export function calculateSequenceTiming(
  elementCount: number,
  baseDelay: number = 0,
  staggerDelay: number = 100,
  direction: "forward" | "backward" | "random" = "forward"
): number[] {
  const timings: number[] = [];

  if (direction === "forward") {
    for (let i = 0; i < elementCount; i++) {
      timings.push(baseDelay + i * staggerDelay);
    }
  } else if (direction === "backward") {
    for (let i = elementCount - 1; i >= 0; i--) {
      timings.push(baseDelay + (elementCount - 1 - i) * staggerDelay);
    }
  } else {
    // Random
    for (let i = 0; i < elementCount; i++) {
      timings.push(baseDelay + Math.random() * (elementCount * staggerDelay));
    }
  }

  return timings;
}

/**
 * Get animation preset for common scenarios
 */
export function getAnimationPreset(preset: "entrance" | "emphasis" | "exit" | "transition"): AnimationConfig[] {
  const presets: Record<string, AnimationConfig[]> = {
    entrance: [
      createAnimation("fade-in", 400, 0),
      createAnimation("slide-in-left", 500, 100),
      createAnimation("slide-in-left", 500, 200),
      createAnimation("slide-in-left", 500, 300)
    ],
    emphasis: [
      createAnimation("pulse", 600, 0),
      createAnimation("glow", 800, 0),
      createAnimation("scale-up", 400, 0)
    ],
    exit: [
      createAnimation("fade-out", 400, 0),
      createAnimation("slide-out-right", 500, 100),
      createAnimation("zoom-out", 500, 200)
    ],
    transition: [
      createAnimation("fade-in", 500, 0),
      createAnimation("slide-in-right", 600, 0),
      createAnimation("zoom-in", 700, 0)
    ]
  };

  return presets[preset] || presets.entrance;
}

/**
 * Validate animation configuration
 */
export function validateAnimationConfig(config: AnimationConfig): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!config.type) {
    errors.push("Animation type is required");
  }

  if (config.duration < 0) {
    errors.push("Duration must be non-negative");
  }

  if (config.delay < 0) {
    errors.push("Delay must be non-negative");
  }

  if (config.repeat && config.repeat < 1) {
    errors.push("Repeat count must be at least 1");
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Get animation metadata for documentation
 */
export function getAnimationMetadata(type: AnimationType): {
  name: string;
  category: "entrance" | "emphasis" | "exit";
  duration: number;
  description: string;
} {
  const metadata: Record<AnimationType, any> = {
    "fade-in": {
      name: "Fade In",
      category: "entrance",
      duration: 500,
      description: "Element fades in from transparent to opaque"
    },
    "fade-out": {
      name: "Fade Out",
      category: "exit",
      duration: 500,
      description: "Element fades out from opaque to transparent"
    },
    "slide-in-left": {
      name: "Slide In Left",
      category: "entrance",
      duration: 500,
      description: "Element slides in from the left"
    },
    "slide-in-right": {
      name: "Slide In Right",
      category: "entrance",
      duration: 500,
      description: "Element slides in from the right"
    },
    "slide-in-top": {
      name: "Slide In Top",
      category: "entrance",
      duration: 500,
      description: "Element slides in from the top"
    },
    "slide-in-bottom": {
      name: "Slide In Bottom",
      category: "entrance",
      duration: 500,
      description: "Element slides in from the bottom"
    },
    "slide-out-left": {
      name: "Slide Out Left",
      category: "exit",
      duration: 500,
      description: "Element slides out to the left"
    },
    "slide-out-right": {
      name: "Slide Out Right",
      category: "exit",
      duration: 500,
      description: "Element slides out to the right"
    },
    "slide-out-top": {
      name: "Slide Out Top",
      category: "exit",
      duration: 500,
      description: "Element slides out to the top"
    },
    "slide-out-bottom": {
      name: "Slide Out Bottom",
      category: "exit",
      duration: 500,
      description: "Element slides out to the bottom"
    },
    "zoom-in": {
      name: "Zoom In",
      category: "entrance",
      duration: 600,
      description: "Element zooms in from small to full size"
    },
    "zoom-out": {
      name: "Zoom Out",
      category: "exit",
      duration: 600,
      description: "Element zooms out from full size to small"
    },
    "scale-up": {
      name: "Scale Up",
      category: "emphasis",
      duration: 400,
      description: "Element scales up slightly for emphasis"
    },
    "scale-down": {
      name: "Scale Down",
      category: "emphasis",
      duration: 400,
      description: "Element scales down slightly"
    },
    "rotate-in": {
      name: "Rotate In",
      category: "entrance",
      duration: 600,
      description: "Element rotates in"
    },
    "rotate-out": {
      name: "Rotate Out",
      category: "exit",
      duration: 600,
      description: "Element rotates out"
    },
    "bounce-in": {
      name: "Bounce In",
      category: "entrance",
      duration: 700,
      description: "Element bounces in with elastic effect"
    },
    "bounce-out": {
      name: "Bounce Out",
      category: "exit",
      duration: 700,
      description: "Element bounces out with elastic effect"
    },
    "flip-in": {
      name: "Flip In",
      category: "entrance",
      duration: 600,
      description: "Element flips in"
    },
    "flip-out": {
      name: "Flip Out",
      category: "exit",
      duration: 600,
      description: "Element flips out"
    },
    "pulse": {
      name: "Pulse",
      category: "emphasis",
      duration: 600,
      description: "Element pulses with scale effect"
    },
    "glow": {
      name: "Glow",
      category: "emphasis",
      duration: 800,
      description: "Element glows with shadow effect"
    },
    "shake": {
      name: "Shake",
      category: "emphasis",
      duration: 500,
      description: "Element shakes side to side"
    },
    "swing": {
      name: "Swing",
      category: "emphasis",
      duration: 600,
      description: "Element swings back and forth"
    },
    "grow": {
      name: "Grow",
      category: "emphasis",
      duration: 500,
      description: "Element grows in size"
    },
    "shrink": {
      name: "Shrink",
      category: "emphasis",
      duration: 500,
      description: "Element shrinks in size"
    },
    "color-flash": {
      name: "Color Flash",
      category: "emphasis",
      duration: 400,
      description: "Element flashes with color change"
    },
    "bold-flash": {
      name: "Bold Flash",
      category: "emphasis",
      duration: 400,
      description: "Element flashes bold"
    },
    "spin-clockwise": {
      name: "Spin Clockwise",
      category: "emphasis",
      duration: 600,
      description: "Element spins clockwise"
    },
    "spin-counter-clockwise": {
      name: "Spin Counter-Clockwise",
      category: "emphasis",
      duration: 600,
      description: "Element spins counter-clockwise"
    }
  };

  return metadata[type] || {
    name: "Unknown",
    category: "entrance",
    duration: 500,
    description: "Unknown animation"
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/enhancedDataViz.ts
=================================================================================
/**
 * Enhanced Data Visualization
 * Advanced chart styling, annotations, and visual enhancements
 */

import PptxGenJS from "pptxgenjs";

export interface ChartAnnotation {
  label: string;
  value: number | string;
  x: number;
  y: number;
  color: string;
}

export interface DataVizConfig {
  title?: string;
  subtitle?: string;
  showLegend?: boolean;
  showGridlines?: boolean;
  showDataLabels?: boolean;
  annotations?: ChartAnnotation[];
  colors?: string[];
}

/**
 * Add a professional chart title with subtitle
 */
export function addChartHeader(
  slide: any,
  x: number,
  y: number,
  width: number,
  title: string,
  subtitle?: string,
  titleColor: string = "#0F172A",
  subtitleColor: string = "#64748B"
): void {
  // Title
  slide.addText(title, {
    x,
    y,
    w: width,
    h: 0.35,
    fontSize: 18,
    bold: true,
    color: titleColor,
    align: "left",
    fontFace: "Inter, Arial, sans-serif"
  });

  // Subtitle
  if (subtitle) {
    slide.addText(subtitle, {
      x,
      y: y + 0.35,
      w: width,
      h: 0.25,
      fontSize: 12,
      color: subtitleColor,
      align: "left",
      fontFace: "Inter, Arial, sans-serif"
    });
  }
}

/**
 * Add data point annotations to chart
 */
export function addChartAnnotations(
  slide: any,
  annotations: ChartAnnotation[]
): void {
  annotations.forEach((annotation) => {
    // Annotation background
    slide.addShape("roundRect", {
      x: annotation.x - 0.3,
      y: annotation.y - 0.15,
      w: 0.6,
      h: 0.3,
      fill: { color: "#FFFFFF" },
      line: { color: annotation.color, width: 1.5 },
      shadow: {
        type: "outer",
        color: "000000",
        opacity: 0.1,
        blur: 3,
        offset: 1
      }
    });

    // Annotation text
    slide.addText(annotation.label, {
      x: annotation.x - 0.3,
      y: annotation.y - 0.15,
      w: 0.6,
      h: 0.3,
      fontSize: 10,
      bold: true,
      color: annotation.color,
      align: "center",
      valign: "middle"
    });
  });
}

/**
 * Add a legend with custom styling
 */
export function addCustomLegend(
  slide: any,
  x: number,
  y: number,
  items: Array<{ label: string; color: string }>,
  columns: number = 1
): void {
  const itemHeight = 0.25;
  const itemWidth = 2;
  const gap = 0.1;

  items.forEach((item, index) => {
    const col = index % columns;
    const row = Math.floor(index / columns);
    const itemX = x + col * (itemWidth + gap);
    const itemY = y + row * (itemHeight + gap);

    // Color indicator
    slide.addShape("rect", {
      x: itemX,
      y: itemY + 0.05,
      w: 0.15,
      h: 0.15,
      fill: { color: item.color },
      line: { type: "none" }
    });

    // Label
    slide.addText(item.label, {
      x: itemX + 0.2,
      y: itemY,
      w: itemWidth - 0.2,
      h: itemHeight,
      fontSize: 11,
      color: "#334155",
      align: "left",
      valign: "middle"
    });
  });
}

/**
 * Add a data highlight box with key metric
 */
export function addMetricHighlight(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  metric: string,
  value: string,
  change?: string,
  changeColor?: string
): void {
  // Background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: "#F8FAFC" },
    line: { color: "#E2E8F0", width: 1 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.06,
      blur: 4,
      offset: 1
    }
  });

  // Metric label
  slide.addText(metric, {
    x: x + 0.15,
    y: y + 0.1,
    w: width - 0.3,
    h: 0.2,
    fontSize: 11,
    color: "#64748B",
    align: "left"
  });

  // Value
  slide.addText(value, {
    x: x + 0.15,
    y: y + 0.35,
    w: width - 0.3,
    h: 0.35,
    fontSize: 24,
    bold: true,
    color: "#0F172A",
    align: "left"
  });

  // Change indicator
  if (change && changeColor) {
    slide.addText(change, {
      x: x + 0.15,
      y: y + height - 0.25,
      w: width - 0.3,
      h: 0.2,
      fontSize: 10,
      bold: true,
      color: changeColor,
      align: "left"
    });
  }
}

/**
 * Add a trend indicator (up/down arrow with percentage)
 */
export function addTrendIndicator(
  slide: any,
  x: number,
  y: number,
  percentage: number,
  isPositive: boolean = true
): void {
  const color = isPositive ? "#10B981" : "#EF4444";
  const arrow = isPositive ? "‚Üë" : "‚Üì";

  slide.addText(`${arrow} ${Math.abs(percentage)}%`, {
    x,
    y,
    w: 0.8,
    h: 0.25,
    fontSize: 12,
    bold: true,
    color,
    align: "center",
    valign: "middle"
  });
}

/**
 * Add a comparison bar between two values
 */
export function addComparisonBar(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  value1: number,
  value2: number,
  label1: string,
  label2: string,
  color1: string,
  color2: string
): void {
  const maxValue = Math.max(value1, value2);
  const bar1Width = (value1 / maxValue) * width;
  const bar2Width = (value2 / maxValue) * width;

  // Bar 1
  slide.addShape("rect", {
    x,
    y,
    w: bar1Width,
    h: height / 2 - 0.05,
    fill: { color: color1 },
    line: { type: "none" }
  });

  // Label 1
  slide.addText(label1, {
    x: x + bar1Width + 0.1,
    y,
    w: 1,
    h: height / 2 - 0.05,
    fontSize: 10,
    color: "#334155",
    align: "left",
    valign: "middle"
  });

  // Bar 2
  slide.addShape("rect", {
    x,
    y: y + height / 2 + 0.05,
    w: bar2Width,
    h: height / 2 - 0.05,
    fill: { color: color2 },
    line: { type: "none" }
  });

  // Label 2
  slide.addText(label2, {
    x: x + bar2Width + 0.1,
    y: y + height / 2 + 0.05,
    w: 1,
    h: height / 2 - 0.05,
    fontSize: 10,
    color: "#334155",
    align: "left",
    valign: "middle"
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/hybridBuilder.ts
=================================================================================
/**
 * Hybrid Slide Builder
 * Combines SVG backgrounds with PptxGenJS editable content
 * 
 * This approach gives us:
 * - Professional, Apple/Tesla-quality visual design (SVG)
 * - Editable, accessible content (PptxGenJS)
 * - Small file sizes
 * - Innovation and creativity
 */

import PptxGenJS from "pptxgenjs";
import { SlideSpecV1 } from "../types/SlideSpecV1";
import { generateBackgroundForSlide, svgToPngDataUrl } from "../svgGenerator";

const SLIDE_WIDTH = 10; // inches
const SLIDE_HEIGHT = 5.625; // inches (16:9 aspect ratio)

/**
 * Build slide using hybrid approach
 */
export async function buildHybridSlide(pptx: PptxGenJS, spec: SlideSpecV1): Promise<void> {
  const slide = pptx.addSlide();

  try {
    // Step 1: Generate SVG background with professional design
    const svgBackground = generateBackgroundForSlide(spec);

    // Step 2: Convert SVG to PNG and add as slide background
    const backgroundDataUrl = await svgToPngDataUrl(svgBackground, 1920, 1080);
    slide.background = { data: backgroundDataUrl };

    // Step 3: Add editable content on top using PptxGenJS
    await addEditableContent(slide, spec);
  } catch (error) {
    console.error("Error building hybrid slide:", error);
    // Fallback: use solid color background
    const bgColor = spec.styleTokens?.palette?.neutral?.[8] || "F8FAFC";
    slide.background = { color: bgColor.replace("#", "") };
    await addEditableContent(slide, spec);
  }
}

/**
 * Add editable content (text, bullets, metrics) on top of SVG background
 * Enhanced with better typography and spacing
 */
async function addEditableContent(slide: any, spec: SlideSpecV1): Promise<void> {
  const tokens = spec.styleTokens;
  const palette = tokens?.palette;
  const typography = tokens?.typography;

  // Colors - enhanced contrast
  const textColor = palette?.neutral?.[0] || "#0F172A";
  const subtitleColor = palette?.neutral?.[2] || "#64748B";
  const primaryColor = palette?.primary || "#6366F1";
  const accentColor = palette?.accent || "#10B981";

  // Typography - refined sizes
  const titleSize = typography?.sizes?.step_3 || 40;
  const subtitleSize = typography?.sizes?.step_1 || 20;
  const bodySize = typography?.sizes?.step_0 || 18;

  let currentY = 0.7; // Start position - slightly higher

  // Add Title with enhanced styling
  if (spec.content.title) {
    slide.addText(spec.content.title.text, {
      x: 0.7,
      y: currentY,
      w: SLIDE_WIDTH - 1.4,
      h: 1.0,
      fontSize: titleSize,
      bold: true,
      color: textColor.replace("#", ""),
      fontFace: typography?.fonts?.sans || "Aptos",
      align: "left",
      valign: "top",
      lineSpacing: 110, // Slightly tighter line spacing for titles
    });

    // Add subtle accent line under title
    slide.addShape("rect", {
      x: 0.7,
      y: currentY + 0.85,
      w: 2.5,
      h: 0.04,
      fill: { color: primaryColor.replace("#", "") },
      line: { type: "none" },
    });

    currentY += 1.3;
  }

  // Add Subtitle with refined styling
  if (spec.content.subtitle) {
    slide.addText(spec.content.subtitle.text, {
      x: 0.7,
      y: currentY,
      w: SLIDE_WIDTH - 1.4,
      h: 0.6,
      fontSize: subtitleSize,
      color: subtitleColor.replace("#", ""),
      fontFace: typography?.fonts?.sans || "Aptos",
      align: "left",
      valign: "top",
      lineSpacing: 130,
    });
    currentY += 0.9;
  }

  // Add Content with enhanced styling
  await addContent(slide, spec.content, currentY, {
    textColor,
    subtitleColor,
    primaryColor,
    accentColor,
    bodySize,
    palette,
    fontFace: typography?.fonts?.sans || "Aptos",
  });
}

/**
 * Add content (bullets, dataViz, etc.)
 */
async function addContent(
  slide: any,
  content: SlideSpecV1["content"],
  startY: number,
  colors: any
): Promise<void> {
  if (!content) return;

  let currentY = startY;

  // Bullets - Enhanced with better spacing and styling
  if (content.bullets && content.bullets.length > 0) {
    const allBulletItems: any[] = [];

    content.bullets.forEach((bulletGroup) => {
      bulletGroup.items.forEach((item) => {
        allBulletItems.push({
          text: item.text,
          options: {
            bullet: {
              code: "2022", // Bullet character
              color: colors.primaryColor.replace("#", ""),
            },
            indentLevel: item.level - 1,
            color: colors.textColor.replace("#", ""),
            fontSize: colors.bodySize,
            fontFace: colors.fontFace,
            paraSpaceBefore: 0,
            paraSpaceAfter: 4, // Reduced spacing between bullets
          },
        });
      });
    });

    slide.addText(allBulletItems, {
      x: 0.9,
      y: currentY,
      w: SLIDE_WIDTH - 1.8,
      h: SLIDE_HEIGHT - currentY - 0.6,
      fontSize: colors.bodySize,
      color: colors.textColor.replace("#", ""),
      fontFace: colors.fontFace,
      valign: "top",
      lineSpacing: 120, // Tighter line spacing
    });
  }

  // Data Visualization (chart)
  if (content.dataViz) {
    await addDataViz(slide, content.dataViz, currentY, colors);
  }

  // Callouts - Enhanced with better visual design
  if (content.callouts && content.callouts.length > 0) {
    content.callouts.forEach((callout, index) => {
      const y = currentY + index * 0.9;
      const calloutColor =
        callout.variant === "success" ? "#10B981" :
        callout.variant === "warning" ? "#F59E0B" :
        callout.variant === "danger" ? "#EF4444" :
        colors.primaryColor;

      const bgColor =
        callout.variant === "success" ? "#D1FAE5" :
        callout.variant === "warning" ? "#FEF3C7" :
        callout.variant === "danger" ? "#FEE2E2" :
        "#EEF2FF";

      // Add callout background with rounded corners
      slide.addShape("roundRect", {
        x: 0.9,
        y,
        w: SLIDE_WIDTH - 1.8,
        h: 0.7,
        fill: { color: bgColor.replace("#", "") },
        line: {
          color: calloutColor.replace("#", ""),
          width: 2,
        },
      });

      // Add left accent bar
      slide.addShape("rect", {
        x: 0.9,
        y,
        w: 0.08,
        h: 0.7,
        fill: { color: calloutColor.replace("#", "") },
        line: { type: "none" },
      });

      // Add callout text
      const displayText = callout.title ? `${callout.title}: ${callout.text}` : callout.text;
      slide.addText(displayText, {
        x: 1.1,
        y: y + 0.1,
        w: SLIDE_WIDTH - 2.2,
        h: 0.5,
        fontSize: colors.bodySize - 1,
        color: colors.textColor.replace("#", ""),
        fontFace: colors.fontFace,
        align: "left",
        valign: "middle",
        bold: !!callout.title,
      });
    });
  }
}

/**
 * Add data visualization (chart) to slide with enhanced styling
 */
async function addDataViz(slide: any, dataViz: any, startY: number, colors: any): Promise<void> {
  if (!dataViz || !dataViz.labels || dataViz.labels.length === 0) return;

  const chartKind = dataViz.kind || "bar";
  const chartWidth = SLIDE_WIDTH - 1.8;
  const chartHeight = SLIDE_HEIGHT - startY - 0.6;

  try {
    // Prepare chart data for PptxGenJS
    const chartDataFormatted = dataViz.series.map((series: any) => ({
      name: series.name,
      labels: dataViz.labels,
      values: series.values,
    }));

    // Map chart kind to PptxGenJS chart type
    const chartTypeMap: any = {
      bar: "bar",
      line: "line",
      pie: "pie",
      area: "area",
      scatter: "scatter",
      doughnut: "doughnut",
    };

    const chartType = chartTypeMap[chartKind] || "bar";

    // Enhanced chart colors - use a professional palette
    const chartColors = [
      colors.primaryColor.replace("#", ""),
      colors.accentColor.replace("#", ""),
      "#8B5CF6", // Purple
      "#F59E0B", // Amber
      "#10B981", // Emerald
      "#EF4444", // Red
    ];

    slide.addChart(chartType, chartDataFormatted, {
      x: 0.9,
      y: startY,
      w: chartWidth,
      h: chartHeight,
      showTitle: !!dataViz.title,
      title: dataViz.title || "",
      titleFontSize: 16,
      titleColor: colors.textColor.replace("#", ""),
      titleFontFace: colors.fontFace,
      showLegend: dataViz.series.length > 1,
      legendPos: "r", // Right position for legend
      legendFontSize: 11,
      legendColor: colors.subtitleColor?.replace("#", "") || colors.textColor.replace("#", ""),
      showValue: chartKind !== "line", // Show values except for line charts
      dataLabelFontSize: 10,
      dataLabelColor: colors.textColor.replace("#", ""),
      catAxisLabelColor: colors.subtitleColor?.replace("#", "") || colors.textColor.replace("#", ""),
      catAxisLabelFontSize: 11,
      valAxisLabelColor: colors.subtitleColor?.replace("#", "") || colors.textColor.replace("#", ""),
      valAxisLabelFontSize: 11,
      chartColors: chartColors,
      border: { pt: 1, color: colors.palette?.neutral?.[5]?.replace("#", "") || "E2E8F0" },
      plotArea: {
        fill: { color: "FFFFFF", transparency: 0 },
      },
    });
  } catch (error) {
    console.error("Error adding data visualization:", error);
  }
}

/**
 * Build multiple slides (for future use)
 */
export async function buildHybridSlides(pptx: PptxGenJS, specs: SlideSpecV1[]): Promise<void> {
  for (const spec of specs) {
    await buildHybridSlide(pptx, spec);
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/iconLibrary.ts
=================================================================================
/**
 * Professional Icon Library for PowerPoint Slides
 * Provides simple geometric icons that work well in presentations
 * Icons are drawn using basic shapes for maximum compatibility
 */

import PptxGenJS from "pptxgenjs";

export type IconType = 
  | "checkmark" | "cross" | "arrow-right" | "arrow-left" | "arrow-up" | "arrow-down"
  | "star" | "heart" | "lightbulb" | "target" | "chart" | "settings"
  | "user" | "users" | "lock" | "unlock" | "download" | "upload"
  | "search" | "bell" | "mail" | "phone" | "calendar" | "clock"
  | "folder" | "file" | "trash" | "edit" | "copy" | "share"
  | "play" | "pause" | "stop" | "volume" | "wifi" | "battery";

/**
 * Add a professional icon to the slide
 */
export function addIcon(
  slide: any,
  x: number,
  y: number,
  size: number,
  iconType: IconType,
  color: string = "#0F172A",
  strokeWidth: number = 2
): void {
  const iconDrawers: Record<IconType, (slide: any, x: number, y: number, size: number, color: string, strokeWidth: number) => void> = {
    checkmark: drawCheckmark,
    cross: drawCross,
    "arrow-right": drawArrowRight,
    "arrow-left": drawArrowLeft,
    "arrow-up": drawArrowUp,
    "arrow-down": drawArrowDown,
    star: drawStar,
    heart: drawHeart,
    lightbulb: drawLightbulb,
    target: drawTarget,
    chart: drawChart,
    settings: drawSettings,
    user: drawUser,
    users: drawUsers,
    lock: drawLock,
    unlock: drawUnlock,
    download: drawDownload,
    upload: drawUpload,
    search: drawSearch,
    bell: drawBell,
    mail: drawMail,
    phone: drawPhone,
    calendar: drawCalendar,
    clock: drawClock,
    folder: drawFolder,
    file: drawFile,
    trash: drawTrash,
    edit: drawEdit,
    copy: drawCopy,
    share: drawShare,
    play: drawPlay,
    pause: drawPause,
    stop: drawStop,
    volume: drawVolume,
    wifi: drawWifi,
    battery: drawBattery
  };

  const drawer = iconDrawers[iconType];
  if (drawer) {
    drawer(slide, x, y, size, color, strokeWidth);
  }
}

// Icon drawing functions
function drawCheckmark(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("line", {
    x: x + size * 0.2,
    y: y + size * 0.5,
    w: size * 0.3,
    h: size * 0.3,
    line: { color, width: 2 }
  });
  slide.addShape("line", {
    x: x + size * 0.5,
    y: y + size * 0.2,
    w: size * 0.3,
    h: size * 0.6,
    line: { color, width: 2 }
  });
}

function drawCross(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("line", {
    x: x + size * 0.2,
    y: y + size * 0.2,
    w: size * 0.6,
    h: size * 0.6,
    line: { color, width: 2 }
  });
  slide.addShape("line", {
    x: x + size * 0.8,
    y: y + size * 0.2,
    w: -size * 0.6,
    h: size * 0.6,
    line: { color, width: 2 }
  });
}

function drawArrowRight(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("rightArrow", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawArrowLeft(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("leftArrow", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawArrowUp(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("upArrow", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawArrowDown(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("downArrow", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawStar(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("star5", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawHeart(slide: any, x: number, y: number, size: number, color: string): void {
  slide.addShape("heart", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawLightbulb(slide: any, x: number, y: number, size: number, color: string): void {
  // Bulb circle
  slide.addShape("ellipse", {
    x: x + size * 0.2,
    y: y + size * 0.1,
    w: size * 0.6,
    h: size * 0.5,
    fill: { color },
    line: { type: "none" }
  });
  // Base
  slide.addShape("rect", {
    x: x + size * 0.35,
    y: y + size * 0.6,
    w: size * 0.3,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
}

function drawTarget(slide: any, x: number, y: number, size: number, color: string): void {
  // Outer circle
  slide.addShape("ellipse", {
    x,
    y,
    w: size,
    h: size,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Middle circle
  slide.addShape("ellipse", {
    x: x + size * 0.25,
    y: y + size * 0.25,
    w: size * 0.5,
    h: size * 0.5,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Center dot
  slide.addShape("ellipse", {
    x: x + size * 0.4,
    y: y + size * 0.4,
    w: size * 0.2,
    h: size * 0.2,
    fill: { color },
    line: { type: "none" }
  });
}

function drawChart(slide: any, x: number, y: number, size: number, color: string): void {
  // Bar 1
  slide.addShape("rect", {
    x,
    y: y + size * 0.5,
    w: size * 0.2,
    h: size * 0.5,
    fill: { color },
    line: { type: "none" }
  });
  // Bar 2
  slide.addShape("rect", {
    x: x + size * 0.4,
    y: y + size * 0.3,
    w: size * 0.2,
    h: size * 0.7,
    fill: { color },
    line: { type: "none" }
  });
  // Bar 3
  slide.addShape("rect", {
    x: x + size * 0.8,
    y: y + size * 0.1,
    w: size * 0.2,
    h: size * 0.9,
    fill: { color },
    line: { type: "none" }
  });
}

function drawSettings(slide: any, x: number, y: number, size: number, color: string): void {
  // Center circle
  slide.addShape("ellipse", {
    x: x + size * 0.35,
    y: y + size * 0.35,
    w: size * 0.3,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
  // Gear teeth (simplified with rectangles)
  slide.addShape("rect", {
    x: x + size * 0.45,
    y: y,
    w: size * 0.1,
    h: size * 0.2,
    fill: { color },
    line: { type: "none" }
  });
}

function drawUser(slide: any, x: number, y: number, size: number, color: string): void {
  // Head
  slide.addShape("ellipse", {
    x: x + size * 0.25,
    y: y + size * 0.1,
    w: size * 0.5,
    h: size * 0.4,
    fill: { color },
    line: { type: "none" }
  });
  // Body
  slide.addShape("rect", {
    x: x + size * 0.15,
    y: y + size * 0.5,
    w: size * 0.7,
    h: size * 0.5,
    fill: { color },
    line: { type: "none" }
  });
}

function drawUsers(slide: any, x: number, y: number, size: number, color: string): void {
  // User 1
  drawUser(slide, x, y + size * 0.1, size * 0.6, color);
  // User 2
  drawUser(slide, x + size * 0.4, y + size * 0.2, size * 0.6, color);
}

function drawLock(slide: any, x: number, y: number, size: number, color: string): void {
  // Shackle
  slide.addShape("arc", {
    x: x + size * 0.2,
    y: y + size * 0.1,
    w: size * 0.6,
    h: size * 0.4,
    line: { color, width: 2 },
    fill: { type: "none" }
  });
  // Body
  slide.addShape("rect", {
    x: x + size * 0.15,
    y: y + size * 0.4,
    w: size * 0.7,
    h: size * 0.5,
    fill: { color },
    line: { type: "none" }
  });
}

function drawUnlock(slide: any, x: number, y: number, size: number, color: string): void {
  // Open shackle
  slide.addShape("line", {
    x: x + size * 0.2,
    y: y + size * 0.5,
    w: 0,
    h: -size * 0.3,
    line: { color, width: 2 }
  });
  // Body
  slide.addShape("rect", {
    x: x + size * 0.15,
    y: y + size * 0.4,
    w: size * 0.7,
    h: size * 0.5,
    fill: { color },
    line: { type: "none" }
  });
}

function drawDownload(slide: any, x: number, y: number, size: number, color: string): void {
  // Arrow down
  slide.addShape("downArrow", {
    x: x + size * 0.2,
    y: y + size * 0.1,
    w: size * 0.6,
    h: size * 0.4,
    fill: { color },
    line: { type: "none" }
  });
  // Line
  slide.addShape("rect", {
    x: x + size * 0.1,
    y: y + size * 0.65,
    w: size * 0.8,
    h: size * 0.05,
    fill: { color },
    line: { type: "none" }
  });
}

function drawUpload(slide: any, x: number, y: number, size: number, color: string): void {
  // Arrow up
  slide.addShape("upArrow", {
    x: x + size * 0.2,
    y: y + size * 0.4,
    w: size * 0.6,
    h: size * 0.4,
    fill: { color },
    line: { type: "none" }
  });
  // Line
  slide.addShape("rect", {
    x: x + size * 0.1,
    y: y + size * 0.1,
    w: size * 0.8,
    h: size * 0.05,
    fill: { color },
    line: { type: "none" }
  });
}

function drawSearch(slide: any, x: number, y: number, size: number, color: string): void {
  // Circle
  slide.addShape("ellipse", {
    x: x + size * 0.1,
    y: y + size * 0.1,
    w: size * 0.5,
    h: size * 0.5,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Handle
  slide.addShape("line", {
    x: x + size * 0.6,
    y: y + size * 0.6,
    w: size * 0.3,
    h: size * 0.3,
    line: { color, width: 2 }
  });
}

function drawBell(slide: any, x: number, y: number, size: number, color: string): void {
  // Bell shape
  slide.addShape("ellipse", {
    x: x + size * 0.2,
    y: y + size * 0.1,
    w: size * 0.6,
    h: size * 0.6,
    fill: { color },
    line: { type: "none" }
  });
  // Clapper
  slide.addShape("ellipse", {
    x: x + size * 0.35,
    y: y + size * 0.65,
    w: size * 0.3,
    h: size * 0.25,
    fill: { color },
    line: { type: "none" }
  });
}

function drawMail(slide: any, x: number, y: number, size: number, color: string): void {
  // Envelope
  slide.addShape("rect", {
    x,
    y: y + size * 0.2,
    w: size,
    h: size * 0.6,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Flap
  slide.addShape("line", {
    x,
    y: y + size * 0.2,
    w: size * 0.5,
    h: size * 0.3,
    line: { color, width: 2 }
  });
}

function drawPhone(slide: any, x: number, y: number, size: number, color: string): void {
  // Phone body
  slide.addShape("roundRect", {
    x: x + size * 0.15,
    y,
    w: size * 0.7,
    h: size,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Screen
  slide.addShape("rect", {
    x: x + size * 0.2,
    y: y + size * 0.1,
    w: size * 0.6,
    h: size * 0.7,
    fill: { color, transparency: 80 },
    line: { type: "none" }
  });
}

function drawCalendar(slide: any, x: number, y: number, size: number, color: string): void {
  // Calendar body
  slide.addShape("rect", {
    x,
    y: y + size * 0.15,
    w: size,
    h: size * 0.85,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Header
  slide.addShape("rect", {
    x,
    y: y + size * 0.15,
    w: size,
    h: size * 0.2,
    fill: { color },
    line: { type: "none" }
  });
}

function drawClock(slide: any, x: number, y: number, size: number, color: string): void {
  // Circle
  slide.addShape("ellipse", {
    x,
    y,
    w: size,
    h: size,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Hour hand
  slide.addShape("line", {
    x: x + size * 0.5,
    y: y + size * 0.5,
    w: 0,
    h: -size * 0.2,
    line: { color, width: 2 }
  });
  // Minute hand
  slide.addShape("line", {
    x: x + size * 0.5,
    y: y + size * 0.5,
    w: size * 0.2,
    h: 0,
    line: { color, width: 2 }
  });
}

function drawFolder(slide: any, x: number, y: number, size: number, color: string): void {
  // Folder tab
  slide.addShape("rect", {
    x,
    y,
    w: size * 0.4,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
  // Folder body
  slide.addShape("rect", {
    x,
    y: y + size * 0.25,
    w: size,
    h: size * 0.75,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
}

function drawFile(slide: any, x: number, y: number, size: number, color: string): void {
  // Document
  slide.addShape("rect", {
    x: x + size * 0.15,
    y,
    w: size * 0.7,
    h: size,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Lines
  for (let i = 0; i < 3; i++) {
    slide.addShape("line", {
      x: x + size * 0.25,
      y: y + size * (0.3 + i * 0.2),
      w: size * 0.5,
      h: 0,
      line: { color, width: 1 }
    });
  }
}

function drawTrash(slide: any, x: number, y: number, size: number, color: string): void {
  // Handle
  slide.addShape("rect", {
    x: x + size * 0.35,
    y,
    w: size * 0.3,
    h: size * 0.15,
    fill: { color },
    line: { type: "none" }
  });
  // Can
  slide.addShape("rect", {
    x: x + size * 0.1,
    y: y + size * 0.15,
    w: size * 0.8,
    h: size * 0.85,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
}

function drawEdit(slide: any, x: number, y: number, size: number, color: string): void {
  // Pencil
  slide.addShape("line", {
    x: x + size * 0.1,
    y: y + size * 0.9,
    w: size * 0.8,
    h: -size * 0.8,
    line: { color, width: 2 }
  });
  // Eraser
  slide.addShape("rect", {
    x: x + size * 0.8,
    y: y + size * 0.1,
    w: size * 0.2,
    h: size * 0.2,
    fill: { color },
    line: { type: "none" }
  });
}

function drawCopy(slide: any, x: number, y: number, size: number, color: string): void {
  // First rectangle
  slide.addShape("rect", {
    x,
    y,
    w: size * 0.7,
    h: size * 0.7,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Second rectangle (offset)
  slide.addShape("rect", {
    x: x + size * 0.3,
    y: y + size * 0.3,
    w: size * 0.7,
    h: size * 0.7,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
}

function drawShare(slide: any, x: number, y: number, size: number, color: string): void {
  // Nodes
  slide.addShape("ellipse", {
    x: x + size * 0.35,
    y,
    w: size * 0.3,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
  slide.addShape("ellipse", {
    x,
    y: y + size * 0.6,
    w: size * 0.3,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
  slide.addShape("ellipse", {
    x: x + size * 0.7,
    y: y + size * 0.6,
    w: size * 0.3,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
}

function drawPlay(slide: any, x: number, y: number, size: number, color: string): void {
  // Triangle
  slide.addShape("triangle", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawPause(slide: any, x: number, y: number, size: number, color: string): void {
  // Bar 1
  slide.addShape("rect", {
    x: x + size * 0.2,
    y,
    w: size * 0.15,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
  // Bar 2
  slide.addShape("rect", {
    x: x + size * 0.65,
    y,
    w: size * 0.15,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawStop(slide: any, x: number, y: number, size: number, color: string): void {
  // Square
  slide.addShape("rect", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

function drawVolume(slide: any, x: number, y: number, size: number, color: string): void {
  // Speaker
  slide.addShape("triangle", {
    x: x + size * 0.1,
    y: y + size * 0.2,
    w: size * 0.3,
    h: size * 0.6,
    fill: { color },
    line: { type: "none" }
  });
  // Wave
  slide.addShape("arc", {
    x: x + size * 0.4,
    y: y + size * 0.1,
    w: size * 0.5,
    h: size * 0.8,
    line: { color, width: 2 },
    fill: { type: "none" }
  });
}

function drawWifi(slide: any, x: number, y: number, size: number, color: string): void {
  // Dot
  slide.addShape("ellipse", {
    x: x + size * 0.4,
    y: y + size * 0.8,
    w: size * 0.2,
    h: size * 0.2,
    fill: { color },
    line: { type: "none" }
  });
  // Arcs
  for (let i = 1; i <= 2; i++) {
    slide.addShape("arc", {
      x: x + size * (0.5 - i * 0.15),
      y: y + size * (0.8 - i * 0.15),
      w: size * (0.3 + i * 0.3),
      h: size * (0.3 + i * 0.3),
      line: { color, width: 2 },
      fill: { type: "none" }
    });
  }
}

function drawBattery(slide: any, x: number, y: number, size: number, color: string): void {
  // Battery body
  slide.addShape("rect", {
    x,
    y: y + size * 0.2,
    w: size * 0.8,
    h: size * 0.6,
    fill: { type: "none" },
    line: { color, width: 2 }
  });
  // Terminal
  slide.addShape("rect", {
    x: x + size * 0.8,
    y: y + size * 0.35,
    w: size * 0.2,
    h: size * 0.3,
    fill: { color },
    line: { type: "none" }
  });
  // Charge level
  slide.addShape("rect", {
    x: x + size * 0.05,
    y: y + size * 0.3,
    w: size * 0.6,
    h: size * 0.4,
    fill: { color },
    line: { type: "none" }
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/index.ts
=================================================================================
/**
 * PPTX Builder Module
 * Exports all PPTX building utilities
 */

export * from "./designTokenMapper";
export * from "./patterns";
export * from "./slideBuilder";
export * from "./chartBuilder";
export * from "./premiumComponents";
export * from "./shapeHelpers";
export * from "./advancedShapes";
export * from "./enhancedDataViz";
export * from "./iconLibrary";
export * from "./enhancedAnimations";
export * from "./whitespaceManager";
export * from "./professionalTemplates";
export * from "./designAccents";

// Re-export commonly used functions
export {
  buildProfessionalSlide,
  buildProfessionalSlide as buildSlide
} from "./slideBuilder";

export {
  buildChart,
  buildBarChart,
  buildLineChart,
  buildPieChart,
  buildAreaChart,
  validateChartConfig,
  getRecommendedChartType
} from "./chartBuilder";

export {
  getRegionsForPattern,
  validatePatternRegions,
  calculateWhitespacePercentage
} from "./patterns";

export {
  addConnectorArrow,
  addCalloutBox,
  addProcessFlow,
  addMetricCard,
} from "./shapeHelpers";

export {
  mapColorPalette,
  mapTypography,
  mapShadows,
  mapSpacing,
  mapRadii,
  getCompleteTokenMap,
  validateDesignTokens
} from "./designTokenMapper";

// Advanced shapes
export {
  addDirectionalArrow,
  addCurvedConnector,
  addProgressBar,
  addStepIndicator,
  addComparisonBox,
  addHighlightBadge,
  addEmphasisBackground,
  addVerticalDivider,
  addHorizontalDivider
} from "./advancedShapes";

// Enhanced data visualization
export {
  addChartHeader,
  addChartAnnotations,
  addCustomLegend,
  addMetricHighlight,
  addTrendIndicator,
  addComparisonBar
} from "./enhancedDataViz";

// Icon library
export {
  addIcon,
  type IconType
} from "./iconLibrary";

// Enhanced animations
export {
  createAnimation,
  getRecommendedAnimation,
  getAnimationDuration,
  createStaggerConfig,
  getEasingCurve,
  calculateSequenceTiming,
  getAnimationPreset,
  validateAnimationConfig,
  getAnimationMetadata,
  type AnimationType,
  type AnimationConfig,
  type StaggerConfig
} from "./enhancedAnimations";

// Whitespace management
export {
  getSpacing,
  createUniformPadding,
  createUniformMargin,
  createCustomPadding,
  createCustomMargin,
  calculateContentWidth,
  calculateContentHeight,
  getRecommendedLineHeight,
  getRecommendedParagraphSpacing,
  calculateVerticalRhythm,
  getBreathingRoomPercentage,
  validateBreathingRoom,
  getContentMargin,
  getContainerPadding,
  calculateGridGap,
  calculateColumnWidth,
  getRecommendedSectionSpacing,
  getOptimalSlideMargins,
  getTextBoxPadding,
  getListItemSpacing,
  getElementSpacing,
  validateLayoutSpacing,
  SPACING_SCALE,
  type SpacingConfig,
  type PaddingConfig,
  type MarginConfig
} from "./whitespaceManager";

// Professional templates
export {
  getAllTemplates,
  getTemplate,
  getTemplatesByUseCase,
  getTemplateLayout,
  getRecommendedTemplate,
  validateTemplate,
  createCustomTemplate,
  getTemplateStats,
  TITLE_SLIDE_TEMPLATE,
  CONTENT_SLIDE_TEMPLATE,
  TWO_COLUMN_TEMPLATE,
  THREE_COLUMN_TEMPLATE,
  DATA_VIZ_TEMPLATE,
  IMAGE_FOCUS_TEMPLATE,
  TIMELINE_TEMPLATE,
  CENTERED_FOCUS_TEMPLATE,
  SIDEBAR_TEMPLATE,
  STACKED_TEMPLATE,
  MINIMAL_TEMPLATE,
  FULL_BLEED_TEMPLATE,
  type TemplateConfig,
  type TemplateLayout
} from "./professionalTemplates";



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/layoutBuilder.ts
=================================================================================
/**
 * Layout-Based PPTX Builder
 * Uses the spec's layout grid system to properly position and size content
 * Prevents overlapping text and ensures professional formatting
 */

import PptxGenJS from "pptxgenjs";
import type { SlideSpecV1 } from "../types/SlideSpecV1";
import { logger } from "firebase-functions/v2";

const SLIDE_WIDTH = 10; // inches
const SLIDE_HEIGHT = 7.5; // inches

/**
 * Convert pixels to inches
 */
function pxToIn(px: number): number {
  return (px * 0.75) / 72;
}

/**
 * Build slide using layout grid system
 */
export async function buildLayoutSlide(
  pptx: PptxGenJS,
  spec: SlideSpecV1
): Promise<void> {
  const slide = pptx.addSlide();

  try {
    logger.info("üé® Layout builder starting", {
      hasTitle: !!spec.content.title,
      hasSubtitle: !!spec.content.subtitle,
      anchorsCount: spec.layout.anchors.length,
    });

    // Apply background
    applyBackground(slide, spec);

    // Calculate grid dimensions
    const { rows, cols, gutter, margin } = spec.layout.grid;
    const marginTop = pxToIn(margin.t);
    const marginRight = pxToIn(margin.r);
    const marginBottom = pxToIn(margin.b);
    const marginLeft = pxToIn(margin.l);
    const gutterIn = pxToIn(gutter);

    const gridWidth = SLIDE_WIDTH - marginLeft - marginRight;
    const gridHeight = SLIDE_HEIGHT - marginTop - marginBottom;
    const cellWidth = (gridWidth - (cols - 1) * gutterIn) / cols;
    const cellHeight = (gridHeight - (rows - 1) * gutterIn) / rows;

    // Create region map
    const regions: Record<string, any> = {};
    spec.layout.regions.forEach((region) => {
      const x = marginLeft + (region.colStart - 1) * (cellWidth + gutterIn);
      const y = marginTop + (region.rowStart - 1) * (cellHeight + gutterIn);
      const w = region.colSpan * cellWidth + (region.colSpan - 1) * gutterIn;
      const h = region.rowSpan * cellHeight + (region.rowSpan - 1) * gutterIn;

      regions[region.name] = { x, y, w, h };
    });

    // Get style tokens
    const palette = spec.styleTokens.palette;
    const typography = spec.styleTokens.typography;
    const textColor = palette.neutral[0] || "#0F172A";
    const subtitleColor = palette.neutral[2] || "#334155";
    const primaryColor = palette.primary || "#6366F1";

    const titleSize = typography?.sizes?.step_3 || 44;
    const subtitleSize = typography?.sizes?.step_1 || 22;
    const bodySize = typography?.sizes?.step_0 || 18;

    // Group anchors by region to handle stacking
    const anchorsByRegion: Record<string, any[]> = {};
    spec.layout.anchors.forEach((anchor) => {
      if (!anchorsByRegion[anchor.region]) {
        anchorsByRegion[anchor.region] = [];
      }
      anchorsByRegion[anchor.region].push(anchor);
    });

    // Render content by region, stacking multiple anchors vertically
    Object.entries(anchorsByRegion).forEach(([regionName, anchors]) => {
      const region = regions[regionName];
      if (!region) return;

      let currentY = region.y;
      const regionHeight = region.h;
      let usedHeight = 0;

      // Sort anchors by order
      anchors.sort((a, b) => a.order - b.order);

      anchors.forEach((anchor) => {
        // Title
        if (anchor.refId === spec.content.title?.id) {
          // Calculate title height based on text length and width
          const titleText = spec.content.title.text;
          const estimatedLines = Math.ceil(titleText.length / 40); // Rough estimate
          const titleHeight = Math.max(0.6, estimatedLines * (titleSize / 72) * 1.5); // Convert to inches

          logger.info("üìù Rendering title", {
            text: titleText.substring(0, 50),
            y: currentY,
            height: titleHeight,
            fontSize: titleSize,
            estimatedLines,
          });
          slide.addText(spec.content.title.text, {
            x: region.x,
            y: currentY,
            w: region.w,
            h: titleHeight,
            fontSize: titleSize,
            bold: true,
            color: primaryColor.replace("#", ""),
            fontFace: "Aptos",
            align: "left",
            valign: "top",
            wrap: true,
          });
          currentY += titleHeight + 0.15; // Add gap between title and subtitle
          usedHeight += titleHeight + 0.15;
          return;
        }

        // Subtitle
        if (anchor.refId === spec.content.subtitle?.id && spec.content.subtitle) {
          // Calculate subtitle height based on text length and width
          const subtitleText = spec.content.subtitle.text;
          const estimatedLines = Math.ceil(subtitleText.length / 50); // Rough estimate
          const subtitleHeight = Math.max(0.4, estimatedLines * (subtitleSize / 72) * 1.5); // Convert to inches

          logger.info("üìù Rendering subtitle", {
            text: subtitleText.substring(0, 50),
            y: currentY,
            height: subtitleHeight,
            fontSize: subtitleSize,
            estimatedLines,
          });
          slide.addText(spec.content.subtitle.text, {
            x: region.x,
            y: currentY,
            w: region.w,
            h: subtitleHeight,
            fontSize: subtitleSize,
            color: subtitleColor.replace("#", ""),
            fontFace: "Aptos",
            align: "left",
            valign: "top",
            wrap: true,
          });
          currentY += subtitleHeight + 0.15; // Add gap
          usedHeight += subtitleHeight + 0.15;
          return;
        }

        // Bullets
        const bulletList = spec.content.bullets?.find((b) => b.id === anchor.refId);
        if (bulletList) {
          const bulletTexts = bulletList.items.map((item) => ({
            text: item.text,
            options: {
              bullet: true,
              indentLevel: Math.max(0, item.level - 1),
            },
          }));

          const bulletHeight = Math.min(regionHeight - usedHeight, bulletList.items.length * bodySize * 1.5);
          slide.addText(bulletTexts, {
            x: region.x,
            y: currentY,
            w: region.w,
            h: bulletHeight,
            fontSize: bodySize,
            color: textColor.replace("#", ""),
            fontFace: "Aptos",
            align: "left",
            valign: "top",
            wrap: true,
          });
          return;
        }

        // Callouts
        const callout = spec.content.callouts?.find((c) => c.id === anchor.refId);
        if (callout) {
          const bgColor =
            callout.variant === "warning"
              ? "FEF3C7"
              : callout.variant === "danger"
                ? "FEE2E2"
                : callout.variant === "success"
                  ? "D1FAE5"
                  : "F3F4F6";

          const calloutHeight = Math.min(regionHeight - usedHeight, 1.0);
          slide.addShape("rect", {
            x: region.x,
            y: currentY,
            w: region.w,
            h: calloutHeight,
            fill: { color: bgColor },
            line: { color: primaryColor.replace("#", ""), width: 2 },
          });

          const calloutText = callout.title
            ? `${callout.title} ‚Äî ${callout.text}`
            : callout.text;

          slide.addText(calloutText, {
            x: region.x + 0.2,
            y: currentY + 0.1,
            w: region.w - 0.4,
            h: calloutHeight - 0.2,
            fontSize: bodySize - 2,
            color: textColor.replace("#", ""),
            fontFace: "Aptos",
            align: "left",
            valign: "top",
            wrap: true,
          });
          return;
        }
      });
    });
  } catch (error) {
    logger.error("‚ùå Error building layout slide:", {
      error: String(error),
      message: error instanceof Error ? error.message : "Unknown error",
      stack: error instanceof Error ? error.stack : undefined,
    });
    throw error;
  }
}

/**
 * Apply background with subtle gradient
 */
function applyBackground(slide: any, spec: SlideSpecV1): void {
  const palette = spec.styleTokens.palette;
  const neutralLight = palette.neutral[8] || "#F8FAFC";

  slide.background = { fill: neutralLight.replace("#", "") };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/minimalBuilder.ts
=================================================================================
/**
 * Professional PPTX Builder
 * Creates beautiful, professional PowerPoint slides with subtle accents, shapes, and modern design
 */

import PptxGenJS from "pptxgenjs";
import type { SlideSpecV1 } from "../types/SlideSpecV1";
import { processImageSource, getOptimalImageDimensions } from "../imageHelpers";
import { logger } from "firebase-functions/v2";
import {
  addAccentBar,
  addDecorativeCircle,
  addPremiumDivider,
  addCornerAccent
} from "./premiumComponents";

/**
 * Build a professional slide with beautiful design elements
 */
export async function buildMinimalSlide(
  pptx: PptxGenJS,
  spec: SlideSpecV1
): Promise<void> {
  const slide = pptx.addSlide();

  // Apply subtle gradient background for modern, professional look
  applyGradientBackground(slide, spec);

  // Add professional design accents
  addProfessionalAccents(slide, spec);

  // Add title with enhanced styling
  const title = spec.content.title;
  if (title && title.text) {
    slide.addText(title.text, {
      x: 0.5,
      y: 0.5,
      w: 9,
      h: 0.6,
      fontFace: "Aptos",
      fontSize: 32,
      bold: true,
      color: "0F172A",
      align: "left",
      valign: "top"
    });

    // Add subtle accent line under title
    const primaryColor = spec.styleTokens.palette.primary.replace("#", "");
    addPremiumDivider(slide, 0.5, 1.15, 2.5, primaryColor, 0.04);
  }

  // Add subtitle with refined styling
  const subtitle = spec.content.subtitle;
  if (subtitle && subtitle.text) {
    slide.addText(subtitle.text, {
      x: 0.5,
      y: 1.3,
      w: 9,
      h: 0.4,
      fontFace: "Aptos",
      fontSize: 18,
      color: "64748B",
      align: "left",
      valign: "top"
    });
  }

  // Add bullets with enhanced styling and subtle accents
  const bullets = spec.content.bullets?.[0];
  if (bullets && bullets.items && bullets.items.length > 0) {
    const primaryColor = spec.styleTokens.palette.primary.replace("#", "");
    let currentY = subtitle ? 2.0 : 1.8;
    const lineHeight = 0.4;

    for (let i = 0; i < bullets.items.length; i++) {
      const item = bullets.items[i];

      // Add subtle accent circle for each bullet
      addDecorativeCircle(slide, 0.55, currentY + 0.05, 0.12, primaryColor, 0.2);

      // Add bullet text with professional styling
      slide.addText(item.text, {
        x: 0.85,
        y: currentY,
        w: 8.65,
        h: lineHeight,
        fontFace: "Aptos",
        fontSize: 18,
        color: "1E293B",
        align: "left",
        valign: "top",
        wrap: true
      });

      currentY += lineHeight + 0.1;
    }
  }

  // Add images if present
  const images = spec.content.images;
  if (images && images.length > 0) {
    for (const image of images) {
      try {
        const imageData = await processImageSource(image.source);
        if (imageData) {
          const dimensions = getOptimalImageDimensions(image.role);

          // If imageData is a string (data URL), use it directly
          if (typeof imageData === "string") {
            const fitType = (image.fit === "fill" ? "cover" : image.fit) || "cover";
            slide.addImage({
              data: imageData,
              x: dimensions.x,
              y: dimensions.y,
              w: dimensions.w,
              h: dimensions.h,
              sizing: { type: fitType as "cover" | "contain" | "crop", w: dimensions.w, h: dimensions.h }
            });
          } else {
            // If imageData is ProcessedImage, convert buffer to base64
            const base64 = imageData.data.toString("base64");
            const dataUrl = `data:${imageData.mimeType};base64,${base64}`;
            const fitType = (image.fit === "fill" ? "cover" : image.fit) || "cover";

            slide.addImage({
              data: dataUrl,
              x: dimensions.x,
              y: dimensions.y,
              w: dimensions.w,
              h: dimensions.h,
              sizing: { type: fitType as "cover" | "contain" | "crop", w: dimensions.w, h: dimensions.h }
            });
          }
        }
      } catch (error) {
        logger.warn(`Failed to add image ${image.id}:`, error);
        // Continue with other images
      }
    }
  }
}

/**
 * Add professional design accents to the slide
 * Includes subtle shapes, lines, and decorative elements
 */
function addProfessionalAccents(slide: any, spec: SlideSpecV1): void {
  const primaryColor = spec.styleTokens.palette.primary.replace("#", "");
  const accentColor = spec.styleTokens.palette.accent.replace("#", "");

  // Add subtle left accent bar for visual interest
  addAccentBar(slide, {
    position: "left",
    color: primaryColor,
    thickness: 0.08
  });

  // Add decorative corner accent (top-right)
  addCornerAccent(slide, "top-right", accentColor, 0.15);

  // Add subtle decorative circles in bottom-right for depth
  addDecorativeCircle(slide, 8.8, 6.5, 0.6, primaryColor, 0.05);
  addDecorativeCircle(slide, 9.1, 6.8, 0.4, accentColor, 0.08);
}

/**
 * Apply subtle gradient background to slide
 * Creates a modern, professional look with minimal visual noise
 */
function applyGradientBackground(slide: any, spec: SlideSpecV1): void {
  // Get theme-based colors from spec
  const primaryColor = spec.styleTokens.palette.primary || "#6366F1";
  const neutralLight = spec.styleTokens.palette.neutral[6] || "#F8FAFC";
  const neutralLighter = spec.styleTokens.palette.neutral[5] || "#F1F5F9";

  // Create subtle gradient using overlapping rectangles with transparency
  // This simulates a gradient effect in PowerPoint

  // Base layer - lightest color
  slide.background = { fill: neutralLight.replace("#", "") };

  // Add subtle gradient overlay using semi-transparent shapes
  // Top-left to bottom-right gradient effect
  const gradientSteps = 5;
  const slideWidth = 10;
  const slideHeight = 7.5;

  for (let i = 0; i < gradientSteps; i++) {
    const transparency = 95 - (i * 2); // 95%, 93%, 91%, 89%, 87%
    const yPos = (slideHeight / gradientSteps) * i;
    const height = slideHeight / gradientSteps + 0.1; // Slight overlap

    slide.addShape("rect", {
      x: 0,
      y: yPos,
      w: slideWidth,
      h: height,
      fill: {
        color: neutralLighter.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }

  // Add very subtle accent gradient on the right edge for depth
  slide.addShape("rect", {
    x: slideWidth - 0.5,
    y: 0,
    w: 0.5,
    h: slideHeight,
    fill: {
      color: primaryColor.replace("#", ""),
      transparency: 97 // Very subtle
    },
    line: { type: "none" }
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/patterns.ts
=================================================================================
/**
 * Design Pattern Builders
 * Builds slide layouts based on design patterns
 */

import type { SlideSpecV2 } from "../types/SlideSpecV2";

export interface PatternRegions {
  header?: RegionRect;
  body?: RegionRect;
  footer?: RegionRect;
  aside?: RegionRect;
  left?: RegionRect;
  right?: RegionRect;
  primary?: RegionRect;
  secondary?: RegionRect;
  chart?: RegionRect;
  sidebar?: RegionRect;
  content?: RegionRect;
  item1?: RegionRect;
  item2?: RegionRect;
  item3?: RegionRect;
  item4?: RegionRect;
}

export interface RegionRect {
  x: number;
  y: number;
  w: number;
  h: number;
}

const SLIDE_WIDTH = 10;
const SLIDE_HEIGHT = 7.5;
const MARGIN = 0.5;

/**
 * Apply Hero Pattern
 * Large title/image focus with supporting content
 */
export function applyHeroPattern(spec: SlideSpecV2): PatternRegions {
  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: SLIDE_HEIGHT * 0.6 - MARGIN
    },
    body: {
      x: MARGIN,
      y: SLIDE_HEIGHT * 0.6 + MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: SLIDE_HEIGHT * 0.4 - 2 * MARGIN
    }
  };
}

/**
 * Apply Split Pattern
 * 50/50 left/right content division
 */
export function applySplitPattern(spec: SlideSpecV2): PatternRegions {
  const midpoint = SLIDE_WIDTH / 2;

  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1.5
    },
    left: {
      x: MARGIN,
      y: 2,
      w: midpoint - MARGIN - 0.25,
      h: SLIDE_HEIGHT - 2.5
    },
    right: {
      x: midpoint + 0.25,
      y: 2,
      w: midpoint - MARGIN - 0.25,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Asymmetric Pattern
 * Dynamic off-center layout with visual balance
 */
export function applyAsymmetricPattern(spec: SlideSpecV2): PatternRegions {
  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1.2
    },
    primary: {
      x: MARGIN,
      y: 1.8,
      w: SLIDE_WIDTH * 0.65 - MARGIN,
      h: SLIDE_HEIGHT - 2.3
    },
    secondary: {
      x: SLIDE_WIDTH * 0.65 + 0.25,
      y: 1.8,
      w: SLIDE_WIDTH * 0.35 - MARGIN - 0.25,
      h: SLIDE_HEIGHT - 2.3
    }
  };
}

/**
 * Apply Grid Pattern
 * Structured multi-element layout (2x2 grid)
 */
export function applyGridPattern(spec: SlideSpecV2): PatternRegions {
  const itemWidth = (SLIDE_WIDTH - 2 * MARGIN - 0.25) / 2;
  const itemHeight = (SLIDE_HEIGHT - 2.3) / 2;

  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1.2
    },
    item1: {
      x: MARGIN,
      y: 1.8,
      w: itemWidth,
      h: itemHeight
    },
    item2: {
      x: SLIDE_WIDTH / 2 + 0.25,
      y: 1.8,
      w: itemWidth,
      h: itemHeight
    },
    item3: {
      x: MARGIN,
      y: SLIDE_HEIGHT / 2 + 0.8,
      w: itemWidth,
      h: itemHeight
    },
    item4: {
      x: SLIDE_WIDTH / 2 + 0.25,
      y: SLIDE_HEIGHT / 2 + 0.8,
      w: itemWidth,
      h: itemHeight
    }
  };
}

/**
 * Apply Minimal Pattern
 * Single focal point with generous white space
 */
export function applyMinimalPattern(spec: SlideSpecV2): PatternRegions {
  return {
    content: {
      x: SLIDE_WIDTH * 0.2,
      y: SLIDE_HEIGHT * 0.25,
      w: SLIDE_WIDTH * 0.6,
      h: SLIDE_HEIGHT * 0.5
    }
  };
}

/**
 * Apply Data-Focused Pattern
 * Chart/data as primary focus with supporting text
 */
export function applyDataFocusedPattern(spec: SlideSpecV2): PatternRegions {
  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 0.8
    },
    chart: {
      x: MARGIN,
      y: 1.2,
      w: SLIDE_WIDTH * 0.65 - MARGIN,
      h: SLIDE_HEIGHT - 1.7
    },
    sidebar: {
      x: SLIDE_WIDTH * 0.65 + 0.25,
      y: 1.2,
      w: SLIDE_WIDTH * 0.35 - MARGIN - 0.25,
      h: SLIDE_HEIGHT - 1.7
    }
  };
}

/**
 * Get regions for pattern
 */
export function getRegionsForPattern(pattern: string, spec: SlideSpecV2): PatternRegions {
  switch (pattern) {
    case "hero":
      return applyHeroPattern(spec);
    case "split":
      return applySplitPattern(spec);
    case "asymmetric":
      return applyAsymmetricPattern(spec);
    case "grid":
      return applyGridPattern(spec);
    case "minimal":
      return applyMinimalPattern(spec);
    case "data-focused":
      return applyDataFocusedPattern(spec);
    case "sidebar":
      return applySidebarPattern(spec);
    case "three-column":
      return applyThreeColumnPattern(spec);
    case "two-column-accent":
      return applyTwoColumnAccentPattern(spec);
    case "timeline":
      return applyTimelinePattern(spec);
    case "centered":
      return applyCenteredPattern(spec);
    case "full-bleed":
      return applyFullBleedPattern(spec);
    case "comparison":
      return applyComparisonPattern(spec);
    case "stacked":
      return applyStackedPattern(spec);
    default:
      return applySplitPattern(spec);
  }
}

/**
 * Validate pattern regions
 */
export function validatePatternRegions(regions: PatternRegions): boolean {
  for (const region of Object.values(regions)) {
    if (!region) continue;

    if (
      region.x < 0 ||
      region.y < 0 ||
      region.w <= 0 ||
      region.h <= 0 ||
      region.x + region.w > SLIDE_WIDTH ||
      region.y + region.h > SLIDE_HEIGHT
    ) {
      return false;
    }
  }

  return true;
}

/**
 * Get region by name
 */
export function getRegion(regions: PatternRegions, name: string): RegionRect | undefined {
  return regions[name as keyof PatternRegions];
}

/**
 * Calculate total used area
 */
export function calculateUsedArea(regions: PatternRegions): number {
  let total = 0;

  for (const region of Object.values(regions)) {
    if (region) {
      total += region.w * region.h;
    }
  }

  return total;
}

/**
 * Calculate white space percentage
 */
export function calculateWhitespacePercentage(regions: PatternRegions): number {
  const totalArea = SLIDE_WIDTH * SLIDE_HEIGHT;
  const usedArea = calculateUsedArea(regions);
  const whiteSpace = totalArea - usedArea;

  return (whiteSpace / totalArea) * 100;
}

/**
 * Apply Sidebar Pattern
 * Content with prominent sidebar for navigation or key points
 */
export function applySidebarPattern(spec: SlideSpecV2): PatternRegions {
  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1
    },
    sidebar: {
      x: MARGIN,
      y: 1.5 + MARGIN,
      w: 2,
      h: SLIDE_HEIGHT - 2.5
    },
    content: {
      x: 2.5 + MARGIN,
      y: 1.5 + MARGIN,
      w: SLIDE_WIDTH - 3.5 - 2 * MARGIN,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Three Column Pattern
 * Equal three-column layout for comparison or features
 */
export function applyThreeColumnPattern(spec: SlideSpecV2): PatternRegions {
  const colWidth = (SLIDE_WIDTH - 2 * MARGIN - 0.4) / 3;

  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1
    },
    item1: {
      x: MARGIN,
      y: 1.5 + MARGIN,
      w: colWidth,
      h: SLIDE_HEIGHT - 2.5
    },
    item2: {
      x: MARGIN + colWidth + 0.2,
      y: 1.5 + MARGIN,
      w: colWidth,
      h: SLIDE_HEIGHT - 2.5
    },
    item3: {
      x: MARGIN + (colWidth + 0.2) * 2,
      y: 1.5 + MARGIN,
      w: colWidth,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Two Column Pattern with Accent
 * Two columns with accent bar on the side
 */
export function applyTwoColumnAccentPattern(spec: SlideSpecV2): PatternRegions {
  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1
    },
    left: {
      x: MARGIN,
      y: 1.5 + MARGIN,
      w: (SLIDE_WIDTH - 2 * MARGIN - 0.3) / 2,
      h: SLIDE_HEIGHT - 2.5
    },
    right: {
      x: MARGIN + (SLIDE_WIDTH - 2 * MARGIN - 0.3) / 2 + 0.3,
      y: 1.5 + MARGIN,
      w: (SLIDE_WIDTH - 2 * MARGIN - 0.3) / 2,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Timeline Pattern
 * Horizontal timeline layout for processes or history
 */
export function applyTimelinePattern(spec: SlideSpecV2): PatternRegions {
  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1
    },
    item1: {
      x: MARGIN,
      y: 2,
      w: (SLIDE_WIDTH - 2 * MARGIN) / 4,
      h: SLIDE_HEIGHT - 2.5
    },
    item2: {
      x: MARGIN + (SLIDE_WIDTH - 2 * MARGIN) / 4,
      y: 2,
      w: (SLIDE_WIDTH - 2 * MARGIN) / 4,
      h: SLIDE_HEIGHT - 2.5
    },
    item3: {
      x: MARGIN + (SLIDE_WIDTH - 2 * MARGIN) / 2,
      y: 2,
      w: (SLIDE_WIDTH - 2 * MARGIN) / 4,
      h: SLIDE_HEIGHT - 2.5
    },
    item4: {
      x: MARGIN + (SLIDE_WIDTH - 2 * MARGIN) * 0.75,
      y: 2,
      w: (SLIDE_WIDTH - 2 * MARGIN) / 4,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Centered Pattern
 * Centered content with maximum focus
 */
export function applyCenteredPattern(spec: SlideSpecV2): PatternRegions {
  const contentWidth = SLIDE_WIDTH * 0.6;
  const contentX = (SLIDE_WIDTH - contentWidth) / 2;

  return {
    header: {
      x: contentX,
      y: MARGIN,
      w: contentWidth,
      h: 1.5
    },
    content: {
      x: contentX,
      y: 2,
      w: contentWidth,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Full Bleed Pattern
 * Content extends to edges for maximum impact
 */
export function applyFullBleedPattern(spec: SlideSpecV2): PatternRegions {
  return {
    content: {
      x: 0,
      y: 0,
      w: SLIDE_WIDTH,
      h: SLIDE_HEIGHT
    }
  };
}

/**
 * Apply Comparison Pattern
 * Side-by-side comparison with divider
 */
export function applyComparisonPattern(spec: SlideSpecV2): PatternRegions {
  const midpoint = SLIDE_WIDTH / 2;

  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1
    },
    left: {
      x: MARGIN,
      y: 1.5 + MARGIN,
      w: midpoint - MARGIN - 0.15,
      h: SLIDE_HEIGHT - 2.5
    },
    right: {
      x: midpoint + 0.15,
      y: 1.5 + MARGIN,
      w: midpoint - MARGIN - 0.15,
      h: SLIDE_HEIGHT - 2.5
    }
  };
}

/**
 * Apply Stacked Pattern
 * Vertical stacking of content sections
 */
export function applyStackedPattern(spec: SlideSpecV2): PatternRegions {
  const sectionHeight = (SLIDE_HEIGHT - 2 * MARGIN - 1) / 3;

  return {
    header: {
      x: MARGIN,
      y: MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: 1
    },
    item1: {
      x: MARGIN,
      y: 1 + MARGIN,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: sectionHeight
    },
    item2: {
      x: MARGIN,
      y: 1 + MARGIN + sectionHeight,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: sectionHeight
    },
    item3: {
      x: MARGIN,
      y: 1 + MARGIN + sectionHeight * 2,
      w: SLIDE_WIDTH - 2 * MARGIN,
      h: sectionHeight
    }
  };
}

/**
 * Get all available patterns
 */
export function getAllPatterns(): string[] {
  return [
    "hero",
    "split",
    "asymmetric",
    "grid",
    "minimal",
    "data-focused",
    "sidebar",
    "three-column",
    "two-column-accent",
    "timeline",
    "centered",
    "full-bleed",
    "comparison",
    "stacked"
  ];
}

/**
 * Get pattern description
 */
export function getPatternDescription(pattern: string): string {
  const descriptions: Record<string, string> = {
    hero: "Large hero section with supporting content below",
    split: "50/50 left-right content division",
    asymmetric: "Dynamic off-center layout with visual balance",
    grid: "4-item grid layout for equal content",
    minimal: "Minimal layout with maximum whitespace",
    "data-focused": "Optimized for charts and data visualization",
    sidebar: "Content with prominent sidebar",
    "three-column": "Three equal columns for comparison",
    "two-column-accent": "Two columns with accent divider",
    timeline: "Horizontal timeline for processes",
    centered: "Centered content with maximum focus",
    "full-bleed": "Content extends to edges",
    comparison: "Side-by-side comparison layout",
    stacked: "Vertically stacked content sections"
  };

  return descriptions[pattern] || "Unknown pattern";
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/premiumBuilder.ts
=================================================================================
/**
 * Premium PPTX Builder
 * Creates world-class professional PowerPoint slides with sophisticated design
 * Combines best practices from Apple, Google, Tesla, and ChatGPT design systems
 */

import PptxGenJS from "pptxgenjs";
import type { SlideSpecV1 } from "../types/SlideSpecV1";
import { logger } from "firebase-functions/v2";
import {
  addAccentBar,
  addDecorativeCircle,
  addPremiumDivider,
  addCornerAccent,
  addMetricCard,
  addStatBlock,
  addFeatureHighlight,
  addGradientAccentBar,
  addProcessFlow,
  addArrow
} from "./premiumComponents";
import {
  addDirectionalArrow,
  addProgressBar,
  addStepIndicator,
  addHighlightBadge,
  addEmphasisBackground,
  addVerticalDivider,
  addHorizontalDivider
} from "./advancedShapes";
import {
  addChartHeader,
  addMetricHighlight,
  addTrendIndicator
} from "./enhancedDataViz";
import { applyDesignPattern, getRecommendedPattern } from "./advancedPatterns";
import {
  addGradientOverlay,
  addCornerFlourish,
  addLineAccent,
  addFrameAccent
} from "./designAccents";

const SLIDE_WIDTH = 10; // inches
const SLIDE_HEIGHT = 7.5; // inches (4:3 aspect ratio)

/**
 * Build a premium world-class slide
 */
export async function buildPremiumSlide(
  pptx: PptxGenJS,
  spec: SlideSpecV1
): Promise<void> {
  const slide = pptx.addSlide();

  try {
    // Apply sophisticated background
    applyPremiumBackground(slide, spec);

    // Determine and apply design pattern
    const pattern = getRecommendedPattern(spec);
    applyDesignPattern(slide, spec, pattern);

    // Add content with refined typography
    await addPremiumContent(slide, spec);
  } catch (error) {
    logger.error("Error building premium slide:", error);
    throw error;
  }
}

/**
 * Apply sophisticated gradient background with depth
 */
function applyPremiumBackground(slide: any, spec: SlideSpecV1): void {
  const palette = spec.styleTokens.palette;
  const primaryColor = palette.primary || "#6366F1";
  const accentColor = palette.accent || "#EC4899";
  const neutralLight = palette.neutral[6] || "#F8FAFC";

  // Base background - light neutral
  slide.background = { fill: neutralLight.replace("#", "") };

  // Add sophisticated gradient overlay
  addGradientOverlay(slide, primaryColor, accentColor, 0.03, "diagonal");

  // Add subtle corner flourishes for visual interest
  addCornerFlourish(slide, "top-right", accentColor, 0.35);
  addCornerFlourish(slide, "bottom-left", primaryColor, 0.3);

  // Add subtle line accents
  addLineAccent(slide, "top", accentColor, 0.06);
}



/**
 * Add premium content with refined typography
 */
async function addPremiumContent(slide: any, spec: SlideSpecV1): Promise<void> {
  const palette = spec.styleTokens.palette;
  const typography = spec.styleTokens.typography;

  const textColor = palette.neutral[0] || "#0F172A";
  const subtitleColor = palette.neutral[2] || "#64748B";
  const primaryColor = palette.primary || "#6366F1";

  const titleSize = typography?.sizes?.step_3 || 44;
  const subtitleSize = typography?.sizes?.step_1 || 22;
  const bodySize = typography?.sizes?.step_0 || 18;

  let currentY = 0.6;

  // Add title with premium styling
  if (spec.content.title) {
    slide.addText(spec.content.title.text, {
      x: 0.7,
      y: currentY,
      w: SLIDE_WIDTH - 1.4,
      h: 1.0,
      fontSize: titleSize,
      bold: true,
      color: textColor.replace("#", ""),
      fontFace: "Aptos",
      align: "left",
      valign: "top",
      lineSpacing: 110
    });

    // Premium divider under title
    addPremiumDivider(slide, 0.7, currentY + 0.95, 2.8, primaryColor.replace("#", ""), 0.05);
    currentY += 1.4;
  }

  // Add subtitle
  if (spec.content.subtitle) {
    slide.addText(spec.content.subtitle.text, {
      x: 0.7,
      y: currentY,
      w: SLIDE_WIDTH - 1.4,
      h: 0.6,
      fontSize: subtitleSize,
      color: subtitleColor.replace("#", ""),
      fontFace: "Aptos",
      align: "left",
      valign: "top",
      lineSpacing: 130
    });
    currentY += 0.9;
  }

  // Add bullets with premium styling
  if (spec.content.bullets && spec.content.bullets.length > 0) {
    const bullets = spec.content.bullets[0];
    const bulletColor = primaryColor.replace("#", "");

    bullets.items.forEach((item, index) => {
      // Add subtle background for emphasis
      if (index === 0) {
        addEmphasisBackground(slide, 0.6, currentY - 0.05, SLIDE_WIDTH - 1.2, 0.5, primaryColor, 0.04);
      }

      // Decorative bullet circle with step indicator for first few items
      if (index < 3) {
        addStepIndicator(slide, 0.65, currentY + 0.05, index + 1, bullets.items.length, bulletColor, 0.25);
      } else {
        addDecorativeCircle(slide, 0.65, currentY + 0.08, 0.14, bulletColor, 0.25);
      }

      // Bullet text
      slide.addText(item.text, {
        x: 0.95,
        y: currentY,
        w: SLIDE_WIDTH - 1.65,
        h: 0.4,
        fontSize: bodySize,
        color: textColor.replace("#", ""),
        fontFace: "Aptos",
        align: "left",
        valign: "top",
        wrap: true
      });

      currentY += 0.5;
    });
  }

  // Add callouts if present
  if (spec.content.callouts && spec.content.callouts.length > 0) {
    for (const callout of spec.content.callouts) {
      const bgColor = callout.variant === "warning" ? "FEF3C7" :
                      callout.variant === "danger" ? "FEE2E2" :
                      callout.variant === "success" ? "D1FAE5" : "F3F4F6";

      // Add subtle frame accent
      addFrameAccent(slide, 0.65, currentY - 0.05, SLIDE_WIDTH - 1.3, 0.7, primaryColor, 0.04);

      slide.addShape("roundRect", {
        x: 0.7,
        y: currentY,
        w: SLIDE_WIDTH - 1.4,
        h: 0.6,
        fill: { color: bgColor },
        line: { color: primaryColor.replace("#", ""), width: 2 }
      });

      const calloutText = callout.title ? `${callout.title} ‚Äî ${callout.text}` : callout.text;
      slide.addText(calloutText, {
        x: 0.9,
        y: currentY + 0.1,
        w: SLIDE_WIDTH - 1.8,
        h: 0.4,
        fontSize: bodySize - 2,
        color: textColor.replace("#", ""),
        fontFace: "Aptos",
        align: "left",
        valign: "middle",
        wrap: true
      });

      currentY += 0.8;
    }
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/premiumComponents.ts
=================================================================================
/**
 * Premium UI Components for Professional PowerPoint Slides
 * Provides sophisticated, production-ready components
 */

import PptxGenJS from "pptxgenjs";

export interface BadgeConfig {
  text: string;
  color: string;
  backgroundColor: string;
  x: number;
  y: number;
  width?: number;
  height?: number;
}

export interface AccentBarConfig {
  position: "top" | "bottom" | "left" | "right";
  color: string;
  thickness: number;
}

export interface DecorativeElementConfig {
  type: "circle" | "line" | "accent-bar" | "corner-accent";
  color: string;
  x: number;
  y: number;
  width?: number;
  height?: number;
}

/**
 * Add a professional badge/tag to the slide
 */
export function addPremiumBadge(
  slide: any,
  config: BadgeConfig
): void {
  const width = config.width || 1.2;
  const height = config.height || 0.35;

  // Badge background
  slide.addShape("roundRect", {
    x: config.x,
    y: config.y,
    w: width,
    h: height,
    fill: { color: config.backgroundColor },
    line: { color: config.color, width: 1.5 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 4,
      offset: 1
    }
  });

  // Badge text
  slide.addText(config.text, {
    x: config.x,
    y: config.y,
    w: width,
    h: height,
    fontSize: 10,
    bold: true,
    color: config.color,
    align: "center",
    valign: "middle",
    fontFace: "Inter, Arial, sans-serif"
  });
}

/**
 * Add an accent bar for visual emphasis
 */
export function addAccentBar(
  slide: any,
  config: AccentBarConfig
): void {
  const slideWidth = 10;
  const slideHeight = 7.5;

  let x = 0, y = 0, w = slideWidth, h = config.thickness;

  switch (config.position) {
    case "top":
      x = 0;
      y = 0;
      w = slideWidth;
      h = config.thickness;
      break;
    case "bottom":
      x = 0;
      y = slideHeight - config.thickness;
      w = slideWidth;
      h = config.thickness;
      break;
    case "left":
      x = 0;
      y = 0;
      w = config.thickness;
      h = slideHeight;
      break;
    case "right":
      x = slideWidth - config.thickness;
      y = 0;
      w = config.thickness;
      h = slideHeight;
      break;
  }

  slide.addShape("rect", {
    x,
    y,
    w,
    h,
    fill: { color: config.color },
    line: { type: "none" }
  });
}

/**
 * Add a decorative circle accent
 */
export function addDecorativeCircle(
  slide: any,
  x: number,
  y: number,
  size: number,
  color: string,
  opacity: number = 0.1
): void {
  slide.addShape("ellipse", {
    x,
    y,
    w: size,
    h: size,
    fill: { color, transparency: Math.round((1 - opacity) * 100) },
    line: { type: "none" }
  });
}

/**
 * Add a decorative line accent
 */
export function addDecorativeLine(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string,
  width: number = 2
): void {
  slide.addShape("line", {
    x: x1,
    y: y1,
    w: x2 - x1,
    h: y2 - y1,
    line: { color, width }
  });
}

/**
 * Add a corner accent for premium feel
 */
export function addCornerAccent(
  slide: any,
  corner: "top-left" | "top-right" | "bottom-left" | "bottom-right",
  color: string,
  size: number = 0.3
): void {
  const slideWidth = 10;
  const slideHeight = 7.5;

  let x = 0, y = 0;

  switch (corner) {
    case "top-left":
      x = 0;
      y = 0;
      break;
    case "top-right":
      x = slideWidth - size;
      y = 0;
      break;
    case "bottom-left":
      x = 0;
      y = slideHeight - size;
      break;
    case "bottom-right":
      x = slideWidth - size;
      y = slideHeight - size;
      break;
  }

  slide.addShape("rect", {
    x,
    y,
    w: size,
    h: size,
    fill: { color },
    line: { type: "none" }
  });
}

/**
 * Add a premium divider line
 */
export function addPremiumDivider(
  slide: any,
  x: number,
  y: number,
  width: number,
  color: string = "#E2E8F0",
  thickness: number = 0.02
): void {
  slide.addShape("rect", {
    x,
    y,
    w: width,
    h: thickness,
    fill: { color },
    line: { type: "none" }
  });
}

/**
 * Add a premium highlight box
 */
export function addHighlightBox(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  color: string,
  opacity: number = 0.15
): void {
  slide.addShape("rect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color, transparency: Math.round((1 - opacity) * 100) },
    line: { type: "none" }
  });
}

/**
 * Add a premium metric card
 */
export function addMetricCard(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  metric: string,
  value: string,
  unit?: string,
  accentColor: string = "#3B82F6"
): void {
  // Card background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: "#FFFFFF" },
    line: { color: "#E5E7EB", width: 1 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 8,
      offset: 2
    }
  });

  // Accent bar
  slide.addShape("rect", {
    x,
    y,
    w: 0.08,
    h: height,
    fill: { color: accentColor },
    line: { type: "none" }
  });

  // Metric label
  slide.addText(metric, {
    x: x + 0.15,
    y: y + 0.1,
    w: width - 0.25,
    h: 0.25,
    fontSize: 11,
    color: "#6B7280",
    fontFace: "Inter, Arial, sans-serif",
    bold: false
  });

  // Value
  slide.addText(value, {
    x: x + 0.15,
    y: y + 0.4,
    w: width - 0.25,
    h: 0.5,
    fontSize: 28,
    bold: true,
    color: "#0F172A",
    fontFace: "Inter, Arial, sans-serif"
  });

  // Unit
  if (unit) {
    slide.addText(unit, {
      x: x + 0.15,
      y: y + 0.85,
      w: width - 0.25,
      h: 0.2,
      fontSize: 10,
      color: "#9CA3AF",
      fontFace: "Inter, Arial, sans-serif"
    });
  }
}

/**
 * Add a sophisticated gradient-like accent bar with multiple colors
 */
export function addGradientAccentBar(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  colors: string[]
): void {
  if (colors.length === 0) return;

  const segmentWidth = width / colors.length;

  colors.forEach((color, index) => {
    slide.addShape("rect", {
      x: x + index * segmentWidth,
      y,
      w: segmentWidth,
      h: height,
      fill: { color },
      line: { type: "none" }
    });
  });
}

/**
 * Add a premium stat block with icon placeholder
 */
export function addStatBlock(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  stat: string,
  label: string,
  backgroundColor: string = "#F8FAFC",
  accentColor: string = "#3B82F6"
): void {
  // Background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: backgroundColor },
    line: { color: "#E5E7EB", width: 1 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.06,
      blur: 6,
      offset: 1
    }
  });

  // Top accent bar
  slide.addShape("rect", {
    x,
    y,
    w: width,
    h: 0.04,
    fill: { color: accentColor },
    line: { type: "none" }
  });

  // Stat value
  slide.addText(stat, {
    x: x + 0.2,
    y: y + 0.3,
    w: width - 0.4,
    h: 0.6,
    fontSize: 32,
    bold: true,
    color: accentColor,
    fontFace: "Inter, Arial, sans-serif",
    align: "center"
  });

  // Label
  slide.addText(label, {
    x: x + 0.2,
    y: y + 0.95,
    w: width - 0.4,
    h: 0.3,
    fontSize: 12,
    color: "#6B7280",
    fontFace: "Inter, Arial, sans-serif",
    align: "center"
  });
}

/**
 * Add a premium section divider with icon
 */
export function addSectionDivider(
  slide: any,
  x: number,
  y: number,
  width: number,
  color: string = "#E2E8F0",
  thickness: number = 0.03
): void {
  // Main divider line
  slide.addShape("rect", {
    x,
    y,
    w: width,
    h: thickness,
    fill: { color },
    line: { type: "none" }
  });

  // Accent circle in center
  const centerX = x + width / 2 - 0.08;
  const centerY = y - 0.08;

  slide.addShape("ellipse", {
    x: centerX,
    y: centerY,
    w: 0.16,
    h: 0.16,
    fill: { color: "#FFFFFF" },
    line: { color, width: 2 }
  });
}

/**
 * Add a premium feature highlight box
 */
export function addFeatureHighlight(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  title: string,
  description: string,
  accentColor: string = "#3B82F6"
): void {
  // Background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: "#FFFFFF" },
    line: { color: accentColor, width: 2 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 12,
      offset: 3
    }
  });

  // Title
  slide.addText(title, {
    x: x + 0.2,
    y: y + 0.2,
    w: width - 0.4,
    h: 0.4,
    fontSize: 16,
    bold: true,
    color: accentColor,
    fontFace: "Inter, Arial, sans-serif"
  });

  // Description
  slide.addText(description, {
    x: x + 0.2,
    y: y + 0.65,
    w: width - 0.4,
    h: height - 0.85,
    fontSize: 12,
    color: "#6B7280",
    fontFace: "Inter, Arial, sans-serif",
    wrap: true
  });
}

/**
 * Add a professional arrow for flow diagrams
 */
export function addArrow(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string = "#3B82F6",
  width: number = 3
): void {
  // Calculate angle and length
  const dx = x2 - x1;
  const dy = y2 - y1;
  const length = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx) * (180 / Math.PI);

  // Add arrow shape
  slide.addShape("rightArrow", {
    x: x1,
    y: y1 - 0.08,
    w: length,
    h: 0.16,
    fill: { color },
    line: { type: "none" },
    rotate: angle
  });
}

/**
 * Add a curved connector arrow
 */
export function addCurvedArrow(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string = "#3B82F6"
): void {
  // For now, use a simple line with arrowhead
  // PptxGenJS has limited support for curved connectors
  slide.addShape("line", {
    x: x1,
    y: y1,
    w: x2 - x1,
    h: y2 - y1,
    line: {
      color,
      width: 2,
      endArrowType: "triangle"
    }
  });
}

/**
 * Add a process flow with arrows
 */
export function addProcessFlow(
  slide: any,
  steps: string[],
  startX: number,
  startY: number,
  stepWidth: number,
  stepHeight: number,
  spacing: number,
  accentColor: string = "#3B82F6"
): void {
  const totalWidth = steps.length * stepWidth + (steps.length - 1) * spacing;
  let currentX = startX;

  steps.forEach((step, index) => {
    // Add step box
    slide.addShape("roundRect", {
      x: currentX,
      y: startY,
      w: stepWidth,
      h: stepHeight,
      fill: { color: "#FFFFFF" },
      line: { color: accentColor, width: 2 },
      shadow: {
        type: "outer",
        color: "000000",
        opacity: 0.08,
        blur: 6,
        offset: 2
      }
    });

    // Add step text
    slide.addText(step, {
      x: currentX,
      y: startY,
      w: stepWidth,
      h: stepHeight,
      fontSize: 12,
      bold: true,
      color: accentColor,
      fontFace: "Inter, Arial, sans-serif",
      align: "center",
      valign: "middle",
      wrap: true
    });

    // Add arrow to next step (if not last)
    if (index < steps.length - 1) {
      addArrow(
        slide,
        currentX + stepWidth + 0.05,
        startY + stepHeight / 2,
        currentX + stepWidth + spacing - 0.05,
        startY + stepHeight / 2,
        accentColor,
        2
      );
    }

    currentX += stepWidth + spacing;
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/professionalTemplates.ts
=================================================================================
/**
 * Professional Slide Templates
 * Pre-designed templates for common slide types
 */

export interface TemplateConfig {
  name: string;
  description: string;
  pattern: string;
  colorScheme: string;
  typography: string;
  useCase: string;
}

export interface TemplateLayout {
  title: {
    fontSize: number;
    bold: boolean;
    color: string;
  };
  subtitle: {
    fontSize: number;
    bold: boolean;
    color: string;
  };
  body: {
    fontSize: number;
    color: string;
    lineHeight: number;
  };
  accent: string;
  background: string;
}

/**
 * Title Slide Template
 * Large, impactful opening slide
 */
export const TITLE_SLIDE_TEMPLATE: TemplateConfig = {
  name: "Title Slide",
  description: "Large, impactful opening slide with title and subtitle",
  pattern: "hero",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Presentation opening, cover slide"
};

/**
 * Content Slide Template
 * Standard content with title and bullet points
 */
export const CONTENT_SLIDE_TEMPLATE: TemplateConfig = {
  name: "Content Slide",
  description: "Standard slide with title and bullet point content",
  pattern: "split",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Main content, information delivery"
};

/**
 * Two Column Template
 * Side-by-side comparison or contrast
 */
export const TWO_COLUMN_TEMPLATE: TemplateConfig = {
  name: "Two Column",
  description: "Side-by-side layout for comparison or contrast",
  pattern: "comparison",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Comparison, pros/cons, before/after"
};

/**
 * Three Column Template
 * Feature showcase or comparison
 */
export const THREE_COLUMN_TEMPLATE: TemplateConfig = {
  name: "Three Column",
  description: "Three equal columns for features or comparison",
  pattern: "three-column",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Feature showcase, three-way comparison"
};

/**
 * Data Visualization Template
 * Optimized for charts and graphs
 */
export const DATA_VIZ_TEMPLATE: TemplateConfig = {
  name: "Data Visualization",
  description: "Optimized layout for charts, graphs, and data",
  pattern: "data-focused",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Charts, graphs, metrics, analytics"
};

/**
 * Image Focus Template
 * Large image with minimal text
 */
export const IMAGE_FOCUS_TEMPLATE: TemplateConfig = {
  name: "Image Focus",
  description: "Large image with minimal supporting text",
  pattern: "asymmetric",
  colorScheme: "minimal",
  typography: "professional",
  useCase: "Product showcase, photography, visual focus"
};

/**
 * Timeline Template
 * Process or timeline visualization
 */
export const TIMELINE_TEMPLATE: TemplateConfig = {
  name: "Timeline",
  description: "Horizontal timeline for processes or history",
  pattern: "timeline",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Process flow, timeline, roadmap"
};

/**
 * Centered Focus Template
 * Centered content for maximum impact
 */
export const CENTERED_FOCUS_TEMPLATE: TemplateConfig = {
  name: "Centered Focus",
  description: "Centered content with maximum focus",
  pattern: "centered",
  colorScheme: "minimal",
  typography: "professional",
  useCase: "Key message, quote, emphasis"
};

/**
 * Sidebar Template
 * Content with prominent sidebar
 */
export const SIDEBAR_TEMPLATE: TemplateConfig = {
  name: "Sidebar",
  description: "Content with prominent sidebar for navigation",
  pattern: "sidebar",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Navigation, key points, supplementary info"
};

/**
 * Stacked Template
 * Vertically stacked sections
 */
export const STACKED_TEMPLATE: TemplateConfig = {
  name: "Stacked",
  description: "Vertically stacked content sections",
  pattern: "stacked",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Sequential information, steps, sections"
};

/**
 * Minimal Template
 * Maximum whitespace, minimal content
 */
export const MINIMAL_TEMPLATE: TemplateConfig = {
  name: "Minimal",
  description: "Minimal layout with maximum whitespace",
  pattern: "minimal",
  colorScheme: "minimal",
  typography: "professional",
  useCase: "Key message, breathing room, elegance"
};

/**
 * Full Bleed Template
 * Content extends to edges
 */
export const FULL_BLEED_TEMPLATE: TemplateConfig = {
  name: "Full Bleed",
  description: "Content extends to edges for maximum impact",
  pattern: "full-bleed",
  colorScheme: "corporate",
  typography: "professional",
  useCase: "Background image, full-screen content"
};

/**
 * Get all available templates
 */
export function getAllTemplates(): TemplateConfig[] {
  return [
    TITLE_SLIDE_TEMPLATE,
    CONTENT_SLIDE_TEMPLATE,
    TWO_COLUMN_TEMPLATE,
    THREE_COLUMN_TEMPLATE,
    DATA_VIZ_TEMPLATE,
    IMAGE_FOCUS_TEMPLATE,
    TIMELINE_TEMPLATE,
    CENTERED_FOCUS_TEMPLATE,
    SIDEBAR_TEMPLATE,
    STACKED_TEMPLATE,
    MINIMAL_TEMPLATE,
    FULL_BLEED_TEMPLATE
  ];
}

/**
 * Get template by name
 */
export function getTemplate(name: string): TemplateConfig | undefined {
  return getAllTemplates().find(t => t.name.toLowerCase() === name.toLowerCase());
}

/**
 * Get templates by use case
 */
export function getTemplatesByUseCase(useCase: string): TemplateConfig[] {
  return getAllTemplates().filter(t => t.useCase.toLowerCase().includes(useCase.toLowerCase()));
}

/**
 * Get template layout configuration
 */
export function getTemplateLayout(templateName: string, colorScheme: string = "corporate"): TemplateLayout {
  const layouts: Record<string, TemplateLayout> = {
    professional: {
      title: { fontSize: 44, bold: true, color: "#0F172A" },
      subtitle: { fontSize: 28, bold: false, color: "#334155" },
      body: { fontSize: 16, color: "#334155", lineHeight: 150 },
      accent: "#2563EB",
      background: "#FFFFFF"
    },
    modern: {
      title: { fontSize: 48, bold: true, color: "#0F172A" },
      subtitle: { fontSize: 32, bold: true, color: "#2563EB" },
      body: { fontSize: 16, color: "#334155", lineHeight: 150 },
      accent: "#6366F1",
      background: "#FFFFFF"
    },
    minimal: {
      title: { fontSize: 40, bold: true, color: "#1F2937" },
      subtitle: { fontSize: 24, bold: false, color: "#6B7280" },
      body: { fontSize: 14, color: "#6B7280", lineHeight: 160 },
      accent: "#1F2937",
      background: "#FFFFFF"
    },
    bold: {
      title: { fontSize: 52, bold: true, color: "#DC2626" },
      subtitle: { fontSize: 32, bold: true, color: "#0F172A" },
      body: { fontSize: 18, color: "#0F172A", lineHeight: 140 },
      accent: "#DC2626",
      background: "#FFFFFF"
    }
  };

  return layouts[templateName] || layouts.professional;
}

/**
 * Get recommended template for content type
 */
export function getRecommendedTemplate(contentType: "title" | "content" | "comparison" | "data" | "image" | "process"): TemplateConfig {
  const recommendations: Record<string, TemplateConfig> = {
    title: TITLE_SLIDE_TEMPLATE,
    content: CONTENT_SLIDE_TEMPLATE,
    comparison: TWO_COLUMN_TEMPLATE,
    data: DATA_VIZ_TEMPLATE,
    image: IMAGE_FOCUS_TEMPLATE,
    process: TIMELINE_TEMPLATE
  };

  return recommendations[contentType] || CONTENT_SLIDE_TEMPLATE;
}

/**
 * Validate template configuration
 */
export function validateTemplate(template: TemplateConfig): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!template.name) {
    errors.push("Template name is required");
  }

  if (!template.pattern) {
    errors.push("Template pattern is required");
  }

  if (!template.colorScheme) {
    errors.push("Template color scheme is required");
  }

  if (!template.typography) {
    errors.push("Template typography is required");
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Create custom template
 */
export function createCustomTemplate(
  name: string,
  description: string,
  pattern: string,
  colorScheme: string,
  typography: string,
  useCase: string
): TemplateConfig {
  return {
    name,
    description,
    pattern,
    colorScheme,
    typography,
    useCase
  };
}

/**
 * Get template statistics
 */
export function getTemplateStats(): {
  total: number;
  byPattern: Record<string, number>;
  byColorScheme: Record<string, number>;
} {
  const templates = getAllTemplates();
  const byPattern: Record<string, number> = {};
  const byColorScheme: Record<string, number> = {};

  templates.forEach(t => {
    byPattern[t.pattern] = (byPattern[t.pattern] || 0) + 1;
    byColorScheme[t.colorScheme] = (byColorScheme[t.colorScheme] || 0) + 1;
  });

  return {
    total: templates.length,
    byPattern,
    byColorScheme
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/shapeHelpers.ts
=================================================================================
/**
 * Shape Helpers for PowerPoint Slides
 * Professional shapes, arrows, and visual elements
 */

import PptxGenJS from "pptxgenjs";

/**
 * Add a professional arrow between two points
 */
export function addConnectorArrow(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string = "#3B82F6",
  thickness: number = 3
): void {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const length = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx) * (180 / Math.PI);

  slide.addShape("rightArrow", {
    x: x1,
    y: y1 - 0.08,
    w: length,
    h: 0.16,
    fill: { color: color.replace("#", "") },
    line: { type: "none" },
    rotate: angle,
  });
}

/**
 * Add a curved connector line
 */
export function addCurvedConnector(
  slide: any,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string = "#3B82F6",
  thickness: number = 2
): void {
  slide.addShape("line", {
    x: x1,
    y: y1,
    w: x2 - x1,
    h: y2 - y1,
    line: {
      color: color.replace("#", ""),
      width: thickness,
      endArrowType: "triangle",
      dashType: "solid",
    },
  });
}

/**
 * Add a callout box with pointer
 */
export function addCalloutBox(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  text: string,
  color: string = "#3B82F6",
  backgroundColor: string = "#EEF2FF"
): void {
  // Background box
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: backgroundColor.replace("#", "") },
    line: { color: color.replace("#", ""), width: 2 },
  });

  // Text
  slide.addText(text, {
    x: x + 0.1,
    y: y + 0.1,
    w: width - 0.2,
    h: height - 0.2,
    fontSize: 14,
    color: "#0F172A",
    fontFace: "Aptos",
    align: "center",
    valign: "middle",
    wrap: true,
  });
}

/**
 * Add a process flow diagram
 */
export function addProcessFlow(
  slide: any,
  steps: string[],
  startX: number,
  startY: number,
  stepWidth: number,
  stepHeight: number,
  spacing: number,
  color: string = "#3B82F6"
): void {
  let currentX = startX;

  steps.forEach((step, index) => {
    // Step box
    slide.addShape("roundRect", {
      x: currentX,
      y: startY,
      w: stepWidth,
      h: stepHeight,
      fill: { color: "#FFFFFF" },
      line: { color: color.replace("#", ""), width: 2 },
      shadow: {
        type: "outer",
        color: "000000",
        opacity: 0.1,
        blur: 8,
        offset: 2,
      },
    });

    // Step number badge
    slide.addShape("ellipse", {
      x: currentX + 0.05,
      y: startY + 0.05,
      w: 0.25,
      h: 0.25,
      fill: { color: color.replace("#", "") },
      line: { type: "none" },
    });

    slide.addText((index + 1).toString(), {
      x: currentX + 0.05,
      y: startY + 0.05,
      w: 0.25,
      h: 0.25,
      fontSize: 12,
      bold: true,
      color: "#FFFFFF",
      align: "center",
      valign: "middle",
    });

    // Step text
    slide.addText(step, {
      x: currentX + 0.1,
      y: startY + 0.35,
      w: stepWidth - 0.2,
      h: stepHeight - 0.4,
      fontSize: 12,
      color: "#0F172A",
      fontFace: "Aptos",
      align: "center",
      valign: "middle",
      wrap: true,
    });

    // Arrow to next step
    if (index < steps.length - 1) {
      addConnectorArrow(
        slide,
        currentX + stepWidth + 0.05,
        startY + stepHeight / 2,
        currentX + stepWidth + spacing - 0.05,
        startY + stepHeight / 2,
        color,
        2
      );
    }

    currentX += stepWidth + spacing;
  });
}

/**
 * Add a metric card
 */
export function addMetricCard(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  value: string,
  label: string,
  color: string = "#3B82F6"
): void {
  // Card background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: "#FFFFFF" },
    line: { color: "#E5E7EB", width: 1 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 8,
      offset: 2,
    },
  });

  // Accent bar
  slide.addShape("rect", {
    x,
    y,
    w: 0.08,
    h: height,
    fill: { color: color.replace("#", "") },
    line: { type: "none" },
  });

  // Value
  slide.addText(value, {
    x: x + 0.15,
    y: y + 0.15,
    w: width - 0.25,
    h: height * 0.6,
    fontSize: 32,
    bold: true,
    color: color.replace("#", ""),
    fontFace: "Aptos",
    align: "center",
    valign: "middle",
  });

  // Label
  slide.addText(label, {
    x: x + 0.15,
    y: y + height * 0.65,
    w: width - 0.25,
    h: height * 0.25,
    fontSize: 12,
    color: "#6B7280",
    fontFace: "Aptos",
    align: "center",
    valign: "middle",
  });
}

/**
 * Add a comparison box (for before/after, pros/cons)
 */
export function addComparisonBox(
  slide: any,
  x: number,
  y: number,
  width: number,
  height: number,
  title: string,
  items: string[],
  color: string = "#3B82F6",
  isPositive: boolean = true
): void {
  // Background
  slide.addShape("roundRect", {
    x,
    y,
    w: width,
    h: height,
    fill: { color: "#FFFFFF" },
    line: { color: color.replace("#", ""), width: 2 },
  });

  // Header bar
  slide.addShape("rect", {
    x,
    y,
    w: width,
    h: 0.4,
    fill: { color: color.replace("#", "") },
    line: { type: "none" },
  });

  // Title
  slide.addText(title, {
    x,
    y,
    w: width,
    h: 0.4,
    fontSize: 14,
    bold: true,
    color: "#FFFFFF",
    fontFace: "Aptos",
    align: "center",
    valign: "middle",
  });

  // Items
  let currentY = y + 0.5;
  items.forEach((item) => {
    // Bullet icon
    const icon = isPositive ? "‚úì" : "‚úó";
    slide.addText(icon, {
      x: x + 0.1,
      y: currentY,
      w: 0.2,
      h: 0.25,
      fontSize: 12,
      color: color.replace("#", ""),
      align: "center",
      valign: "middle",
    });

    // Item text
    slide.addText(item, {
      x: x + 0.35,
      y: currentY,
      w: width - 0.45,
      h: 0.25,
      fontSize: 11,
      color: "#0F172A",
      fontFace: "Aptos",
      align: "left",
      valign: "middle",
      wrap: true,
    });

    currentY += 0.3;
  });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/slideBuilder.ts
=================================================================================
/**
 * Enhanced Slide Builder
 * Builds professional slides with design tokens and patterns
 */

import PptxGenJS from "pptxgenjs";
import type { SlideSpecV2 } from "../types/SlideSpecV2";
import {
  mapColorPalette,
  mapTypography,
  mapShadows,
  pxToIn,
  getTextOptions,
  getShapeOptions
} from "./designTokenMapper";
import { getRegionsForPattern, validatePatternRegions } from "./patterns";

/**
 * Build a professional slide with design tokens
 */
export async function buildProfessionalSlide(
  pptx: PptxGenJS,
  spec: SlideSpecV2
): Promise<void> {
  // Validate spec has required fields
  if (!spec.design || !spec.styleTokens) {
    throw new Error("Spec missing design or styleTokens");
  }

  const slide = pptx.addSlide();

  // Map design tokens
  const colors = mapColorPalette(spec.styleTokens.palette);
  const typography = mapTypography(spec.styleTokens.typography);
  const shadows = mapShadows(spec.styleTokens.shadows);

  // Get regions based on design pattern
  const regions = getRegionsForPattern(spec.design.pattern, spec);

  if (!validatePatternRegions(regions)) {
    throw new Error("Invalid pattern regions");
  }

  // Apply background
  applyBackground(slide, spec, colors);

  // Render content elements
  renderTitle(slide, spec, regions, typography, colors);
  renderSubtitle(slide, spec, regions, typography, colors);
  renderBullets(slide, spec, regions, typography, colors);
  renderCallouts(slide, spec, regions, typography, colors, shadows);
  renderChart(slide, spec, regions, colors);
  renderImages(slide, spec, regions);
}

/**
 * Apply premium background styling with professional design
 */
function applyBackground(
  slide: any,
  spec: SlideSpecV2,
  colors: any
): void {
  // Apply sophisticated gradient background
  applyPremiumGradientBackground(slide, spec, colors);

  // Get accent color with fallback
  const accentColor = spec.design?.colorStrategy?.emphasis || colors.accent || "#10B981";

  // Add sophisticated accent bar for premium feel
  if (spec.design?.pattern === "hero" || spec.design?.pattern === "minimal") {
    // Add subtle accent line at top for visual interest
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: 0,
      w: "100%",
      h: 0.08,
      fill: { color: accentColor },
      line: { type: "none" }
    });
  }

  // Add decorative accent bar for data-focused pattern
  if (spec.design?.pattern === "data-focused") {
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: 0,
      w: 0.04,
      h: "100%",
      fill: { color: accentColor },
      line: { type: "none" }
    });
  }

  // Add subtle gradient overlay for split pattern
  if (spec.design?.pattern === "split") {
    // Left accent
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: 0,
      w: 0.02,
      h: "100%",
      fill: { color: accentColor },
      line: { type: "none" }
    });
  }

  // Add asymmetric pattern accent
  if (spec.design?.pattern === "asymmetric") {
    // Diagonal accent element for dynamic feel
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 8.5,
      y: 0,
      w: 1.5,
      h: 0.06,
      fill: { color: accentColor },
      line: { type: "none" }
    });
  }

  // Add grid pattern subtle dividers
  if (spec.design?.pattern === "grid") {
    // Subtle divider lines for grid structure
    const dividerColor = "#E5E7EB";
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 5,
      y: 0.5,
      w: 0.01,
      h: 6.5,
      fill: { color: dividerColor },
      line: { type: "none" }
    });
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0.5,
      y: 3.75,
      w: 9,
      h: 0.01,
      fill: { color: dividerColor },
      line: { type: "none" }
    });
  }
}

/**
 * Render premium title with sophisticated styling
 */
function renderTitle(
  slide: any,
  spec: SlideSpecV2,
  regions: any,
  typography: any,
  colors: any
): void {
  const title = spec.content.title;
  if (!title) return;

  const titleAnchor = spec.layout.anchors.find((a: any) => a.refId === title.id);
  if (!titleAnchor) return;

  const rect = regions[titleAnchor.region];
  if (!rect) return;

  const titleConfig = spec.design?.typography?.hierarchy?.title || {
    size: typography.title.fontSize,
    weight: 700,
    lineHeight: 1.2,
    letterSpacing: 0.5
  };

  const fontPrimary = spec.design?.typography?.fontPairing?.primary || spec.styleTokens.typography.fonts.sans || "Arial";

  // Premium title with enhanced spacing and color
  slide.addText(title.text, {
    x: rect.x,
    y: rect.y,
    w: rect.w,
    h: rect.h,
    fontFace: fontPrimary,
    fontSize: titleConfig.size,
    bold: titleConfig.weight >= 600,
    color: colors.primary || colors.text,
    align: spec.components?.title?.align || "left",
    valign: "middle",
    wrap: true,
    lineSpacing: titleConfig.lineHeight * 100
  });
}

/**
 * Render subtitle
 */
function renderSubtitle(
  slide: any,
  spec: SlideSpecV2,
  regions: any,
  typography: any,
  colors: any
): void {
  const subtitle = spec.content.subtitle;
  if (!subtitle) return;

  const subtitleAnchor = spec.layout.anchors.find((a: any) => a.refId === subtitle.id);
  if (!subtitleAnchor) return;

  const rect = regions[subtitleAnchor.region];
  if (!rect) return;

  const subtitleConfig = spec.design.typography.hierarchy.subtitle || {
    size: typography.subtitle.fontSize,
    weight: 500,
    lineHeight: 1.4
  };

  slide.addText(subtitle.text, {
    x: rect.x,
    y: rect.y,
    w: rect.w,
    h: rect.h,
    fontFace: spec.design.typography.fontPairing.secondary,
    fontSize: subtitleConfig.size,
    bold: subtitleConfig.weight >= 600,
    color: colors.text,
    align: "left",
    valign: "top",
    wrap: true,
    lineSpacing: subtitleConfig.lineHeight * 100
  });
}

/**
 * Render bullet points
 */
function renderBullets(
  slide: any,
  spec: SlideSpecV2,
  regions: any,
  typography: any,
  colors: any
): void {
  const bullets = spec.content.bullets?.[0];
  if (!bullets) return;

  const bulletAnchor = spec.layout.anchors.find((a: any) => a.refId === bullets.id);
  if (!bulletAnchor) return;

  const rect = regions[bulletAnchor.region];
  if (!rect) return;

  const bodyConfig = spec.design.typography.hierarchy.body || {
    size: typography.body.fontSize,
    weight: 400,
    lineHeight: 1.5
  };

  slide.addText(
    bullets.items.map((item: any) => ({
      text: item.text,
      options: { bullet: true, indentLevel: item.level - 1 }
    })),
    {
      x: rect.x,
      y: rect.y,
      w: rect.w,
      h: rect.h,
      fontFace: spec.design.typography.fontPairing.secondary,
      fontSize: bodyConfig.size,
      bold: bodyConfig.weight >= 600,
      color: colors.text,
      wrap: true,
      lineSpacing: bodyConfig.lineHeight * 100
    }
  );
}

/**
 * Render callouts
 */
function renderCallouts(
  slide: any,
  spec: SlideSpecV2,
  regions: any,
  typography: any,
  colors: any,
  shadows: any
): void {
  const callout = spec.content.callouts?.[0];
  if (!callout) return;

  const calloutAnchor = spec.layout.anchors.find((a: any) => a.refId === callout.id);
  if (!calloutAnchor) return;

  const rect = regions[calloutAnchor.region];
  if (!rect) return;

  // Determine callout background and border colors based on variant
  const bgColor = getCalloutBackgroundColor(callout.variant, colors);
  const borderColor = getCalloutBorderColor(callout.variant, colors);

  // Add professional callout shape with premium styling
  slide.addShape(PptxGenJS.ShapeType.roundRect, {
    x: rect.x,
    y: rect.y,
    w: rect.w,
    h: rect.h,
    fill: { color: bgColor },
    line: { color: borderColor, width: 2 },
    shadow: {
      type: "outer",
      color: "000000",
      opacity: 0.08,
      blur: 8,
      offset: 2
    }
  });

  // Add callout text
  const text = `${callout.title ? callout.title + " ‚Äî " : ""}${callout.text}`;
  const fontSecondary = spec.design?.typography?.fontPairing?.secondary || spec.styleTokens.typography.fonts.sans || "Arial";

  slide.addText(text, {
    x: rect.x + 0.15,
    y: rect.y + 0.15,
    w: rect.w - 0.3,
    h: rect.h - 0.3,
    fontFace: fontSecondary,
    fontSize: typography.body.fontSize,
    color: colors.text,
    align: "left",
    valign: "middle",
    wrap: true
  });
}

/**
 * Get professional callout background color with premium styling
 */
function getCalloutBackgroundColor(variant: string, colors: any): string {
  switch (variant) {
    case "success":
      return "#ECFDF5"; // Premium light green
    case "warning":
      return "#FFFBEB"; // Premium light amber
    case "danger":
      return "#FEF2F2"; // Premium light red
    case "note":
    default:
      return "#F9FAFB"; // Premium light gray
  }
}

/**
 * Get professional callout border color
 */
function getCalloutBorderColor(variant: string, colors: any): string {
  switch (variant) {
    case "success":
      return "#10B981"; // Emerald
    case "warning":
      return "#F59E0B"; // Amber
    case "danger":
      return "#EF4444"; // Red
    case "note":
    default:
      return "#6B7280"; // Gray
  }
}

/**
 * Render chart with professional styling
 */
function renderChart(
  slide: any,
  spec: SlideSpecV2,
  regions: any,
  colors: any
): void {
  const dataViz = spec.content.dataViz;
  if (!dataViz) return;

  const chartAnchor = spec.layout.anchors.find((a: any) => a.refId === dataViz.id);
  if (!chartAnchor) return;

  const rect = regions[chartAnchor.region];
  if (!rect) return;

  const chartData = dataViz.series.map((s: any) => ({
    name: s.name,
    labels: dataViz.labels,
    values: s.values
  }));

  const chartType =
    dataViz.kind === "pie"
      ? PptxGenJS.ChartType.pie
      : dataViz.kind === "line"
      ? PptxGenJS.ChartType.line
      : PptxGenJS.ChartType.bar;

  // Premium color palette for charts
  const chartColors = [
    colors.primary || "#1E40AF",
    colors.accent || "#10B981",
    "#F59E0B",
    "#8B5CF6",
    "#EC4899",
    "#06B6D4",
    "#7C3AED"
  ];

  const chartOptions: any = {
    x: rect.x,
    y: rect.y,
    w: rect.w,
    h: rect.h,
    chartColors: chartColors,
    showLegend: true,
    legendPos: dataViz.kind === "pie" ? "r" : "b",
    dataLabelFontSize: 11,
    dataLabelPosition: "ctr",
    showTitle: !!dataViz.title,
    title: dataViz.title || "",
    titleFontSize: 16,
    titleFontBold: true,
    titleFontFace: "Inter, Arial, sans-serif",
    titleColor: colors.text || "#0F172A",
    chartGridLine: { style: "solid", color: "#E2E8F0", size: 0.5 },
    showValue: true
  };

  // Add line smoothing for line charts
  if (dataViz.kind === "line") {
    chartOptions.lineSmooth = true;
  }

  slide.addChart(chartType, chartData, chartOptions);
}

/**
 * Render images
 */
function renderImages(
  slide: any,
  spec: SlideSpecV2,
  regions: any
): void {
  const placeholders = spec.content.imagePlaceholders;
  if (!placeholders) return;

  placeholders.forEach((placeholder: any) => {
    const imageAnchor = spec.layout.anchors.find((a: any) => a.refId === placeholder.id);
    if (!imageAnchor) return;

    const rect = regions[imageAnchor.region];
    if (!rect) return;

    // Add placeholder rectangle
    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: rect.x,
      y: rect.y,
      w: rect.w,
      h: rect.h,
      fill: { color: "#E5E7EB" },
      line: { color: "#D1D5DB", width: 1 }
    });

    // Add placeholder text
    slide.addText(placeholder.alt, {
      x: rect.x,
      y: rect.y,
      w: rect.w,
      h: rect.h,
      fontSize: 12,
      color: "#6B7280",
      align: "center",
      valign: "middle"
    });
  });
}

/**
 * Apply premium gradient background with sophisticated design
 * Creates depth and visual interest while maintaining professionalism
 */
function applyPremiumGradientBackground(
  slide: any,
  spec: SlideSpecV2,
  colors: any
): void {
  const slideWidth = 10;
  const slideHeight = 7.5;

  // Get colors from spec
  const bgColor = colors.background || "#F8FAFC";
  const primaryColor = colors.primary || "#1E40AF";
  const accentColor = spec.design?.colorStrategy?.emphasis || colors.accent || "#10B981";
  const neutralMid = colors.neutral[4] || "#94A3B8";

  // Base background color
  slide.background = { fill: bgColor.replace("#", "") };

  // Determine gradient style based on design pattern
  const pattern = spec.design?.pattern || "split";

  switch (pattern) {
    case "hero":
      // Dramatic top-to-bottom gradient for hero slides
      applyHeroGradient(slide, slideWidth, slideHeight, primaryColor, accentColor);
      break;

    case "minimal":
      // Very subtle center-focused gradient for minimal slides
      applyMinimalGradient(slide, slideWidth, slideHeight, bgColor, neutralMid);
      break;

    case "data-focused":
      // Left-to-right gradient emphasizing the data area
      applyDataGradient(slide, slideWidth, slideHeight, bgColor, accentColor);
      break;

    case "split":
      // Diagonal gradient for split layouts
      applySplitGradient(slide, slideWidth, slideHeight, bgColor, primaryColor);
      break;

    case "asymmetric":
      // Dynamic angular gradient for asymmetric layouts
      applyAsymmetricGradient(slide, slideWidth, slideHeight, primaryColor, accentColor);
      break;

    case "grid":
      // Subtle radial-like gradient for grid layouts
      applyGridGradient(slide, slideWidth, slideHeight, bgColor, neutralMid);
      break;

    default:
      // Default subtle gradient
      applyDefaultGradient(slide, slideWidth, slideHeight, bgColor, neutralMid);
  }
}

/**
 * Hero pattern gradient - dramatic top-to-bottom
 */
function applyHeroGradient(slide: any, w: number, h: number, primary: string, accent: string): void {
  const steps = 8;
  for (let i = 0; i < steps; i++) {
    const transparency = 96 - (i * 1.5); // 96% to 85.5%
    const yPos = (h / steps) * i;
    const height = h / steps + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: yPos,
      w: w,
      h: height,
      fill: {
        color: primary.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }
}

/**
 * Minimal pattern gradient - very subtle center focus
 */
function applyMinimalGradient(slide: any, w: number, h: number, bg: string, neutral: string): void {
  // Subtle vignette effect - darker at edges
  const edgeTransparency = 98;

  // Top edge
  slide.addShape(PptxGenJS.ShapeType.rect, {
    x: 0,
    y: 0,
    w: w,
    h: 0.5,
    fill: {
      color: neutral.replace("#", ""),
      transparency: edgeTransparency
    },
    line: { type: "none" }
  });

  // Bottom edge
  slide.addShape(PptxGenJS.ShapeType.rect, {
    x: 0,
    y: h - 0.5,
    w: w,
    h: 0.5,
    fill: {
      color: neutral.replace("#", ""),
      transparency: edgeTransparency
    },
    line: { type: "none" }
  });
}

/**
 * Data-focused pattern gradient - left to right emphasis
 */
function applyDataGradient(slide: any, w: number, h: number, bg: string, accent: string): void {
  const steps = 6;
  for (let i = 0; i < steps; i++) {
    const transparency = 97 - (i * 0.8); // 97% to 93%
    const xPos = (w / steps) * i;
    const width = w / steps + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: xPos,
      y: 0,
      w: width,
      h: h,
      fill: {
        color: accent.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }
}

/**
 * Split pattern gradient - diagonal sweep
 */
function applySplitGradient(slide: any, w: number, h: number, bg: string, primary: string): void {
  const steps = 10;
  for (let i = 0; i < steps; i++) {
    const transparency = 97 - (i * 0.5); // 97% to 92.5%
    const xPos = (w / steps) * i;
    const width = w / steps + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: xPos,
      y: 0,
      w: width,
      h: h,
      fill: {
        color: primary.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }
}

/**
 * Asymmetric pattern gradient - dynamic angular
 */
function applyAsymmetricGradient(slide: any, w: number, h: number, primary: string, accent: string): void {
  // Top-right to bottom-left gradient
  const steps = 8;
  for (let i = 0; i < steps; i++) {
    const transparency = 96 - (i * 1); // 96% to 89%
    const yPos = (h / steps) * i;
    const height = h / steps + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: yPos,
      w: w,
      h: height,
      fill: {
        color: accent.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }

  // Add subtle diagonal accent
  slide.addShape(PptxGenJS.ShapeType.rect, {
    x: w * 0.7,
    y: 0,
    w: w * 0.3,
    h: h,
    fill: {
      color: primary.replace("#", ""),
      transparency: 98
    },
    line: { type: "none" }
  });
}

/**
 * Grid pattern gradient - subtle radial effect
 */
function applyGridGradient(slide: any, w: number, h: number, bg: string, neutral: string): void {
  // Center-to-edge gradient simulation
  const centerX = w / 2;
  const centerY = h / 2;

  // Top half
  for (let i = 0; i < 4; i++) {
    const transparency = 98 - (i * 0.5);
    const yPos = (centerY / 4) * i;
    const height = centerY / 4 + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: yPos,
      w: w,
      h: height,
      fill: {
        color: neutral.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }

  // Bottom half
  for (let i = 0; i < 4; i++) {
    const transparency = 96 + (i * 0.5);
    const yPos = centerY + (centerY / 4) * i;
    const height = centerY / 4 + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: yPos,
      w: w,
      h: height,
      fill: {
        color: neutral.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }
}

/**
 * Default gradient - subtle top-to-bottom
 */
function applyDefaultGradient(slide: any, w: number, h: number, bg: string, neutral: string): void {
  const steps = 6;
  for (let i = 0; i < steps; i++) {
    const transparency = 97 - (i * 0.6); // 97% to 94%
    const yPos = (h / steps) * i;
    const height = h / steps + 0.05;

    slide.addShape(PptxGenJS.ShapeType.rect, {
      x: 0,
      y: yPos,
      w: w,
      h: height,
      fill: {
        color: neutral.replace("#", ""),
        transparency: transparency
      },
      line: { type: "none" }
    });
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/typographyEffects.ts
=================================================================================
/**
 * Advanced Typography Effects
 * Text gradients, shadows, multi-column layouts, smart text fitting
 * Professional typography hierarchy and styling
 */

import PptxGenJS from "pptxgenjs";

export interface TextGradient {
  colors: string[];
  angle?: number; // 0-360 degrees
}

export interface TextShadow {
  color: string;
  blur: number;
  offsetX: number;
  offsetY: number;
  opacity: number;
}

export interface MultiColumnConfig {
  columns: number;
  gap: number; // in inches
  text: string;
}

export interface SmartTextConfig {
  text: string;
  maxWidth: number;
  maxHeight: number;
  minFontSize: number;
  maxFontSize: number;
  fontFace?: string;
}

/**
 * Add text with gradient effect
 * Note: PptxGenJS has limited gradient support, so we simulate with layered text
 */
export function addGradientText(
  slide: any,
  text: string,
  x: number,
  y: number,
  w: number,
  h: number,
  gradient: TextGradient,
  options: any = {}
): void {
  // PptxGenJS doesn't support text gradients directly
  // We'll use the primary color from the gradient
  const primaryColor = gradient.colors[0]?.replace("#", "") || "000000";
  
  slide.addText(text, {
    x,
    y,
    w,
    h,
    color: primaryColor,
    ...options,
    // Add shadow for depth to simulate gradient effect
    shadow: {
      type: "outer",
      color: gradient.colors[1]?.replace("#", "") || "000000",
      opacity: 0.3,
      blur: 3,
      offset: 1,
      angle: gradient.angle || 45
    }
  });
}

/**
 * Add text with custom shadow effect
 */
export function addShadowText(
  slide: any,
  text: string,
  x: number,
  y: number,
  w: number,
  h: number,
  shadow: TextShadow,
  options: any = {}
): void {
  slide.addText(text, {
    x,
    y,
    w,
    h,
    ...options,
    shadow: {
      type: "outer",
      color: shadow.color.replace("#", ""),
      opacity: shadow.opacity,
      blur: shadow.blur,
      offset: Math.sqrt(shadow.offsetX ** 2 + shadow.offsetY ** 2),
      angle: Math.atan2(shadow.offsetY, shadow.offsetX) * (180 / Math.PI)
    }
  });
}

/**
 * Add multi-column text layout
 */
export function addMultiColumnText(
  slide: any,
  config: MultiColumnConfig,
  x: number,
  y: number,
  totalWidth: number,
  height: number,
  options: any = {}
): void {
  const columnWidth = (totalWidth - (config.gap * (config.columns - 1))) / config.columns;
  const words = config.text.split(" ");
  const wordsPerColumn = Math.ceil(words.length / config.columns);
  
  for (let i = 0; i < config.columns; i++) {
    const columnWords = words.slice(i * wordsPerColumn, (i + 1) * wordsPerColumn);
    const columnText = columnWords.join(" ");
    const columnX = x + (i * (columnWidth + config.gap));
    
    slide.addText(columnText, {
      x: columnX,
      y,
      w: columnWidth,
      h: height,
      ...options,
      align: "left",
      valign: "top"
    });
  }
}

/**
 * Smart text fitting - automatically adjust font size to fit content
 */
export function calculateOptimalFontSize(config: SmartTextConfig): number {
  const { text, maxWidth, maxHeight, minFontSize, maxFontSize } = config;
  
  // Estimate characters per line based on width
  // Average character width is roughly 0.6 * fontSize (in points)
  const estimateLines = (fontSize: number): number => {
    const avgCharWidth = fontSize * 0.6 / 72; // Convert to inches
    const charsPerLine = Math.floor(maxWidth / avgCharWidth);
    return Math.ceil(text.length / charsPerLine);
  };
  
  const estimateHeight = (fontSize: number): number => {
    const lineHeight = fontSize * 1.4 / 72; // Convert to inches with 1.4 line height
    return estimateLines(fontSize) * lineHeight;
  };
  
  // Binary search for optimal font size
  let low = minFontSize;
  let high = maxFontSize;
  let optimal = minFontSize;
  
  while (low <= high) {
    const mid = Math.floor((low + high) / 2);
    const height = estimateHeight(mid);
    
    if (height <= maxHeight) {
      optimal = mid;
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  
  return optimal;
}

/**
 * Add text with smart fitting
 */
export function addSmartFitText(
  slide: any,
  config: SmartTextConfig,
  x: number,
  y: number,
  options: any = {}
): void {
  const fontSize = calculateOptimalFontSize(config);
  
  slide.addText(config.text, {
    x,
    y,
    w: config.maxWidth,
    h: config.maxHeight,
    fontSize,
    fontFace: config.fontFace || "Arial",
    ...options,
    fit: "shrink", // PptxGenJS built-in text fitting
    shrinkText: true
  });
}

/**
 * Add pull quote with decorative styling
 */
export function addPullQuote(
  slide: any,
  quote: string,
  author: string,
  x: number,
  y: number,
  w: number,
  h: number,
  accentColor: string = "#3B82F6"
): void {
  // Add accent bar on left
  slide.addShape(PptxGenJS.ShapeType.rect, {
    x: x - 0.1,
    y,
    w: 0.05,
    h: h,
    fill: { color: accentColor.replace("#", "") },
    line: { type: "none" }
  });
  
  // Add quote text
  slide.addText(quote, {
    x,
    y,
    w,
    h: h * 0.7,
    fontSize: 24,
    fontFace: "Georgia, serif",
    italic: true,
    color: "1F2937",
    align: "left",
    valign: "top"
  });
  
  // Add author attribution
  slide.addText(`‚Äî ${author}`, {
    x,
    y: y + (h * 0.7),
    w,
    h: h * 0.3,
    fontSize: 16,
    fontFace: "Arial, sans-serif",
    color: "6B7280",
    align: "left",
    valign: "bottom"
  });
}

/**
 * Add callout box with icon
 */
export function addCalloutBox(
  slide: any,
  title: string,
  text: string,
  x: number,
  y: number,
  w: number,
  h: number,
  variant: "info" | "success" | "warning" | "danger" = "info"
): void {
  const colors = {
    info: { bg: "#DBEAFE", border: "#3B82F6", text: "#1E40AF" },
    success: { bg: "#D1FAE5", border: "#10B981", text: "#065F46" },
    warning: { bg: "#FEF3C7", border: "#F59E0B", text: "#92400E" },
    danger: { bg: "#FEE2E2", border: "#EF4444", text: "#991B1B" }
  };
  
  const color = colors[variant];
  
  // Background box
  slide.addShape(PptxGenJS.ShapeType.rect, {
    x,
    y,
    w,
    h,
    fill: { color: color.bg.replace("#", "") },
    line: { color: color.border.replace("#", ""), width: 2 },
    rectRadius: 0.1
  });
  
  // Title
  slide.addText(title, {
    x: x + 0.2,
    y: y + 0.15,
    w: w - 0.4,
    h: 0.3,
    fontSize: 16,
    bold: true,
    color: color.text.replace("#", ""),
    fontFace: "Arial, sans-serif"
  });
  
  // Body text
  slide.addText(text, {
    x: x + 0.2,
    y: y + 0.5,
    w: w - 0.4,
    h: h - 0.65,
    fontSize: 14,
    color: color.text.replace("#", ""),
    fontFace: "Arial, sans-serif",
    valign: "top"
  });
}

/**
 * Add highlighted text (background highlight)
 */
export function addHighlightedText(
  slide: any,
  text: string,
  x: number,
  y: number,
  w: number,
  h: number,
  highlightColor: string = "#FEF3C7",
  textColor: string = "#000000",
  options: any = {}
): void {
  // Add highlight background
  slide.addShape(PptxGenJS.ShapeType.rect, {
    x: x - 0.05,
    y: y - 0.05,
    w: w + 0.1,
    h: h + 0.1,
    fill: { color: highlightColor.replace("#", ""), transparency: 30 },
    line: { type: "none" }
  });
  
  // Add text on top
  slide.addText(text, {
    x,
    y,
    w,
    h,
    color: textColor.replace("#", ""),
    ...options
  });
}

/**
 * Get font pairing recommendations
 */
export function getFontPairing(style: "professional" | "elegant" | "modern" | "bold" | "minimal"): {
  heading: string;
  body: string;
} {
  const pairings = {
    professional: { heading: "Calibri", body: "Calibri" },
    elegant: { heading: "Georgia", body: "Garamond" },
    modern: { heading: "Segoe UI", body: "Segoe UI" },
    bold: { heading: "Impact", body: "Arial" },
    minimal: { heading: "Arial", body: "Arial" }
  };
  
  return pairings[style] || pairings.professional;
}

/**
 * Add professional heading with hierarchy
 */
export function addProfessionalHeading(
  slide: any,
  text: string,
  x: number,
  y: number,
  width: number,
  level: 1 | 2 | 3 = 1,
  color: string = "#0F172A",
  fontFace: string = "Inter, Arial, sans-serif"
): void {
  const sizes: Record<number, number> = {
    1: 44,
    2: 32,
    3: 24
  };

  const weights: Record<number, boolean> = {
    1: true,
    2: true,
    3: false
  };

  const lineHeights: Record<number, number> = {
    1: 120,
    2: 130,
    3: 140
  };

  slide.addText(text, {
    x,
    y,
    w: width,
    h: sizes[level] * 0.1,
    fontSize: sizes[level],
    bold: weights[level],
    color,
    fontFace,
    align: "left",
    valign: "top",
    lineSpacing: lineHeights[level],
    wrap: true
  });
}

/**
 * Add professional body text with optimal readability
 */
export function addProfessionalBody(
  slide: any,
  text: string,
  x: number,
  y: number,
  width: number,
  height: number,
  color: string = "#334155",
  fontFace: string = "Inter, Arial, sans-serif",
  fontSize: number = 16
): void {
  slide.addText(text, {
    x,
    y,
    w: width,
    h: height,
    fontSize,
    color,
    fontFace,
    align: "left",
    valign: "top",
    lineSpacing: 150,
    wrap: true
  });
}

/**
 * Add emphasized text with accent color
 */
export function addEmphasisText(
  slide: any,
  text: string,
  x: number,
  y: number,
  width: number,
  height: number,
  accentColor: string = "#6366F1",
  fontFace: string = "Inter, Arial, sans-serif"
): void {
  slide.addText(text, {
    x,
    y,
    w: width,
    h: height,
    fontSize: 18,
    bold: true,
    color: accentColor,
    fontFace,
    align: "left",
    valign: "middle",
    wrap: true,
    shadow: {
      type: "outer",
      color: accentColor.replace("#", ""),
      opacity: 0.15,
      blur: 4,
      offset: 1
    }
  });
}

/**
 * Add caption text (small, subtle)
 */
export function addCaptionText(
  slide: any,
  text: string,
  x: number,
  y: number,
  width: number,
  color: string = "#94A3B8",
  fontFace: string = "Inter, Arial, sans-serif"
): void {
  slide.addText(text, {
    x,
    y,
    w: width,
    h: 0.25,
    fontSize: 11,
    color,
    fontFace,
    align: "left",
    valign: "top"
  });
}

/**
 * Add label text (for annotations and callouts)
 */
export function addLabelText(
  slide: any,
  text: string,
  x: number,
  y: number,
  width: number,
  color: string = "#64748B",
  fontFace: string = "Inter, Arial, sans-serif"
): void {
  slide.addText(text, {
    x,
    y,
    w: width,
    h: 0.3,
    fontSize: 12,
    bold: true,
    color,
    fontFace,
    align: "left",
    valign: "middle",
    letterSpacing: 0.5
  });
}

/**
 * Calculate optimal line height for readability
 */
export function getOptimalLineHeight(fontSize: number): number {
  // Golden ratio for typography: 1.5 for body, 1.2 for headings
  if (fontSize >= 32) {
    return 120; // Headings
  } else if (fontSize >= 20) {
    return 130; // Subheadings
  } else {
    return 150; // Body text
  }
}

/**
 * Get recommended font size for content type
 */
export function getRecommendedFontSize(contentType: "title" | "subtitle" | "body" | "caption" | "label"): number {
  const sizes: Record<string, number> = {
    title: 44,
    subtitle: 28,
    body: 16,
    caption: 11,
    label: 12
  };

  return sizes[contentType] || 16;
}

/**
 * Create typography hierarchy configuration
 */
export function createTypographyHierarchy(
  baseSize: number = 16,
  fontFace: string = "Inter, Arial, sans-serif"
): Record<string, any> {
  return {
    title: {
      fontSize: baseSize * 2.75,
      fontWeight: 700,
      lineHeight: 120,
      letterSpacing: -0.5
    },
    subtitle: {
      fontSize: baseSize * 1.75,
      fontWeight: 600,
      lineHeight: 130,
      letterSpacing: 0
    },
    body: {
      fontSize: baseSize,
      fontWeight: 400,
      lineHeight: 150,
      letterSpacing: 0
    },
    caption: {
      fontSize: baseSize * 0.75,
      fontWeight: 400,
      lineHeight: 140,
      letterSpacing: 0.5
    },
    label: {
      fontSize: baseSize * 0.75,
      fontWeight: 600,
      lineHeight: 140,
      letterSpacing: 0.5
    }
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/pptxBuilder/whitespaceManager.ts
=================================================================================
/**
 * Whitespace Management System
 * Professional spacing, breathing room, and layout optimization
 */

export interface SpacingConfig {
  xs: number;    // Extra small: 0.25"
  sm: number;    // Small: 0.5"
  md: number;    // Medium: 0.75"
  lg: number;    // Large: 1"
  xl: number;    // Extra large: 1.5"
  xxl: number;   // Double extra large: 2"
}

export interface PaddingConfig {
  top: number;
  right: number;
  bottom: number;
  left: number;
}

export interface MarginConfig {
  top: number;
  right: number;
  bottom: number;
  left: number;
}

/**
 * Standard spacing scale
 */
export const SPACING_SCALE: SpacingConfig = {
  xs: 0.25,
  sm: 0.5,
  md: 0.75,
  lg: 1,
  xl: 1.5,
  xxl: 2
};

/**
 * Get spacing value by name
 */
export function getSpacing(size: keyof SpacingConfig): number {
  return SPACING_SCALE[size];
}

/**
 * Create uniform padding
 */
export function createUniformPadding(size: keyof SpacingConfig): PaddingConfig {
  const value = getSpacing(size);
  return {
    top: value,
    right: value,
    bottom: value,
    left: value
  };
}

/**
 * Create uniform margin
 */
export function createUniformMargin(size: keyof SpacingConfig): MarginConfig {
  const value = getSpacing(size);
  return {
    top: value,
    right: value,
    bottom: value,
    left: value
  };
}

/**
 * Create custom padding
 */
export function createCustomPadding(
  top: number,
  right: number,
  bottom: number,
  left: number
): PaddingConfig {
  return { top, right, bottom, left };
}

/**
 * Create custom margin
 */
export function createCustomMargin(
  top: number,
  right: number,
  bottom: number,
  left: number
): MarginConfig {
  return { top, right, bottom, left };
}

/**
 * Calculate content width with padding
 */
export function calculateContentWidth(
  totalWidth: number,
  padding: PaddingConfig
): number {
  return totalWidth - padding.left - padding.right;
}

/**
 * Calculate content height with padding
 */
export function calculateContentHeight(
  totalHeight: number,
  padding: PaddingConfig
): number {
  return totalHeight - padding.top - padding.bottom;
}

/**
 * Get recommended line height for readability
 */
export function getRecommendedLineHeight(fontSize: number): number {
  // Golden ratio: 1.5 for body, 1.2 for headings
  if (fontSize >= 32) {
    return 1.2; // Headings
  } else if (fontSize >= 20) {
    return 1.3; // Subheadings
  } else {
    return 1.5; // Body text
  }
}

/**
 * Get recommended paragraph spacing
 */
export function getRecommendedParagraphSpacing(fontSize: number): number {
  // Spacing between paragraphs should be 1-1.5x line height
  const lineHeight = getRecommendedLineHeight(fontSize);
  return (fontSize / 72) * lineHeight; // Convert to inches
}

/**
 * Calculate optimal vertical rhythm
 */
export function calculateVerticalRhythm(
  baselineHeight: number,
  multiplier: number = 1
): number {
  return baselineHeight * multiplier;
}

/**
 * Get breathing room percentage for slide
 */
export function getBreathingRoomPercentage(contentArea: number, totalArea: number): number {
  const whiteSpace = totalArea - contentArea;
  return (whiteSpace / totalArea) * 100;
}

/**
 * Validate breathing room (should be 20-40% for professional slides)
 */
export function validateBreathingRoom(
  contentArea: number,
  totalArea: number
): { valid: boolean; percentage: number; recommendation: string } {
  const percentage = getBreathingRoomPercentage(contentArea, totalArea);

  let recommendation = "";
  let valid = true;

  if (percentage < 20) {
    recommendation = "Content is too dense. Add more whitespace.";
    valid = false;
  } else if (percentage > 40) {
    recommendation = "Too much whitespace. Consider adding more content.";
    valid = false;
  } else {
    recommendation = "Breathing room is optimal.";
    valid = true;
  }

  return { valid, percentage, recommendation };
}

/**
 * Get margin for different content types
 */
export function getContentMargin(contentType: "title" | "body" | "chart" | "image"): MarginConfig {
  const margins: Record<string, MarginConfig> = {
    title: createCustomMargin(0, 0, 0.5, 0),
    body: createCustomMargin(0.25, 0, 0.25, 0),
    chart: createCustomMargin(0.5, 0, 0.5, 0),
    image: createCustomMargin(0.5, 0, 0.5, 0)
  };

  return margins[contentType] || createUniformMargin("md");
}

/**
 * Get padding for different container types
 */
export function getContainerPadding(containerType: "card" | "box" | "section" | "highlight"): PaddingConfig {
  const paddings: Record<string, PaddingConfig> = {
    card: createCustomPadding(0.5, 0.5, 0.5, 0.5),
    box: createCustomPadding(0.75, 0.75, 0.75, 0.75),
    section: createCustomPadding(1, 1, 1, 1),
    highlight: createCustomPadding(0.5, 0.75, 0.5, 0.75)
  };

  return paddings[containerType] || createUniformPadding("md");
}

/**
 * Calculate grid gap for multi-column layouts
 */
export function calculateGridGap(columnCount: number, totalWidth: number): number {
  // Recommended gap: 0.25" to 0.5" depending on columns
  if (columnCount <= 2) {
    return 0.5;
  } else if (columnCount <= 3) {
    return 0.4;
  } else {
    return 0.25;
  }
}

/**
 * Calculate column width for grid
 */
export function calculateColumnWidth(
  totalWidth: number,
  columnCount: number,
  gap: number
): number {
  const totalGap = gap * (columnCount - 1);
  return (totalWidth - totalGap) / columnCount;
}

/**
 * Get recommended section spacing
 */
export function getRecommendedSectionSpacing(sectionType: "header" | "body" | "footer"): number {
  const spacing: Record<string, number> = {
    header: 0.5,
    body: 0.75,
    footer: 0.5
  };

  return spacing[sectionType] || 0.5;
}

/**
 * Calculate optimal slide margins
 */
export function getOptimalSlideMargins(slideWidth: number, slideHeight: number): MarginConfig {
  // Golden ratio margins: approximately 5-10% of slide dimensions
  const horizontalMargin = slideWidth * 0.05;
  const verticalMargin = slideHeight * 0.067;

  return createCustomMargin(verticalMargin, horizontalMargin, verticalMargin, horizontalMargin);
}

/**
 * Get text box padding for readability
 */
export function getTextBoxPadding(textLength: number): PaddingConfig {
  // Longer text needs more breathing room
  if (textLength > 500) {
    return createCustomPadding(0.75, 0.75, 0.75, 0.75);
  } else if (textLength > 200) {
    return createCustomPadding(0.5, 0.5, 0.5, 0.5);
  } else {
    return createCustomPadding(0.25, 0.25, 0.25, 0.25);
  }
}

/**
 * Calculate list item spacing
 */
export function getListItemSpacing(itemCount: number): number {
  // More items = less spacing to fit on slide
  if (itemCount <= 3) {
    return 0.4;
  } else if (itemCount <= 5) {
    return 0.3;
  } else {
    return 0.2;
  }
}

/**
 * Get recommended spacing between elements
 */
export function getElementSpacing(elementType: "heading-body" | "body-body" | "section-section"): number {
  const spacing: Record<string, number> = {
    "heading-body": 0.3,
    "body-body": 0.2,
    "section-section": 0.75
  };

  return spacing[elementType] || 0.25;
}

/**
 * Validate layout spacing
 */
export function validateLayoutSpacing(
  elements: Array<{ y: number; h: number }>,
  slideHeight: number
): { valid: boolean; issues: string[] } {
  const issues: string[] = [];

  // Check for overlapping elements
  for (let i = 0; i < elements.length - 1; i++) {
    const current = elements[i];
    const next = elements[i + 1];

    if (current.y + current.h > next.y) {
      issues.push(`Elements ${i} and ${i + 1} are overlapping`);
    }
  }

  // Check if content fits on slide
  const lastElement = elements[elements.length - 1];
  if (lastElement.y + lastElement.h > slideHeight) {
    issues.push("Content extends beyond slide height");
  }

  return {
    valid: issues.length === 0,
    issues
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/presentationAI.ts
=================================================================================
/**
 * Presentation-Level AI Intelligence
 * Multi-slide generation, narrative flow, slide relationships
 */

import { logger } from "firebase-functions/v2";
import type { SlideSpecV1 } from "./types/SlideSpecV1";

export interface PresentationRequest {
  topic: string;
  audience?: "executives" | "technical" | "sales" | "general" | "investors";
  tone?: "formal" | "casual" | "persuasive" | "educational" | "inspirational";
  slideCount?: number; // Desired number of slides (default: auto-determine)
  industry?: "tech" | "finance" | "healthcare" | "marketing" | "corporate";
  includeAgenda?: boolean;
  includeSummary?: boolean;
}

export interface PresentationStructure {
  title: string;
  slides: Array<{
    type: "title" | "agenda" | "content" | "data" | "quote" | "summary" | "cta";
    title: string;
    purpose: string;
    keyPoints: string[];
    suggestedPattern: "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused";
  }>;
  narrativeFlow: string;
  transitionStrategy: string;
}

/**
 * Analyze presentation request and generate structure
 */
export function analyzePresentationRequest(request: PresentationRequest): PresentationStructure {
  const { topic, audience = "general", tone = "formal", slideCount, industry = "corporate" } = request;
  
  // Determine optimal slide count if not specified
  const optimalSlideCount = slideCount || determineOptimalSlideCount(topic, audience);
  
  // Generate presentation structure
  const structure: PresentationStructure = {
    title: topic,
    slides: [],
    narrativeFlow: generateNarrativeFlow(topic, audience, tone),
    transitionStrategy: determineTransitionStrategy(tone, industry)
  };
  
  // Add title slide
  structure.slides.push({
    type: "title",
    title: topic,
    purpose: "Introduce the presentation topic and set the tone",
    keyPoints: [topic, `Presented to ${audience} audience`],
    suggestedPattern: "hero"
  });
  
  // Add agenda slide if requested
  if (request.includeAgenda) {
    structure.slides.push({
      type: "agenda",
      title: "Agenda",
      purpose: "Outline the presentation structure",
      keyPoints: ["Overview", "Key Topics", "Conclusion"],
      suggestedPattern: "minimal"
    });
  }
  
  // Generate content slides based on topic analysis
  const contentSlides = generateContentSlides(topic, optimalSlideCount - 2, audience, industry);
  structure.slides.push(...contentSlides);
  
  // Add summary slide if requested
  if (request.includeSummary) {
    structure.slides.push({
      type: "summary",
      title: "Key Takeaways",
      purpose: "Summarize main points and reinforce message",
      keyPoints: ["Summary point 1", "Summary point 2", "Summary point 3"],
      suggestedPattern: "minimal"
    });
  }
  
  return structure;
}

/**
 * Determine optimal slide count based on topic complexity
 */
function determineOptimalSlideCount(topic: string, audience: string): number {
  const topicLength = topic.split(" ").length;
  
  // Base count on topic complexity
  let baseCount = 5; // Default
  
  if (topicLength > 10) baseCount = 8; // Complex topic
  if (topicLength > 15) baseCount = 12; // Very complex topic
  
  // Adjust for audience
  if (audience === "executives") baseCount = Math.min(baseCount, 7); // Executives prefer concise
  if (audience === "technical") baseCount += 2; // Technical audiences need more detail
  
  return baseCount;
}

/**
 * Generate narrative flow description
 */
function generateNarrativeFlow(topic: string, audience: string, tone: string): string {
  const flows = {
    executives: "Problem ‚Üí Solution ‚Üí Impact ‚Üí ROI ‚Üí Next Steps",
    technical: "Context ‚Üí Architecture ‚Üí Implementation ‚Üí Results ‚Üí Future Work",
    sales: "Pain Point ‚Üí Solution ‚Üí Benefits ‚Üí Proof ‚Üí Call to Action",
    general: "Introduction ‚Üí Key Points ‚Üí Supporting Details ‚Üí Conclusion",
    investors: "Opportunity ‚Üí Market ‚Üí Solution ‚Üí Traction ‚Üí Ask"
  };
  
  return flows[audience as keyof typeof flows] || flows.general;
}

/**
 * Determine transition strategy
 */
function determineTransitionStrategy(tone: string, industry: string): string {
  if (tone === "formal" && industry === "finance") {
    return "Minimal transitions (fade only) for professional, serious tone";
  }
  
  if (tone === "inspirational" || industry === "marketing") {
    return "Dynamic transitions (push, zoom) for energetic, engaging feel";
  }
  
  if (industry === "tech") {
    return "Modern transitions (wipe, split) for contemporary, innovative feel";
  }
  
  return "Balanced transitions (fade, push) for professional yet engaging presentation";
}

/**
 * Generate content slides based on topic
 */
function generateContentSlides(
  topic: string,
  count: number,
  audience: string,
  industry: string
): PresentationStructure["slides"] {
  const slides: PresentationStructure["slides"] = [];
  
  // Analyze topic to determine slide types
  const topicLower = topic.toLowerCase();
  
  // Determine slide distribution
  const hasData = topicLower.match(/sales|revenue|growth|metrics|performance|analytics/);
  const hasProcess = topicLower.match(/process|workflow|steps|implementation|strategy/);
  const hasComparison = topicLower.match(/vs|versus|compare|comparison|alternative/);
  
  for (let i = 0; i < count; i++) {
    const slideNumber = i + 1;
    
    // Vary slide types for engagement
    if (i === 0) {
      // First content slide - overview
      slides.push({
        type: "content",
        title: `${topic} - Overview`,
        purpose: "Provide high-level context and set expectations",
        keyPoints: ["Context", "Scope", "Objectives"],
        suggestedPattern: "split"
      });
    } else if (hasData && i === Math.floor(count / 2)) {
      // Middle slide - data visualization
      slides.push({
        type: "data",
        title: "Key Metrics & Performance",
        purpose: "Present data-driven insights",
        keyPoints: ["Metric 1", "Metric 2", "Metric 3"],
        suggestedPattern: "data-focused"
      });
    } else if (hasComparison && i === Math.floor(count / 3)) {
      // Comparison slide
      slides.push({
        type: "content",
        title: "Comparison & Analysis",
        purpose: "Compare options or approaches",
        keyPoints: ["Option A", "Option B", "Recommendation"],
        suggestedPattern: "split"
      });
    } else if (i === count - 1) {
      // Last content slide - call to action
      slides.push({
        type: "cta",
        title: "Next Steps",
        purpose: "Drive action and provide clear next steps",
        keyPoints: ["Action 1", "Action 2", "Timeline"],
        suggestedPattern: "minimal"
      });
    } else {
      // Regular content slide
      slides.push({
        type: "content",
        title: `Key Point ${slideNumber}`,
        purpose: "Develop main argument or provide supporting information",
        keyPoints: ["Point 1", "Point 2", "Point 3"],
        suggestedPattern: i % 2 === 0 ? "asymmetric" : "grid"
      });
    }
  }
  
  return slides;
}

/**
 * Generate enhanced prompt for multi-slide presentation
 */
export function generatePresentationPrompt(request: PresentationRequest): string {
  const structure = analyzePresentationRequest(request);
  
  const prompt = `
Create a professional ${structure.slides.length}-slide presentation on "${request.topic}".

AUDIENCE: ${request.audience || "general"}
TONE: ${request.tone || "formal"}
INDUSTRY: ${request.industry || "corporate"}

NARRATIVE FLOW: ${structure.narrativeFlow}

SLIDE STRUCTURE:
${structure.slides.map((slide, idx) => `
${idx + 1}. ${slide.title} (${slide.type})
   Pattern: ${slide.suggestedPattern}
   Purpose: ${slide.purpose}
   Key Points: ${slide.keyPoints.join(", ")}
`).join("\n")}

REQUIREMENTS:
- Maintain consistent design language across all slides
- Use ${structure.transitionStrategy}
- Ensure logical flow from slide to slide
- Include relevant data visualizations where appropriate
- Keep text concise and impactful (max 5 bullets per slide)
- Use professional color palette appropriate for ${request.industry}

Generate a complete presentation with all ${structure.slides.length} slides.
`;
  
  return prompt;
}

/**
 * Validate slide relationships and narrative flow
 */
export function validatePresentationFlow(slides: SlideSpecV1[]): {
  valid: boolean;
  issues: string[];
  suggestions: string[];
} {
  const issues: string[] = [];
  const suggestions: string[] = [];
  
  // Check for title slide
  if (slides.length > 0 && !slides[0].content.title.text.match(/^[A-Z]/)) {
    issues.push("First slide should have a capitalized title");
  }
  
  // Check for consistent theme
  const themes = slides.map(s => s.meta.theme);
  const uniqueThemes = new Set(themes);
  if (uniqueThemes.size > 1) {
    issues.push(`Inconsistent themes detected: ${Array.from(uniqueThemes).join(", ")}`);
    suggestions.push("Use a consistent theme across all slides");
  }
  
  // Check for consistent color palette
  const primaryColors = slides.map(s => s.styleTokens.palette.primary);
  const uniqueColors = new Set(primaryColors);
  if (uniqueColors.size > 2) {
    issues.push("Too many different primary colors used");
    suggestions.push("Limit to 1-2 primary colors for consistency");
  }
  
  // Check slide count
  if (slides.length < 3) {
    suggestions.push("Consider adding more slides for a complete presentation");
  }
  if (slides.length > 20) {
    suggestions.push("Consider condensing content - presentations over 20 slides may lose audience attention");
  }
  
  // Check for data visualization distribution
  const dataSlides = slides.filter(s => s.content.dataViz);
  if (dataSlides.length === 0 && slides.length > 5) {
    suggestions.push("Consider adding data visualizations to support key points");
  }
  
  return {
    valid: issues.length === 0,
    issues,
    suggestions
  };
}

/**
 * Generate agenda slide content from presentation structure
 */
export function generateAgendaSlide(slides: SlideSpecV1[]): {
  title: string;
  items: string[];
} {
  return {
    title: "Agenda",
    items: slides
      .filter((_, idx) => idx > 0) // Skip title slide
      .map(s => s.content.title.text)
      .slice(0, 6) // Max 6 agenda items
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/promptEnhancer.ts
=================================================================================
/**
 * Prompt Enhancer
 * Analyzes and enhances user prompts with design guidance
 */

export interface EnhancedPrompt {
  original: string;
  enhanced: string;
  suggestedPattern: string;
  suggestedPalette: string;
  suggestedTypography: string;
  designGuidance: string[];
  contentType: string;
}

/**
 * Analyze prompt to determine content type
 */
export function analyzeContentType(prompt: string): string {
  const lower = prompt.toLowerCase();

  if (lower.includes("data") || lower.includes("chart") || lower.includes("metric") || lower.includes("analytics")) {
    return "data-visualization";
  }
  if (lower.includes("compare") || lower.includes("vs") || lower.includes("before") || lower.includes("after")) {
    return "comparison";
  }
  if (lower.includes("process") || lower.includes("step") || lower.includes("flow")) {
    return "process";
  }
  if (lower.includes("feature") || lower.includes("product") || lower.includes("launch")) {
    return "product";
  }
  if (lower.includes("quote") || lower.includes("message") || lower.includes("key point")) {
    return "emphasis";
  }
  if (lower.includes("education") || lower.includes("learn") || lower.includes("teach")) {
    return "educational";
  }
  if (lower.includes("business") || lower.includes("corporate") || lower.includes("professional")) {
    return "corporate";
  }
  if (lower.includes("creative") || lower.includes("design") || lower.includes("art")) {
    return "creative";
  }

  return "general";
}

/**
 * Suggest design pattern based on content type
 */
export function suggestPattern(contentType: string): string {
  const patterns: Record<string, string> = {
    "data-visualization": "data-focused",
    comparison: "split",
    process: "grid",
    product: "hero",
    emphasis: "minimal",
    educational: "split",
    corporate: "split",
    creative: "asymmetric",
    general: "split"
  };

  return patterns[contentType] || "split";
}

/**
 * Suggest color palette based on content type
 */
export function suggestPalette(contentType: string): string {
  const palettes: Record<string, string> = {
    "data-visualization": "finance",
    comparison: "corporate",
    process: "tech",
    product: "creative",
    emphasis: "minimal",
    educational: "education",
    corporate: "corporate",
    creative: "creative",
    general: "corporate"
  };

  return palettes[contentType] || "corporate";
}

/**
 * Suggest typography based on content type
 */
export function suggestTypography(contentType: string): string {
  const typographies: Record<string, string> = {
    "data-visualization": "modern",
    comparison: "corporate",
    process: "modern",
    product: "bold",
    emphasis: "elegant",
    educational: "friendly",
    corporate: "corporate",
    creative: "creative",
    general: "modern"
  };

  return typographies[contentType] || "modern";
}

/**
 * Generate design guidance based on content type
 */
export function generateDesignGuidance(contentType: string): string[] {
  const guidance: Record<string, string[]> = {
    "data-visualization": [
      "Use data-focused pattern with chart as primary focus",
      "Ensure high contrast for readability",
      "Include supporting text in sidebar",
      "Use complementary colors for data series",
      "Add data labels for clarity"
    ],
    comparison: [
      "Use split pattern for 50/50 comparison",
      "Maintain visual balance between sides",
      "Use contrasting colors to highlight differences",
      "Include clear labels for each side",
      "Consider using icons for quick recognition"
    ],
    process: [
      "Use grid pattern for step-by-step flow",
      "Number or label each step clearly",
      "Use consistent styling across steps",
      "Consider adding arrows between steps",
      "Maintain logical left-to-right or top-to-bottom flow"
    ],
    product: [
      "Use hero pattern for strong visual impact",
      "Feature product image or key visual prominently",
      "Use bold typography for headlines",
      "Include key benefits in supporting text",
      "Use accent color for call-to-action"
    ],
    emphasis: [
      "Use minimal pattern with generous white space",
      "Center content for maximum impact",
      "Use large, bold typography",
      "Limit to essential message only",
      "Consider using accent color for emphasis"
    ],
    educational: [
      "Use split pattern for content organization",
      "Include visual aids or diagrams",
      "Use friendly, approachable typography",
      "Break content into digestible chunks",
      "Use consistent color coding for concepts"
    ],
    corporate: [
      "Use professional color palette",
      "Maintain consistent branding",
      "Use corporate typography",
      "Include company logo if appropriate",
      "Ensure WCAG AA accessibility compliance"
    ],
    creative: [
      "Use asymmetric pattern for dynamic layout",
      "Experiment with bold colors",
      "Use creative typography pairings",
      "Consider unconventional layouts",
      "Balance creativity with readability"
    ],
    general: [
      "Choose appropriate design pattern for content",
      "Ensure sufficient white space",
      "Maintain visual hierarchy",
      "Use consistent typography",
      "Verify color contrast ratios"
    ]
  };

  return guidance[contentType] || guidance.general;
}

/**
 * Enhance prompt with design guidance
 */
export function enhancePrompt(userPrompt: string): EnhancedPrompt {
  const contentType = analyzeContentType(userPrompt);
  const pattern = suggestPattern(contentType);
  const palette = suggestPalette(contentType);
  const typography = suggestTypography(contentType);
  const guidance = generateDesignGuidance(contentType);

  const enhanced = `${userPrompt}

DESIGN GUIDANCE:
- Pattern: ${pattern}
- Color Palette: ${palette}
- Typography: ${typography}
- Key Principles:
${guidance.map(g => `  ‚Ä¢ ${g}`).join("\n")}`;

  return {
    original: userPrompt,
    enhanced,
    suggestedPattern: pattern,
    suggestedPalette: palette,
    suggestedTypography: typography,
    designGuidance: guidance,
    contentType
  };
}

/**
 * Validate prompt for design quality
 */
export function validatePromptQuality(prompt: string): {
  isValid: boolean;
  issues: string[];
  suggestions: string[];
} {
  const issues: string[] = [];
  const suggestions: string[] = [];

  if (prompt.length < 10) {
    issues.push("Prompt is too short - provide more context");
  }

  if (prompt.length > 1000) {
    suggestions.push("Prompt is quite long - consider breaking into multiple slides");
  }

  if (!prompt.includes(" ")) {
    issues.push("Prompt appears to be a single word - provide more detail");
  }

  const hasNumbers = /\d/.test(prompt);
  if (!hasNumbers && prompt.toLowerCase().includes("data")) {
    suggestions.push("Data-related prompt should include specific numbers or metrics");
  }

  const hasAction = /\b(show|display|create|make|build|design)\b/i.test(prompt);
  if (!hasAction) {
    suggestions.push("Consider using action verbs like 'show', 'display', or 'create'");
  }

  return {
    isValid: issues.length === 0,
    issues,
    suggestions
  };
}

/**
 * Extract key topics from prompt
 */
export function extractKeyTopics(prompt: string): string[] {
  const words = prompt.split(/\s+/);
  const stopWords = new Set([
    "the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for",
    "of", "with", "by", "from", "is", "are", "was", "were", "be", "been"
  ]);

  return words
    .filter(word => word.length > 3 && !stopWords.has(word.toLowerCase()))
    .slice(0, 5);
}

/**
 * Generate slide title suggestions
 */
export function generateTitleSuggestions(prompt: string): string[] {
  const topics = extractKeyTopics(prompt);
  const contentType = analyzeContentType(prompt);

  const suggestions: string[] = [];

  // Suggestion 1: Direct topic
  if (topics.length > 0) {
    suggestions.push(topics[0].charAt(0).toUpperCase() + topics[0].slice(1));
  }

  // Suggestion 2: Combined topics
  if (topics.length > 1) {
    suggestions.push(
      topics.slice(0, 2).map(t => t.charAt(0).toUpperCase() + t.slice(1)).join(" & ")
    );
  }

  // Suggestion 3: Content type based
  const typeBasedTitles: Record<string, string> = {
    "data-visualization": "Key Metrics & Insights",
    comparison: "Comparison Analysis",
    process: "Process Overview",
    product: "Product Highlights",
    emphasis: "Key Message",
    educational: "Learning Objectives",
    corporate: "Business Update",
    creative: "Creative Showcase"
  };

  if (typeBasedTitles[contentType]) {
    suggestions.push(typeBasedTitles[contentType]);
  }

  return suggestions;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/prompts.ts
=================================================================================
/** Enhanced system prompt with world-class design guidance */
export const ENHANCED_SYSTEM_PROMPT = `
You are the SlideSpec generator for plzfixthx, an AI-powered single-slide generator.
Your task is to convert user prompts into beautiful, professional slide specifications with sophisticated design.

CRITICAL RULES:
1. Output ONLY valid JSON - no markdown, no explanations, no additional text
2. The JSON must validate against the SlideSpec v1 schema
3. Use meta.version "1.0" and aspectRatio "16:9" as defaults
4. Keep text concise and professional (max 5 bullets total, levels 1-3)
5. Use hex colors (#RRGGBB format only)
6. IDs must match pattern [A-Za-z0-9_-]
7. If including dataViz, ensure labels array has 2-10 items and all series values arrays match labels length
8. Every slide will automatically include professional design accents: sophisticated SVG backgrounds, accent bars, decorative shapes, and corner accents

CONTENT QUALITY GUIDELINES:
- Titles: Clear, concise, action-oriented (4-8 words ideal)
- Subtitles: Provide context or key insight (8-15 words)
- Bullets: One clear idea per bullet, parallel structure, start with strong verbs
- Data: Use specific numbers, percentages, and metrics for credibility
- Callouts: Highlight critical information, warnings, or key takeaways
- Keep total word count under 100 words per slide for maximum impact

WORLD-CLASS DESIGN PRINCIPLES (Apple/Google/Tesla/ChatGPT Standards):
1. Visual Hierarchy: Create crystal-clear focal points using sophisticated size, color, and contrast
   - Primary focus: Largest, boldest, most saturated - commands immediate attention
   - Secondary focus: Medium size, medium weight - supports primary narrative
   - Supporting: Smallest, lightest, neutral colors - provides context without distraction
   - Use 3-4 hierarchy levels maximum for clarity
2. White Space Mastery: Generous breathing room creates luxury and sophistication
   - Generous (40-50%): Premium, luxury, high-end, minimalist aesthetic
   - Balanced (28-36%): Professional, modern, corporate, Apple-like
   - Compact (18-26%): Data-focused, grid, information-dense but still elegant
   - Minimum margins: 32px (0.44in) for professional presentations
3. Automatic Professional Design Accents (Applied to Every Slide):
   - Sophisticated SVG gradient backgrounds with subtle color transitions and depth
   - Left accent bar (0.08-0.12" width) in primary color for visual anchor
   - Corner accents with refined opacity (8-15%) for sophistication
   - Decorative circles and abstract shapes for visual interest
   - Premium divider line under title (2.5" width, 0.04" height) in primary color
   - Colored bullet points matching primary color for cohesion
   - Wave patterns and curved accents for modern, dynamic feel
   - All accents are automatically added - focus on content quality and hierarchy
4. Color Psychology & Sophistication:
   - Tech/Innovation: Deep Blues (#1E40AF, #2563EB), Purples (#7C3AED), Cyans (#06B6D4)
   - Finance: Navy (#0F172A), Emerald (#10B981), Gold (#F59E0B)
   - Healthcare: Teal (#0D9488), Sky Blue (#0EA5E9), Sage (#10B981)
   - Creative: Magenta (#EC4899), Amber (#F59E0B), Violet (#8B5CF6)
   - Corporate: Slate (#475569), Indigo (#4F46E5), Charcoal (#1F2937)
   - Use color sparingly - 1-2 accent colors maximum for sophistication
5. Typography Excellence: Professional font pairing with perfect hierarchy
   - All slides use Aptos font (modern, professional, clean, excellent readability)
   - Title: 36-44px, bold (700), dark slate (#0F172A), line-height 1.1-1.2
   - Subtitle: 18-22px, medium (500), slate gray (#64748B), line-height 1.3
   - Body/Bullets: 16-18px, regular (400), dark gray (#1E293B), line-height 1.4-1.5
   - Callouts: 16-17px, medium (500), with colored backgrounds and borders
   - Chart labels: 10-12px, regular, subtle gray (#64748B)
   - Generous spacing between elements (8-12px paragraph spacing)
6. Balance & Composition: Use rule of thirds, golden ratio, and negative space
   - Align elements to invisible grid (8px or 16px)
   - Create visual tension through asymmetry when appropriate
   - Maintain consistent padding and margins throughout

PROFESSIONAL DESIGN PATTERNS (choose one based on content):
- Hero: Large title/image (55-65% of slide), minimal supporting text - for announcements, key messages, product launches
  * Best for: Executive summaries, product reveals, keynote slides
  * Whitespace: Generous (40-50%)
  * Typography: Bold, large titles (44-56px), subtle subtitles
- Split: 50/50 content division with clear visual separation - for comparisons, before/after, dual narratives
  * Best for: Comparisons, pros/cons, two-part stories
  * Whitespace: Balanced (28-36%)
  * Typography: Equal weight on both sides
- Asymmetric: Dynamic off-center layout with visual tension - for creative, feature highlights, modern brands
  * Best for: Creative industries, feature highlights, modern tech
  * Whitespace: Balanced to generous (30-45%)
  * Typography: Varied sizes creating visual interest
- Grid: Structured multi-element layout (2x2, 3x3, etc.) - for multiple items, portfolio, process flows
  * Best for: Portfolio items, process steps, multiple metrics
  * Whitespace: Compact to balanced (20-32%)
  * Typography: Consistent sizing across grid items
- Minimal: Maximum white space (40%+), essential content only - for quotes, emphasis, luxury brands
  * Best for: Quotes, key takeaways, luxury/premium positioning
  * Whitespace: Generous (45-55%)
  * Typography: Large, bold, centered
- Data-Focused: Chart as primary (55-70%), supporting text sidebar - for analytics, metrics, financial data
  * Best for: Analytics, financial reports, data-driven insights
  * Whitespace: Compact (18-26%)
  * Typography: Smaller, supporting role

PROFESSIONAL LAYOUT GUIDELINES:
- Use a 12-column, 8-row grid system with 8px gutter
- Standard regions: header (rows 1-2, rowSpan: 2), body (rows 3-7), footer/aside (rows 3-7, cols 9-12)
- CRITICAL: Header region MUST have rowSpan: 2 (minimum) to accommodate title + subtitle without overlap
- If slide has both title AND subtitle, ensure header rowSpan >= 2
- Anchor content elements to appropriate regions with clear hierarchy
- Minimum margins: 32px (0.44in) all around for professional appearance
- Ensure visual balance using rule of thirds or golden ratio
- Align all elements to 8px or 16px grid for precision

PROFESSIONAL STYLE GUIDELINES:
- Choose sophisticated color palettes matching content theme and industry
- Business/Corporate: Navy (#0F172A), Indigo (#4F46E5), Slate (#475569)
- Finance/Banking: Navy (#1E40AF), Emerald (#10B981), Gold (#F59E0B)
- Tech/Innovation: Deep Blue (#1E40AF), Purple (#7C3AED), Cyan (#06B6D4)
- Healthcare: Teal (#0D9488), Sky (#0EA5E9), Sage (#10B981)
- Creative/Marketing: Magenta (#EC4899), Amber (#F59E0B), Violet (#8B5CF6)
- Use 7 neutral colors from dark (#0F172A) to light (#F8FAFC)
- Typography sizes: step_3 (36-44px) for titles, step_1 (20-24px) for subtitles, step_0 (16px) for body
- Ensure WCAG AAA contrast ratio of 7:1 for premium accessibility
- Use subtle shadows (0 4px 12px rgba(0,0,0,0.08)) for depth without clutter

ADVANCED DESIGN TECHNIQUES FOR WORLD-CLASS SLIDES:
1. Micro-interactions & Visual Refinement:
   - Use subtle opacity variations (8%, 12%, 15%) for layered depth
   - Apply refined border-radius (4-8px) for modern, approachable feel
   - Implement consistent spacing rhythm (8px base unit)
   - Use premium shadows with proper blur and offset for elevation
2. Typography Refinement:
   - Implement proper letter-spacing for titles (+0.5px to +1px)
   - Use line-height 1.2-1.3 for titles, 1.4-1.6 for body text
   - Apply font-weight hierarchy: 700 (bold) for titles, 600 (semibold) for emphasis, 400 (regular) for body
   - Ensure minimum 16px font size for body text (accessibility)
3. Color Harmony & Contrast:
   - Primary color: Use for titles, accents, and key elements
   - Accent color: Complementary or analogous to primary, used sparingly
   - Neutral palette: 7-step scale from dark to light for text and backgrounds
   - Ensure 4.5:1 minimum contrast for WCAG AA, 7:1 for AAA (premium)
4. Layout Sophistication:
   - Use asymmetric layouts for visual interest (not centered)
   - Apply rule of thirds for focal point placement
   - Create breathing room with 40-50% whitespace for premium feel
   - Align all elements to 8px grid for precision and consistency
5. Data Visualization Excellence:
   - Use professional color palettes for charts (avoid rainbow)
   - Implement proper chart spacing and margins
   - Add subtle gridlines for readability without clutter
   - Use appropriate chart types: bar for comparisons, line for trends, pie for composition
   - Ensure chart labels are readable (10-12px minimum)

EXAMPLE 1 - Premium Business Presentation (Data-Focused Pattern):
User: "Q4 sales performance with revenue growth chart"
Output: {
  "meta": {"version": "1.0", "locale": "en-US", "theme": "Premium Business", "aspectRatio": "16:9"},
  "content": {
    "title": {"id": "title", "text": "Q4 Sales Performance"},
    "subtitle": {"id": "subtitle", "text": "Revenue Growth & Strategic Metrics"},
    "bullets": [{"id": "b1", "items": [
      {"text": "Total revenue increased 23% YoY", "level": 1},
      {"text": "New customer acquisition up 15%", "level": 1},
      {"text": "Customer retention rate: 94%", "level": 1}
    ]}],
    "dataViz": {
      "id": "chart1",
      "kind": "bar",
      "title": "Quarterly Revenue Trajectory",
      "labels": ["Q1", "Q2", "Q3", "Q4"],
      "series": [{"name": "Revenue ($M)", "values": [12, 15, 18, 22]}]
    }
  },
  "layout": {
    "grid": {"rows": 8, "cols": 12, "gutter": 8, "margin": {"t": 32, "r": 32, "b": 32, "l": 32}},
    "regions": [
      {"name": "header", "rowStart": 1, "colStart": 1, "rowSpan": 2, "colSpan": 12},
      {"name": "body", "rowStart": 3, "colStart": 1, "rowSpan": 5, "colSpan": 8},
      {"name": "aside", "rowStart": 3, "colStart": 9, "rowSpan": 5, "colSpan": 4}
    ],
    "anchors": [
      {"refId": "title", "region": "header", "order": 0},
      {"refId": "subtitle", "region": "header", "order": 1},
      {"refId": "chart1", "region": "body", "order": 0},
      {"refId": "b1", "region": "aside", "order": 0}
    ]
  },
  "styleTokens": {
    "palette": {"primary": "#0F172A", "accent": "#10B981", "neutral": ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"]},
    "typography": {
      "fonts": {"sans": "Inter, Arial, sans-serif"},
      "sizes": {"step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 20, "step_2": 28, "step_3": 40},
      "weights": {"regular": 400, "medium": 500, "semibold": 600, "bold": 700},
      "lineHeights": {"compact": 1.2, "standard": 1.5}
    },
    "spacing": {"base": 4, "steps": [0,4,8,12,16,24,32]},
    "radii": {"sm": 4, "md": 8, "lg": 12},
    "shadows": {"sm": "0 2px 4px rgba(0,0,0,.08)", "md": "0 4px 12px rgba(0,0,0,.12)", "lg": "0 12px 32px rgba(0,0,0,.16)"},
    "contrast": {"minTextContrast": 7, "minUiContrast": 4.5}
  },
  "design": {
    "pattern": "data-focused",
    "visualHierarchy": {
      "primaryFocus": "chart1",
      "secondaryFocus": ["title", "b1"],
      "emphasisLevels": {"chart1": 5, "title": 4, "b1": 3, "subtitle": 2}
    },
    "whitespace": {
      "strategy": "balanced",
      "breathingRoom": 32
    },
    "typography": {
      "strategy": "modern",
      "fontPairing": {"primary": "Inter, sans-serif", "secondary": "Inter, sans-serif"},
      "hierarchy": {
        "title": {"size": 40, "weight": 700, "lineHeight": 1.2, "letterSpacing": 0.5},
        "subtitle": {"size": 20, "weight": 500, "lineHeight": 1.4},
        "body": {"size": 16, "weight": 400, "lineHeight": 1.5}
      }
    },
    "colorStrategy": {
      "distribution": "complementary",
      "emphasis": "#10B981",
      "contrast": "high"
    }
  }
}

EXAMPLE 2 - Premium Educational Content (Split Pattern):
User: "Introduction to photosynthesis for high school students"
Output: {
  "meta": {"version": "1.0", "locale": "en-US", "theme": "Premium Education", "aspectRatio": "16:9"},
  "content": {
    "title": {"id": "title", "text": "Photosynthesis"},
    "subtitle": {"id": "subtitle", "text": "How Plants Convert Light into Energy"},
    "bullets": [{"id": "b1", "items": [
      {"text": "Process occurs in chloroplasts", "level": 1},
      {"text": "Requires sunlight, water, and CO‚ÇÇ", "level": 1},
      {"text": "Produces glucose and oxygen", "level": 1},
      {"text": "Essential for life on Earth", "level": 1}
    ]}],
    "callouts": [{"id": "c1", "title": "Key Formula", "text": "6CO‚ÇÇ + 6H‚ÇÇO + Light ‚Üí C‚ÇÜH‚ÇÅ‚ÇÇO‚ÇÜ + 6O‚ÇÇ", "variant": "note"}]
  },
  "layout": {
    "grid": {"rows": 8, "cols": 12, "gutter": 8, "margin": {"t": 32, "r": 32, "b": 32, "l": 32}},
    "regions": [
      {"name": "header", "rowStart": 1, "colStart": 1, "rowSpan": 2, "colSpan": 12},
      {"name": "body", "rowStart": 3, "colStart": 1, "rowSpan": 5, "colSpan": 6},
      {"name": "aside", "rowStart": 3, "colStart": 7, "rowSpan": 5, "colSpan": 6}
    ],
    "anchors": [
      {"refId": "title", "region": "header", "order": 0},
      {"refId": "subtitle", "region": "header", "order": 1},
      {"refId": "b1", "region": "body", "order": 0},
      {"refId": "c1", "region": "aside", "order": 0}
    ]
  },
  "styleTokens": {
    "palette": {"primary": "#0D9488", "accent": "#F59E0B", "neutral": ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"]},
    "typography": {
      "fonts": {"sans": "Inter, Arial, sans-serif"},
      "sizes": {"step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 20, "step_2": 28, "step_3": 44},
      "weights": {"regular": 400, "medium": 500, "semibold": 600, "bold": 700},
      "lineHeights": {"compact": 1.2, "standard": 1.6}
    },
    "spacing": {"base": 4, "steps": [0,4,8,12,16,24,32]},
    "radii": {"sm": 4, "md": 8, "lg": 12},
    "shadows": {"sm": "0 2px 4px rgba(0,0,0,.08)", "md": "0 4px 12px rgba(0,0,0,.12)", "lg": "0 12px 32px rgba(0,0,0,.16)"},
    "contrast": {"minTextContrast": 7, "minUiContrast": 4.5}
  },
  "design": {
    "pattern": "split",
    "visualHierarchy": {
      "primaryFocus": "b1",
      "secondaryFocus": ["title", "c1"],
      "emphasisLevels": {"title": 5, "b1": 4, "c1": 4, "subtitle": 2}
    },
    "whitespace": {
      "strategy": "balanced",
      "breathingRoom": 32
    },
    "typography": {
      "strategy": "modern",
      "fontPairing": {"primary": "Inter, sans-serif", "secondary": "Inter, sans-serif"},
      "hierarchy": {
        "title": {"size": 44, "weight": 700, "lineHeight": 1.2, "letterSpacing": 0.5},
        "subtitle": {"size": 24, "weight": 600, "lineHeight": 1.4},
        "body": {"size": 16, "weight": 400, "lineHeight": 1.6}
      }
    },
    "colorStrategy": {
      "distribution": "analogous",
      "emphasis": "#F59E0B",
      "contrast": "high"
    }
  }
}

EXAMPLE 3 - Premium Marketing Presentation (Hero Pattern):
User: "Product launch announcement with key features"
Output: {
  "meta": {"version": "1.0", "locale": "en-US", "theme": "Premium Marketing", "aspectRatio": "16:9"},
  "content": {
    "title": {"id": "title", "text": "Introducing Our New Product"},
    "subtitle": {"id": "subtitle", "text": "Innovation Meets Excellence"},
    "bullets": [{"id": "b1", "items": [
      {"text": "Advanced AI-powered features", "level": 1},
      {"text": "Seamless integration with existing tools", "level": 2},
      {"text": "50% faster performance", "level": 1},
      {"text": "Enterprise-grade security", "level": 1}
    ]}],
    "callouts": [{"id": "c1", "title": "Special Launch Offer", "text": "Get 30% off for early adopters", "variant": "success"}]
  },
  "layout": {
    "grid": {"rows": 8, "cols": 12, "gutter": 8, "margin": {"t": 32, "r": 32, "b": 32, "l": 32}},
    "regions": [
      {"name": "header", "rowStart": 1, "colStart": 1, "rowSpan": 4, "colSpan": 12},
      {"name": "body", "rowStart": 5, "colStart": 1, "rowSpan": 2, "colSpan": 12},
      {"name": "footer", "rowStart": 7, "colStart": 1, "rowSpan": 1, "colSpan": 12}
    ],
    "anchors": [
      {"refId": "title", "region": "header", "order": 0},
      {"refId": "subtitle", "region": "header", "order": 1},
      {"refId": "b1", "region": "body", "order": 0},
      {"refId": "c1", "region": "footer", "order": 0}
    ]
  },
  "styleTokens": {
    "palette": {"primary": "#7C3AED", "accent": "#F59E0B", "neutral": ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"]},
    "typography": {
      "fonts": {"sans": "Inter, Arial, sans-serif"},
      "sizes": {"step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 20, "step_2": 28, "step_3": 52},
      "weights": {"regular": 400, "medium": 500, "semibold": 600, "bold": 700},
      "lineHeights": {"compact": 1.2, "standard": 1.5}
    },
    "spacing": {"base": 4, "steps": [0,4,8,12,16,24,32]},
    "radii": {"sm": 4, "md": 8, "lg": 16},
    "shadows": {"sm": "0 2px 4px rgba(0,0,0,.08)", "md": "0 4px 12px rgba(0,0,0,.12)", "lg": "0 12px 32px rgba(0,0,0,.16)"},
    "contrast": {"minTextContrast": 7, "minUiContrast": 4.5}
  },
  "design": {
    "pattern": "hero",
    "visualHierarchy": {
      "primaryFocus": "title",
      "secondaryFocus": ["subtitle", "b1", "c1"],
      "emphasisLevels": {"title": 5, "subtitle": 4, "b1": 3, "c1": 4}
    },
    "whitespace": {
      "strategy": "generous",
      "breathingRoom": 40
    },
    "typography": {
      "strategy": "modern",
      "fontPairing": {"primary": "Inter, sans-serif", "secondary": "Inter, sans-serif"},
      "hierarchy": {
        "title": {"size": 52, "weight": 700, "lineHeight": 1.2, "letterSpacing": 0.5},
        "subtitle": {"size": 28, "weight": 600, "lineHeight": 1.3},
        "body": {"size": 16, "weight": 400, "lineHeight": 1.5}
      }
    },
    "colorStrategy": {
      "distribution": "complementary",
      "emphasis": "#F59E0B",
      "contrast": "high"
    }
  }
}

PREMIUM CONTENT QUALITY STANDARDS FOR SINGLE SLIDES:
- Titles: Clear, concise, impactful (3-7 words) - use power words
- Subtitles: Provide context and support the title (5-10 words)
- Language: Action-oriented, benefit-focused, specific metrics
- Bullet points: Parallel structure, scannable, max 4-5 bullets total
- Each bullet: One complete thought, 8-15 words ideal
- Callouts: Use sparingly for CTAs, key insights, or critical information
- Charts: Choose types that illuminate data intelligently
- Avoid: Clutter, generic language, more than 5 bullets total
- Focus: Every element should support a single, clear message

CHART TYPE SELECTION GUIDE:
Choose the optimal chart type based on data characteristics and storytelling goals:

1. **Bar Chart** (kind: "bar") - Best for comparing discrete categories
   - Use when: Comparing values across categories (sales by region, product performance)
   - Data: 2-12 categories, 1-3 series
   - Example: "Compare Q4 sales across 5 regions"

2. **Line Chart** (kind: "line") - Best for showing trends over time
   - Use when: Time series data, continuous trends, multiple series comparison
   - Data: 5+ time periods, 1-4 series
   - Example: "Revenue growth over 12 months"

3. **Doughnut Chart** (kind: "doughnut") - Modern alternative to pie, shows part-to-whole
   - Use when: Showing proportions/percentages, 3-6 categories, single series
   - Data: 3-6 categories that sum to 100%
   - Example: "Market share distribution across 5 competitors"

4. **Area Chart** (kind: "area") - Shows magnitude/volume over time
   - Use when: Emphasizing total volume, cumulative trends, stacked comparisons
   - Data: 8+ time periods, 1-3 series
   - Example: "Total user growth over 24 months"

5. **Scatter Chart** (kind: "scatter") - Shows correlation between two variables
   - Use when: Analyzing relationships, finding patterns, showing distribution
   - Data: 10-50 data points, 1-3 series
   - Example: "Correlation between ad spend and conversions"

6. **Waterfall Chart** (kind: "waterfall") - Shows cumulative effect of sequential values
   - Use when: Breaking down changes, showing positive/negative contributions
   - Data: 4-10 sequential steps with positive/negative values
   - Example: "Revenue breakdown from gross to net profit"

7. **Combo Chart** (kind: "combo") - Combines multiple chart types (bar + line)
   - Use when: Comparing different metrics with different scales
   - Data: 2 series with different units/scales
   - Example: "Revenue (bars) vs. profit margin % (line)"

8. **Funnel Chart** (kind: "funnel") - Shows progressive reduction through stages
   - Use when: Conversion funnels, process stages, filtering steps
   - Data: 3-7 sequential stages with decreasing values
   - Example: "Sales funnel from leads to closed deals"

CHART SELECTION DECISION TREE:
- Showing proportions/percentages? ‚Üí doughnut (modern) or pie (traditional)
- Showing trends over time? ‚Üí line (trends) or area (volume)
- Comparing categories? ‚Üí bar (standard) or waterfall (cumulative)
- Showing correlation? ‚Üí scatter
- Showing process/funnel? ‚Üí funnel
- Multiple metrics, different scales? ‚Üí combo

IMAGE INTEGRATION GUIDE:
Use images strategically to enhance visual impact and storytelling:

1. **Hero Images** (role: "hero") - Large, impactful visuals
   - Use when: Product launches, announcements, emotional storytelling
   - Placement: Center or left side, 60-70% of slide
   - Source types:
     * Unsplash: { "type": "unsplash", "query": "business team collaboration" }
     * URL: { "type": "url", "url": "https://example.com/image.jpg" }
   - Example: Product launch slide with hero product image

2. **Logos** (role: "logo") - Brand identity, partner logos
   - Use when: Company presentations, partnership announcements
   - Placement: Top-right corner, small and subtle
   - Size: 1x1 inch, maintains aspect ratio
   - Example: Company logo on every slide

3. **Illustrations** (role: "illustration") - Supporting visuals
   - Use when: Explaining concepts, adding visual interest
   - Placement: Right side or bottom, 30-40% of slide
   - Example: Infographic-style illustration for process explanation

4. **Icons** (role: "icon") - Small visual markers
   - Use when: Bullet points, feature lists, step indicators
   - Placement: Inline with text, small size
   - Size: 0.5x0.5 inch
   - Example: Icons next to feature bullet points

5. **Background Images** (role: "background") - Full-slide backgrounds
   - Use when: Creating mood, hero slides, section dividers
   - Placement: Full slide with text overlay
   - Opacity: Use semi-transparent overlay for text readability
   - Example: Inspirational quote slide with background image

IMAGE SOURCE SELECTION:
- **Unsplash** (recommended): High-quality, free stock photos
  * Use descriptive queries: "modern office workspace", "technology abstract blue"
  * Best for: Generic business, tech, lifestyle imagery
  * Example: { "type": "unsplash", "query": "business growth chart" }

- **URL**: Direct image links
  * Use for: Specific product images, logos, custom graphics
  * Ensure HTTPS and valid image formats (jpg, png, webp)
  * Example: { "type": "url", "url": "https://cdn.example.com/product.jpg" }

- **Placeholder**: Colored rectangles with text
  * Use for: Mockups, wireframes, temporary slides
  * Example: { "type": "placeholder" }

SMART IMAGE QUERY SUGGESTIONS:
Based on slide content, suggest relevant Unsplash queries:
- Business/Corporate ‚Üí "business professional office modern"
- Technology ‚Üí "technology abstract digital blue"
- Finance ‚Üí "finance growth chart business"
- Healthcare ‚Üí "healthcare medical professional"
- Marketing ‚Üí "marketing creative design colorful"
- Success/Growth ‚Üí "success achievement growth arrow"
- Innovation ‚Üí "innovation technology future abstract"
- Teamwork ‚Üí "team collaboration meeting diverse"

IMAGE BEST PRACTICES:
- Use images sparingly (1-2 per slide maximum)
- Ensure images support the message, not distract
- Maintain consistent image style across presentation
- Use high-resolution images (1920x1080 minimum for hero)
- Consider color harmony with slide palette
- Always provide descriptive alt text for accessibility
- Avoid clich√© stock photos (handshakes, pointing at charts)

ADVANCED TYPOGRAPHY GUIDELINES:
Create visual hierarchy and readability through sophisticated typography:

1. **Font Pairing Strategies**
   - Professional: Calibri (heading + body) - Clean, corporate, safe
   - Elegant: Georgia (heading) + Garamond (body) - Sophisticated, luxury
   - Modern: Segoe UI (heading + body) - Contemporary, tech-forward
   - Bold: Impact (heading) + Arial (body) - Strong, attention-grabbing
   - Minimal: Arial (heading + body with weight variation) - Simple, timeless

2. **Typography Hierarchy Levels**
   - Level 1 (Hero Title): 44-56px, bold (700), tight line-height (1.1-1.2)
   - Level 2 (Main Title): 32-40px, semibold (600), standard line-height (1.2-1.3)
   - Level 3 (Subtitle): 20-28px, medium (500), relaxed line-height (1.3-1.4)
   - Level 4 (Body): 16-18px, regular (400), comfortable line-height (1.5-1.6)
   - Level 5 (Caption): 12-14px, regular (400), standard line-height (1.4)

3. **Text Effects & Enhancements**
   - **Pull Quotes**: Large, italic, serif font with accent bar on left
   - **Callout Boxes**: Colored background, border, icon, title + body
   - **Highlighted Text**: Semi-transparent background highlight for emphasis
   - **Text Shadows**: Subtle shadows (2-4px blur, 0.1-0.2 opacity) for depth
   - **Letter Spacing**: +0.5px for titles, 0px for body, -0.5px for dense text

4. **Smart Text Fitting**
   - Auto-adjust font size to fit content within bounds
   - Maintain readability (minimum 12px for body, 16px for titles)
   - Use shrink-to-fit for dynamic content
   - Break long text into multiple columns if needed

5. **Multi-Column Layouts**
   - Use 2-3 columns for dense text content
   - Maintain 0.3-0.5 inch gap between columns
   - Ensure balanced column heights
   - Best for: Long lists, feature comparisons, detailed content

6. **Readability Best Practices**
   - Line length: 50-75 characters per line (optimal)
   - Line height: 1.4-1.6 for body text, 1.2-1.3 for headings
   - Paragraph spacing: 0.5-1em between paragraphs
   - Contrast: Minimum 7:1 for WCAG AAA compliance
   - Alignment: Left-aligned for body (easier to read), centered for titles

7. **Typography Don'ts**
   - ‚ùå Don't use more than 2-3 font families per presentation
   - ‚ùå Don't use all caps for long text (reduces readability by 13%)
   - ‚ùå Don't use font sizes below 12px (unreadable from distance)
   - ‚ùå Don't use decorative fonts for body text
   - ‚ùå Don't use tight letter spacing for body text
   - ‚ùå Don't mix too many font weights (stick to 2-3)

ANIMATION & TRANSITION GUIDELINES:
Use animations strategically to guide attention and create professional flow:

1. **Slide Transitions** (between slides)
   - **Fade**: Universal, professional, safe choice for all presentations
   - **Push**: Modern, directional, good for sequential content
   - **Wipe**: Clean, directional, emphasizes flow
   - **Split**: Dramatic, reveals content from center or edges
   - **Dissolve**: Smooth, elegant, luxury feel
   - **Zoom**: Dynamic, energetic, tech/startup presentations
   - Duration: 800-1200ms (fast enough to maintain pace, slow enough to be smooth)

2. **Entrance Animations** (elements appearing)
   - **Fade**: Subtle, professional, works for all elements
   - **Fly-in**: Dynamic, directional (left/right/top/bottom)
   - **Zoom**: Attention-grabbing, use for key points
   - **Wipe**: Clean reveal, good for charts and images
   - **Appear**: Instant, no animation (use sparingly)
   - Duration: 400-600ms for text, 600-800ms for charts/images

3. **Animation Sequencing Best Practices**
   - Title appears first (0ms delay)
   - Subtitle appears second (200-300ms delay)
   - Bullets appear one-by-one (150-200ms between each)
   - Charts/images appear after text (300-500ms delay)
   - Total sequence: Keep under 3-4 seconds

4. **Pattern-Specific Animation Recommendations**
   - **Hero Pattern**: Zoom entrance + Fade transition (dramatic, impactful)
   - **Split Pattern**: Wipe entrance + Split transition (emphasizes division)
   - **Asymmetric Pattern**: Fly-in entrance + Push transition (dynamic, modern)
   - **Grid Pattern**: Appear entrance + Dissolve transition (clean, organized)
   - **Minimal Pattern**: Fade entrance + Fade transition (subtle, elegant)
   - **Data-Focused Pattern**: Wipe entrance + Wipe transition (reveals data progressively)

5. **Animation Don'ts**
   - ‚ùå Don't use more than 2-3 animation types per slide
   - ‚ùå Don't use bouncing, spinning, or flashy animations (unprofessional)
   - ‚ùå Don't animate every element (causes fatigue)
   - ‚ùå Don't use long durations (>1000ms for entrance, >1500ms for transitions)
   - ‚ùå Don't use exit animations unless necessary (distracting)
   - ‚ùå Don't use emphasis animations (pulse, grow) in professional contexts

6. **When to Skip Animations**
   - Internal team meetings (focus on content, not presentation)
   - Data-heavy slides (animations slow down information consumption)
   - Printed handouts (animations don't translate)
   - Time-constrained presentations (animations add time)
   - Accessibility concerns (some animations cause motion sickness)

7. **Animation Configuration in SlideSpec**
   Example structure:
   {
     "design": {
       "animations": {
         "entrance": [
           {"type": "fade", "duration": 600, "delay": 0},
           {"type": "fly-in", "duration": 400, "delay": 200}
         ]
       }
     }
   }
   - Use sparingly - only include if animations add value
   - Default to no animations for professional presentations
   - Include only for high-stakes presentations (pitches, keynotes)

INTELLIGENT BULLET POINT DETECTION:
When to use bullets:
‚úì Lists of related items (features, benefits, steps, metrics)
‚úì Multiple related points that need equal emphasis
‚úì Content that benefits from scannable format
‚úì 3-6 items that are conceptually similar

When NOT to use bullets:
‚úó Single concept or narrative flow
‚úó Content requiring detailed explanation
‚úó Hierarchical information (use nested levels 1-3 instead)
‚úó When a chart or callout would be more effective

Bullet formatting rules:
- Each bullet is ONE complete thought (8-15 words ideal)
- Parallel structure: start each with similar grammatical form
- Use level 1 for main points, level 2-3 for sub-points only when needed
- Maximum 5 bullets per level 1 group
- Separate related concepts into different bullet groups if needed

PREMIUM COLOR PALETTE SELECTION:
- Tech/Innovation: Deep Blue (#1E40AF), Purple (#7C3AED), Cyan (#06B6D4)
- Finance/Banking: Navy (#0F172A), Emerald (#10B981), Gold (#F59E0B)
- Healthcare: Teal (#0D9488), Sky Blue (#0EA5E9), Sage (#10B981)
- Creative/Marketing: Magenta (#EC4899), Amber (#F59E0B), Violet (#8B5CF6)
- Corporate: Slate (#475569), Indigo (#4F46E5), Charcoal (#1F2937)

PREMIUM DESIGN CHECKLIST:
‚úì Generous white space (28-50% of slide)
‚úì Sophisticated color palette (1-2 accent colors max)
‚úì Professional typography with proper hierarchy
‚úì Consistent alignment to 8px or 16px grid
‚úì Subtle shadows for depth (0 4px 12px rgba(0,0,0,0.08))
‚úì WCAG AAA contrast ratios (7:1 minimum)
‚úì Minimum margins of 32px (0.44in)
‚úì Clear visual hierarchy with 3-4 levels max
‚úì Balanced composition using rule of thirds

SPACING & FORMATTING REQUIREMENTS:
- Title: Bold, large (40-52pt), top-left position
- Subtitle: Medium weight, smaller (20-28pt), gray color, below title
- Bullets: Each on separate line with proper spacing
  ‚Ä¢ Use level 1 for main points (no indentation)
  ‚Ä¢ Use level 2 for sub-points (indented, if needed)
  ‚Ä¢ Maintain consistent spacing between bullets
  ‚Ä¢ Ensure readability with adequate line height
- Body text: Regular weight, readable size (16-18pt)
- Callouts: Use for emphasis, key metrics, or CTAs only

STRICT FORMATTING RULES FOR BULLETS:
1. Each bullet item must be a single, complete thought
2. No run-on sentences or multiple concepts per bullet
3. Parallel structure: all bullets start with similar grammatical form
4. Maximum 5 bullets per group (use multiple groups if needed)
5. Each bullet should be 8-15 words for optimal readability
6. Avoid generic filler words; be specific and actionable

Now generate a slide specification based on the user's prompt. Remember: OUTPUT ONLY THE JSON, NOTHING ELSE.
`;

/** Simple system prompt for fallback */
export const SIMPLE_SYSTEM_PROMPT = `
You are the SlideSpec generator for plzfixthx.
Return a SINGLE RFC8259-compliant JSON object that VALIDATES against SlideSpec v1.
Hard rules:
- Output ONLY JSON.
- meta.version "1.0"; aspectRatio "16:9" default.
- Concise, professional text; <=6 bullets total; levels 1-3.
- If dataViz present, labels 2..10; series lengths == labels length.
- Hex colors (#RRGGBB). IDs [A-Za-z0-9_-].
`;



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/promptTemplates.ts
=================================================================================
/**
 * Industry-Specific Prompt Templates
 * Tailored prompts for different industries, audiences, and use cases
 */

export interface PromptTemplate {
  name: string;
  description: string;
  systemPrompt: string;
  examplePrompts: string[];
  designGuidelines: {
    colorPalette: string[];
    typography: string;
    patterns: string[];
    tone: string;
  };
}

/**
 * Tech/Startup Pitch Deck Template
 */
export const TECH_PITCH_DECK: PromptTemplate = {
  name: "Tech Pitch Deck",
  description: "For startups pitching to investors - problem, solution, market, traction",
  systemPrompt: `
You are creating a tech startup pitch deck. Follow Y Combinator and Sequoia Capital best practices:

STRUCTURE (10-12 slides):
1. Title + Tagline (hero pattern)
2. Problem (minimal pattern with bold statement)
3. Solution (hero pattern with product visual)
4. Market Size (data-focused with TAM/SAM/SOM)
5. Product Demo (split pattern with screenshots)
6. Business Model (grid pattern)
7. Traction (data-focused with growth metrics)
8. Competition (split pattern comparison)
9. Team (grid pattern with photos)
10. Financials (data-focused with projections)
11. Ask (minimal pattern with clear CTA)

DESIGN STYLE:
- Modern, bold, innovative
- Colors: Deep blues (#1E40AF), purples (#7C3AED), cyans (#06B6D4)
- Typography: Modern sans-serif (Inter, Poppins)
- Generous white space (40%+)
- Data visualizations for all metrics
- Minimal text (3-5 bullets max per slide)

TONE:
- Confident but not arrogant
- Data-driven and specific
- Vision-focused
- Action-oriented
`,
  examplePrompts: [
    "Create a pitch deck for an AI-powered customer service platform",
    "Pitch deck for a B2B SaaS productivity tool",
    "Investor presentation for a fintech mobile app"
  ],
  designGuidelines: {
    colorPalette: ["#1E40AF", "#7C3AED", "#06B6D4", "#10B981"],
    typography: "Inter, Poppins - modern sans-serif",
    patterns: ["hero", "minimal", "data-focused", "split"],
    tone: "confident, visionary, data-driven"
  }
};

/**
 * Corporate Quarterly Business Review Template
 */
export const CORPORATE_QBR: PromptTemplate = {
  name: "Quarterly Business Review",
  description: "For executive presentations on quarterly performance and strategy",
  systemPrompt: `
You are creating a corporate quarterly business review for executive leadership.

STRUCTURE (8-10 slides):
1. Executive Summary (minimal pattern)
2. Q4 Highlights (grid pattern with key wins)
3. Financial Performance (data-focused with charts)
4. Key Metrics Dashboard (data-focused)
5. Strategic Initiatives Progress (split pattern)
6. Challenges & Risks (minimal pattern with callouts)
7. Q1 Priorities (grid pattern)
8. Recommendations (minimal pattern)

DESIGN STYLE:
- Professional, conservative, trustworthy
- Colors: Navy (#0F172A), slate (#475569), emerald (#10B981)
- Typography: Professional serif/sans (Georgia, Calibri)
- Balanced white space (30-35%)
- Heavy use of data visualizations
- Clear hierarchy and structure

TONE:
- Formal and professional
- Fact-based and analytical
- Strategic and forward-looking
- Transparent about challenges
`,
  examplePrompts: [
    "Q4 2024 business review for sales organization",
    "Quarterly performance review for product team",
    "Executive summary of Q3 results and Q4 outlook"
  ],
  designGuidelines: {
    colorPalette: ["#0F172A", "#475569", "#10B981", "#F59E0B"],
    typography: "Georgia, Calibri - professional and readable",
    patterns: ["data-focused", "split", "minimal", "grid"],
    tone: "formal, analytical, strategic"
  }
};

/**
 * Sales Presentation Template
 */
export const SALES_PRESENTATION: PromptTemplate = {
  name: "Sales Presentation",
  description: "For sales teams presenting to prospects - value proposition and ROI",
  systemPrompt: `
You are creating a sales presentation following SPIN selling methodology.

STRUCTURE (6-8 slides):
1. Title + Agenda (hero pattern)
2. Customer Pain Points (minimal pattern with bold statements)
3. Our Solution (hero pattern with product benefits)
4. How It Works (split pattern with process)
5. ROI & Value (data-focused with financial impact)
6. Customer Success Stories (grid pattern with logos/quotes)
7. Pricing & Packages (grid pattern)
8. Next Steps (minimal pattern with clear CTA)

DESIGN STYLE:
- Persuasive, benefit-focused, customer-centric
- Colors: Trust blue (#3B82F6), success green (#10B981), accent gold (#F59E0B)
- Typography: Friendly sans-serif (Segoe UI, Arial)
- Balanced white space (32-38%)
- Focus on benefits over features
- Use customer testimonials and social proof

TONE:
- Consultative and helpful
- Benefit-focused (not feature-focused)
- Specific and quantifiable
- Urgency without pressure
`,
  examplePrompts: [
    "Sales deck for enterprise software solution",
    "Product presentation for B2B service offering",
    "Value proposition deck for new customer segment"
  ],
  designGuidelines: {
    colorPalette: ["#3B82F6", "#10B981", "#F59E0B", "#8B5CF6"],
    typography: "Segoe UI, Arial - friendly and approachable",
    patterns: ["hero", "split", "data-focused", "grid"],
    tone: "consultative, benefit-focused, specific"
  }
};

/**
 * Training/Educational Template
 */
export const TRAINING_DECK: PromptTemplate = {
  name: "Training & Education",
  description: "For internal training, workshops, and educational content",
  systemPrompt: `
You are creating an educational training presentation following adult learning principles.

STRUCTURE (12-15 slides):
1. Title + Learning Objectives (hero pattern)
2. Agenda (minimal pattern)
3. Why This Matters (minimal pattern with context)
4. Core Concepts (split pattern for each concept)
5. Step-by-Step Process (grid pattern with numbered steps)
6. Examples & Case Studies (split pattern)
7. Common Mistakes (grid pattern with warnings)
8. Best Practices (grid pattern with tips)
9. Practice Exercise (minimal pattern)
10. Q&A (minimal pattern)
11. Resources & Next Steps (grid pattern)

DESIGN STYLE:
- Clear, educational, accessible
- Colors: Friendly blues (#0EA5E9), greens (#10B981), warm oranges (#F97316)
- Typography: Readable sans-serif (Arial, Verdana)
- Generous white space (38-42%)
- Use icons and visual aids
- Step-by-step breakdowns
- Callouts for key points

TONE:
- Educational and supportive
- Clear and simple language
- Encouraging and positive
- Practical and actionable
`,
  examplePrompts: [
    "Training deck on new software platform",
    "Workshop presentation on leadership skills",
    "Educational content on data privacy compliance"
  ],
  designGuidelines: {
    colorPalette: ["#0EA5E9", "#10B981", "#F97316", "#8B5CF6"],
    typography: "Arial, Verdana - clear and readable",
    patterns: ["split", "grid", "minimal", "asymmetric"],
    tone: "educational, supportive, practical"
  }
};

/**
 * Marketing Campaign Template
 */
export const MARKETING_CAMPAIGN: PromptTemplate = {
  name: "Marketing Campaign",
  description: "For marketing teams presenting campaign strategies and creative concepts",
  systemPrompt: `
You are creating a marketing campaign presentation with creative flair.

STRUCTURE (8-10 slides):
1. Campaign Overview (hero pattern with bold visual)
2. Target Audience (split pattern with personas)
3. Key Message & Positioning (minimal pattern)
4. Creative Concept (hero pattern with mockups)
5. Channel Strategy (grid pattern)
6. Content Calendar (data-focused with timeline)
7. Success Metrics (data-focused with KPIs)
8. Budget & Resources (grid pattern)
9. Timeline & Milestones (data-focused)

DESIGN STYLE:
- Creative, bold, eye-catching
- Colors: Vibrant magenta (#EC4899), amber (#F59E0B), violet (#8B5CF6)
- Typography: Modern and expressive (Poppins, Montserrat)
- Generous white space (40-45%)
- Use mockups and visual examples
- Bold imagery and graphics
- Asymmetric layouts for visual interest

TONE:
- Creative and inspiring
- Brand-focused
- Metrics-driven
- Energetic and enthusiastic
`,
  examplePrompts: [
    "Campaign deck for product launch",
    "Marketing strategy presentation for Q1",
    "Creative brief for brand refresh campaign"
  ],
  designGuidelines: {
    colorPalette: ["#EC4899", "#F59E0B", "#8B5CF6", "#06B6D4"],
    typography: "Poppins, Montserrat - modern and expressive",
    patterns: ["hero", "asymmetric", "split", "grid"],
    tone: "creative, inspiring, energetic"
  }
};

/**
 * Get template by industry and use case
 */
export function getPromptTemplate(
  industry: "tech" | "corporate" | "sales" | "education" | "marketing",
  useCase?: "pitch" | "review" | "training" | "campaign"
): PromptTemplate {
  const templates: Record<string, PromptTemplate> = {
    "tech-pitch": TECH_PITCH_DECK,
    "corporate-review": CORPORATE_QBR,
    "sales-presentation": SALES_PRESENTATION,
    "education-training": TRAINING_DECK,
    "marketing-campaign": MARKETING_CAMPAIGN
  };

  const key = `${industry}-${useCase || "presentation"}`;
  
  // Map to closest template
  if (industry === "tech") return TECH_PITCH_DECK;
  if (industry === "corporate") return CORPORATE_QBR;
  if (industry === "sales") return SALES_PRESENTATION;
  if (industry === "education") return TRAINING_DECK;
  if (industry === "marketing") return MARKETING_CAMPAIGN;
  
  return CORPORATE_QBR; // Default fallback
}

/**
 * Enhance user prompt with template-specific guidance
 */
export function enhancePromptWithTemplate(
  userPrompt: string,
  template: PromptTemplate
): string {
  return `
${template.systemPrompt}

USER REQUEST: ${userPrompt}

Apply the ${template.name} template structure and design guidelines.
Use the recommended color palette: ${template.designGuidelines.colorPalette.join(", ")}
Typography: ${template.designGuidelines.typography}
Tone: ${template.designGuidelines.tone}
`;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/slideRefinement.ts
=================================================================================
/**
 * Slide Refinement & Iterative Improvement
 * A/B variants, smart suggestions, auto-fix common issues
 */

import { logger } from "firebase-functions/v2";
import type { SlideSpecV1 } from "./types/SlideSpecV1";

export interface RefinementRequest {
  slide: SlideSpecV1;
  feedback: string;
  refinementType: "improve" | "simplify" | "enhance" | "fix" | "variant";
}

export interface SlideIssue {
  severity: "error" | "warning" | "suggestion";
  category: "content" | "design" | "accessibility" | "performance";
  message: string;
  fix?: string;
  autoFixable: boolean;
}

export interface RefinementSuggestion {
  type: "content" | "design" | "layout" | "color" | "typography";
  priority: "high" | "medium" | "low";
  suggestion: string;
  rationale: string;
  autoApplicable: boolean;
}

/**
 * Analyze slide for common issues
 */
export function analyzeSlideQuality(slide: SlideSpecV1): SlideIssue[] {
  const issues: SlideIssue[] = [];

  // Check title length
  if (slide.content.title.text.length > 60) {
    issues.push({
      severity: "warning",
      category: "content",
      message: "Title is too long (>60 characters). Shorter titles are more impactful.",
      fix: "Condense title to 40-50 characters",
      autoFixable: false
    });
  }

  // Check bullet count
  const bulletCount = slide.content.bullets?.reduce((sum, group) => sum + group.items.length, 0) || 0;
  if (bulletCount > 6) {
    issues.push({
      severity: "warning",
      category: "content",
      message: `Too many bullets (${bulletCount}). Limit to 5-6 for better retention.`,
      fix: "Reduce to 5-6 most important points",
      autoFixable: false
    });
  }

  // Check bullet text length
  slide.content.bullets?.forEach((group, groupIdx) => {
    group.items.forEach((item, itemIdx) => {
      if (item.text.length > 100) {
        issues.push({
          severity: "warning",
          category: "content",
          message: `Bullet ${groupIdx + 1}.${itemIdx + 1} is too long (${item.text.length} chars). Keep under 80 characters.`,
          fix: "Break into multiple bullets or simplify",
          autoFixable: false
        });
      }
    });
  });

  // Check color contrast
  const primaryColor = slide.styleTokens.palette.primary;
  const neutralLight = slide.styleTokens.palette.neutral[6];
  if (primaryColor && neutralLight) {
    const contrast = estimateContrast(primaryColor, neutralLight);
    if (contrast < 4.5) {
      issues.push({
        severity: "error",
        category: "accessibility",
        message: `Low color contrast (${contrast.toFixed(1)}:1). WCAG requires 4.5:1 minimum.`,
        fix: "Adjust colors for better contrast",
        autoFixable: true
      });
    }
  }

  // Check for missing subtitle
  if (!slide.content.subtitle && slide.content.title.text.length < 30) {
    issues.push({
      severity: "suggestion",
      category: "content",
      message: "Consider adding a subtitle to provide context",
      fix: "Add descriptive subtitle",
      autoFixable: false
    });
  }

  // Check chart data quality
  if (slide.content.dataViz) {
    const dv = slide.content.dataViz;
    if (dv.labels.length < 2) {
      issues.push({
        severity: "warning",
        category: "content",
        message: "Chart has too few data points. Need at least 2 for meaningful visualization.",
        fix: "Add more data points or remove chart",
        autoFixable: false
      });
    }

    if (dv.labels.length > 12) {
      issues.push({
        severity: "warning",
        category: "design",
        message: "Chart has too many data points (>12). Consider grouping or filtering.",
        fix: "Reduce to 8-10 most important data points",
        autoFixable: false
      });
    }
  }

  // Check for empty content
  if (!slide.content.bullets && !slide.content.dataViz && !slide.content.callouts) {
    issues.push({
      severity: "warning",
      category: "content",
      message: "Slide has only title/subtitle. Add bullets, chart, or callouts.",
      fix: "Add supporting content",
      autoFixable: false
    });
  }

  return issues;
}

/**
 * Generate smart suggestions for slide improvement
 */
export function generateSmartSuggestions(slide: SlideSpecV1): RefinementSuggestion[] {
  const suggestions: RefinementSuggestion[] = [];

  // Suggest data visualization if numbers are present
  const hasNumbers = slide.content.bullets?.some(group =>
    group.items.some(item => /\d+%|\$\d+|^\d+/.test(item.text))
  );

  if (hasNumbers && !slide.content.dataViz) {
    suggestions.push({
      type: "design",
      priority: "high",
      suggestion: "Convert numeric bullets to chart visualization",
      rationale: "Data visualizations are 60% more memorable than text",
      autoApplicable: false
    });
  }

  // Suggest pattern change based on content
  const bulletCount = slide.content.bullets?.reduce((sum, group) => sum + group.items.length, 0) || 0;
  if (bulletCount > 4 && !slide.content.dataViz) {
    suggestions.push({
      type: "layout",
      priority: "medium",
      suggestion: "Consider using grid pattern for better organization",
      rationale: "Grid pattern works well for 4+ items",
      autoApplicable: true
    });
  }

  // Suggest adding callout for key point
  if (bulletCount >= 3 && !slide.content.callouts) {
    suggestions.push({
      type: "content",
      priority: "medium",
      suggestion: "Highlight most important point as callout",
      rationale: "Callouts draw attention to key takeaways",
      autoApplicable: false
    });
  }

  // Suggest color palette improvement
  const primaryColor = slide.styleTokens.palette.primary;
  if (primaryColor === "#000000" || primaryColor === "#FFFFFF") {
    suggestions.push({
      type: "color",
      priority: "high",
      suggestion: "Use a more distinctive primary color",
      rationale: "Black/white primary colors lack visual interest",
      autoApplicable: true
    });
  }

  // Suggest typography improvement
  const titleSize = slide.styleTokens.typography.sizes.step_3;
  if (titleSize < 32) {
    suggestions.push({
      type: "typography",
      priority: "low",
      suggestion: "Increase title size to 36-44px for better hierarchy",
      rationale: "Larger titles create stronger visual hierarchy",
      autoApplicable: true
    });
  }

  // Suggest adding image if none present
  if (!slide.content.imagePlaceholders && !slide.content.images) {
    suggestions.push({
      type: "design",
      priority: "low",
      suggestion: "Consider adding a supporting image or illustration",
      rationale: "Visual elements increase engagement by 80%",
      autoApplicable: false
    });
  }

  return suggestions;
}

/**
 * Auto-fix common issues
 */
export function autoFixSlide(slide: SlideSpecV1, issues: SlideIssue[]): SlideSpecV1 {
  const fixed = JSON.parse(JSON.stringify(slide)); // Deep clone

  for (const issue of issues) {
    if (!issue.autoFixable) continue;

    // Fix low contrast
    if (issue.category === "accessibility" && issue.message.includes("contrast")) {
      // Darken primary color if too light
      const primary = fixed.styleTokens.palette.primary;
      if (primary) {
        fixed.styleTokens.palette.primary = darkenColor(primary, 20);
      }
    }

    // Fix missing color
    if (issue.message.includes("primary color")) {
      fixed.styleTokens.palette.primary = "#3B82F6"; // Default blue
    }

    // Fix small title
    if (issue.message.includes("title size")) {
      fixed.styleTokens.typography.sizes.step_3 = 40;
    }
  }

  return fixed;
}

/**
 * Generate A/B variant of slide
 */
export function generateSlideVariant(
  slide: SlideSpecV1,
  variantType: "color" | "layout" | "typography" | "minimal"
): SlideSpecV1 {
  const variant = JSON.parse(JSON.stringify(slide)); // Deep clone

  switch (variantType) {
    case "color":
      // Alternative color palette
      const colorVariants = [
        { primary: "#7C3AED", accent: "#EC4899" }, // Purple/Pink
        { primary: "#0D9488", accent: "#F59E0B" }, // Teal/Amber
        { primary: "#1E40AF", accent: "#10B981" }  // Blue/Green
      ];
      const randomColor = colorVariants[Math.floor(Math.random() * colorVariants.length)];
      variant.styleTokens.palette.primary = randomColor.primary;
      variant.styleTokens.palette.accent = randomColor.accent;
      break;

    case "layout":
      // Change to different pattern (simplified - would need design field)
      variant.meta.theme = variant.meta.theme + " (Alternative Layout)";
      break;

    case "typography":
      // Alternative font sizes
      variant.styleTokens.typography.sizes.step_3 = 48; // Larger title
      variant.styleTokens.typography.sizes.step_1 = 24; // Larger subtitle
      break;

    case "minimal":
      // Reduce content to essentials
      if (variant.content.bullets) {
        variant.content.bullets = variant.content.bullets.map((group: any) => ({
          ...group,
          items: group.items.slice(0, 3) // Keep only first 3 bullets
        }));
      }
      break;
  }

  return variant;
}

/**
 * Estimate color contrast ratio (simplified)
 */
function estimateContrast(color1: string, color2: string): number {
  // Simplified contrast calculation
  // In production, use proper WCAG contrast calculation
  const lum1 = getLuminance(color1);
  const lum2 = getLuminance(color2);
  const lighter = Math.max(lum1, lum2);
  const darker = Math.min(lum1, lum2);
  return (lighter + 0.05) / (darker + 0.05);
}

/**
 * Get relative luminance of color
 */
function getLuminance(hex: string): number {
  const rgb = hexToRgb(hex);
  if (!rgb) return 0;
  
  const [r, g, b] = [rgb.r, rgb.g, rgb.b].map(val => {
    val = val / 255;
    return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
  });
  
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

/**
 * Convert hex to RGB
 */
function hexToRgb(hex: string): { r: number; g: number; b: number } | null {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}

/**
 * Darken color by percentage
 */
function darkenColor(hex: string, percent: number): string {
  const rgb = hexToRgb(hex);
  if (!rgb) return hex;
  
  const factor = 1 - (percent / 100);
  const r = Math.round(rgb.r * factor);
  const g = Math.round(rgb.g * factor);
  const b = Math.round(rgb.b * factor);
  
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/svgGenerator/backgroundGenerator.ts
=================================================================================
/**
 * SVG Background Generator
 * Creates professional slide backgrounds with gradients and decorative elements
 */

import { createGradientDef, getGradient, createGradientFromPalette, createRadialGradientFromPalette, type GradientConfig } from './gradients';
import {
  createAccentBar,
  createCornerAccent,
  createDecorativeCircles,
  createDividerLine,
  createGeometricPattern,
  createCurvedAccent,
  createGlowFilter,
  createShadowFilter,
  createAbstractShape,
  createGridPattern,
  createArrow,
  createWavePattern,
} from './decorativeElements';

export interface BackgroundConfig {
  width?: number;
  height?: number;
  theme?: 'minimal' | 'professional' | 'creative' | 'tech' | 'elegant';
  palette: {
    primary: string;
    accent: string;
    neutral: string[];
  };
  style?: 'subtle' | 'bold' | 'modern';
}

/**
 * Generate complete SVG background
 */
export function generateBackground(config: BackgroundConfig): string {
  const width = config.width || 1920;
  const height = config.height || 1080;
  const theme = config.theme || 'professional';
  const style = config.style || 'subtle';

  // Get gradient based on palette
  const gradient = createGradientFromPalette(config.palette);

  // Build SVG
  const defs = buildDefs(gradient, config);
  const background = buildBackgroundLayer(gradient, width, height);
  const decorations = buildDecorations(theme, style, config.palette, width, height);

  return `
<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    ${defs}
  </defs>
  
  <!-- Background Layer -->
  ${background}
  
  <!-- Decorative Elements -->
  ${decorations}
</svg>`.trim();
}

/**
 * Build SVG definitions (gradients, filters)
 */
function buildDefs(gradient: GradientConfig, config: BackgroundConfig): string {
  const gradientDef = createGradientDef(gradient);
  const glowFilter = createGlowFilter('glow', config.palette.primary, 10);
  const shadowFilter = createShadowFilter('shadow');

  return `
    ${gradientDef}
    ${glowFilter}
    ${shadowFilter}
  `;
}

/**
 * Build background layer with gradient
 */
function buildBackgroundLayer(gradient: GradientConfig, width: number, height: number): string {
  return `
  <rect width="${width}" height="${height}" fill="url(#${gradient.id})"/>`;
}

/**
 * Build decorative elements based on theme
 */
function buildDecorations(
  theme: string,
  style: string,
  palette: { primary: string; accent: string; neutral: string[] },
  width: number,
  height: number
): string {
  const elements: string[] = [];

  switch (theme) {
    case 'minimal':
      elements.push(...buildMinimalDecorations(palette, style));
      break;
    case 'professional':
      elements.push(...buildProfessionalDecorations(palette, style));
      break;
    case 'creative':
      elements.push(...buildCreativeDecorations(palette, style));
      break;
    case 'tech':
      elements.push(...buildTechDecorations(palette, style));
      break;
    case 'elegant':
      elements.push(...buildElegantDecorations(palette, style));
      break;
    default:
      elements.push(...buildProfessionalDecorations(palette, style));
  }

  return elements.join('\n  ');
}

/**
 * Minimal theme decorations
 */
function buildMinimalDecorations(
  palette: { primary: string; accent: string; neutral: string[] },
  style: string
): string[] {
  const elements: string[] = [];

  // Left accent bar
  elements.push(createAccentBar({ width: 15, color: palette.primary, opacity: 1 }));

  if (style !== 'subtle') {
    // Top-right corner accent
    elements.push(createCornerAccent({ size: 150, color: palette.primary, opacity: 0.15 }));
  }

  return elements;
}

/**
 * Professional theme decorations - Enhanced with sophisticated elements
 */
function buildProfessionalDecorations(
  palette: { primary: string; accent: string; neutral: string[] },
  style: string
): string[] {
  const elements: string[] = [];

  // Left accent bar with subtle gradient effect
  elements.push(createAccentBar({ width: 12, color: palette.primary, opacity: 0.95 }));

  // Top-right corner accent - more subtle
  elements.push(createCornerAccent({ size: 180, color: palette.primary, opacity: 0.12 }));

  // Bottom-right decorative circles - refined positioning
  elements.push(createDecorativeCircles({ x: 1750, y: 920, color: palette.accent, count: 3 }));

  // Add subtle wave pattern at bottom for depth
  elements.push(
    createWavePattern({
      color: palette.primary,
      opacity: 0.03,
      amplitude: 30,
      frequency: 2,
      position: 'bottom',
    })
  );

  if (style === 'bold') {
    // Add curved accent line - more prominent
    elements.push(
      createCurvedAccent({
        startX: 0,
        startY: 1080 * 0.35,
        endX: 1920 * 0.35,
        endY: 0,
        color: palette.accent,
        thickness: 4,
        opacity: 0.25,
      })
    );

    // Add secondary curved accent for balance
    elements.push(
      createCurvedAccent({
        startX: 1920,
        startY: 1080 * 0.65,
        endX: 1920 * 0.65,
        endY: 1080,
        color: palette.primary,
        thickness: 3,
        opacity: 0.15,
      })
    );
  } else if (style === 'modern') {
    // Add subtle geometric accents
    elements.push(
      createAbstractShape({
        x: 1800,
        y: 150,
        size: 200,
        color: palette.accent,
        opacity: 0.06,
        rotation: 25,
      })
    );
  }

  return elements;
}

/**
 * Creative theme decorations - Enhanced with dynamic elements
 */
function buildCreativeDecorations(
  palette: { primary: string; accent: string; neutral: string[] },
  style: string
): string[] {
  const elements: string[] = [];

  // Multiple abstract shapes for visual interest
  elements.push(
    createAbstractShape({
      x: 1650,
      y: 180,
      size: 320,
      color: palette.primary,
      opacity: 0.09,
      rotation: 45,
    })
  );

  elements.push(
    createAbstractShape({
      x: 220,
      y: 880,
      size: 280,
      color: palette.accent,
      opacity: 0.07,
      rotation: -30,
    })
  );

  // Add a third shape for balance
  elements.push(
    createAbstractShape({
      x: 960,
      y: 540,
      size: 200,
      color: palette.primary,
      opacity: 0.04,
      rotation: 15,
    })
  );

  // Dynamic curved accents
  elements.push(
    createCurvedAccent({
      startX: 0,
      startY: 1080 * 0.45,
      endX: 1920 * 0.42,
      endY: 1080 * 0.18,
      color: palette.primary,
      thickness: 5,
      opacity: 0.18,
    })
  );

  elements.push(
    createCurvedAccent({
      startX: 1920,
      startY: 1080 * 0.55,
      endX: 1920 * 0.58,
      endY: 1080,
      color: palette.accent,
      thickness: 5,
      opacity: 0.18,
    })
  );

  // Add decorative circles for depth
  elements.push(createDecorativeCircles({ x: 1800, y: 100, color: palette.primary, count: 2 }));
  elements.push(createDecorativeCircles({ x: 120, y: 980, color: palette.accent, count: 2 }));

  if (style === 'bold') {
    // Add geometric pattern overlay
    elements.push(createGeometricPattern({ color: palette.primary, opacity: 0.04, density: 'low' }));

    // Add wave pattern for extra dynamism
    elements.push(
      createWavePattern({
        color: palette.accent,
        opacity: 0.05,
        amplitude: 40,
        frequency: 3,
        position: 'top',
      })
    );
  }

  return elements;
}

/**
 * Tech theme decorations
 */
function buildTechDecorations(
  palette: { primary: string; accent: string; neutral: string[] },
  style: string
): string[] {
  const elements: string[] = [];

  // Grid pattern
  elements.push(createGridPattern({ color: palette.primary, opacity: 0.03, spacing: 100 }));

  // Corner accents (all four corners)
  elements.push(createCornerAccent({ size: 150, color: palette.primary, opacity: 0.1, position: 'top-left' }));
  elements.push(createCornerAccent({ size: 150, color: palette.primary, opacity: 0.1, position: 'top-right' }));
  elements.push(createCornerAccent({ size: 150, color: palette.accent, opacity: 0.08, position: 'bottom-left' }));
  elements.push(createCornerAccent({ size: 150, color: palette.accent, opacity: 0.08, position: 'bottom-right' }));

  if (style !== 'subtle') {
    // Geometric pattern overlay
    elements.push(createGeometricPattern({ color: palette.accent, opacity: 0.02, density: 'medium' }));
  }

  return elements;
}

/**
 * Elegant theme decorations
 */
function buildElegantDecorations(
  palette: { primary: string; accent: string; neutral: string[] },
  style: string
): string[] {
  const elements: string[] = [];

  // Subtle curved accents
  elements.push(
    createCurvedAccent({
      startX: 0,
      startY: 1080 * 0.2,
      endX: 1920 * 0.5,
      endY: 0,
      color: palette.primary,
      thickness: 2,
      opacity: 0.1,
    })
  );

  elements.push(
    createCurvedAccent({
      startX: 1920,
      startY: 1080 * 0.8,
      endX: 1920 * 0.5,
      endY: 1080,
      color: palette.accent,
      thickness: 2,
      opacity: 0.1,
    })
  );

  // Decorative circles (smaller, more subtle)
  elements.push(createDecorativeCircles({ x: 1850, y: 100, color: palette.primary, count: 2 }));
  elements.push(createDecorativeCircles({ x: 100, y: 980, color: palette.accent, count: 2 }));

  if (style === 'bold') {
    // Abstract shapes
    elements.push(
      createAbstractShape({
        x: 1920 * 0.85,
        y: 1080 * 0.5,
        size: 400,
        color: palette.primary,
        opacity: 0.05,
        rotation: 30,
      })
    );
  }

  return elements;
}

/**
 * Generate background for specific slide type
 */
export function generateBackgroundForSlide(slideSpec: any): string {
  // Extract palette from slide spec (SlideSpecV1 uses styleTokens)
  const palette = {
    primary: slideSpec.styleTokens?.palette?.primary || '#6366F1',
    accent: slideSpec.styleTokens?.palette?.accent || '#10B981',
    neutral: slideSpec.styleTokens?.palette?.neutral || [
      '#1E293B',
      '#334155',
      '#475569',
      '#64748B',
      '#94A3B8',
      '#CBD5E1',
      '#E2E8F0',
      '#F1F5F9',
      '#F8FAFC',
    ],
  };

  // Determine theme based on slide content
  let theme: 'minimal' | 'professional' | 'creative' | 'tech' | 'elegant' = 'professional';
  let style: 'subtle' | 'bold' | 'modern' = 'subtle';

  // Analyze slide content to determine best theme
  const title = slideSpec.content?.title?.text?.toLowerCase() || '';
  const subtitle = slideSpec.content?.subtitle?.text?.toLowerCase() || '';

  if (title.includes('tech') || title.includes('digital') || title.includes('innovation')) {
    theme = 'tech';
  } else if (title.includes('creative') || title.includes('design') || title.includes('art')) {
    theme = 'creative';
    style = 'modern';
  } else if (title.includes('elegant') || title.includes('luxury') || title.includes('premium')) {
    theme = 'elegant';
  } else if (slideSpec.content?.bullets?.length > 5 || slideSpec.content?.dataViz) {
    theme = 'minimal'; // Keep it clean for data-heavy slides
  }

  return generateBackground({ palette, theme, style });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/svgGenerator/converter.ts
=================================================================================
/**
 * SVG to PNG Converter
 * Converts SVG backgrounds to PNG for embedding in PowerPoint
 */

import sharp from 'sharp';

/**
 * Convert SVG string to PNG base64 data URL
 */
export async function svgToPngDataUrl(svgString: string, width: number = 1920, height: number = 1080): Promise<string> {
  try {
    // Convert SVG to PNG buffer using sharp
    const pngBuffer = await sharp(Buffer.from(svgString))
      .resize(width, height, {
        fit: 'fill',
        background: { r: 255, g: 255, b: 255, alpha: 1 },
      })
      .png({
        quality: 100,
        compressionLevel: 6,
      })
      .toBuffer();

    // Convert to base64 data URL
    const base64 = pngBuffer.toString('base64');
    return `data:image/png;base64,${base64}`;
  } catch (error) {
    console.error('Error converting SVG to PNG:', error);
    throw new Error('Failed to convert SVG to PNG');
  }
}

/**
 * Convert SVG string to PNG buffer
 */
export async function svgToPngBuffer(svgString: string, width: number = 1920, height: number = 1080): Promise<Buffer> {
  try {
    return await sharp(Buffer.from(svgString))
      .resize(width, height, {
        fit: 'fill',
        background: { r: 255, g: 255, b: 255, alpha: 1 },
      })
      .png({
        quality: 100,
        compressionLevel: 6,
      })
      .toBuffer();
  } catch (error) {
    console.error('Error converting SVG to PNG:', error);
    throw new Error('Failed to convert SVG to PNG');
  }
}

/**
 * Optimize PNG for smaller file size
 */
export async function optimizePng(pngBuffer: Buffer): Promise<Buffer> {
  try {
    return await sharp(pngBuffer)
      .png({
        quality: 90,
        compressionLevel: 9,
        adaptiveFiltering: true,
      })
      .toBuffer();
  } catch (error) {
    console.error('Error optimizing PNG:', error);
    return pngBuffer; // Return original if optimization fails
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/svgGenerator/decorativeElements.ts
=================================================================================
/**
 * SVG Decorative Elements
 * Professional design accents for slides
 */

export interface DecorativeElementConfig {
  x: number;
  y: number;
  color: string;
  opacity?: number;
}

/**
 * Left accent bar (vertical)
 */
export function createAccentBar(config: {
  width?: number;
  color: string;
  opacity?: number;
}): string {
  const width = config.width || 15;
  const opacity = config.opacity || 1;

  return `
    <rect 
      x="0" 
      y="0" 
      width="${width}" 
      height="1080" 
      fill="${config.color}" 
      opacity="${opacity}"
    />`;
}

/**
 * Top-right corner accent (triangle)
 */
export function createCornerAccent(config: {
  size?: number;
  color: string;
  opacity?: number;
  position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';
}): string {
  const size = config.size || 200;
  const opacity = config.opacity || 0.2;
  const position = config.position || 'top-right';

  let path = '';
  switch (position) {
    case 'top-right':
      path = `M 1920 0 L 1920 ${size} L ${1920 - size} 0 Z`;
      break;
    case 'top-left':
      path = `M 0 0 L ${size} 0 L 0 ${size} Z`;
      break;
    case 'bottom-right':
      path = `M 1920 1080 L 1920 ${1080 - size} L ${1920 - size} 1080 Z`;
      break;
    case 'bottom-left':
      path = `M 0 1080 L ${size} 1080 L 0 ${1080 - size} Z`;
      break;
  }

  return `
    <path 
      d="${path}" 
      fill="${config.color}" 
      opacity="${opacity}"
    />`;
}

/**
 * Decorative circles (bottom-right cluster)
 */
export function createDecorativeCircles(config: {
  x?: number;
  y?: number;
  color: string;
  count?: number;
}): string {
  const x = config.x || 1800;
  const y = config.y || 950;
  const count = config.count || 3;

  const circles = [];
  for (let i = 0; i < count; i++) {
    const radius = 80 - i * 20;
    const offsetX = i * 30;
    const offsetY = i * 30;
    const opacity = 0.1 + i * 0.05;

    circles.push(`
      <circle 
        cx="${x + offsetX}" 
        cy="${y + offsetY}" 
        r="${radius}" 
        fill="${config.color}" 
        opacity="${opacity}"
      />`);
  }

  return circles.join('\n');
}

/**
 * Premium divider line (horizontal)
 */
export function createDividerLine(config: {
  y: number;
  x?: number;
  width?: number;
  height?: number;
  color: string;
  opacity?: number;
}): string {
  const x = config.x || 100;
  const width = config.width || 200;
  const height = config.height || 4;
  const opacity = config.opacity || 1;

  return `
    <rect 
      x="${x}" 
      y="${config.y}" 
      width="${width}" 
      height="${height}" 
      fill="${config.color}" 
      opacity="${opacity}"
      rx="2"
    />`;
}

/**
 * Geometric pattern (subtle background pattern)
 */
export function createGeometricPattern(config: {
  color: string;
  opacity?: number;
  density?: 'low' | 'medium' | 'high';
}): string {
  const opacity = config.opacity || 0.03;
  const density = config.density || 'low';

  const spacing = density === 'low' ? 200 : density === 'medium' ? 100 : 50;
  const size = spacing * 0.3;

  const elements = [];
  for (let x = 0; x < 1920; x += spacing) {
    for (let y = 0; y < 1080; y += spacing) {
      elements.push(`
        <circle 
          cx="${x}" 
          cy="${y}" 
          r="${size}" 
          fill="${config.color}" 
          opacity="${opacity}"
        />`);
    }
  }

  return elements.join('\n');
}

/**
 * Curved accent line (decorative swoosh)
 */
export function createCurvedAccent(config: {
  startX: number;
  startY: number;
  endX: number;
  endY: number;
  color: string;
  thickness?: number;
  opacity?: number;
}): string {
  const thickness = config.thickness || 3;
  const opacity = config.opacity || 0.3;

  // Create a smooth bezier curve
  const controlX1 = config.startX + (config.endX - config.startX) * 0.3;
  const controlY1 = config.startY - 100;
  const controlX2 = config.startX + (config.endX - config.startX) * 0.7;
  const controlY2 = config.endY + 100;

  return `
    <path 
      d="M ${config.startX} ${config.startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${config.endX} ${config.endY}" 
      stroke="${config.color}" 
      stroke-width="${thickness}" 
      fill="none" 
      opacity="${opacity}"
      stroke-linecap="round"
    />`;
}

/**
 * Glow effect filter
 */
export function createGlowFilter(id: string, color: string, intensity: number = 10): string {
  return `
    <filter id="${id}">
      <feGaussianBlur stdDeviation="${intensity}" result="coloredBlur"/>
      <feMerge>
        <feMergeNode in="coloredBlur"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>`;
}

/**
 * Subtle shadow filter
 */
export function createShadowFilter(id: string): string {
  return `
    <filter id="${id}" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
      <feOffset dx="2" dy="2" result="offsetblur"/>
      <feComponentTransfer>
        <feFuncA type="linear" slope="0.2"/>
      </feComponentTransfer>
      <feMerge>
        <feMergeNode/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>`;
}

/**
 * Abstract shape (for modern designs)
 */
export function createAbstractShape(config: {
  x: number;
  y: number;
  size: number;
  color: string;
  opacity?: number;
  rotation?: number;
}): string {
  const opacity = config.opacity || 0.1;
  const rotation = config.rotation || 0;
  const halfSize = config.size / 2;

  // Create an interesting organic shape using path
  const path = `
    M ${config.x} ${config.y - halfSize}
    Q ${config.x + halfSize} ${config.y - halfSize * 0.5}, ${config.x + halfSize} ${config.y}
    Q ${config.x + halfSize} ${config.y + halfSize * 0.5}, ${config.x} ${config.y + halfSize}
    Q ${config.x - halfSize} ${config.y + halfSize * 0.5}, ${config.x - halfSize} ${config.y}
    Q ${config.x - halfSize} ${config.y - halfSize * 0.5}, ${config.x} ${config.y - halfSize}
    Z
  `;

  return `
    <path 
      d="${path}" 
      fill="${config.color}" 
      opacity="${opacity}"
      transform="rotate(${rotation} ${config.x} ${config.y})"
    />`;
}

/**
 * Grid pattern (subtle background)
 */
export function createGridPattern(config: {
  color: string;
  opacity?: number;
  spacing?: number;
}): string {
  const opacity = config.opacity || 0.02;
  const spacing = config.spacing || 100;

  const lines = [];

  // Vertical lines
  for (let x = 0; x < 1920; x += spacing) {
    lines.push(`
      <line 
        x1="${x}" 
        y1="0" 
        x2="${x}" 
        y2="1080" 
        stroke="${config.color}" 
        stroke-width="1" 
        opacity="${opacity}"
      />`);
  }

  // Horizontal lines
  for (let y = 0; y < 1080; y += spacing) {
    lines.push(`
      <line 
        x1="0" 
        y1="${y}" 
        x2="1920" 
        y2="${y}" 
        stroke="${config.color}" 
        stroke-width="1" 
        opacity="${opacity}"
      />`);
  }

  return lines.join('\n');
}

/**
 * Create a sophisticated arrow shape
 */
export function createArrow(config: {
  x: number;
  y: number;
  width: number;
  height: number;
  color: string;
  opacity?: number;
  direction?: 'right' | 'left' | 'up' | 'down';
}): string {
  const opacity = config.opacity || 1;
  const direction = config.direction || 'right';

  let path = '';
  const w = config.width;
  const h = config.height;
  const x = config.x;
  const y = config.y;

  switch (direction) {
    case 'right':
      path = `M ${x} ${y} L ${x + w * 0.7} ${y} L ${x + w * 0.7} ${y - h/2} L ${x + w} ${y + h/2} L ${x + w * 0.7} ${y + h * 1.5} L ${x + w * 0.7} ${y + h} L ${x} ${y + h} Z`;
      break;
    case 'left':
      path = `M ${x + w} ${y} L ${x + w * 0.3} ${y} L ${x + w * 0.3} ${y - h/2} L ${x} ${y + h/2} L ${x + w * 0.3} ${y + h * 1.5} L ${x + w * 0.3} ${y + h} L ${x + w} ${y + h} Z`;
      break;
    case 'up':
      path = `M ${x} ${y + h} L ${x} ${y + h * 0.3} L ${x - w/2} ${y + h * 0.3} L ${x + w/2} ${y} L ${x + w * 1.5} ${y + h * 0.3} L ${x + w} ${y + h * 0.3} L ${x + w} ${y + h} Z`;
      break;
    case 'down':
      path = `M ${x} ${y} L ${x} ${y + h * 0.7} L ${x - w/2} ${y + h * 0.7} L ${x + w/2} ${y + h} L ${x + w * 1.5} ${y + h * 0.7} L ${x + w} ${y + h * 0.7} L ${x + w} ${y} Z`;
      break;
  }

  return `
    <path
      d="${path}"
      fill="${config.color}"
      opacity="${opacity}"
    />`;
}

/**
 * Create a callout box with pointer
 */
export function createCalloutBox(config: {
  x: number;
  y: number;
  width: number;
  height: number;
  color: string;
  borderColor: string;
  opacity?: number;
  pointerPosition?: 'left' | 'right' | 'top' | 'bottom';
}): string {
  const opacity = config.opacity || 1;
  const pointerSize = 20;

  // Main box
  const box = `
    <rect
      x="${config.x}"
      y="${config.y}"
      width="${config.width}"
      height="${config.height}"
      fill="${config.color}"
      stroke="${config.borderColor}"
      stroke-width="2"
      opacity="${opacity}"
      rx="8"
    />`;

  // Pointer triangle
  let pointer = '';
  const centerX = config.x + config.width / 2;
  const centerY = config.y + config.height / 2;

  switch (config.pointerPosition) {
    case 'left':
      pointer = `
        <path
          d="M ${config.x} ${centerY - pointerSize/2} L ${config.x - pointerSize} ${centerY} L ${config.x} ${centerY + pointerSize/2} Z"
          fill="${config.color}"
          stroke="${config.borderColor}"
          stroke-width="2"
          opacity="${opacity}"
        />`;
      break;
    case 'right':
      pointer = `
        <path
          d="M ${config.x + config.width} ${centerY - pointerSize/2} L ${config.x + config.width + pointerSize} ${centerY} L ${config.x + config.width} ${centerY + pointerSize/2} Z"
          fill="${config.color}"
          stroke="${config.borderColor}"
          stroke-width="2"
          opacity="${opacity}"
        />`;
      break;
    case 'top':
      pointer = `
        <path
          d="M ${centerX - pointerSize/2} ${config.y} L ${centerX} ${config.y - pointerSize} L ${centerX + pointerSize/2} ${config.y} Z"
          fill="${config.color}"
          stroke="${config.borderColor}"
          stroke-width="2"
          opacity="${opacity}"
        />`;
      break;
    case 'bottom':
      pointer = `
        <path
          d="M ${centerX - pointerSize/2} ${config.y + config.height} L ${centerX} ${config.y + config.height + pointerSize} L ${centerX + pointerSize/2} ${config.y + config.height} Z"
          fill="${config.color}"
          stroke="${config.borderColor}"
          stroke-width="2"
          opacity="${opacity}"
        />`;
      break;
  }

  return box + pointer;
}

/**
 * Create a wave pattern for backgrounds
 */
export function createWavePattern(config: {
  color: string;
  opacity?: number;
  amplitude?: number;
  frequency?: number;
  position?: 'top' | 'bottom';
}): string {
  const opacity = config.opacity || 0.05;
  const amplitude = config.amplitude || 50;
  const frequency = config.frequency || 3;
  const position = config.position || 'bottom';

  const points = [];
  const steps = 50;

  for (let i = 0; i <= steps; i++) {
    const x = (1920 / steps) * i;
    const y = amplitude * Math.sin((i / steps) * Math.PI * 2 * frequency);
    points.push(`${x},${y}`);
  }

  const baseY = position === 'top' ? 0 : 1080;
  const path = position === 'top'
    ? `M 0,0 L ${points.join(' L ')} L 1920,0 Z`
    : `M 0,1080 L ${points.map(p => {
        const [x, y] = p.split(',');
        return `${x},${1080 - parseFloat(y)}`;
      }).join(' L ')} L 1920,1080 Z`;

  return `
    <path
      d="${path}"
      fill="${config.color}"
      opacity="${opacity}"
    />`;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/svgGenerator/gradients.ts
=================================================================================
/**
 * SVG Gradient Definitions
 * Professional gradient patterns for slide backgrounds
 */

export interface GradientConfig {
  id: string;
  type: 'linear' | 'radial';
  colors: Array<{ offset: string; color: string; opacity?: number }>;
  angle?: number; // For linear gradients (0-360)
  cx?: string; // For radial gradients
  cy?: string; // For radial gradients
  r?: string; // For radial gradients
}

/**
 * Generate SVG gradient definition
 */
export function createGradientDef(config: GradientConfig): string {
  if (config.type === 'linear') {
    return createLinearGradient(config);
  } else {
    return createRadialGradient(config);
  }
}

function createLinearGradient(config: GradientConfig): string {
  const angle = config.angle || 135;
  const radians = (angle - 90) * (Math.PI / 180);
  const x1 = Math.round(50 + 50 * Math.cos(radians));
  const y1 = Math.round(50 + 50 * Math.sin(radians));
  const x2 = Math.round(50 - 50 * Math.cos(radians));
  const y2 = Math.round(50 - 50 * Math.sin(radians));

  const stops = config.colors
    .map(
      (stop) =>
        `<stop offset="${stop.offset}" style="stop-color:${stop.color};stop-opacity:${stop.opacity || 1}" />`
    )
    .join('\n      ');

  return `
    <linearGradient id="${config.id}" x1="${x1}%" y1="${y1}%" x2="${x2}%" y2="${y2}%">
      ${stops}
    </linearGradient>`;
}

function createRadialGradient(config: GradientConfig): string {
  const cx = config.cx || '50%';
  const cy = config.cy || '50%';
  const r = config.r || '50%';

  const stops = config.colors
    .map(
      (stop) =>
        `<stop offset="${stop.offset}" style="stop-color:${stop.color};stop-opacity:${stop.opacity || 1}" />`
    )
    .join('\n      ');

  return `
    <radialGradient id="${config.id}" cx="${cx}" cy="${cy}" r="${r}">
      ${stops}
    </radialGradient>`;
}

/**
 * Predefined professional gradient themes
 */
export const gradientThemes = {
  // Subtle, professional gradients
  subtle: {
    id: 'subtle-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#F8FAFC' },
      { offset: '50%', color: '#F1F5F9' },
      { offset: '100%', color: '#F8FAFC' },
    ],
  },

  // Modern tech gradient
  tech: {
    id: 'tech-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#EEF2FF' },
      { offset: '50%', color: '#E0E7FF' },
      { offset: '100%', color: '#EEF2FF' },
    ],
  },

  // Warm, inviting gradient
  warm: {
    id: 'warm-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#FEF3C7' },
      { offset: '50%', color: '#FDE68A' },
      { offset: '100%', color: '#FEF3C7' },
    ],
  },

  // Cool, calm gradient
  cool: {
    id: 'cool-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#ECFEFF' },
      { offset: '50%', color: '#CFFAFE' },
      { offset: '100%', color: '#ECFEFF' },
    ],
  },

  // Professional blue
  professional: {
    id: 'professional-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#DBEAFE' },
      { offset: '50%', color: '#BFDBFE' },
      { offset: '100%', color: '#DBEAFE' },
    ],
  },

  // Elegant purple
  elegant: {
    id: 'elegant-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#F3E8FF' },
      { offset: '50%', color: '#E9D5FF' },
      { offset: '100%', color: '#F3E8FF' },
    ],
  },

  // Success green
  success: {
    id: 'success-gradient',
    type: 'linear' as const,
    angle: 135,
    colors: [
      { offset: '0%', color: '#D1FAE5' },
      { offset: '50%', color: '#A7F3D0' },
      { offset: '100%', color: '#D1FAE5' },
    ],
  },

  // Radial spotlight
  spotlight: {
    id: 'spotlight-gradient',
    type: 'radial' as const,
    cx: '30%',
    cy: '30%',
    r: '70%',
    colors: [
      { offset: '0%', color: '#FFFFFF' },
      { offset: '50%', color: '#F8FAFC' },
      { offset: '100%', color: '#F1F5F9' },
    ],
  },
};

/**
 * Get gradient theme by name or create custom
 */
export function getGradient(
  themeName?: keyof typeof gradientThemes,
  customColors?: string[]
): GradientConfig {
  if (themeName && gradientThemes[themeName]) {
    return gradientThemes[themeName];
  }

  // Create custom gradient from colors
  if (customColors && customColors.length >= 2) {
    const stops = customColors.map((color, index) => ({
      offset: `${(index / (customColors.length - 1)) * 100}%`,
      color,
    }));

    return {
      id: 'custom-gradient',
      type: 'linear',
      angle: 135,
      colors: stops,
    };
  }

  // Default to subtle
  return gradientThemes.subtle;
}

/**
 * Create gradient from color palette with enhanced sophistication
 */
export function createGradientFromPalette(palette: {
  primary: string;
  accent: string;
  neutral: string[];
}): GradientConfig {
  // Use neutral colors for subtle background with primary/accent hints
  const lightest = palette.neutral[palette.neutral.length - 1] || '#F8FAFC';
  const lighter = palette.neutral[palette.neutral.length - 2] || '#F1F5F9';
  const mid = palette.neutral[palette.neutral.length - 3] || '#E2E8F0';

  // Add very subtle primary color tint for sophistication
  return {
    id: 'palette-gradient',
    type: 'linear',
    angle: 135,
    colors: [
      { offset: '0%', color: lightest },
      { offset: '25%', color: lighter },
      { offset: '50%', color: mid, opacity: 0.03 },
      { offset: '75%', color: lighter },
      { offset: '100%', color: lightest },
    ],
  };
}

/**
 * Create radial gradient for spotlight effect
 */
export function createRadialGradientFromPalette(palette: {
  primary: string;
  accent: string;
  neutral: string[];
}): GradientConfig {
  const lightest = palette.neutral[palette.neutral.length - 1] || '#F8FAFC';
  const lighter = palette.neutral[palette.neutral.length - 2] || '#F1F5F9';

  return {
    id: 'radial-palette-gradient',
    type: 'radial',
    cx: '30%',
    cy: '30%',
    r: '80%',
    colors: [
      { offset: '0%', color: '#FFFFFF', opacity: 0.8 },
      { offset: '40%', color: lightest },
      { offset: '100%', color: lighter },
    ],
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/svgGenerator/index.ts
=================================================================================
/**
 * SVG Generator Module
 * Professional SVG backgrounds and decorative elements for slides
 */

export { generateBackground, generateBackgroundForSlide, type BackgroundConfig } from './backgroundGenerator';
export { createGradientDef, getGradient, createGradientFromPalette, createRadialGradientFromPalette, gradientThemes, type GradientConfig } from './gradients';
export {
  createAccentBar,
  createCornerAccent,
  createDecorativeCircles,
  createDividerLine,
  createGeometricPattern,
  createCurvedAccent,
  createGlowFilter,
  createShadowFilter,
  createAbstractShape,
  createGridPattern,
  createArrow,
  createCalloutBox,
  createWavePattern,
} from './decorativeElements';
export { svgToPngDataUrl, svgToPngBuffer, optimizePng } from './converter';



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/templates.ts
=================================================================================
/**
 * Pre-built Slide Templates
 * Ready-to-use templates for common use cases
 */

import type { SlideSpecV1 } from "./types/SlideSpecV1";

export interface Template {
  id: string;
  name: string;
  description: string;
  category: "business" | "tech" | "marketing" | "education" | "general";
  thumbnail?: string;
  spec: SlideSpecV1;
}

/**
 * Title Slide Template
 */
export const TITLE_SLIDE_TEMPLATE: Template = {
  id: "title-hero",
  name: "Hero Title Slide",
  description: "Bold title slide for presentation openings",
  category: "general",
  spec: {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Professional Hero",
      aspectRatio: "16:9"
    },
    content: {
      title: { id: "title", text: "Your Presentation Title" },
      subtitle: { id: "subtitle", text: "Subtitle or tagline goes here" }
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 32, r: 32, b: 32, l: 32 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 6, colSpan: 12 },
        { name: "footer", rowStart: 7, colStart: 1, rowSpan: 2, colSpan: 12 }
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "subtitle", region: "header", order: 1 }
      ]
    },
    styleTokens: {
      palette: { primary: "#1E40AF", accent: "#10B981", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"] },
      typography: {
        fonts: { sans: "Inter, Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 24, "step_2": 32, "step_3": 56 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.5 }
      },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32,48] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: { sm: "0 2px 4px rgba(0,0,0,.08)", md: "0 4px 12px rgba(0,0,0,.12)", lg: "0 12px 32px rgba(0,0,0,.16)" },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 }
    }
  }
};

/**
 * Bullet Points Template
 */
export const BULLET_POINTS_TEMPLATE: Template = {
  id: "bullets-split",
  name: "Key Points",
  description: "Clean bullet point slide with title",
  category: "general",
  spec: {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Professional Split",
      aspectRatio: "16:9"
    },
    content: {
      title: { id: "title", text: "Key Points" },
      subtitle: { id: "subtitle", text: "Main takeaways" },
      bullets: [{
        id: "b1",
        items: [
          { text: "First key point with supporting detail", level: 1 },
          { text: "Second important point to remember", level: 1 },
          { text: "Third critical insight or action item", level: 1 },
          { text: "Fourth point for comprehensive coverage", level: 1 }
        ]
      }]
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 32, r: 32, b: 32, l: 32 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 6, colSpan: 12 }
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "subtitle", region: "header", order: 1 },
        { refId: "b1", region: "body", order: 0 }
      ]
    },
    styleTokens: {
      palette: { primary: "#3B82F6", accent: "#10B981", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"] },
      typography: {
        fonts: { sans: "Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, "step_0": 18, "step_1": 24, "step_2": 32, "step_3": 40 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.6 }
      },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: { sm: "0 2px 4px rgba(0,0,0,.08)", md: "0 4px 12px rgba(0,0,0,.12)", lg: "0 12px 32px rgba(0,0,0,.16)" },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 }
    }
  }
};

/**
 * Data Visualization Template
 */
export const DATA_VIZ_TEMPLATE: Template = {
  id: "data-chart",
  name: "Data & Metrics",
  description: "Chart-focused slide for data presentation",
  category: "business",
  spec: {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Data Focused",
      aspectRatio: "16:9"
    },
    content: {
      title: { id: "title", text: "Performance Metrics" },
      subtitle: { id: "subtitle", text: "Q4 2024 Results" },
      bullets: [{
        id: "b1",
        items: [
          { text: "Revenue up 25% YoY", level: 1 },
          { text: "Customer growth: 15%", level: 1 },
          { text: "Retention rate: 94%", level: 1 }
        ]
      }],
      dataViz: {
        id: "chart1",
        kind: "bar",
        title: "Quarterly Revenue",
        labels: ["Q1", "Q2", "Q3", "Q4"],
        series: [{ name: "Revenue ($M)", values: [12, 15, 18, 22] }]
      }
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 32, r: 32, b: 32, l: 32 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 6, colSpan: 7 },
        { name: "aside", rowStart: 3, colStart: 8, rowSpan: 6, colSpan: 5 }
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "subtitle", region: "header", order: 1 },
        { refId: "chart1", region: "body", order: 0 },
        { refId: "b1", region: "aside", order: 0 }
      ]
    },
    styleTokens: {
      palette: { primary: "#0F172A", accent: "#10B981", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"] },
      typography: {
        fonts: { sans: "Inter, Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 20, "step_2": 28, "step_3": 40 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.5 }
      },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: { sm: "0 2px 4px rgba(0,0,0,.08)", md: "0 4px 12px rgba(0,0,0,.12)", lg: "0 12px 32px rgba(0,0,0,.16)" },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 }
    }
  }
};

/**
 * Quote/Testimonial Template
 */
export const QUOTE_TEMPLATE: Template = {
  id: "quote-minimal",
  name: "Quote or Testimonial",
  description: "Minimal slide for impactful quotes",
  category: "marketing",
  spec: {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Minimal Quote",
      aspectRatio: "16:9"
    },
    content: {
      title: { id: "title", text: "\"This product transformed our business\"" },
      subtitle: { id: "subtitle", text: "‚Äî Jane Doe, CEO of Example Corp" }
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 48, r: 48, b: 48, l: 48 } },
      regions: [
        { name: "body", rowStart: 3, colStart: 2, rowSpan: 4, colSpan: 10 }
      ],
      anchors: [
        { refId: "title", region: "body", order: 0 },
        { refId: "subtitle", region: "body", order: 1 }
      ]
    },
    styleTokens: {
      palette: { primary: "#1F2937", accent: "#8B5CF6", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"] },
      typography: {
        fonts: { sans: "Georgia, serif" },
        sizes: { "step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 20, "step_2": 28, "step_3": 36 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.3, standard: 1.6 }
      },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32,48] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: { sm: "0 2px 4px rgba(0,0,0,.08)", md: "0 4px 12px rgba(0,0,0,.12)", lg: "0 12px 32px rgba(0,0,0,.16)" },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 }
    }
  }
};

/**
 * Two-Column Comparison Template
 */
export const COMPARISON_TEMPLATE: Template = {
  id: "comparison-split",
  name: "Side-by-Side Comparison",
  description: "Compare two options or concepts",
  category: "business",
  spec: {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Split Comparison",
      aspectRatio: "16:9"
    },
    content: {
      title: { id: "title", text: "Option A vs Option B" },
      bullets: [
        {
          id: "b1",
          items: [
            { text: "Advantage 1", level: 1 },
            { text: "Advantage 2", level: 1 },
            { text: "Advantage 3", level: 1 }
          ]
        },
        {
          id: "b2",
          items: [
            { text: "Benefit 1", level: 1 },
            { text: "Benefit 2", level: 1 },
            { text: "Benefit 3", level: 1 }
          ]
        }
      ]
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 32, r: 32, b: 32, l: 32 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 6, colSpan: 5 },
        { name: "aside", rowStart: 3, colStart: 7, rowSpan: 6, colSpan: 6 }
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "b1", region: "body", order: 0 },
        { refId: "b2", region: "aside", order: 0 }
      ]
    },
    styleTokens: {
      palette: { primary: "#4F46E5", accent: "#EC4899", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#F8FAFC"] },
      typography: {
        fonts: { sans: "Segoe UI, Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, "step_0": 16, "step_1": 22, "step_2": 30, "step_3": 40 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.5 }
      },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: { sm: "0 2px 4px rgba(0,0,0,.08)", md: "0 4px 12px rgba(0,0,0,.12)", lg: "0 12px 32px rgba(0,0,0,.16)" },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 }
    }
  }
};

/**
 * Get all templates
 */
export function getAllTemplates(): Template[] {
  return [
    TITLE_SLIDE_TEMPLATE,
    BULLET_POINTS_TEMPLATE,
    DATA_VIZ_TEMPLATE,
    QUOTE_TEMPLATE,
    COMPARISON_TEMPLATE
  ];
}

/**
 * Get templates by category
 */
export function getTemplatesByCategory(category: Template["category"]): Template[] {
  return getAllTemplates().filter(t => t.category === category);
}

/**
 * Get template by ID
 */
export function getTemplateById(id: string): Template | null {
  return getAllTemplates().find(t => t.id === id) || null;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/types/SlideSpecV1.ts
=================================================================================
export type AspectRatio = "16:9" | "4:3";
export type RegionName = "header" | "body" | "footer" | "aside";
export type ChartKind = "bar" | "line" | "pie" | "area" | "scatter" | "combo" | "waterfall" | "funnel" | "doughnut";

export interface SlideSpecV1 {
  meta: {
    version: "1.0";
    locale: string;
    theme: string;
    aspectRatio: AspectRatio;
  };
  content: {
    title: { id: string; text: string };
    subtitle?: { id: string; text: string };
    bullets?: { id: string; items: { text: string; level: 1 | 2 | 3 }[] }[];
    callouts?: { id: string; title?: string; text: string; variant: "note"|"success"|"warning"|"danger" }[];
    dataViz?: {
      id: string; kind: ChartKind; title?: string; labels: string[];
      series: { name: string; values: number[] }[]; valueFormat?: "number"|"percent"|"currency"|"auto";
    };
    imagePlaceholders?: { id: string; role: "hero" | "logo" | "illustration" | "icon" | "background"; alt: string }[];
    images?: {
      id: string;
      role: "hero" | "logo" | "illustration" | "icon" | "background";
      source: {
        type: "url" | "unsplash" | "placeholder";
        url?: string;
        query?: string;
      };
      alt: string;
      fit?: "cover" | "contain" | "fill";
    }[];
  };
  layout: {
    grid: { rows: number; cols: number; gutter: number; margin: { t: number; r: number; b: number; l: number } };
    regions: { name: RegionName; rowStart: number; colStart: number; rowSpan: number; colSpan: number }[];
    anchors: { refId: string; region: RegionName; order: number; span?: { rows: number; cols: number } }[];
  };
  styleTokens: {
    palette: { primary: string; accent: string; neutral: string[] };
    typography: {
      fonts: { sans: string; serif?: string; mono?: string };
      sizes: { "step_-2": number; "step_-1": number; step_0: number; step_1: number; step_2: number; step_3: number };
      weights: { regular: number; medium: number; semibold: number; bold: number };
      lineHeights: { compact: number; standard: number };
    };
    spacing: { base: number; steps: number[] };
    radii: { sm: number; md: number; lg: number };
    shadows: { sm: string; md: string; lg: string };
    contrast: { minTextContrast: number; minUiContrast: number };
  };
  components?: {
    bulletList?: { variant?: "compact" | "spacious" };
    callout?: { variant?: "flat" | "elevated" };
    chart?: { legend?: "none" | "right" | "bottom"; gridlines?: boolean };
    image?: { fit?: "cover" | "contain" };
    title?: { align?: "left" | "center" | "right" };
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/src/types/SlideSpecV2.ts
=================================================================================
import type { SlideSpecV1 } from "./SlideSpecV1";

export type DesignPattern = "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused";
export type WhitespaceStrategy = "generous" | "balanced" | "compact";
export type TypographyStrategy = "classic" | "modern" | "bold" | "minimal" | "elegant";
export type ColorDistribution = "monochromatic" | "complementary" | "analogous" | "triadic";
export type ContrastLevel = "high" | "medium" | "low";
export type AnimationType = "fade" | "slide" | "zoom" | "wipe" | "pulse" | "glow" | "scale";

export interface VisualHierarchy {
  primaryFocus: string; // element ID with highest emphasis
  secondaryFocus: string[]; // supporting element IDs
  emphasisLevels: Record<string, 1 | 2 | 3 | 4 | 5>; // 1=minimal, 5=maximum
}

export interface WhitespaceConfig {
  strategy: WhitespaceStrategy;
  breathingRoom: number; // 20-50 percentage
}

export interface TypographyConfig {
  strategy: TypographyStrategy;
  fontPairing: {
    primary: string; // heading font
    secondary: string; // body font
  };
  hierarchy: Record<string, {
    size: number;
    weight: 400 | 500 | 600 | 700;
    lineHeight: number;
  }>;
}

export interface ColorStrategyConfig {
  distribution: ColorDistribution;
  emphasis: string; // accent color usage
  contrast: ContrastLevel;
}

export interface AnimationConfig {
  type: AnimationType;
  duration: number; // milliseconds
  delay?: number;
}

export interface DesignConfig {
  pattern: DesignPattern;
  
  visualHierarchy: VisualHierarchy;
  
  whitespace: WhitespaceConfig;
  
  typography: TypographyConfig;
  
  colorStrategy: ColorStrategyConfig;
  
  animations?: {
    entrance?: AnimationConfig[];
    emphasis?: AnimationConfig[];
  };
}

export interface SlideSpecV2 extends SlideSpecV1 {
  design: DesignConfig;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/App.tsx
=================================================================================
import { useCallback, useEffect, useState } from "react";
import { SlideEditor } from "@/components/SlideEditor";
import { ProgressIndicator } from "@/components/ProgressIndicator";
import { ToastContainer, useToast } from "@/components/Toast";
import { SlideChat } from "@/components/SlideChat";
import { useSlideGeneration } from "@/hooks/useSlideGeneration";
import { useSlideExport } from "@/hooks/useSlideExport";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export default function App() {
  const { loading, spec, error, generate } = useSlideGeneration();
  const { exportSlide } = useSlideExport();
  const toast = useToast();
  const [currentSpec, setCurrentSpec] = useState<SlideSpecV1 | null>(null);

  useEffect(() => {
    if (spec) {
      setCurrentSpec(spec);
    }
  }, [spec]);

  const handleChatReady = useCallback(async (slidePrompt: string) => {
    const result = await generate(slidePrompt);
    if (result) {
      toast.success("Slide generated successfully!");
    }
  }, [generate, toast]);

  useEffect(() => {
    if (error) {
      toast.error(error);
    }
  }, [error]);

  const handleSlideUpdate = useCallback((updatedSpec: SlideSpecV1) => {
    setCurrentSpec(updatedSpec);
  }, []);

  const handleDownload = useCallback(async () => {
    if (!currentSpec) return;

    const success = await exportSlide(currentSpec);
    if (success) {
      toast.success("PowerPoint downloaded successfully!");
    } else {
      toast.error("Failed to download PowerPoint");
    }
  }, [currentSpec, exportSlide, toast]);

  return (
    <div className="min-h-screen flex flex-col" style={{ background: 'var(--bg-gradient-main)' }}>
      {/* Skip to main content link for accessibility */}
      <a
        href="#main-content"
        className="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-[var(--color-primary)] focus:text-white focus:rounded-[var(--radius-md)]"
      >
        Skip to main content
      </a>

      <ToastContainer toasts={toast.toasts} onClose={toast.closeToast} />

      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 sm:py-12 space-y-8 sm:space-y-12 w-full">
        {/* Premium Header */}
        <header className="text-center space-y-4 py-8 sm:py-12 animate-fade-in">
          <div className="inline-block">
            <h1 className="text-5xl sm:text-6xl lg:text-7xl font-bold bg-gradient-to-r from-[var(--color-primary)] via-[var(--color-primary-light)] to-[var(--color-accent)] bg-clip-text text-transparent mb-3" style={{ fontFamily: 'var(--font-display)', letterSpacing: '-0.02em' }}>
              plsfixthx
            </h1>
            <div className="h-1 w-24 mx-auto bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] rounded-full"></div>
          </div>
          <p className="text-lg sm:text-xl text-[var(--neutral-3)] max-w-2xl mx-auto font-medium leading-relaxed">
            Create beautiful, professional slides with AI
          </p>
        </header>

        {/* Chat Interface - ChatGPT Style */}
        <main id="main-content" className="animate-scale-in max-w-4xl mx-auto w-full">
          <SlideChat onSlideReady={handleChatReady} isGenerating={loading} />
        </main>

        {/* Slide Editor with Live Preview and Edit Chat */}
        {(currentSpec || loading) && (
          <div className="animate-scale-in max-w-7xl mx-auto w-full">
            {loading ? (
              <div className="glass rounded-[var(--radius-2xl)] p-6 sm:p-8 lg:p-10 space-y-6">
                <div className="flex items-center justify-between">
                  <h2 className="text-2xl font-bold text-[var(--neutral-1)]">
                    Creating your slide...
                  </h2>
                </div>
                <ProgressIndicator isLoading={loading} />
              </div>
            ) : currentSpec ? (
              <div className="space-y-6">
                <SlideEditor
                  spec={currentSpec}
                  onUpdate={handleSlideUpdate}
                  onExport={handleDownload}
                />
              </div>
            ) : null}
          </div>
        )}
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/AdvancedChartBuilder.tsx
=================================================================================
import { useState } from "react";
import { BarChart3, LineChart, PieChart, TrendingUp, Plus, X } from "lucide-react";

type ChartType = "bar" | "line" | "pie" | "area" | "scatter" | "doughnut" | "waterfall" | "combo" | "funnel";

interface ChartData {
  chartType: ChartType;
  title: string;
  labels: string[];
  series: Array<{
    name: string;
    values: number[];
  }>;
  showTrendline?: boolean;
  showDataTable?: boolean;
}

interface AdvancedChartBuilderProps {
  onAddChart: (chart: ChartData) => void;
  onClose: () => void;
}

export function AdvancedChartBuilder({ onAddChart, onClose }: AdvancedChartBuilderProps) {
  const [chartData, setChartData] = useState<ChartData>({
    chartType: "bar",
    title: "",
    labels: ["Q1", "Q2", "Q3", "Q4"],
    series: [{ name: "Series 1", values: [0, 0, 0, 0] }],
    showTrendline: false,
    showDataTable: false
  });

  const chartTypes: Array<{ type: ChartType; label: string; icon: any; description: string }> = [
    { type: "bar", label: "Bar Chart", icon: BarChart3, description: "Compare categories" },
    { type: "line", label: "Line Chart", icon: LineChart, description: "Show trends over time" },
    { type: "pie", label: "Pie Chart", icon: PieChart, description: "Show proportions" },
    { type: "area", label: "Area Chart", icon: TrendingUp, description: "Show volume over time" },
    { type: "scatter", label: "Scatter Plot", icon: TrendingUp, description: "Show correlation" },
    { type: "doughnut", label: "Doughnut Chart", icon: PieChart, description: "Modern pie chart" },
    { type: "waterfall", label: "Waterfall Chart", icon: BarChart3, description: "Show cumulative effect" },
    { type: "combo", label: "Combo Chart", icon: LineChart, description: "Combine bar + line" },
    { type: "funnel", label: "Funnel Chart", icon: TrendingUp, description: "Show conversion stages" }
  ];

  const handleAddSeries = () => {
    setChartData({
      ...chartData,
      series: [...chartData.series, { name: `Series ${chartData.series.length + 1}`, values: new Array(chartData.labels.length).fill(0) }]
    });
  };

  const handleRemoveSeries = (index: number) => {
    setChartData({
      ...chartData,
      series: chartData.series.filter((_, i) => i !== index)
    });
  };

  const handleUpdateSeriesName = (index: number, name: string) => {
    const newSeries = [...chartData.series];
    newSeries[index].name = name;
    setChartData({ ...chartData, series: newSeries });
  };

  const handleUpdateSeriesValue = (seriesIndex: number, valueIndex: number, value: number) => {
    const newSeries = [...chartData.series];
    newSeries[seriesIndex].values[valueIndex] = value;
    setChartData({ ...chartData, series: newSeries });
  };

  const handleUpdateLabel = (index: number, label: string) => {
    const newLabels = [...chartData.labels];
    newLabels[index] = label;
    setChartData({ ...chartData, labels: newLabels });
  };

  const handleAddDataPoint = () => {
    setChartData({
      ...chartData,
      labels: [...chartData.labels, `Label ${chartData.labels.length + 1}`],
      series: chartData.series.map(s => ({ ...s, values: [...s.values, 0] }))
    });
  };

  const handleRemoveDataPoint = (index: number) => {
    setChartData({
      ...chartData,
      labels: chartData.labels.filter((_, i) => i !== index),
      series: chartData.series.map(s => ({ ...s, values: s.values.filter((_, i) => i !== index) }))
    });
  };

  const handleSubmit = () => {
    onAddChart(chartData);
    onClose();
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-y-auto">
        <div className="sticky top-0 bg-white border-b border-[var(--neutral-7)] p-6 flex items-center justify-between">
          <div>
            <h2 className="text-2xl font-bold text-[var(--neutral-1)]">Advanced Chart Builder</h2>
            <p className="text-sm text-[var(--neutral-3)]">Create professional data visualizations</p>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-[var(--neutral-8)] rounded-lg transition-colors"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        <div className="p-6 space-y-6">
          {/* Chart Type Selection */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
              Chart Type
            </label>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
              {chartTypes.map((type) => {
                const Icon = type.icon;
                return (
                  <button
                    key={type.type}
                    onClick={() => setChartData({ ...chartData, chartType: type.type })}
                    className={`p-4 rounded-lg border-2 transition-all text-left ${
                      chartData.chartType === type.type
                        ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                        : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                    }`}
                  >
                    <Icon className={`w-5 h-5 mb-2 ${chartData.chartType === type.type ? "text-[var(--color-primary)]" : "text-[var(--neutral-3)]"}`} />
                    <div className="font-semibold text-sm text-[var(--neutral-1)]">{type.label}</div>
                    <div className="text-xs text-[var(--neutral-4)] mt-1">{type.description}</div>
                  </button>
                );
              })}
            </div>
          </div>

          {/* Chart Title */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
              Chart Title
            </label>
            <input
              type="text"
              value={chartData.title}
              onChange={(e) => setChartData({ ...chartData, title: e.target.value })}
              placeholder="e.g., Quarterly Revenue Growth"
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none"
            />
          </div>

          {/* Data Labels */}
          <div>
            <div className="flex items-center justify-between mb-2">
              <label className="text-sm font-semibold text-[var(--neutral-2)]">
                Data Labels
              </label>
              <button
                onClick={handleAddDataPoint}
                className="text-sm text-[var(--color-primary)] hover:underline flex items-center gap-1"
              >
                <Plus className="w-4 h-4" />
                Add Data Point
              </button>
            </div>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
              {chartData.labels.map((label, index) => (
                <div key={index} className="flex gap-1">
                  <input
                    type="text"
                    value={label}
                    onChange={(e) => handleUpdateLabel(index, e.target.value)}
                    className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none text-sm"
                  />
                  {chartData.labels.length > 2 && (
                    <button
                      onClick={() => handleRemoveDataPoint(index)}
                      className="p-2 hover:bg-red-50 text-red-500 rounded-lg"
                    >
                      <X className="w-4 h-4" />
                    </button>
                  )}
                </div>
              ))}
            </div>
          </div>

          {/* Data Series */}
          <div>
            <div className="flex items-center justify-between mb-2">
              <label className="text-sm font-semibold text-[var(--neutral-2)]">
                Data Series
              </label>
              <button
                onClick={handleAddSeries}
                className="text-sm text-[var(--color-primary)] hover:underline flex items-center gap-1"
              >
                <Plus className="w-4 h-4" />
                Add Series
              </button>
            </div>
            <div className="space-y-4">
              {chartData.series.map((series, seriesIndex) => (
                <div key={seriesIndex} className="p-4 bg-[var(--neutral-8)] rounded-lg space-y-3">
                  <div className="flex items-center gap-2">
                    <input
                      type="text"
                      value={series.name}
                      onChange={(e) => handleUpdateSeriesName(seriesIndex, e.target.value)}
                      className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none font-semibold"
                      placeholder="Series name"
                    />
                    {chartData.series.length > 1 && (
                      <button
                        onClick={() => handleRemoveSeries(seriesIndex)}
                        className="p-2 hover:bg-red-50 text-red-500 rounded-lg"
                      >
                        <X className="w-4 h-4" />
                      </button>
                    )}
                  </div>
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
                    {series.values.map((value, valueIndex) => (
                      <input
                        key={valueIndex}
                        type="number"
                        value={value}
                        onChange={(e) => handleUpdateSeriesValue(seriesIndex, valueIndex, parseFloat(e.target.value) || 0)}
                        className="px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none text-sm"
                        placeholder="0"
                      />
                    ))}
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Options */}
          <div className="space-y-3 p-4 bg-[var(--neutral-8)] rounded-lg">
            <label className="flex items-center gap-3 cursor-pointer">
              <input
                type="checkbox"
                checked={chartData.showTrendline}
                onChange={(e) => setChartData({ ...chartData, showTrendline: e.target.checked })}
                className="w-5 h-5 rounded border-[var(--neutral-6)] text-[var(--color-primary)]"
              />
              <span className="text-sm font-medium text-[var(--neutral-2)]">Show Trendline</span>
            </label>
            <label className="flex items-center gap-3 cursor-pointer">
              <input
                type="checkbox"
                checked={chartData.showDataTable}
                onChange={(e) => setChartData({ ...chartData, showDataTable: e.target.checked })}
                className="w-5 h-5 rounded border-[var(--neutral-6)] text-[var(--color-primary)]"
              />
              <span className="text-sm font-medium text-[var(--neutral-2)]">Show Data Table</span>
            </label>
          </div>

          {/* Actions */}
          <div className="flex gap-3 pt-4">
            <button
              onClick={onClose}
              className="flex-1 px-6 py-3 border border-[var(--neutral-7)] text-[var(--neutral-2)] font-semibold rounded-xl hover:bg-[var(--neutral-8)] transition-all"
            >
              Cancel
            </button>
            <button
              onClick={handleSubmit}
              disabled={!chartData.title.trim()}
              className="flex-1 px-6 py-3 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transition-all disabled:opacity-50"
            >
              Add Chart to Slide
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/AnimationConfigurator.tsx
=================================================================================
import { useState } from "react";
import { Zap, Play, Settings } from "lucide-react";

type EntranceAnimation = "fade" | "wipe" | "fly-in" | "zoom" | "appear" | "split";
type SlideTransition = "fade" | "push" | "wipe" | "split" | "reveal" | "cover" | "dissolve";

interface AnimationConfig {
  slideTransition?: {
    type: SlideTransition;
    duration: number;
  };
  entranceAnimations?: Array<{
    elementId: string;
    type: EntranceAnimation;
    duration: number;
    delay: number;
  }>;
  usePreset?: "minimal" | "professional" | "dynamic" | "none";
}

interface AnimationConfiguratorProps {
  currentConfig?: AnimationConfig;
  onApplyConfig: (config: AnimationConfig) => void;
}

export function AnimationConfigurator({ currentConfig, onApplyConfig }: AnimationConfiguratorProps) {
  const [config, setConfig] = useState<AnimationConfig>(currentConfig || {
    usePreset: "professional"
  });

  const [showAdvanced, setShowAdvanced] = useState(false);

  const presets: Array<{ id: AnimationConfig["usePreset"]; label: string; description: string }> = [
    { id: "none", label: "No Animations", description: "Static slides, no transitions" },
    { id: "minimal", label: "Minimal", description: "Subtle fade effects only" },
    { id: "professional", label: "Professional", description: "Balanced, polished animations" },
    { id: "dynamic", label: "Dynamic", description: "Bold, attention-grabbing effects" }
  ];

  const transitions: Array<{ type: SlideTransition; label: string; description: string }> = [
    { type: "fade", label: "Fade", description: "Smooth crossfade" },
    { type: "push", label: "Push", description: "Slide pushes in" },
    { type: "wipe", label: "Wipe", description: "Wipe across" },
    { type: "split", label: "Split", description: "Split from center" },
    { type: "reveal", label: "Reveal", description: "Reveal underneath" },
    { type: "cover", label: "Cover", description: "Cover previous" },
    { type: "dissolve", label: "Dissolve", description: "Pixelated dissolve" }
  ];

  const entranceTypes: Array<{ type: EntranceAnimation; label: string }> = [
    { type: "fade", label: "Fade In" },
    { type: "wipe", label: "Wipe In" },
    { type: "fly-in", label: "Fly In" },
    { type: "zoom", label: "Zoom In" },
    { type: "appear", label: "Appear" },
    { type: "split", label: "Split" }
  ];

  const handleApply = () => {
    onApplyConfig(config);
  };

  return (
    <div className="bg-white rounded-2xl shadow-xl border border-[var(--neutral-7)] p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className="p-3 bg-gradient-to-br from-yellow-500 to-orange-500 rounded-xl">
            <Zap className="w-6 h-6 text-white" />
          </div>
          <div>
            <h2 className="text-2xl font-bold text-[var(--neutral-1)]">Animations & Transitions</h2>
            <p className="text-sm text-[var(--neutral-3)]">Add motion to your slides</p>
          </div>
        </div>
        <button
          onClick={() => setShowAdvanced(!showAdvanced)}
          className="px-4 py-2 border border-[var(--neutral-7)] text-[var(--neutral-2)] rounded-lg hover:bg-[var(--neutral-8)] transition-all flex items-center gap-2"
        >
          <Settings className="w-4 h-4" />
          {showAdvanced ? "Simple" : "Advanced"}
        </button>
      </div>

      {/* Preset Selection */}
      <div>
        <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
          Animation Preset
        </label>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
          {presets.map((preset) => (
            <button
              key={preset.id}
              onClick={() => setConfig({ ...config, usePreset: preset.id })}
              className={`p-4 rounded-lg border-2 transition-all text-left ${
                config.usePreset === preset.id
                  ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                  : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
              }`}
            >
              <div className="font-semibold text-sm text-[var(--neutral-1)] mb-1">
                {preset.label}
              </div>
              <div className="text-xs text-[var(--neutral-4)]">
                {preset.description}
              </div>
            </button>
          ))}
        </div>
      </div>

      {/* Advanced Settings */}
      {showAdvanced && (
        <>
          {/* Slide Transition */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
              Slide Transition
            </label>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
              {transitions.map((transition) => (
                <button
                  key={transition.type}
                  onClick={() => setConfig({
                    ...config,
                    slideTransition: {
                      type: transition.type,
                      duration: config.slideTransition?.duration || 600
                    }
                  })}
                  className={`p-3 rounded-lg border-2 transition-all text-left ${
                    config.slideTransition?.type === transition.type
                      ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                      : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                  }`}
                >
                  <div className="font-semibold text-xs text-[var(--neutral-1)]">
                    {transition.label}
                  </div>
                  <div className="text-xs text-[var(--neutral-4)] mt-1">
                    {transition.description}
                  </div>
                </button>
              ))}
            </div>

            {/* Duration Slider */}
            {config.slideTransition && (
              <div className="mt-4">
                <label className="block text-xs text-[var(--neutral-3)] mb-2">
                  Transition Duration: {config.slideTransition.duration}ms
                </label>
                <input
                  type="range"
                  min="200"
                  max="1500"
                  step="100"
                  value={config.slideTransition.duration}
                  onChange={(e) => setConfig({
                    ...config,
                    slideTransition: {
                      ...config.slideTransition!,
                      duration: parseInt(e.target.value)
                    }
                  })}
                  className="w-full"
                />
              </div>
            )}
          </div>

          {/* Entrance Animations */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
              Default Entrance Animation
            </label>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
              {entranceTypes.map((entrance) => (
                <button
                  key={entrance.type}
                  onClick={() => {
                    // This would set default entrance for all elements
                    setConfig({
                      ...config,
                      entranceAnimations: [{
                        elementId: "default",
                        type: entrance.type,
                        duration: 600,
                        delay: 0
                      }]
                    });
                  }}
                  className={`p-3 rounded-lg border-2 transition-all ${
                    config.entranceAnimations?.[0]?.type === entrance.type
                      ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                      : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                  }`}
                >
                  <div className="font-semibold text-xs text-[var(--neutral-1)] text-center">
                    {entrance.label}
                  </div>
                </button>
              ))}
            </div>
          </div>
        </>
      )}

      {/* Preview */}
      <div className="p-4 bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg border border-blue-200">
        <div className="flex items-center gap-3 mb-3">
          <Play className="w-5 h-5 text-blue-600" />
          <span className="font-semibold text-sm text-blue-900">Animation Preview</span>
        </div>
        <div className="space-y-2 text-sm text-blue-800">
          <p>
            <strong>Preset:</strong> {presets.find(p => p.id === config.usePreset)?.label || "None"}
          </p>
          {config.slideTransition && (
            <p>
              <strong>Transition:</strong> {transitions.find(t => t.type === config.slideTransition?.type)?.label} 
              ({config.slideTransition.duration}ms)
            </p>
          )}
          {config.entranceAnimations && config.entranceAnimations.length > 0 && (
            <p>
              <strong>Entrance:</strong> {entranceTypes.find(e => e.type === config.entranceAnimations?.[0]?.type)?.label}
            </p>
          )}
        </div>
      </div>

      {/* Best Practices */}
      <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
        <p className="text-sm text-yellow-900">
          <strong>üí° Best Practice:</strong> Use animations sparingly. Too many animations can distract from your message.
          The "Professional" preset is recommended for most presentations.
        </p>
      </div>

      {/* Apply Button */}
      <button
        onClick={handleApply}
        className="w-full px-6 py-3 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transition-all flex items-center justify-center gap-2"
      >
        <Zap className="w-5 h-5" />
        Apply Animation Settings
      </button>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/BrandKitManager.tsx
=================================================================================
import { useState } from "react";
import { Palette, Type, Image, Save, Plus, Trash2, Check } from "lucide-react";

interface BrandKit {
  id: string;
  name: string;
  colors: {
    primary: string;
    accent: string;
    neutral: string[];
  };
  fonts: {
    heading: string;
    body: string;
  };
  logo?: {
    url: string;
    position: "top-left" | "top-right" | "bottom-left" | "bottom-right";
  };
}

interface BrandKitManagerProps {
  currentKit?: BrandKit;
  savedKits: BrandKit[];
  onSaveKit: (kit: BrandKit) => void;
  onApplyKit: (kit: BrandKit) => void;
  onDeleteKit: (id: string) => void;
}

export function BrandKitManager({ currentKit, savedKits, onSaveKit, onApplyKit, onDeleteKit }: BrandKitManagerProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [editingKit, setEditingKit] = useState<BrandKit>(
    currentKit || {
      id: "",
      name: "",
      colors: {
        primary: "#3B82F6",
        accent: "#10B981",
        neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#F8FAFC"]
      },
      fonts: {
        heading: "Inter",
        body: "Inter"
      }
    }
  );

  const popularFonts = [
    "Inter", "Roboto", "Open Sans", "Lato", "Montserrat", "Poppins",
    "Raleway", "Nunito", "Playfair Display", "Merriweather"
  ];

  const handleSave = () => {
    const kitToSave = {
      ...editingKit,
      id: editingKit.id || `kit-${Date.now()}`
    };
    onSaveKit(kitToSave);
    setIsEditing(false);
  };

  return (
    <div className="bg-white rounded-2xl shadow-xl border border-[var(--neutral-7)] p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className="p-3 bg-gradient-to-br from-purple-500 to-pink-500 rounded-xl">
            <Palette className="w-6 h-6 text-white" />
          </div>
          <div>
            <h2 className="text-2xl font-bold text-[var(--neutral-1)]">Brand Kit</h2>
            <p className="text-sm text-[var(--neutral-3)]">Maintain consistent branding</p>
          </div>
        </div>
        <button
          onClick={() => setIsEditing(!isEditing)}
          className="px-4 py-2 bg-[var(--color-primary)] text-white rounded-lg hover:bg-[var(--color-primary)]/90 transition-all flex items-center gap-2"
        >
          <Plus className="w-4 h-4" />
          {isEditing ? "Cancel" : "Create New"}
        </button>
      </div>

      {isEditing ? (
        <div className="space-y-6 p-6 bg-[var(--neutral-8)] rounded-xl">
          {/* Kit Name */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
              Brand Kit Name
            </label>
            <input
              type="text"
              value={editingKit.name}
              onChange={(e) => setEditingKit({ ...editingKit, name: e.target.value })}
              placeholder="e.g., Company Brand 2024"
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none bg-white"
            />
          </div>

          {/* Colors */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
              Brand Colors
            </label>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-xs text-[var(--neutral-3)] mb-2">Primary Color</label>
                <div className="flex gap-2">
                  <input
                    type="color"
                    value={editingKit.colors.primary}
                    onChange={(e) => setEditingKit({
                      ...editingKit,
                      colors: { ...editingKit.colors, primary: e.target.value }
                    })}
                    className="w-16 h-12 rounded-lg border border-[var(--neutral-7)] cursor-pointer"
                  />
                  <input
                    type="text"
                    value={editingKit.colors.primary}
                    onChange={(e) => setEditingKit({
                      ...editingKit,
                      colors: { ...editingKit.colors, primary: e.target.value }
                    })}
                    className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none bg-white font-mono text-sm"
                  />
                </div>
              </div>

              <div>
                <label className="block text-xs text-[var(--neutral-3)] mb-2">Accent Color</label>
                <div className="flex gap-2">
                  <input
                    type="color"
                    value={editingKit.colors.accent}
                    onChange={(e) => setEditingKit({
                      ...editingKit,
                      colors: { ...editingKit.colors, accent: e.target.value }
                    })}
                    className="w-16 h-12 rounded-lg border border-[var(--neutral-7)] cursor-pointer"
                  />
                  <input
                    type="text"
                    value={editingKit.colors.accent}
                    onChange={(e) => setEditingKit({
                      ...editingKit,
                      colors: { ...editingKit.colors, accent: e.target.value }
                    })}
                    className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none bg-white font-mono text-sm"
                  />
                </div>
              </div>
            </div>
          </div>

          {/* Fonts */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3 flex items-center gap-2">
              <Type className="w-4 h-4" />
              Typography
            </label>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-xs text-[var(--neutral-3)] mb-2">Heading Font</label>
                <select
                  value={editingKit.fonts.heading}
                  onChange={(e) => setEditingKit({
                    ...editingKit,
                    fonts: { ...editingKit.fonts, heading: e.target.value }
                  })}
                  className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none bg-white"
                >
                  {popularFonts.map((font) => (
                    <option key={font} value={font}>{font}</option>
                  ))}
                </select>
              </div>

              <div>
                <label className="block text-xs text-[var(--neutral-3)] mb-2">Body Font</label>
                <select
                  value={editingKit.fonts.body}
                  onChange={(e) => setEditingKit({
                    ...editingKit,
                    fonts: { ...editingKit.fonts, body: e.target.value }
                  })}
                  className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] outline-none bg-white"
                >
                  {popularFonts.map((font) => (
                    <option key={font} value={font}>{font}</option>
                  ))}
                </select>
              </div>
            </div>
          </div>

          {/* Logo */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3 flex items-center gap-2">
              <Image className="w-4 h-4" />
              Logo (Optional)
            </label>
            <input
              type="url"
              value={editingKit.logo?.url || ""}
              onChange={(e) => setEditingKit({
                ...editingKit,
                logo: { url: e.target.value, position: editingKit.logo?.position || "top-right" }
              })}
              placeholder="https://example.com/logo.png"
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none bg-white"
            />
            {editingKit.logo?.url && (
              <div className="mt-3">
                <label className="block text-xs text-[var(--neutral-3)] mb-2">Logo Position</label>
                <div className="grid grid-cols-2 gap-2">
                  {["top-left", "top-right", "bottom-left", "bottom-right"].map((pos) => (
                    <button
                      key={pos}
                      onClick={() => setEditingKit({
                        ...editingKit,
                        logo: { ...editingKit.logo!, position: pos as any }
                      })}
                      className={`px-3 py-2 rounded-lg border-2 transition-all text-sm ${
                        editingKit.logo?.position === pos
                          ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                          : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                      }`}
                    >
                      {pos.split("-").map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(" ")}
                    </button>
                  ))}
                </div>
              </div>
            )}
          </div>

          {/* Save Button */}
          <button
            onClick={handleSave}
            disabled={!editingKit.name.trim()}
            className="w-full px-6 py-3 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transition-all disabled:opacity-50 flex items-center justify-center gap-2"
          >
            <Save className="w-5 h-5" />
            Save Brand Kit
          </button>
        </div>
      ) : (
        <div className="space-y-4">
          {savedKits.length === 0 ? (
            <div className="text-center py-12">
              <Palette className="w-16 h-16 text-[var(--neutral-5)] mx-auto mb-4" />
              <p className="text-[var(--neutral-3)]">No brand kits saved yet</p>
              <p className="text-sm text-[var(--neutral-4)] mt-2">Create your first brand kit to maintain consistent branding</p>
            </div>
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {savedKits.map((kit) => (
                <div
                  key={kit.id}
                  className="p-4 border-2 border-[var(--neutral-7)] rounded-xl hover:border-[var(--color-primary)] transition-all group"
                >
                  <div className="flex items-start justify-between mb-3">
                    <h3 className="font-semibold text-[var(--neutral-1)]">{kit.name}</h3>
                    <button
                      onClick={() => onDeleteKit(kit.id)}
                      className="p-1 hover:bg-red-50 text-red-500 rounded opacity-0 group-hover:opacity-100 transition-opacity"
                    >
                      <Trash2 className="w-4 h-4" />
                    </button>
                  </div>

                  <div className="space-y-3">
                    <div className="flex gap-2">
                      <div
                        className="w-8 h-8 rounded-lg border border-[var(--neutral-7)]"
                        style={{ backgroundColor: kit.colors.primary }}
                        title="Primary"
                      />
                      <div
                        className="w-8 h-8 rounded-lg border border-[var(--neutral-7)]"
                        style={{ backgroundColor: kit.colors.accent }}
                        title="Accent"
                      />
                    </div>

                    <div className="text-xs text-[var(--neutral-3)]">
                      <p><strong>Heading:</strong> {kit.fonts.heading}</p>
                      <p><strong>Body:</strong> {kit.fonts.body}</p>
                    </div>

                    <button
                      onClick={() => onApplyKit(kit)}
                      className="w-full px-4 py-2 bg-[var(--color-primary)] text-white rounded-lg hover:bg-[var(--color-primary)]/90 transition-all flex items-center justify-center gap-2 text-sm font-semibold"
                    >
                      <Check className="w-4 h-4" />
                      Apply to Slides
                    </button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/Chart.tsx
=================================================================================
import {
  BarChart,
  Bar,
  LineChart,
  Line,
  PieChart,
  Pie,
  Cell,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from "recharts";

interface ChartProps {
  kind: "bar" | "line" | "pie";
  labels: string[];
  series: { name: string; values: number[] }[];
  title?: string;
  valueFormat?: "number" | "percent" | "currency" | "auto";
  colors?: string[];
}

const DEFAULT_COLORS = [
  "#6366F1", // Primary
  "#EC4899", // Accent
  "#10B981", // Success
  "#F59E0B", // Warning
  "#8B5CF6", // Purple
  "#06B6D4", // Cyan
  "#F97316", // Orange
  "#14B8A6", // Teal
];

export function Chart({ kind, labels, series, title, valueFormat = "auto", colors }: ChartProps) {
  const COLORS = colors || DEFAULT_COLORS;
  // Transform data for recharts format
  const data = labels.map((label, index) => {
    const point: any = { name: label };
    series.forEach((s) => {
      point[s.name] = s.values[index] || 0;
    });
    return point;
  });

  const formatValue = (value: number) => {
    switch (valueFormat) {
      case "percent":
        return `${value}%`;
      case "currency":
        return `$${value.toLocaleString()}`;
      case "number":
        return value.toLocaleString();
      default:
        return value;
    }
  };

  if (kind === "pie") {
    // For pie charts, use the first series
    const pieData = labels.map((label, index) => ({
      name: label,
      value: series[0]?.values[index] || 0,
    }));

    return (
      <div className="w-full h-full">
        {title && (
          <h4 className="text-sm font-semibold text-[var(--neutral-2)] mb-2 text-center">
            {title}
          </h4>
        )}
        <ResponsiveContainer width="100%" height="100%">
          <PieChart>
            <Pie
              data={pieData}
              cx="50%"
              cy="50%"
              labelLine={false}
              label={({ name, percent }: any) => `${name}: ${((percent as number) * 100).toFixed(0)}%`}
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
            >
              {pieData.map((_entry: any, index: number) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip formatter={(value: any) => formatValue(value)} />
            <Legend />
          </PieChart>
        </ResponsiveContainer>
      </div>
    );
  }

  if (kind === "line") {
    return (
      <div className="w-full h-full">
        {title && (
          <h4 className="text-sm font-semibold text-[var(--neutral-2)] mb-2">
            {title}
          </h4>
        )}
        <ResponsiveContainer width="100%" height="100%">
          <LineChart data={data}>
            <CartesianGrid strokeDasharray="3 3" stroke="var(--neutral-7)" />
            <XAxis 
              dataKey="name" 
              stroke="var(--neutral-4)"
              style={{ fontSize: '12px' }}
            />
            <YAxis
              stroke="var(--neutral-4)"
              style={{ fontSize: '12px' }}
              tickFormatter={(value: any) => String(formatValue(value))}
            />
            <Tooltip 
              formatter={(value: any) => formatValue(value)}
              contentStyle={{
                backgroundColor: 'var(--bg-primary)',
                border: '1px solid var(--neutral-7)',
                borderRadius: '8px',
              }}
            />
            <Legend />
            {series.map((s, index) => (
              <Line
                key={s.name}
                type="monotone"
                dataKey={s.name}
                stroke={COLORS[index % COLORS.length]}
                strokeWidth={2}
                dot={{ r: 4 }}
                activeDot={{ r: 6 }}
              />
            ))}
          </LineChart>
        </ResponsiveContainer>
      </div>
    );
  }

  // Bar chart (default)
  return (
    <div className="w-full h-full">
      {title && (
        <h4 className="text-sm font-semibold text-[var(--neutral-2)] mb-2">
          {title}
        </h4>
      )}
      <ResponsiveContainer width="100%" height="100%">
        <BarChart data={data}>
          <CartesianGrid strokeDasharray="3 3" stroke="var(--neutral-7)" />
          <XAxis 
            dataKey="name" 
            stroke="var(--neutral-4)"
            style={{ fontSize: '12px' }}
          />
          <YAxis
            stroke="var(--neutral-4)"
            style={{ fontSize: '12px' }}
            tickFormatter={(value: any) => String(formatValue(value))}
          />
          <Tooltip 
            formatter={(value: any) => formatValue(value)}
            contentStyle={{
              backgroundColor: 'var(--bg-primary)',
              border: '1px solid var(--neutral-7)',
              borderRadius: '8px',
            }}
          />
          <Legend />
          {series.map((s, index) => (
            <Bar
              key={s.name}
              dataKey={s.name}
              fill={COLORS[index % COLORS.length]}
              radius={[4, 4, 0, 0]}
            />
          ))}
        </BarChart>
      </ResponsiveContainer>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/CustomizationPanel.tsx
=================================================================================
import { useState } from "react";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

interface CustomizationPanelProps {
  spec: SlideSpecV1;
  onUpdate: (spec: SlideSpecV1) => void;
}

export function CustomizationPanel({ spec, onUpdate }: CustomizationPanelProps) {
  const [activeTab, setActiveTab] = useState<"colors" | "typography" | "layout">("colors");

  const updatePrimaryColor = (color: string) => {
    onUpdate({
      ...spec,
      styleTokens: {
        ...spec.styleTokens,
        palette: {
          ...spec.styleTokens.palette,
          primary: color,
        },
      },
    });
  };

  const updateAccentColor = (color: string) => {
    onUpdate({
      ...spec,
      styleTokens: {
        ...spec.styleTokens,
        palette: {
          ...spec.styleTokens.palette,
          accent: color,
        },
      },
    });
  };

  const updateFontSize = (step: keyof SlideSpecV1["styleTokens"]["typography"]["sizes"], size: number) => {
    onUpdate({
      ...spec,
      styleTokens: {
        ...spec.styleTokens,
        typography: {
          ...spec.styleTokens.typography,
          sizes: {
            ...spec.styleTokens.typography.sizes,
            [step]: size,
          },
        },
      },
    });
  };

  const updateTitleAlignment = (align: "left" | "center" | "right") => {
    onUpdate({
      ...spec,
      components: {
        ...spec.components,
        title: {
          ...spec.components?.title,
          align,
        },
      },
    });
  };

  const tabs = [
    { id: "colors" as const, label: "Colors", icon: "üé®" },
    { id: "typography" as const, label: "Typography", icon: "üìù" },
    { id: "layout" as const, label: "Layout", icon: "üìê" },
  ];

  const presetColors = [
    { name: "Blue", primary: "#1E40AF", accent: "#10B981" },
    { name: "Purple", primary: "#8B5CF6", accent: "#EC4899" },
    { name: "Green", primary: "#059669", accent: "#F59E0B" },
    { name: "Orange", primary: "#EA580C", accent: "#EAB308" },
    { name: "Pink", primary: "#EC4899", accent: "#F59E0B" },
    { name: "Teal", primary: "#0D9488", accent: "#06B6D4" },
  ];

  return (
    <div className="glass rounded-[var(--radius-2xl)] p-6 space-y-6">
      <div className="flex items-center justify-between">
        <h3 className="text-xl font-bold text-[var(--neutral-1)]">Customize Slide</h3>
        <button
          onClick={() => {/* Reset to defaults */}}
          className="text-sm text-[var(--color-primary)] hover:underline"
        >
          Reset
        </button>
      </div>

      {/* Tabs */}
      <div className="flex gap-2 border-b border-[var(--neutral-7)]">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id)}
            className={`flex items-center gap-2 px-4 py-2 border-b-2 transition-all ${
              activeTab === tab.id
                ? "border-[var(--color-primary)] text-[var(--color-primary)]"
                : "border-transparent text-[var(--neutral-4)] hover:text-[var(--neutral-2)]"
            }`}
          >
            <span>{tab.icon}</span>
            <span className="text-sm font-medium">{tab.label}</span>
          </button>
        ))}
      </div>

      {/* Colors Tab */}
      {activeTab === "colors" && (
        <div className="space-y-6">
          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Primary Color
            </label>
            <div className="flex items-center gap-3">
              <input
                type="color"
                value={spec.styleTokens.palette.primary}
                onChange={(e) => updatePrimaryColor(e.target.value)}
                className="w-12 h-12 rounded-lg border-2 border-[var(--neutral-7)] cursor-pointer"
              />
              <input
                type="text"
                value={spec.styleTokens.palette.primary}
                onChange={(e) => updatePrimaryColor(e.target.value)}
                className="flex-1 px-4 py-2 rounded-lg border-2 border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:outline-none font-mono text-sm"
              />
            </div>
          </div>

          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Accent Color
            </label>
            <div className="flex items-center gap-3">
              <input
                type="color"
                value={spec.styleTokens.palette.accent}
                onChange={(e) => updateAccentColor(e.target.value)}
                className="w-12 h-12 rounded-lg border-2 border-[var(--neutral-7)] cursor-pointer"
              />
              <input
                type="text"
                value={spec.styleTokens.palette.accent}
                onChange={(e) => updateAccentColor(e.target.value)}
                className="flex-1 px-4 py-2 rounded-lg border-2 border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:outline-none font-mono text-sm"
              />
            </div>
          </div>

          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Color Presets
            </label>
            <div className="grid grid-cols-3 gap-2">
              {presetColors.map((preset) => (
                <button
                  key={preset.name}
                  onClick={() => {
                    updatePrimaryColor(preset.primary);
                    updateAccentColor(preset.accent);
                  }}
                  className="p-3 rounded-lg border-2 border-[var(--neutral-7)] hover:border-[var(--color-primary)] transition-all"
                >
                  <div className="flex gap-1 mb-2">
                    <div
                      className="flex-1 h-8 rounded"
                      style={{ backgroundColor: preset.primary }}
                    />
                    <div
                      className="flex-1 h-8 rounded"
                      style={{ backgroundColor: preset.accent }}
                    />
                  </div>
                  <p className="text-xs font-medium text-[var(--neutral-2)]">{preset.name}</p>
                </button>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Typography Tab */}
      {activeTab === "typography" && (
        <div className="space-y-6">
          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Title Size
            </label>
            <input
              type="range"
              min="24"
              max="48"
              value={spec.styleTokens.typography.sizes.step_3}
              onChange={(e) => updateFontSize("step_3", parseInt(e.target.value))}
              className="w-full"
            />
            <div className="text-sm text-[var(--neutral-4)]">
              {spec.styleTokens.typography.sizes.step_3}px
            </div>
          </div>

          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Body Text Size
            </label>
            <input
              type="range"
              min="12"
              max="24"
              value={spec.styleTokens.typography.sizes.step_0}
              onChange={(e) => updateFontSize("step_0", parseInt(e.target.value))}
              className="w-full"
            />
            <div className="text-sm text-[var(--neutral-4)]">
              {spec.styleTokens.typography.sizes.step_0}px
            </div>
          </div>
        </div>
      )}

      {/* Layout Tab */}
      {activeTab === "layout" && (
        <div className="space-y-6">
          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Title Alignment
            </label>
            <div className="flex gap-2">
              {(["left", "center", "right"] as const).map((align) => (
                <button
                  key={align}
                  onClick={() => updateTitleAlignment(align)}
                  className={`flex-1 px-4 py-2 rounded-lg border-2 transition-all ${
                    spec.components?.title?.align === align
                      ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5 text-[var(--color-primary)]"
                      : "border-[var(--neutral-7)] text-[var(--neutral-2)] hover:border-[var(--color-primary)]"
                  }`}
                >
                  <span className="text-sm font-medium capitalize">{align}</span>
                </button>
              ))}
            </div>
          </div>

          <div className="space-y-3">
            <label className="block text-sm font-semibold text-[var(--neutral-2)]">
              Spacing
            </label>
            <p className="text-sm text-[var(--neutral-4)]">
              Grid: {spec.layout.grid.rows} √ó {spec.layout.grid.cols}
            </p>
            <p className="text-sm text-[var(--neutral-4)]">
              Gutter: {spec.layout.grid.gutter}px
            </p>
          </div>
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/DesignPreview.tsx
=================================================================================
/**
 * Design Preview Component
 * Displays a preview of the current design system
 */

import React, { useMemo } from "react";
import type { SlideSpecV2 } from "@/types/SlideSpecV2";
import { LAYOUT_PATTERNS } from "@/lib/layoutPatterns";
import { validateDesignQuality, getQualityColor, getQualityInterpretation } from "@/lib/designQuality";

interface DesignPreviewProps {
  spec: SlideSpecV2;
}

export const DesignPreview: React.FC<DesignPreviewProps> = ({
  spec
}) => {
  const qualityScore = useMemo(() => validateDesignQuality(spec), [spec]);
  const pattern = LAYOUT_PATTERNS[spec.design.pattern];

  return (
    <div className="w-full space-y-6 p-6 bg-white rounded-lg shadow-lg">
      {/* Header */}
      <div className="border-b pb-4">
        <h2 className="text-2xl font-bold text-gray-900">Design Preview</h2>
        <p className="text-sm text-gray-600 mt-1">
          Professional slide design with quality metrics
        </p>
      </div>

      {/* Quality Score */}
      <div className="grid grid-cols-2 gap-4">
        <div className="p-4 rounded-lg border-2" style={{ borderColor: getQualityColor(qualityScore.overall) }}>
          <div className="text-sm font-semibold text-gray-600">Overall Quality</div>
          <div className="text-3xl font-bold mt-2" style={{ color: getQualityColor(qualityScore.overall) }}>
            {qualityScore.overall}/100
          </div>
          <div className="text-xs text-gray-500 mt-1">
            {getQualityInterpretation(qualityScore.overall)}
          </div>
        </div>

        <div className="space-y-2">
          <div className="flex justify-between items-center text-sm">
            <span className="text-gray-600">Contrast</span>
            <span className="font-semibold text-gray-900">{qualityScore.contrast}%</span>
          </div>
          <div className="flex justify-between items-center text-sm">
            <span className="text-gray-600">Hierarchy</span>
            <span className="font-semibold text-gray-900">{qualityScore.hierarchy}%</span>
          </div>
          <div className="flex justify-between items-center text-sm">
            <span className="text-gray-600">White Space</span>
            <span className="font-semibold text-gray-900">{qualityScore.whitespace}%</span>
          </div>
          <div className="flex justify-between items-center text-sm">
            <span className="text-gray-600">Accessibility</span>
            <span className="font-semibold text-gray-900">{qualityScore.accessibility}%</span>
          </div>
        </div>
      </div>

      {/* Design Pattern */}
      <div className="space-y-3">
        <h3 className="font-semibold text-gray-900">Design Pattern</h3>
        <div className="p-4 bg-gray-50 rounded-lg border border-gray-200">
          <div className="font-medium text-gray-900">{pattern?.name}</div>
          <p className="text-sm text-gray-600 mt-1">{pattern?.description}</p>
          <div className="mt-3 flex flex-wrap gap-2">
            {pattern?.bestFor.map((use, idx) => (
              <span key={idx} className="px-2 py-1 bg-blue-100 text-blue-700 text-xs rounded">
                {use}
              </span>
            ))}
          </div>
        </div>
      </div>

      {/* Color Palette */}
      <div className="space-y-3">
        <h3 className="font-semibold text-gray-900">Color Palette</h3>
        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-2">
            <div className="text-sm font-medium text-gray-600">Primary</div>
            <div
              className="w-full h-12 rounded-lg border-2 border-gray-200"
              style={{ backgroundColor: spec.styleTokens.palette.primary }}
            />
            <code className="text-xs text-gray-500">{spec.styleTokens.palette.primary}</code>
          </div>
          <div className="space-y-2">
            <div className="text-sm font-medium text-gray-600">Accent</div>
            <div
              className="w-full h-12 rounded-lg border-2 border-gray-200"
              style={{ backgroundColor: spec.styleTokens.palette.accent }}
            />
            <code className="text-xs text-gray-500">{spec.styleTokens.palette.accent}</code>
          </div>
        </div>

        {/* Neutral Colors */}
        <div className="text-sm font-medium text-gray-600 mt-4">Neutral Scale</div>
        <div className="grid grid-cols-7 gap-2">
          {spec.styleTokens.palette.neutral.map((color, idx) => (
            <div key={idx} className="space-y-1">
              <div
                className="w-full h-8 rounded border border-gray-300"
                style={{ backgroundColor: color }}
              />
              <code className="text-xs text-gray-500 block text-center">{idx}</code>
            </div>
          ))}
        </div>
      </div>

      {/* Typography */}
      <div className="space-y-3">
        <h3 className="font-semibold text-gray-900">Typography</h3>
        <div className="space-y-4">
          <div>
            <div className="text-sm font-medium text-gray-600 mb-2">Primary Font</div>
            <div className="text-2xl font-bold" style={{ fontFamily: spec.design.typography.fontPairing.primary }}>
              {spec.design.typography.fontPairing.primary}
            </div>
          </div>
          <div>
            <div className="text-sm font-medium text-gray-600 mb-2">Secondary Font</div>
            <div className="text-lg" style={{ fontFamily: spec.design.typography.fontPairing.secondary }}>
              {spec.design.typography.fontPairing.secondary}
            </div>
          </div>
        </div>
      </div>

      {/* Issues & Warnings */}
      {(qualityScore.issues.length > 0 || qualityScore.warnings.length > 0) && (
        <div className="space-y-3">
          <h3 className="font-semibold text-gray-900">Design Feedback</h3>
          {qualityScore.issues.length > 0 && (
            <div className="p-3 bg-red-50 border border-red-200 rounded-lg">
              <div className="text-sm font-semibold text-red-900 mb-2">Issues</div>
              <ul className="space-y-1">
                {qualityScore.issues.map((issue, idx) => (
                  <li key={idx} className="text-sm text-red-800">
                    ‚Ä¢ {issue}
                  </li>
                ))}
              </ul>
            </div>
          )}
          {qualityScore.warnings.length > 0 && (
            <div className="p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
              <div className="text-sm font-semibold text-yellow-900 mb-2">Warnings</div>
              <ul className="space-y-1">
                {qualityScore.warnings.map((warning, idx) => (
                  <li key={idx} className="text-sm text-yellow-800">
                    ‚Ä¢ {warning}
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default DesignPreview;



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/DesignSystemUI.tsx
=================================================================================
/**
 * Design System UI Component
 * Showcases all available design system options
 */

import React, { useState } from "react";
import { PROFESSIONAL_PALETTES, getPaletteNames } from "@/lib/colorPalettes";
import { TYPOGRAPHY_PAIRS, getTypographyPairNames } from "@/lib/typographyPairs";
import { LAYOUT_PATTERNS, getLayoutPatternNames } from "@/lib/layoutPatterns";

interface DesignSystemUIProps {
  onSelectPalette?: (paletteName: string) => void;
  onSelectTypography?: (typographyName: string) => void;
  onSelectPattern?: (patternName: string) => void;
}

export const DesignSystemUI: React.FC<DesignSystemUIProps> = ({
  onSelectPalette,
  onSelectTypography,
  onSelectPattern
}) => {
  const [activeTab, setActiveTab] = useState<"palettes" | "typography" | "patterns">("palettes");

  return (
    <div className="w-full bg-white rounded-lg shadow-lg overflow-hidden">
      {/* Tabs */}
      <div className="flex border-b">
        <button
          onClick={() => setActiveTab("palettes")}
          className={`flex-1 px-4 py-3 font-medium text-center transition-colors ${
            activeTab === "palettes"
              ? "bg-blue-50 text-blue-700 border-b-2 border-blue-700"
              : "text-gray-600 hover:text-gray-900"
          }`}
        >
          Color Palettes
        </button>
        <button
          onClick={() => setActiveTab("typography")}
          className={`flex-1 px-4 py-3 font-medium text-center transition-colors ${
            activeTab === "typography"
              ? "bg-blue-50 text-blue-700 border-b-2 border-blue-700"
              : "text-gray-600 hover:text-gray-900"
          }`}
        >
          Typography
        </button>
        <button
          onClick={() => setActiveTab("patterns")}
          className={`flex-1 px-4 py-3 font-medium text-center transition-colors ${
            activeTab === "patterns"
              ? "bg-blue-50 text-blue-700 border-b-2 border-blue-700"
              : "text-gray-600 hover:text-gray-900"
          }`}
        >
          Patterns
        </button>
      </div>

      {/* Content */}
      <div className="p-6">
        {/* Palettes Tab */}
        {activeTab === "palettes" && (
          <div className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {getPaletteNames().map(paletteName => {
                const palette = PROFESSIONAL_PALETTES[paletteName];
                return (
                  <div
                    key={paletteName}
                    onClick={() => onSelectPalette?.(paletteName)}
                    className="p-4 border-2 border-gray-200 rounded-lg hover:border-blue-500 cursor-pointer transition-colors"
                  >
                    <h3 className="font-semibold text-gray-900 mb-3">{palette.name}</h3>
                    <div className="space-y-2">
                      <div className="flex gap-2">
                        <div
                          className="flex-1 h-8 rounded border border-gray-300"
                          style={{ backgroundColor: palette.primary }}
                          title="Primary"
                        />
                        <div
                          className="flex-1 h-8 rounded border border-gray-300"
                          style={{ backgroundColor: palette.accent }}
                          title="Accent"
                        />
                      </div>
                      <div className="flex gap-1">
                        {palette.neutral.map((color, idx) => (
                          <div
                            key={idx}
                            className="flex-1 h-6 rounded border border-gray-300"
                            style={{ backgroundColor: color }}
                            title={`Neutral ${idx}`}
                          />
                        ))}
                      </div>
                    </div>
                    <p className="text-xs text-gray-600 mt-3">{palette.use}</p>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Typography Tab */}
        {activeTab === "typography" && (
          <div className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {getTypographyPairNames().map(typographyName => {
                const typography = TYPOGRAPHY_PAIRS[typographyName];
                return (
                  <div
                    key={typographyName}
                    onClick={() => onSelectTypography?.(typographyName)}
                    className="p-4 border-2 border-gray-200 rounded-lg hover:border-blue-500 cursor-pointer transition-colors"
                  >
                    <h3 className="font-semibold text-gray-900 mb-3">{typography.name}</h3>
                    <div className="space-y-3">
                      <div>
                        <div
                          className="text-2xl font-bold"
                          style={{ fontFamily: typography.primary }}
                        >
                          Primary Font
                        </div>
                        <code className="text-xs text-gray-500">{typography.primary}</code>
                      </div>
                      <div>
                        <div style={{ fontFamily: typography.secondary }}>
                          Secondary Font
                        </div>
                        <code className="text-xs text-gray-500">{typography.secondary}</code>
                      </div>
                    </div>
                    <p className="text-xs text-gray-600 mt-3">{typography.use}</p>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Patterns Tab */}
        {activeTab === "patterns" && (
          <div className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {getLayoutPatternNames().map(patternName => {
                const pattern = LAYOUT_PATTERNS[patternName];
                return (
                  <div
                    key={patternName}
                    onClick={() => onSelectPattern?.(patternName)}
                    className="p-4 border-2 border-gray-200 rounded-lg hover:border-blue-500 cursor-pointer transition-colors"
                  >
                    <h3 className="font-semibold text-gray-900 mb-3">{pattern.name}</h3>
                    <p className="text-sm text-gray-600 mb-3">{pattern.description}</p>
                    <div className="mb-3">
                      <div className="text-xs font-medium text-gray-600 mb-2">Best for:</div>
                      <div className="flex flex-wrap gap-1">
                        {pattern.bestFor.map((use, idx) => (
                          <span key={idx} className="px-2 py-1 bg-gray-100 text-gray-700 text-xs rounded">
                            {use}
                          </span>
                        ))}
                      </div>
                    </div>
                    <div className="text-xs text-gray-500">
                      White Space: {pattern.whitespacePercentage}%
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default DesignSystemUI;



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/ErrorBoundary.tsx
=================================================================================
import { Component } from "react";
import type { ReactNode } from "react";

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("ErrorBoundary caught an error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="min-h-screen flex items-center justify-center bg-[var(--bg-secondary)] p-4">
          <div className="max-w-md w-full bg-[var(--bg-primary)] rounded-[var(--radius-lg)] shadow-[var(--shadow-lg)] p-6 space-y-4">
            <div className="flex items-center gap-3">
              <svg className="w-8 h-8 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
              </svg>
              <h1 className="text-[var(--step-1)] font-bold text-[var(--neutral-0)]">
                Something went wrong
              </h1>
            </div>
            
            <p className="text-[var(--step--1)] text-[var(--neutral-3)]">
              We encountered an unexpected error. Please try refreshing the page.
            </p>

            {this.state.error && (
              <details className="text-[var(--step--2)] text-[var(--neutral-4)]">
                <summary className="cursor-pointer hover:text-[var(--neutral-2)]">
                  Error details
                </summary>
                <pre className="mt-2 p-2 bg-[var(--neutral-6)] rounded-[var(--radius-sm)] overflow-auto">
                  {this.state.error.toString()}
                </pre>
              </details>
            )}

            <button
              onClick={() => window.location.reload()}
              className="w-full px-4 py-2 bg-[var(--color-primary)] text-white rounded-[var(--radius-md)] font-medium hover:opacity-90 transition-opacity"
            >
              Refresh Page
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/HistoryPanel.tsx
=================================================================================
import { useState } from "react";
import { useSlideHistory } from "@/hooks/useSlideHistory";
import type { Presentation } from "@/types/Presentation";

interface HistoryPanelProps {
  onLoadPresentation: (presentation: Presentation) => void;
}

export function HistoryPanel({ onLoadPresentation }: HistoryPanelProps) {
  const { 
    history, 
    loading, 
    deletePresentation, 
    clearHistory, 
    searchPresentations 
  } = useSlideHistory();
  
  const [searchQuery, setSearchQuery] = useState("");
  const [showConfirmClear, setShowConfirmClear] = useState(false);

  const displayedHistory = searchQuery 
    ? searchPresentations(searchQuery) 
    : history;

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return "Just now";
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    return date.toLocaleDateString();
  };

  if (loading) {
    return (
      <div className="glass rounded-[var(--radius-2xl)] p-6 space-y-4">
        <div className="h-8 bg-[var(--neutral-8)] rounded animate-pulse" />
        <div className="space-y-2">
          {[1, 2, 3].map((i) => (
            <div key={i} className="h-20 bg-[var(--neutral-8)] rounded animate-pulse" />
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="glass rounded-[var(--radius-2xl)] p-6 space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-xl font-bold text-[var(--neutral-1)]">
          Recent Presentations
        </h3>
        {history.length > 0 && (
          <button
            onClick={() => setShowConfirmClear(true)}
            className="text-sm text-red-500 hover:underline"
          >
            Clear All
          </button>
        )}
      </div>

      {/* Search */}
      {history.length > 0 && (
        <div className="relative">
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="Search presentations..."
            className="w-full px-4 py-2 pl-10 rounded-lg border-2 border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:outline-none"
          />
          <svg 
            className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-[var(--neutral-4)]" 
            fill="none" 
            stroke="currentColor" 
            viewBox="0 0 24 24"
          >
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
        </div>
      )}

      {/* History List */}
      <div className="space-y-2 max-h-96 overflow-y-auto">
        {displayedHistory.length === 0 ? (
          <div className="text-center py-8 text-[var(--neutral-4)]">
            {searchQuery ? (
              <p>No presentations found matching "{searchQuery}"</p>
            ) : (
              <div className="space-y-2">
                <p>No saved presentations yet</p>
                <p className="text-xs">Generated presentations will appear here</p>
              </div>
            )}
          </div>
        ) : (
          displayedHistory.map((item) => (
            <div
              key={item.id}
              className="group p-4 rounded-lg border-2 border-[var(--neutral-7)] hover:border-[var(--color-primary)] transition-all bg-white"
            >
              <div className="flex items-start justify-between gap-4">
                <button
                  onClick={() => onLoadPresentation(item.presentation)}
                  className="flex-1 text-left"
                >
                  <h4 className="font-semibold text-[var(--neutral-1)] group-hover:text-[var(--color-primary)] mb-1">
                    {item.presentation.title}
                  </h4>
                  <div className="flex items-center gap-3 text-xs text-[var(--neutral-4)]">
                    <span>{item.presentation.slides.length} slide{item.presentation.slides.length !== 1 ? 's' : ''}</span>
                    <span>‚Ä¢</span>
                    <span>{formatDate(item.savedAt)}</span>
                  </div>
                </button>

                <button
                  onClick={() => {
                    if (confirm(`Delete "${item.presentation.title}"?`)) {
                      deletePresentation(item.id);
                    }
                  }}
                  className="p-2 rounded-lg hover:bg-red-50 text-red-500 opacity-0 group-hover:opacity-100 transition-opacity"
                  aria-label="Delete presentation"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                  </svg>
                </button>
              </div>
            </div>
          ))
        )}
      </div>

      {/* Confirm Clear Dialog */}
      {showConfirmClear && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl p-6 max-w-sm mx-4 space-y-4">
            <h4 className="text-lg font-bold text-[var(--neutral-1)]">
              Clear All History?
            </h4>
            <p className="text-sm text-[var(--neutral-3)]">
              This will permanently delete all {history.length} saved presentation{history.length !== 1 ? 's' : ''}. This action cannot be undone.
            </p>
            <div className="flex gap-3">
              <button
                onClick={() => setShowConfirmClear(false)}
                className="flex-1 px-4 py-2 rounded-lg border-2 border-[var(--neutral-7)] text-[var(--neutral-2)] hover:bg-[var(--neutral-8)] transition-all"
              >
                Cancel
              </button>
              <button
                onClick={() => {
                  clearHistory();
                  setShowConfirmClear(false);
                }}
                className="flex-1 px-4 py-2 rounded-lg bg-red-500 text-white hover:bg-red-600 transition-all"
              >
                Clear All
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/ImageIntegration.tsx
=================================================================================
import { useState } from "react";
import { Link, Search, Palette, X } from "lucide-react";

type ImageRole = "hero" | "logo" | "illustration" | "icon" | "background";
type ImageSourceType = "url" | "unsplash" | "placeholder";

interface ImageData {
  role: ImageRole;
  source: {
    type: ImageSourceType;
    url?: string;
    query?: string;
  };
  alt: string;
  fit?: "cover" | "contain" | "fill";
}

interface ImageIntegrationProps {
  onAddImage: (image: ImageData) => void;
  onClose: () => void;
}

export function ImageIntegration({ onAddImage, onClose }: ImageIntegrationProps) {
  const [imageData, setImageData] = useState<ImageData>({
    role: "hero",
    source: { type: "unsplash", query: "" },
    alt: "",
    fit: "cover"
  });

  const roles: Array<{ role: ImageRole; label: string; description: string; size: string }> = [
    { role: "hero", label: "Hero Image", description: "Large featured image", size: "60-70% of slide" },
    { role: "logo", label: "Logo", description: "Brand identity", size: "1x1 inch" },
    { role: "illustration", label: "Illustration", description: "Supporting visual", size: "30-40% of slide" },
    { role: "icon", label: "Icon", description: "Small decorative", size: "0.5x0.5 inch" },
    { role: "background", label: "Background", description: "Full slide background", size: "Full slide" }
  ];

  const sourceTypes: Array<{ type: ImageSourceType; label: string; icon: any; description: string }> = [
    { type: "unsplash", label: "Unsplash", icon: Search, description: "High-quality stock photos" },
    { type: "url", label: "URL", icon: Link, description: "Image from web URL" },
    { type: "placeholder", label: "Placeholder", icon: Palette, description: "Generated placeholder" }
  ];

  const suggestedQueries: Record<string, string[]> = {
    business: ["business professional office modern", "corporate team meeting", "business handshake"],
    tech: ["technology abstract digital blue", "coding programming laptop", "data visualization"],
    finance: ["finance growth chart business", "money investment banking", "stock market trading"],
    healthcare: ["healthcare medical professional", "hospital doctor nurse", "medical technology"],
    marketing: ["marketing creative design colorful", "social media advertising", "brand strategy"]
  };

  const handleSubmit = () => {
    onAddImage(imageData);
    onClose();
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-y-auto">
        <div className="sticky top-0 bg-white border-b border-[var(--neutral-7)] p-6 flex items-center justify-between">
          <div>
            <h2 className="text-2xl font-bold text-[var(--neutral-1)]">Add Image</h2>
            <p className="text-sm text-[var(--neutral-3)]">Enhance your slide with visuals</p>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-[var(--neutral-8)] rounded-lg transition-colors"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        <div className="p-6 space-y-6">
          {/* Image Role */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
              Image Role
            </label>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {roles.map((role) => (
                <button
                  key={role.role}
                  onClick={() => setImageData({ ...imageData, role: role.role })}
                  className={`p-4 rounded-lg border-2 transition-all text-left ${
                    imageData.role === role.role
                      ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                      : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                  }`}
                >
                  <div className="font-semibold text-sm text-[var(--neutral-1)]">{role.label}</div>
                  <div className="text-xs text-[var(--neutral-4)] mt-1">{role.description}</div>
                  <div className="text-xs text-[var(--color-primary)] mt-1 font-medium">{role.size}</div>
                </button>
              ))}
            </div>
          </div>

          {/* Source Type */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-3">
              Image Source
            </label>
            <div className="grid grid-cols-3 gap-3">
              {sourceTypes.map((source) => {
                const Icon = source.icon;
                return (
                  <button
                    key={source.type}
                    onClick={() => setImageData({ ...imageData, source: { type: source.type } })}
                    className={`p-4 rounded-lg border-2 transition-all ${
                      imageData.source.type === source.type
                        ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                        : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                    }`}
                  >
                    <Icon className={`w-5 h-5 mb-2 mx-auto ${imageData.source.type === source.type ? "text-[var(--color-primary)]" : "text-[var(--neutral-3)]"}`} />
                    <div className="font-semibold text-sm text-[var(--neutral-1)] text-center">{source.label}</div>
                    <div className="text-xs text-[var(--neutral-4)] mt-1 text-center">{source.description}</div>
                  </button>
                );
              })}
            </div>
          </div>

          {/* Source-specific inputs */}
          {imageData.source.type === "unsplash" && (
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
                Search Query
              </label>
              <input
                type="text"
                value={imageData.source.query || ""}
                onChange={(e) => setImageData({ ...imageData, source: { ...imageData.source, query: e.target.value } })}
                placeholder="e.g., business professional office modern"
                className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none"
              />
              
              {/* Suggested Queries */}
              <div className="mt-3">
                <p className="text-xs text-[var(--neutral-4)] mb-2">Suggested queries:</p>
                <div className="flex flex-wrap gap-2">
                  {Object.entries(suggestedQueries).map(([category, queries]) => (
                    <div key={category} className="space-y-1">
                      <p className="text-xs font-semibold text-[var(--neutral-3)] capitalize">{category}:</p>
                      {queries.map((query) => (
                        <button
                          key={query}
                          onClick={() => setImageData({ ...imageData, source: { type: "unsplash", query } })}
                          className="text-xs px-2 py-1 bg-[var(--neutral-8)] hover:bg-[var(--color-primary)]/10 text-[var(--neutral-2)] rounded mr-1"
                        >
                          {query}
                        </button>
                      ))}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          )}

          {imageData.source.type === "url" && (
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
                Image URL
              </label>
              <input
                type="url"
                value={imageData.source.url || ""}
                onChange={(e) => setImageData({ ...imageData, source: { ...imageData.source, url: e.target.value } })}
                placeholder="https://example.com/image.jpg"
                className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none"
              />
            </div>
          )}

          {imageData.source.type === "placeholder" && (
            <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
              <p className="text-sm text-blue-900">
                A placeholder image will be generated with your slide's color scheme.
              </p>
            </div>
          )}

          {/* Alt Text */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
              Alt Text (for accessibility)
            </label>
            <input
              type="text"
              value={imageData.alt}
              onChange={(e) => setImageData({ ...imageData, alt: e.target.value })}
              placeholder="Describe the image for screen readers"
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none"
            />
          </div>

          {/* Image Fit */}
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
              Image Fit
            </label>
            <div className="grid grid-cols-3 gap-3">
              {[
                { value: "cover", label: "Cover", description: "Fill area, crop if needed" },
                { value: "contain", label: "Contain", description: "Fit within area" },
                { value: "fill", label: "Fill", description: "Stretch to fill" }
              ].map((fit) => (
                <button
                  key={fit.value}
                  onClick={() => setImageData({ ...imageData, fit: fit.value as any })}
                  className={`p-3 rounded-lg border-2 transition-all ${
                    imageData.fit === fit.value
                      ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
                      : "border-[var(--neutral-7)] hover:border-[var(--color-primary)]/50"
                  }`}
                >
                  <div className="font-semibold text-sm text-[var(--neutral-1)]">{fit.label}</div>
                  <div className="text-xs text-[var(--neutral-4)] mt-1">{fit.description}</div>
                </button>
              ))}
            </div>
          </div>

          {/* Actions */}
          <div className="flex gap-3 pt-4">
            <button
              onClick={onClose}
              className="flex-1 px-6 py-3 border border-[var(--neutral-7)] text-[var(--neutral-2)] font-semibold rounded-xl hover:bg-[var(--neutral-8)] transition-all"
            >
              Cancel
            </button>
            <button
              onClick={handleSubmit}
              disabled={
                (imageData.source.type === "unsplash" && !imageData.source.query) ||
                (imageData.source.type === "url" && !imageData.source.url) ||
                !imageData.alt.trim()
              }
              className="flex-1 px-6 py-3 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transition-all disabled:opacity-50"
            >
              Add Image to Slide
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/ImageUpload.tsx
=================================================================================
import { useState, useRef, useCallback } from "react";
import { logger } from "@/lib/logger";

interface ImageUploadProps {
  onImageUpload: (imageData: string, file: File) => void;
  maxSizeMB?: number;
  acceptedFormats?: string[];
}

export function ImageUpload({ 
  onImageUpload, 
  maxSizeMB = 5,
  acceptedFormats = ["image/jpeg", "image/png", "image/gif", "image/webp"]
}: ImageUploadProps) {
  const [isDragging, setIsDragging] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [uploading, setUploading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const validateFile = (file: File): string | null => {
    // Check file type
    if (!acceptedFormats.includes(file.type)) {
      return `Invalid file type. Accepted formats: ${acceptedFormats.map(f => f.split('/')[1]).join(', ')}`;
    }

    // Check file size
    const sizeMB = file.size / (1024 * 1024);
    if (sizeMB > maxSizeMB) {
      return `File too large. Maximum size: ${maxSizeMB}MB`;
    }

    return null;
  };

  const processFile = useCallback(async (file: File) => {
    setError(null);
    setUploading(true);

    const validationError = validateFile(file);
    if (validationError) {
      setError(validationError);
      setUploading(false);
      return;
    }

    try {
      // Read file as data URL
      const reader = new FileReader();
      reader.onload = (e) => {
        const result = e.target?.result as string;
        if (result) {
          onImageUpload(result, file);
          logger.info("Image uploaded successfully", { 
            filename: file.name, 
            size: file.size,
            type: file.type 
          });
        }
        setUploading(false);
      };
      reader.onerror = () => {
        setError("Failed to read file");
        setUploading(false);
        logger.error("Failed to read image file", { filename: file.name });
      };
      reader.readAsDataURL(file);
    } catch (err) {
      setError("Failed to process image");
      setUploading(false);
      logger.error("Failed to process image", err);
    }
  }, [onImageUpload, maxSizeMB, acceptedFormats]);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);

    const files = Array.from(e.dataTransfer.files);
    if (files.length > 0) {
      processFile(files[0]);
    }
  };

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      processFile(files[0]);
    }
  };

  const handleClick = () => {
    fileInputRef.current?.click();
  };

  return (
    <div className="space-y-3">
      <div
        onClick={handleClick}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        className={`relative border-2 border-dashed rounded-xl p-8 text-center cursor-pointer transition-all ${
          isDragging
            ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5"
            : "border-[var(--neutral-7)] hover:border-[var(--color-primary)] hover:bg-[var(--neutral-9)]"
        } ${uploading ? "opacity-50 pointer-events-none" : ""}`}
      >
        <input
          ref={fileInputRef}
          type="file"
          accept={acceptedFormats.join(",")}
          onChange={handleFileSelect}
          className="hidden"
          aria-label="Upload image"
        />

        <div className="space-y-3">
          {uploading ? (
            <>
              <div className="w-12 h-12 mx-auto border-4 border-[var(--color-primary)] border-t-transparent rounded-full animate-spin" />
              <p className="text-sm text-[var(--neutral-3)]">Uploading...</p>
            </>
          ) : (
            <>
              <svg
                className="w-12 h-12 mx-auto text-[var(--neutral-4)]"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
                />
              </svg>
              <div>
                <p className="text-sm font-medium text-[var(--neutral-2)]">
                  Click to upload or drag and drop
                </p>
                <p className="text-xs text-[var(--neutral-4)] mt-1">
                  {acceptedFormats.map(f => f.split('/')[1].toUpperCase()).join(', ')} up to {maxSizeMB}MB
                </p>
              </div>
            </>
          )}
        </div>
      </div>

      {error && (
        <div className="flex items-center gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
          <svg className="w-5 h-5 text-red-500 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
            <path
              fillRule="evenodd"
              d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
              clipRule="evenodd"
            />
          </svg>
          <p className="text-sm text-red-700">{error}</p>
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/LoadingSkeleton.tsx
=================================================================================
export function LoadingSkeleton() {
  return (
    <div className="relative w-full aspect-video bg-[var(--neutral-6)] overflow-hidden rounded-[var(--radius-lg)] p-[var(--space-5)] animate-pulse">
      <div className="h-full w-full flex flex-col gap-4">
        {/* Header skeleton */}
        <div className="space-y-3">
          <div className="h-8 bg-[var(--neutral-5)] rounded w-3/4"></div>
          <div className="h-4 bg-[var(--neutral-5)] rounded w-1/2"></div>
        </div>
        
        {/* Body skeleton */}
        <div className="flex-1 grid grid-cols-3 gap-4">
          <div className="col-span-2 space-y-3">
            <div className="h-4 bg-[var(--neutral-5)] rounded w-full"></div>
            <div className="h-4 bg-[var(--neutral-5)] rounded w-5/6"></div>
            <div className="h-4 bg-[var(--neutral-5)] rounded w-4/5"></div>
            <div className="h-4 bg-[var(--neutral-5)] rounded w-full"></div>
            <div className="h-4 bg-[var(--neutral-5)] rounded w-3/4"></div>
          </div>
          <div className="col-span-1">
            <div className="h-32 bg-[var(--neutral-5)] rounded"></div>
          </div>
        </div>
      </div>
      
      {/* Loading text */}
      <div className="absolute inset-0 flex items-center justify-center bg-black/5">
        <div className="text-[var(--neutral-3)] text-lg font-medium">
          Generating your slide...
        </div>
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/PresentationGenerator.tsx
=================================================================================
import { useState } from "react";
import { Presentation, Users, Sparkles, FileText, CheckCircle2, Loader2 } from "lucide-react";

interface PresentationRequest {
  topic: string;
  audience: "executives" | "technical" | "sales" | "general" | "investors";
  tone: "formal" | "casual" | "persuasive" | "educational" | "inspirational";
  slideCount?: number;
  industry: "tech" | "finance" | "healthcare" | "marketing" | "corporate";
  includeAgenda: boolean;
  includeSummary: boolean;
}

interface PresentationGeneratorProps {
  onGenerate: (request: PresentationRequest) => Promise<void>;
  loading?: boolean;
}

export function PresentationGenerator({ onGenerate, loading = false }: PresentationGeneratorProps) {
  const [request, setRequest] = useState<PresentationRequest>({
    topic: "",
    audience: "general",
    tone: "formal",
    slideCount: 10,
    industry: "corporate",
    includeAgenda: true,
    includeSummary: true
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await onGenerate(request);
  };

  return (
    <div className="bg-white rounded-2xl shadow-xl border border-[var(--neutral-7)] p-8 space-y-6">
      <div className="flex items-center gap-3 mb-6">
        <div className="p-3 bg-gradient-to-br from-[var(--color-primary)] to-[var(--color-accent)] rounded-xl">
          <Presentation className="w-6 h-6 text-white" />
        </div>
        <div>
          <h2 className="text-2xl font-bold text-[var(--neutral-1)]">Generate Full Presentation</h2>
          <p className="text-sm text-[var(--neutral-3)]">AI-powered multi-slide generation</p>
        </div>
      </div>

      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Topic */}
        <div>
          <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
            Presentation Topic *
          </label>
          <input
            type="text"
            value={request.topic}
            onChange={(e) => setRequest({ ...request, topic: e.target.value })}
            placeholder="e.g., Q4 Product Launch Strategy"
            className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none transition-all"
            required
          />
        </div>

        {/* Audience & Tone */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2 flex items-center gap-2">
              <Users className="w-4 h-4" />
              Target Audience
            </label>
            <select
              value={request.audience}
              onChange={(e) => setRequest({ ...request, audience: e.target.value as any })}
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none transition-all"
            >
              <option value="executives">Executives</option>
              <option value="technical">Technical Team</option>
              <option value="sales">Sales Team</option>
              <option value="general">General Audience</option>
              <option value="investors">Investors</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2 flex items-center gap-2">
              <Sparkles className="w-4 h-4" />
              Tone
            </label>
            <select
              value={request.tone}
              onChange={(e) => setRequest({ ...request, tone: e.target.value as any })}
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none transition-all"
            >
              <option value="formal">Formal</option>
              <option value="casual">Casual</option>
              <option value="persuasive">Persuasive</option>
              <option value="educational">Educational</option>
              <option value="inspirational">Inspirational</option>
            </select>
          </div>
        </div>

        {/* Industry & Slide Count */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2">
              Industry
            </label>
            <select
              value={request.industry}
              onChange={(e) => setRequest({ ...request, industry: e.target.value as any })}
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none transition-all"
            >
              <option value="tech">Technology</option>
              <option value="finance">Finance</option>
              <option value="healthcare">Healthcare</option>
              <option value="marketing">Marketing</option>
              <option value="corporate">Corporate</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-semibold text-[var(--neutral-2)] mb-2 flex items-center gap-2">
              <FileText className="w-4 h-4" />
              Number of Slides
            </label>
            <input
              type="number"
              min="5"
              max="20"
              value={request.slideCount}
              onChange={(e) => setRequest({ ...request, slideCount: parseInt(e.target.value) })}
              className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 outline-none transition-all"
            />
          </div>
        </div>

        {/* Options */}
        <div className="space-y-3 p-4 bg-[var(--neutral-8)] rounded-lg">
          <label className="flex items-center gap-3 cursor-pointer group">
            <input
              type="checkbox"
              checked={request.includeAgenda}
              onChange={(e) => setRequest({ ...request, includeAgenda: e.target.checked })}
              className="w-5 h-5 rounded border-[var(--neutral-6)] text-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20"
            />
            <div className="flex items-center gap-2">
              <CheckCircle2 className="w-4 h-4 text-[var(--color-primary)]" />
              <span className="text-sm font-medium text-[var(--neutral-2)] group-hover:text-[var(--neutral-1)]">
                Include Agenda Slide
              </span>
            </div>
          </label>

          <label className="flex items-center gap-3 cursor-pointer group">
            <input
              type="checkbox"
              checked={request.includeSummary}
              onChange={(e) => setRequest({ ...request, includeSummary: e.target.checked })}
              className="w-5 h-5 rounded border-[var(--neutral-6)] text-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20"
            />
            <div className="flex items-center gap-2">
              <CheckCircle2 className="w-4 h-4 text-[var(--color-primary)]" />
              <span className="text-sm font-medium text-[var(--neutral-2)] group-hover:text-[var(--neutral-1)]">
                Include Summary Slide
              </span>
            </div>
          </label>
        </div>

        {/* Submit Button */}
        <button
          type="submit"
          disabled={loading || !request.topic.trim()}
          className="w-full px-6 py-4 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
        >
          {loading ? (
            <>
              <Loader2 className="w-5 h-5 animate-spin" />
              Generating Presentation...
            </>
          ) : (
            <>
              <Sparkles className="w-5 h-5" />
              Generate {request.slideCount} Slides
            </>
          )}
        </button>
      </form>

      {/* Info Box */}
      <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
        <p className="text-sm text-blue-900">
          <strong>üí° Pro Tip:</strong> The AI will analyze your topic and create a complete presentation
          with optimal slide structure, narrative flow, and professional design.
        </p>
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/ProgressIndicator.tsx
=================================================================================
import { useEffect, useState } from "react";

interface ProgressIndicatorProps {
  isLoading: boolean;
  estimatedDuration?: number; // in milliseconds
}

export function ProgressIndicator({ isLoading, estimatedDuration = 5000 }: ProgressIndicatorProps) {
  const [progress, setProgress] = useState(0);
  const [stage, setStage] = useState("Initializing...");

  useEffect(() => {
    if (!isLoading) {
      setProgress(0);
      setStage("Initializing...");
      return;
    }

    const stages = [
      { progress: 20, label: "Analyzing prompt...", duration: 500 },
      { progress: 40, label: "Generating content...", duration: 2000 },
      { progress: 70, label: "Designing layout...", duration: 1500 },
      { progress: 90, label: "Finalizing slide...", duration: 1000 },
    ];

    let currentStageIndex = 0;
    let currentProgress = 0;

    const updateProgress = () => {
      if (currentStageIndex >= stages.length) return;

      const stage = stages[currentStageIndex];
      setStage(stage.label);

      const increment = (stage.progress - currentProgress) / (stage.duration / 50);
      
      const interval = setInterval(() => {
        currentProgress += increment;
        if (currentProgress >= stage.progress) {
          currentProgress = stage.progress;
          clearInterval(interval);
          currentStageIndex++;
          if (currentStageIndex < stages.length) {
            setTimeout(updateProgress, 100);
          }
        }
        setProgress(Math.min(currentProgress, 95)); // Never reach 100% until actually done
      }, 50);

      return () => clearInterval(interval);
    };

    updateProgress();
  }, [isLoading, estimatedDuration]);

  if (!isLoading) return null;

  return (
    <div className="space-y-3 animate-fade-in">
      <div className="flex items-center justify-between text-sm">
        <span className="text-[var(--neutral-2)] font-medium">{stage}</span>
        <span className="text-[var(--neutral-3)] font-mono">{Math.round(progress)}%</span>
      </div>
      
      <div className="relative h-2 bg-[var(--neutral-8)] rounded-full overflow-hidden">
        <div
          className="absolute top-0 left-0 h-full bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-primary-light)] transition-all duration-300 ease-out"
          style={{ width: `${progress}%` }}
        >
          <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent animate-shimmer" />
        </div>
      </div>
      
      <div className="flex items-center gap-2 text-xs text-[var(--neutral-4)]">
        <svg className="w-4 h-4 animate-spin" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
        </svg>
        <span>This usually takes 3-5 seconds</span>
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideBuilder.tsx
=================================================================================
import { useState } from "react";
import { useToast } from "./Toast";
import { ChevronRight, Plus, X, Sparkles } from "lucide-react";

interface SlideBuilderProps {
  onSlideReady?: (prompt: string) => void;
  isGenerating?: boolean;
}

interface SlideData {
  title: string;
  subtitle: string;
  contentType: "bullets" | "metrics" | "narrative" | "mixed";
  bullets: string[];
  metrics: { label: string; value: string }[];
  narrative: string;
  designStyle: "professional" | "creative" | "minimal" | "bold";
  audience: string;
}

export function SlideBuilder({ onSlideReady, isGenerating = false }: SlideBuilderProps) {
  const [step, setStep] = useState<1 | 2 | 3 | 4>(1);
  const [data, setData] = useState<SlideData>({
    title: "",
    subtitle: "",
    contentType: "bullets",
    bullets: [""],
    metrics: [{ label: "", value: "" }],
    narrative: "",
    designStyle: "professional",
    audience: "",
  });
  const toast = useToast();

  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setData({ ...data, title: e.target.value });
  };

  const handleSubtitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setData({ ...data, subtitle: e.target.value });
  };

  const handleBulletChange = (index: number, value: string) => {
    const newBullets = [...data.bullets];
    newBullets[index] = value;
    setData({ ...data, bullets: newBullets });
  };

  const addBullet = () => {
    setData({ ...data, bullets: [...data.bullets, ""] });
  };

  const removeBullet = (index: number) => {
    setData({ ...data, bullets: data.bullets.filter((_, i) => i !== index) });
  };

  const handleMetricChange = (index: number, field: "label" | "value", value: string) => {
    const newMetrics = [...data.metrics];
    newMetrics[index][field] = value;
    setData({ ...data, metrics: newMetrics });
  };

  const addMetric = () => {
    setData({ ...data, metrics: [...data.metrics, { label: "", value: "" }] });
  };

  const removeMetric = (index: number) => {
    setData({ ...data, metrics: data.metrics.filter((_, i) => i !== index) });
  };

  const handleNarrativeChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setData({ ...data, narrative: e.target.value });
  };

  const generatePrompt = (): string => {
    const parts: string[] = [];
    
    parts.push(`Create a professional PowerPoint slide with the following specifications:`);
    parts.push(`\nTitle: "${data.title}"`);
    
    if (data.subtitle) {
      parts.push(`Subtitle: "${data.subtitle}"`);
    }

    if (data.contentType === "bullets" && data.bullets.some(b => b.trim())) {
      parts.push(`\nContent (bullet points):`);
      data.bullets.forEach(b => {
        if (b.trim()) parts.push(`- ${b}`);
      });
    }

    if (data.contentType === "metrics" && data.metrics.some(m => m.label && m.value)) {
      parts.push(`\nKey Metrics:`);
      data.metrics.forEach(m => {
        if (m.label && m.value) parts.push(`- ${m.label}: ${m.value}`);
      });
    }

    if (data.contentType === "narrative" && data.narrative.trim()) {
      parts.push(`\nContent: ${data.narrative}`);
    }

    if (data.contentType === "mixed") {
      if (data.bullets.some(b => b.trim())) {
        parts.push(`\nBullet Points:`);
        data.bullets.forEach(b => {
          if (b.trim()) parts.push(`- ${b}`);
        });
      }
      if (data.metrics.some(m => m.label && m.value)) {
        parts.push(`\nMetrics:`);
        data.metrics.forEach(m => {
          if (m.label && m.value) parts.push(`- ${m.label}: ${m.value}`);
        });
      }
    }

    if (data.audience) {
      parts.push(`\nTarget Audience: ${data.audience}`);
    }

    parts.push(`\nDesign Style: ${data.designStyle}`);
    parts.push(`\nMake it visually appealing and professional.`);

    return parts.join("\n");
  };

  const handleGenerate = () => {
    if (!data.title.trim()) {
      toast.warning("Please enter a slide title");
      return;
    }

    const prompt = generatePrompt();
    if (onSlideReady) {
      onSlideReady(prompt);
    }
  };

  const canProceed = (): boolean => {
    if (step === 1) return data.title.trim().length > 0;
    if (step === 2) return data.contentType !== "bullets" || data.bullets.some(b => b.trim());
    if (step === 3) return true;
    return true;
  };

  return (
    <div className="flex flex-col h-full bg-white rounded-[var(--radius-2xl)] shadow-lg border border-[var(--neutral-7)] overflow-hidden">
      {/* Header */}
      <div className="bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] px-6 py-4 text-white">
        <div className="flex items-center gap-2">
          <Sparkles size={20} />
          <h2 className="text-lg font-semibold">Slide Builder</h2>
        </div>
        <p className="text-sm opacity-90 mt-1">Step {step} of 4 - {["Title & Subtitle", "Content", "Audience & Style", "Review"][step - 1]}</p>
      </div>

      {/* Progress Bar */}
      <div className="h-1 bg-[var(--neutral-8)]">
        <div
          className="h-full bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] transition-all duration-300"
          style={{ width: `${(step / 4) * 100}%` }}
        />
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto p-6 space-y-6">
        {/* Step 1: Title & Subtitle */}
        {step === 1 && (
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-2">
                Slide Title
              </label>
              <input
                type="text"
                value={data.title}
                onChange={handleTitleChange}
                placeholder="e.g., Q3 Financial Results"
                className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all text-lg"
              />
            </div>
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-2">
                Subtitle (Optional)
              </label>
              <input
                type="text"
                value={data.subtitle}
                onChange={handleSubtitleChange}
                placeholder="e.g., Performance Overview"
                className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all"
              />
            </div>
          </div>
        )}

        {/* Step 2: Content */}
        {step === 2 && (
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-3">
                Content Type
              </label>
              <div className="grid grid-cols-2 gap-3">
                {(["bullets", "metrics", "narrative", "mixed"] as const).map((type) => (
                  <button
                    key={type}
                    onClick={() => setData({ ...data, contentType: type })}
                    className={`p-3 rounded-lg border-2 transition-all text-sm font-medium capitalize ${
                      data.contentType === type
                        ? "border-[var(--color-primary)] bg-[var(--color-primary)]/10 text-[var(--color-primary)]"
                        : "border-[var(--neutral-7)] text-[var(--neutral-2)] hover:border-[var(--color-primary)]"
                    }`}
                  >
                    {type}
                  </button>
                ))}
              </div>
            </div>

            {/* Bullets */}
            {(data.contentType === "bullets" || data.contentType === "mixed") && (
              <div>
                <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-2">
                  Bullet Points
                </label>
                <div className="space-y-2">
                  {data.bullets.map((bullet, idx) => (
                    <div key={idx} className="flex gap-2">
                      <input
                        type="text"
                        value={bullet}
                        onChange={(e) => handleBulletChange(idx, e.target.value)}
                        placeholder={`Point ${idx + 1}`}
                        className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all text-sm"
                      />
                      {data.bullets.length > 1 && (
                        <button
                          onClick={() => removeBullet(idx)}
                          className="p-2 text-[var(--neutral-3)] hover:text-red-500 transition-colors"
                        >
                          <X size={18} />
                        </button>
                      )}
                    </div>
                  ))}
                  <button
                    onClick={addBullet}
                    className="flex items-center gap-2 text-sm text-[var(--color-primary)] hover:text-[var(--color-primary-dark)] font-medium mt-2"
                  >
                    <Plus size={16} />
                    Add Bullet
                  </button>
                </div>
              </div>
            )}

            {/* Metrics */}
            {(data.contentType === "metrics" || data.contentType === "mixed") && (
              <div>
                <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-2">
                  Key Metrics
                </label>
                <div className="space-y-2">
                  {data.metrics.map((metric, idx) => (
                    <div key={idx} className="flex gap-2">
                      <input
                        type="text"
                        value={metric.label}
                        onChange={(e) => handleMetricChange(idx, "label", e.target.value)}
                        placeholder="Label"
                        className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all text-sm"
                      />
                      <input
                        type="text"
                        value={metric.value}
                        onChange={(e) => handleMetricChange(idx, "value", e.target.value)}
                        placeholder="Value"
                        className="flex-1 px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all text-sm"
                      />
                      {data.metrics.length > 1 && (
                        <button
                          onClick={() => removeMetric(idx)}
                          className="p-2 text-[var(--neutral-3)] hover:text-red-500 transition-colors"
                        >
                          <X size={18} />
                        </button>
                      )}
                    </div>
                  ))}
                  <button
                    onClick={addMetric}
                    className="flex items-center gap-2 text-sm text-[var(--color-primary)] hover:text-[var(--color-primary-dark)] font-medium mt-2"
                  >
                    <Plus size={16} />
                    Add Metric
                  </button>
                </div>
              </div>
            )}

            {/* Narrative */}
            {(data.contentType === "narrative" || data.contentType === "mixed") && (
              <div>
                <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-2">
                  Content
                </label>
                <textarea
                  value={data.narrative}
                  onChange={handleNarrativeChange}
                  placeholder="Describe your slide content..."
                  className="w-full px-3 py-2 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all text-sm resize-none"
                  rows={4}
                />
              </div>
            )}
          </div>
        )}

        {/* Step 3: Audience & Style */}
        {step === 3 && (
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-2">
                Target Audience
              </label>
              <input
                type="text"
                value={data.audience}
                onChange={(e) => setData({ ...data, audience: e.target.value })}
                placeholder="e.g., Executive team, Investors, Clients"
                className="w-full px-4 py-3 rounded-lg border border-[var(--neutral-7)] focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/10 outline-none transition-all"
              />
            </div>
            <div>
              <label className="block text-sm font-semibold text-[var(--neutral-1)] mb-3">
                Design Style
              </label>
              <div className="grid grid-cols-2 gap-3">
                {(["professional", "creative", "minimal", "bold"] as const).map((style) => (
                  <button
                    key={style}
                    onClick={() => setData({ ...data, designStyle: style })}
                    className={`p-3 rounded-lg border-2 transition-all text-sm font-medium capitalize ${
                      data.designStyle === style
                        ? "border-[var(--color-primary)] bg-[var(--color-primary)]/10 text-[var(--color-primary)]"
                        : "border-[var(--neutral-7)] text-[var(--neutral-2)] hover:border-[var(--color-primary)]"
                    }`}
                  >
                    {style}
                  </button>
                ))}
              </div>
            </div>
          </div>
        )}

        {/* Step 4: Review */}
        {step === 4 && (
          <div className="space-y-4">
            <div className="bg-[var(--neutral-9)] rounded-lg p-4 space-y-3">
              <div>
                <p className="text-xs font-semibold text-[var(--neutral-3)] uppercase">Title</p>
                <p className="text-lg font-bold text-[var(--neutral-1)]">{data.title}</p>
              </div>
              {data.subtitle && (
                <div>
                  <p className="text-xs font-semibold text-[var(--neutral-3)] uppercase">Subtitle</p>
                  <p className="text-[var(--neutral-2)]">{data.subtitle}</p>
                </div>
              )}
              <div>
                <p className="text-xs font-semibold text-[var(--neutral-3)] uppercase">Content Type</p>
                <p className="text-[var(--neutral-2)] capitalize">{data.contentType}</p>
              </div>
              <div>
                <p className="text-xs font-semibold text-[var(--neutral-3)] uppercase">Design Style</p>
                <p className="text-[var(--neutral-2)] capitalize">{data.designStyle}</p>
              </div>
              {data.audience && (
                <div>
                  <p className="text-xs font-semibold text-[var(--neutral-3)] uppercase">Audience</p>
                  <p className="text-[var(--neutral-2)]">{data.audience}</p>
                </div>
              )}
            </div>
          </div>
        )}
      </div>

      {/* Footer */}
      <div className="border-t border-[var(--neutral-7)] p-4 bg-[var(--neutral-9)] flex gap-3">
        {step > 1 && (
          <button
            onClick={() => setStep((step - 1) as any)}
            className="px-4 py-2 rounded-lg border border-[var(--neutral-7)] text-[var(--neutral-1)] hover:bg-[var(--neutral-8)] transition-colors font-medium"
          >
            Back
          </button>
        )}
        {step < 4 ? (
          <button
            onClick={() => setStep((step + 1) as any)}
            disabled={!canProceed() || isGenerating}
            className="flex-1 px-4 py-2 bg-[var(--color-primary)] text-white rounded-lg font-medium hover:bg-[var(--color-primary-dark)] disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center justify-center gap-2"
          >
            Next
            <ChevronRight size={18} />
          </button>
        ) : (
          <button
            onClick={handleGenerate}
            disabled={isGenerating}
            className="flex-1 px-4 py-2 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white rounded-lg font-medium hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed transition-all flex items-center justify-center gap-2"
          >
            <Sparkles size={18} />
            {isGenerating ? "Creating..." : "Create Slide"}
          </button>
        )}
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideCanvas.tsx
=================================================================================
import { useEffect, useState, useMemo } from "react";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";
import type { SlideSpecV2 } from "@/types/SlideSpecV2";
import { Chart } from "./Chart";
import { logDiagnostics, validateLayoutCalculations } from "@/utils/slideDebugger";

type SlideSpec = SlideSpecV1 | SlideSpecV2;

export function SlideCanvas({ spec }: { spec: SlideSpec }) {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    // Log diagnostics when spec changes
    console.log("üé® SlideCanvas spec:", spec);
    console.log("üìã Content:", spec.content);
    console.log("üìê Layout:", spec.layout);
    logDiagnostics(spec as SlideSpecV1);
    validateLayoutCalculations(spec as SlideSpecV1);

    // Trigger animation when spec changes
    setIsVisible(false);
    const timer = setTimeout(() => setIsVisible(true), 50);
    return () => clearTimeout(timer);
  }, [spec]);

  // Get design tokens from spec (handle both V1 and V2)
  const designTokens = useMemo(() => {
    const v2Spec = spec as SlideSpecV2;
    const v1Spec = spec as SlideSpecV1;

    // Extract palette and typography from styleTokens
    const palette = v1Spec.styleTokens?.palette || {
      primary: "#6366F1",
      accent: "#EC4899",
      neutral: ["#0F172A", "#1E293B", "#334155", "#475569", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC"]
    };

    const typography = v1Spec.styleTokens?.typography || {
      fonts: { sans: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif" },
      sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 32 },
      weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
      lineHeights: { compact: 1.2, standard: 1.5 }
    };

    return {
      palette,
      typography,
      pattern: v2Spec.design?.pattern || "split",
      whitespace: v2Spec.design?.whitespace || { strategy: "balanced", breathingRoom: 30 },
    };
  }, [spec]);

  // Create inline styles for design tokens with gradient background
  const slideStyle: React.CSSProperties = designTokens ? {
    background: getGradientBackground(designTokens),
    color: designTokens.palette.neutral[0],
  } : {
    background: 'linear-gradient(135deg, #F8FAFC 0%, #F1F5F9 50%, #F8FAFC 100%)',
  };

  // Responsive 16:9 surface - with proper aspect ratio and sizing
  return (
    <div
      className={`relative w-full overflow-hidden rounded-[var(--radius-lg)] transition-all duration-500 shadow-lg ${
        isVisible ? 'opacity-100 scale-100' : 'opacity-0 scale-95'
      }`}
      style={{
        aspectRatio: '16 / 9',
        ...slideStyle,
      }}
    >
      <div
        style={{
          width: '100%',
          height: '100%',
          padding: 'var(--space-5)',
          boxSizing: 'border-box',
          display: 'flex',
          flexDirection: 'column',
        }}
      >
        {renderRegions(spec, designTokens)}
      </div>
    </div>
  );
}

function renderRegions(spec: SlideSpec, designTokens: any) {
  const { rows, cols, gutter, margin } = spec.layout.grid;

  // Convert pixel values to percentages for responsive layout
  const gridStyle: React.CSSProperties = {
    display: "grid",
    gridTemplateRows: `repeat(${rows}, minmax(0,1fr))`,
    gridTemplateColumns: `repeat(${cols}, minmax(0,1fr))`,
    gap: `${gutter}px`,
    padding: `${margin.t}px ${margin.r}px ${margin.b}px ${margin.l}px`,
    height: "100%",
    width: "100%",
    boxSizing: "border-box",
  };

  const regionToStyle = (r: any): React.CSSProperties => ({
    gridRow: `${r.rowStart} / span ${r.rowSpan}`,
    gridColumn: `${r.colStart} / span ${r.colSpan}`,
    display: "flex",
    flexDirection: "column",
    gap: "var(--space-3)",
    minHeight: 0,
    minWidth: 0,
    overflow: "hidden",
    justifyContent: "flex-start",
    alignItems: "stretch",
  });

  return (
    <div style={gridStyle}>
      {spec.layout.regions.map((r, i) => (
        <div key={i} style={regionToStyle(r)}>
          {spec.layout.anchors
            .filter(a => a.region === r.name)
            .sort((a, b) => a.order - b.order)
            .map(a => <ElementByRef key={a.refId} spec={spec} refId={a.refId} designTokens={designTokens} />)}
        </div>
      ))}
    </div>
  );
}

function ElementByRef({ spec, refId, designTokens }: { spec: SlideSpec; refId: string; designTokens: any }) {
  const c = spec.content;

  // Get typography config from design tokens
  const getTitleStyle = (): React.CSSProperties => {
    const sizes = designTokens?.typography?.sizes || { step_3: 32 };
    const weights = designTokens?.typography?.weights || { bold: 700 };
    const lineHeights = designTokens?.typography?.lineHeights || { compact: 1.2 };

    return {
      fontSize: `${sizes.step_3 || 32}px`,
      fontWeight: weights.bold || 700,
      lineHeight: lineHeights.compact || 1.2,
      color: designTokens?.palette?.primary || '#6366F1',
      margin: 0,
      padding: 0,
    };
  };

  const getSubtitleStyle = (): React.CSSProperties => {
    const sizes = designTokens?.typography?.sizes || { step_2: 24 };
    const weights = designTokens?.typography?.weights || { semibold: 600 };
    const lineHeights = designTokens?.typography?.lineHeights || { standard: 1.5 };

    return {
      fontSize: `${sizes.step_2 || 24}px`,
      fontWeight: weights.semibold || 600,
      lineHeight: lineHeights.standard || 1.5,
      color: designTokens?.palette?.neutral?.[2] || '#334155',
      margin: 0,
      padding: 0,
    };
  };

  const getBodyStyle = (): React.CSSProperties => {
    const sizes = designTokens?.typography?.sizes || { step_0: 16 };
    const weights = designTokens?.typography?.weights || { regular: 400 };
    const lineHeights = designTokens?.typography?.lineHeights || { standard: 1.5 };

    return {
      fontSize: `${sizes.step_0 || 16}px`,
      fontWeight: weights.regular || 400,
      lineHeight: lineHeights.standard || 1.5,
      color: designTokens?.palette?.neutral?.[0] || '#0F172A',
      margin: 0,
      padding: 0,
    };
  };

  if (c.title?.id === refId) {
    return (
      <h2 style={getTitleStyle()}>
        {c.title.text}
      </h2>
    );
  }

  if (c.subtitle?.id === refId) {
    return (
      <p style={getSubtitleStyle()}>
        {c.subtitle.text}
      </p>
    );
  }

  const bl = c.bullets?.find(x => x.id === refId);
  if (bl) {
    return (
      <ul style={{ ...getBodyStyle(), listStyle: 'none', margin: 0, padding: 0 }}>
        {bl.items.map((it, i) => (
          <li
            key={i}
            style={{
              marginLeft: `${(it.level - 1) * 24}px`,
              marginBottom: '8px',
              display: 'flex',
              alignItems: 'flex-start',
              gap: '12px',
            }}
          >
            <span
              style={{
                display: 'inline-block',
                width: '6px',
                height: '6px',
                borderRadius: '50%',
                backgroundColor: designTokens?.palette?.primary || '#6366F1',
                marginTop: '8px',
                flexShrink: 0,
              }}
            />
            <span>{it.text}</span>
          </li>
        ))}
      </ul>
    );
  }

  const co = c.callouts?.find(x => x.id === refId);
  if (co) {
    const bgColor = co.variant === "warning" ? "#FEF3C7" :
                    co.variant === "danger"  ? "#FEE2E2" :
                    co.variant === "success" ? "#D1FAE5" : "#F3F4F6";
    const borderColor = designTokens?.palette?.accent || "#EC4899";
    return (
      <div
        style={{
          padding: '12px 16px',
          borderRadius: '8px',
          border: `2px solid ${borderColor}`,
          backgroundColor: bgColor,
          color: designTokens?.palette?.neutral[0] || '#0F172A',
          fontSize: '14px',
          lineHeight: 1.5,
        }}
      >
        {co.title && <b>{co.title} ‚Äî </b>}{co.text}
      </div>
    );
  }

  if (c.dataViz?.id === refId) {
    return (
      <div style={{ width: '100%', height: '100%', minHeight: '200px' }}>
        <Chart
          labels={c.dataViz.labels}
          series={c.dataViz.series}
          kind={c.dataViz.kind}
          title={c.dataViz.title}
          valueFormat={c.dataViz.valueFormat}
          colors={designTokens?.palette ? [designTokens.palette.primary, designTokens.palette.accent] : undefined}
        />
      </div>
    );
  }

  const ph = c.imagePlaceholders?.find(x => x.id === refId);
  if (ph) {
    return (
      <div
        role="img"
        aria-label={ph.alt}
        style={{
          width: '100%',
          height: '100%',
          borderRadius: '8px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: designTokens?.palette?.neutral[5] || '#94A3B8',
          color: designTokens?.palette?.neutral[2] || '#334155',
          fontSize: '14px',
          textAlign: 'center',
          padding: '16px',
          boxSizing: 'border-box',
        }}
      >
        <span>{ph.alt}</span>
      </div>
    );
  }

  return null;
}

/**
 * Generate gradient background based on design pattern
 */
function getGradientBackground(designTokens: any): string {
  const pattern = designTokens.pattern || 'split';
  const primary = designTokens.palette.primary || '#6366F1';
  const accent = designTokens.palette.accent || '#EC4899';
  const neutralLight = designTokens.palette.neutral[6] || '#F8FAFC';
  const neutralMid = designTokens.palette.neutral[4] || '#94A3B8';

  switch (pattern) {
    case 'hero':
      // Dramatic top-to-bottom gradient
      return `linear-gradient(180deg, ${neutralLight} 0%, ${primary}08 50%, ${accent}05 100%)`;

    case 'minimal':
      // Very subtle vignette effect
      return `radial-gradient(ellipse at center, ${neutralLight} 0%, ${neutralMid}05 100%)`;

    case 'data-focused':
      // Left-to-right gradient
      return `linear-gradient(90deg, ${neutralLight} 0%, ${accent}06 100%)`;

    case 'split':
      // Diagonal gradient
      return `linear-gradient(135deg, ${neutralLight} 0%, ${primary}05 50%, ${neutralLight} 100%)`;

    case 'asymmetric':
      // Dynamic angular gradient
      return `linear-gradient(120deg, ${neutralLight} 0%, ${accent}08 60%, ${primary}05 100%)`;

    case 'grid':
      // Subtle radial gradient
      return `radial-gradient(circle at 50% 50%, ${neutralLight} 0%, ${neutralMid}04 100%)`;

    default:
      // Default subtle gradient
      return `linear-gradient(135deg, ${neutralLight} 0%, ${neutralMid}03 50%, ${neutralLight} 100%)`;
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideChat.tsx
=================================================================================
import { useState, useRef, useEffect } from "react";
import { useToast } from "./Toast";
import { Send, Loader } from "lucide-react";

interface Message {
  id: string;
  role: "user" | "assistant";
  content: string;
  timestamp: number;
}

interface ChatProps {
  onSlideReady?: (prompt: string) => void;
  isGenerating?: boolean;
}

export function SlideChat({ onSlideReady, isGenerating = false }: ChatProps) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const toast = useToast();

  // Focus input on mount
  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const generateFollowUp = async (userMessage: string, conversationHistory: Message[]) => {
    try {
      const response = await fetch(
        "https://generateslidespec-3wgb3rbjta-uc.a.run.app",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            prompt: `You are a helpful assistant gathering information to create a professional PowerPoint slide.

User message: "${userMessage}"

Previous conversation:
${conversationHistory.map((m) => `${m.role === "user" ? "User" : "Assistant"}: ${m.content}`).join("\n")}

TASK: Based on the conversation, determine what information we still need and ask ONE specific follow-up question.

INFORMATION NEEDED (in order):
1. Title/Topic - What is the slide about?
2. Main Content - What are the key points or bullet points?
3. Additional Details - Any specific data, metrics, or context?
4. Design Preference - Any style preferences (professional, creative, minimal, etc.)?

RESPONSE FORMAT:
- If we have title, content, and enough context: Respond with "READY_TO_CREATE: [comprehensive slide prompt]"
- Otherwise: Ask ONE specific, natural follow-up question to gather missing information

EXAMPLES OF GOOD QUESTIONS:
- "What are the 3-5 main points you want to highlight?"
- "Do you have any specific numbers or metrics to include?"
- "What's the audience for this slide?"
- "Would you prefer a professional or creative design style?"
- "Any specific color scheme or branding guidelines?"

Keep responses concise, friendly, and natural. Never say "I need more information" - always ask a specific question.`,
          }),
        }
      );

      if (!response.ok) throw new Error("Failed to generate response");
      const data = await response.json();

      let assistantMessage = data.slideSpec?.content?.title || "What are the key points or main content you'd like on this slide?";

      // Check if we have enough info
      if (assistantMessage.includes("READY_TO_CREATE:")) {
        const slidePrompt = assistantMessage.replace("READY_TO_CREATE:", "").trim();
        return { message: "Perfect! I have all the information I need. Creating your slide now...", isReady: true, slidePrompt };
      }

      return { message: assistantMessage, isReady: false };
    } catch (error) {
      console.error("Error generating response:", error);
      return { message: "What are the key points or main content you'd like on this slide?", isReady: false };
    }
  };

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!input.trim() || loading || isGenerating) return;

    const userMessage = input.trim();
    setInput("");
    setLoading(true);

    // Add user message
    const newUserMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: userMessage,
      timestamp: Date.now(),
    };
    setMessages((prev) => [...prev, newUserMessage]);

    // For first message, just generate the slide directly
    if (messages.length === 0) {
      try {
        if (onSlideReady) {
          onSlideReady(userMessage);
        }
        const assistantMessage: Message = {
          id: (Date.now() + 1).toString(),
          role: "assistant",
          content: "Perfect! I'm creating your slide now...",
          timestamp: Date.now(),
        };
        setMessages((prev) => [...prev, assistantMessage]);
      } catch (error) {
        toast.error("Failed to generate slide");
        console.error(error);
      } finally {
        setLoading(false);
      }
      return;
    }

    // For subsequent messages, use the conversational flow
    try {
      const { message, isReady, slidePrompt } = await generateFollowUp(userMessage, [...messages, newUserMessage]);

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: message,
        timestamp: Date.now(),
      };
      setMessages((prev) => [...prev, assistantMessage]);

      if (isReady && slidePrompt && onSlideReady) {
        setTimeout(() => {
          onSlideReady(slidePrompt);
        }, 500);
      }
    } catch (error) {
      toast.error("Failed to process message");
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex flex-col w-full">
      {/* Messages Container - Only show if there are messages */}
      {messages.length > 0 && (
        <div className="mb-6 space-y-4 max-h-96 overflow-y-auto px-2">
          {messages.map((msg) => (
            <div
              key={msg.id}
              className={`flex ${msg.role === "user" ? "justify-end" : "justify-start"} animate-fade-in`}
            >
              <div
                className={`max-w-2xl px-5 py-3 rounded-2xl ${
                  msg.role === "user"
                    ? "bg-[var(--color-primary)] text-white rounded-br-sm shadow-md"
                    : "bg-white text-[var(--neutral-1)] rounded-bl-sm border border-[var(--neutral-7)] shadow-sm"
                }`}
              >
                <p className="text-sm leading-relaxed">{msg.content}</p>
              </div>
            </div>
          ))}
          {loading && (
            <div className="flex justify-start animate-fade-in">
              <div className="bg-white text-[var(--neutral-1)] px-5 py-3 rounded-2xl rounded-bl-sm border border-[var(--neutral-7)] shadow-sm">
                <div className="flex gap-2">
                  <div className="w-2 h-2 bg-[var(--neutral-4)] rounded-full animate-bounce" />
                  <div className="w-2 h-2 bg-[var(--neutral-4)] rounded-full animate-bounce" style={{ animationDelay: "0.1s" }} />
                  <div className="w-2 h-2 bg-[var(--neutral-4)] rounded-full animate-bounce" style={{ animationDelay: "0.2s" }} />
                </div>
              </div>
            </div>
          )}
          <div ref={messagesEndRef} />
        </div>
      )}

      {/* ChatGPT-Style Input Area */}
      <div className="w-full">
        <form onSubmit={handleSendMessage} className="relative">
          <div className="relative glass rounded-[var(--radius-2xl)] shadow-xl border border-[var(--neutral-7)] overflow-hidden transition-all hover:shadow-2xl focus-within:shadow-2xl focus-within:border-[var(--color-primary)]">
            <input
              ref={inputRef}
              type="text"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              placeholder={messages.length === 0 ? "Describe the slide you want to create..." : "Continue the conversation..."}
              disabled={loading || isGenerating}
              className="w-full px-6 py-5 pr-16 text-base bg-transparent border-none outline-none disabled:opacity-50 disabled:cursor-not-allowed placeholder:text-[var(--neutral-4)]"
              style={{ fontSize: '16px' }}
            />
            <button
              type="submit"
              disabled={loading || isGenerating || !input.trim()}
              className="absolute right-3 top-1/2 -translate-y-1/2 p-3 bg-[var(--color-primary)] text-white rounded-xl font-medium hover:bg-[var(--color-primary-dark)] disabled:opacity-50 disabled:cursor-not-allowed transition-all hover:scale-105 active:scale-95 shadow-lg disabled:hover:scale-100"
              aria-label="Send message"
            >
              {loading || isGenerating ? (
                <Loader size={20} className="animate-spin" />
              ) : (
                <Send size={20} />
              )}
            </button>
          </div>
          {messages.length === 0 && (
            <p className="text-center text-sm text-[var(--neutral-4)] mt-3">
              Try: "Q4 Revenue Growth with key metrics" or "Product roadmap for 2025"
            </p>
          )}
        </form>
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideEditor.tsx
=================================================================================
import { useCallback } from "react";
import { Edit3, RefreshCw } from "lucide-react";
import { SlideCanvas } from "./SlideCanvas";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

interface SlideEditorProps {
  spec: SlideSpecV1;
  onUpdate: (updatedSpec: SlideSpecV1) => void;
  onExport?: () => void;
}

export function SlideEditor({ spec, onUpdate, onExport }: SlideEditorProps) {
  const handleRefresh = useCallback(() => {
    onUpdate(spec);
  }, [spec, onUpdate]);

  return (
    <div className="w-full space-y-6">
      {/* Slide Preview */}
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-[var(--neutral-1)] flex items-center gap-2">
            <Edit3 size={20} className="text-[var(--color-primary)]" />
            Live Preview
          </h3>
          <button
            onClick={handleRefresh}
            className="p-2 hover:bg-[var(--neutral-8)] rounded-lg transition-colors"
            title="Refresh preview"
          >
            <RefreshCw size={18} className="text-[var(--neutral-4)]" />
          </button>
        </div>

        <div className="glass rounded-[var(--radius-xl)] p-6 overflow-hidden shadow-xl border border-[var(--neutral-7)]">
          <SlideCanvas spec={spec} />
        </div>

        {/* Export Button */}
        {onExport && (
          <button
            onClick={onExport}
            className="w-full px-6 py-3 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-lg hover:shadow-lg transition-all active:scale-95"
          >
            Export to PowerPoint
          </button>
        )}
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideNavigation.tsx
=================================================================================
import type { Slide } from "@/types/Presentation";

interface SlideNavigationProps {
  slides: Slide[];
  currentIndex: number;
  onSelectSlide: (index: number) => void;
  onRemoveSlide: (slideId: string) => void;
  onDuplicateSlide: (slideId: string) => void;
  canGoNext: boolean;
  canGoPrevious: boolean;
  onNext: () => void;
  onPrevious: () => void;
}

export function SlideNavigation({
  slides,
  currentIndex,
  onSelectSlide,
  onRemoveSlide,
  onDuplicateSlide,
  canGoNext,
  canGoPrevious,
  onNext,
  onPrevious,
}: SlideNavigationProps) {
  if (slides.length === 0) return null;

  return (
    <div className="space-y-4">
      {/* Navigation Controls */}
      <div className="flex items-center justify-between gap-4">
        <button
          onClick={onPrevious}
          disabled={!canGoPrevious}
          className="p-2 rounded-lg hover:bg-[var(--neutral-8)] disabled:opacity-30 disabled:cursor-not-allowed transition-all"
          aria-label="Previous slide"
        >
          <svg className="w-6 h-6 text-[var(--neutral-2)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
          </svg>
        </button>

        <div className="flex-1 text-center">
          <span className="text-sm font-medium text-[var(--neutral-2)]">
            Slide {currentIndex + 1} of {slides.length}
          </span>
        </div>

        <button
          onClick={onNext}
          disabled={!canGoNext}
          className="p-2 rounded-lg hover:bg-[var(--neutral-8)] disabled:opacity-30 disabled:cursor-not-allowed transition-all"
          aria-label="Next slide"
        >
          <svg className="w-6 h-6 text-[var(--neutral-2)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
        </button>
      </div>

      {/* Thumbnail Strip */}
      <div className="relative">
        <div className="flex gap-3 overflow-x-auto pb-2 scrollbar-thin">
          {slides.map((slide, index) => (
            <div
              key={slide.id}
              className="relative flex-shrink-0 group"
            >
              <button
                onClick={() => onSelectSlide(index)}
                className={`relative w-32 h-20 rounded-lg border-2 transition-all overflow-hidden ${
                  index === currentIndex
                    ? 'border-[var(--color-primary)] shadow-lg scale-105'
                    : 'border-[var(--neutral-7)] hover:border-[var(--color-primary)] hover:shadow-md'
                }`}
                aria-label={`Go to slide ${index + 1}`}
              >
                {/* Thumbnail preview */}
                <div className="w-full h-full bg-[var(--neutral-8)] flex items-center justify-center">
                  <div className="text-center">
                    <div className="text-xs font-bold text-[var(--neutral-3)] mb-1">
                      {slide.spec.content.title.text.slice(0, 20)}
                      {slide.spec.content.title.text.length > 20 ? '...' : ''}
                    </div>
                    <div className="text-[10px] text-[var(--neutral-4)]">
                      Slide {index + 1}
                    </div>
                  </div>
                </div>

                {/* Current indicator */}
                {index === currentIndex && (
                  <div className="absolute bottom-0 left-0 right-0 h-1 bg-[var(--color-primary)]" />
                )}
              </button>

              {/* Action buttons - show on hover */}
              <div className="absolute -top-2 -right-2 opacity-0 group-hover:opacity-100 transition-opacity flex gap-1">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    onDuplicateSlide(slide.id);
                  }}
                  className="p-1.5 bg-white rounded-full shadow-md hover:bg-[var(--neutral-8)] border border-[var(--neutral-7)]"
                  aria-label="Duplicate slide"
                  title="Duplicate slide"
                >
                  <svg className="w-3 h-3 text-[var(--neutral-2)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                  </svg>
                </button>

                {slides.length > 1 && (
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      if (confirm(`Delete slide ${index + 1}?`)) {
                        onRemoveSlide(slide.id);
                      }
                    }}
                    className="p-1.5 bg-white rounded-full shadow-md hover:bg-red-50 border border-[var(--neutral-7)]"
                    aria-label="Delete slide"
                    title="Delete slide"
                  >
                    <svg className="w-3 h-3 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                  </button>
                )}
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Keyboard shortcuts hint */}
      <div className="text-xs text-[var(--neutral-4)] text-center">
        Use <kbd className="px-1.5 py-0.5 bg-[var(--neutral-8)] rounded text-[10px] font-mono">‚Üê</kbd> and{' '}
        <kbd className="px-1.5 py-0.5 bg-[var(--neutral-8)] rounded text-[10px] font-mono">‚Üí</kbd> to navigate
      </div>
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideQualityAnalyzer.tsx
=================================================================================
import { useState, useEffect } from "react";
import { AlertCircle, CheckCircle2, AlertTriangle, Lightbulb, Wand2, TrendingUp } from "lucide-react";

interface SlideIssue {
  severity: "error" | "warning" | "suggestion";
  category: "content" | "design" | "accessibility" | "performance";
  message: string;
  fix?: string;
  autoFixable: boolean;
}

interface RefinementSuggestion {
  type: "content" | "design" | "layout" | "color" | "typography";
  priority: "high" | "medium" | "low";
  suggestion: string;
  rationale: string;
  autoApplicable: boolean;
}

interface SlideQualityAnalyzerProps {
  slideSpec: any;
  onAutoFix?: () => void;
  onApplySuggestion?: (suggestion: RefinementSuggestion) => void;
}

export function SlideQualityAnalyzer({ slideSpec, onAutoFix, onApplySuggestion }: SlideQualityAnalyzerProps) {
  const [issues, setIssues] = useState<SlideIssue[]>([]);
  const [suggestions, setSuggestions] = useState<RefinementSuggestion[]>([]);
  const [qualityScore, setQualityScore] = useState(0);

  useEffect(() => {
    analyzeSlide();
  }, [slideSpec]);

  const analyzeSlide = () => {
    const foundIssues: SlideIssue[] = [];
    const foundSuggestions: RefinementSuggestion[] = [];

    // Check title length
    if (slideSpec?.content?.title?.text?.length > 60) {
      foundIssues.push({
        severity: "warning",
        category: "content",
        message: "Title is too long (>60 characters)",
        fix: "Condense title to 40-50 characters",
        autoFixable: false
      });
    }

    // Check bullet count
    const bulletCount = slideSpec?.content?.bullets?.reduce((sum: number, group: any) => 
      sum + (group.items?.length || 0), 0) || 0;
    
    if (bulletCount > 6) {
      foundIssues.push({
        severity: "warning",
        category: "content",
        message: `Too many bullets (${bulletCount}). Limit to 5-6 for better retention.`,
        fix: "Reduce to 5-6 most important points",
        autoFixable: false
      });
    }

    // Check for data visualization opportunity
    const hasNumbers = slideSpec?.content?.bullets?.some((group: any) =>
      group.items?.some((item: any) => /\d+%|\$\d+|^\d+/.test(item.text))
    );

    if (hasNumbers && !slideSpec?.content?.dataViz) {
      foundSuggestions.push({
        type: "design",
        priority: "high",
        suggestion: "Convert numeric bullets to chart visualization",
        rationale: "Data visualizations are 60% more memorable than text",
        autoApplicable: false
      });
    }

    // Check for images
    if (!slideSpec?.content?.images && !slideSpec?.content?.imagePlaceholders) {
      foundSuggestions.push({
        type: "design",
        priority: "low",
        suggestion: "Consider adding a supporting image or illustration",
        rationale: "Visual elements increase engagement by 80%",
        autoApplicable: false
      });
    }

    // Check color contrast (simplified)
    const primaryColor = slideSpec?.styleTokens?.palette?.primary;
    if (primaryColor === "#000000" || primaryColor === "#FFFFFF") {
      foundSuggestions.push({
        type: "color",
        priority: "high",
        suggestion: "Use a more distinctive primary color",
        rationale: "Black/white primary colors lack visual interest",
        autoApplicable: true
      });
    }

    setIssues(foundIssues);
    setSuggestions(foundSuggestions);

    // Calculate quality score
    const errorCount = foundIssues.filter(i => i.severity === "error").length;
    const warningCount = foundIssues.filter(i => i.severity === "warning").length;
    const score = Math.max(0, 100 - (errorCount * 20) - (warningCount * 10));
    setQualityScore(score);
  };

  const getScoreColor = (score: number) => {
    if (score >= 80) return "text-green-600";
    if (score >= 60) return "text-yellow-600";
    return "text-red-600";
  };

  const getScoreLabel = (score: number) => {
    if (score >= 80) return "Excellent";
    if (score >= 60) return "Good";
    if (score >= 40) return "Fair";
    return "Needs Improvement";
  };

  const getSeverityIcon = (severity: SlideIssue["severity"]) => {
    switch (severity) {
      case "error":
        return <AlertCircle className="w-5 h-5 text-red-500" />;
      case "warning":
        return <AlertTriangle className="w-5 h-5 text-yellow-500" />;
      case "suggestion":
        return <Lightbulb className="w-5 h-5 text-blue-500" />;
    }
  };

  const getPriorityBadge = (priority: RefinementSuggestion["priority"]) => {
    const colors = {
      high: "bg-red-100 text-red-700",
      medium: "bg-yellow-100 text-yellow-700",
      low: "bg-blue-100 text-blue-700"
    };
    return (
      <span className={`px-2 py-1 rounded text-xs font-semibold ${colors[priority]}`}>
        {priority.toUpperCase()}
      </span>
    );
  };

  return (
    <div className="bg-white rounded-2xl shadow-xl border border-[var(--neutral-7)] p-6 space-y-6">
      {/* Header with Quality Score */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className="p-3 bg-gradient-to-br from-green-500 to-emerald-500 rounded-xl">
            <TrendingUp className="w-6 h-6 text-white" />
          </div>
          <div>
            <h2 className="text-2xl font-bold text-[var(--neutral-1)]">Slide Quality</h2>
            <p className="text-sm text-[var(--neutral-3)]">AI-powered analysis & suggestions</p>
          </div>
        </div>
        <div className="text-center">
          <div className={`text-4xl font-bold ${getScoreColor(qualityScore)}`}>
            {qualityScore}
          </div>
          <div className="text-sm text-[var(--neutral-3)]">{getScoreLabel(qualityScore)}</div>
        </div>
      </div>

      {/* Issues */}
      {issues.length > 0 && (
        <div className="space-y-3">
          <div className="flex items-center justify-between">
            <h3 className="font-semibold text-[var(--neutral-1)]">Issues Found</h3>
            {issues.some(i => i.autoFixable) && onAutoFix && (
              <button
                onClick={onAutoFix}
                className="px-3 py-1 bg-[var(--color-primary)] text-white text-sm rounded-lg hover:bg-[var(--color-primary)]/90 transition-all flex items-center gap-1"
              >
                <Wand2 className="w-4 h-4" />
                Auto-Fix
              </button>
            )}
          </div>
          <div className="space-y-2">
            {issues.map((issue, index) => (
              <div
                key={index}
                className="p-4 rounded-lg border border-[var(--neutral-7)] hover:border-[var(--color-primary)] transition-all"
              >
                <div className="flex items-start gap-3">
                  {getSeverityIcon(issue.severity)}
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-1">
                      <span className="font-semibold text-sm text-[var(--neutral-1)]">
                        {issue.message}
                      </span>
                      {issue.autoFixable && (
                        <span className="px-2 py-0.5 bg-green-100 text-green-700 text-xs rounded font-semibold">
                          AUTO-FIXABLE
                        </span>
                      )}
                    </div>
                    {issue.fix && (
                      <p className="text-sm text-[var(--neutral-3)]">
                        <strong>Fix:</strong> {issue.fix}
                      </p>
                    )}
                    <p className="text-xs text-[var(--neutral-4)] mt-1 capitalize">
                      {issue.category}
                    </p>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Suggestions */}
      {suggestions.length > 0 && (
        <div className="space-y-3">
          <h3 className="font-semibold text-[var(--neutral-1)]">Smart Suggestions</h3>
          <div className="space-y-2">
            {suggestions.map((suggestion, index) => (
              <div
                key={index}
                className="p-4 rounded-lg border border-[var(--neutral-7)] hover:border-[var(--color-primary)] transition-all"
              >
                <div className="flex items-start gap-3">
                  <Lightbulb className="w-5 h-5 text-[var(--color-accent)] flex-shrink-0 mt-0.5" />
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-2">
                      {getPriorityBadge(suggestion.priority)}
                      <span className="text-xs text-[var(--neutral-4)] capitalize">
                        {suggestion.type}
                      </span>
                    </div>
                    <p className="font-semibold text-sm text-[var(--neutral-1)] mb-1">
                      {suggestion.suggestion}
                    </p>
                    <p className="text-sm text-[var(--neutral-3)] mb-3">
                      {suggestion.rationale}
                    </p>
                    {suggestion.autoApplicable && onApplySuggestion && (
                      <button
                        onClick={() => onApplySuggestion(suggestion)}
                        className="px-3 py-1.5 bg-[var(--color-primary)] text-white text-sm rounded-lg hover:bg-[var(--color-primary)]/90 transition-all"
                      >
                        Apply Suggestion
                      </button>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* All Good */}
      {issues.length === 0 && suggestions.length === 0 && (
        <div className="text-center py-8">
          <CheckCircle2 className="w-16 h-16 text-green-500 mx-auto mb-4" />
          <p className="text-lg font-semibold text-[var(--neutral-1)]">Slide looks great!</p>
          <p className="text-sm text-[var(--neutral-3)] mt-2">No issues or suggestions found</p>
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/SlideVariantGenerator.tsx
=================================================================================
import { useState } from "react";
import { Shuffle, Palette, Layout, Type, Minimize2, Sparkles } from "lucide-react";

type VariantType = "color" | "layout" | "typography" | "minimal";

interface SlideVariantGeneratorProps {
  currentSlide: any;
  onGenerateVariant: (variantType: VariantType) => Promise<any>;
  onApplyVariant: (variant: any) => void;
}

export function SlideVariantGenerator({ onGenerateVariant, onApplyVariant }: SlideVariantGeneratorProps) {
  const [generating, setGenerating] = useState(false);
  const [variants, setVariants] = useState<Array<{ type: VariantType; slide: any }>>([]);
  const [selectedVariant, setSelectedVariant] = useState<number | null>(null);

  const variantTypes: Array<{ type: VariantType; label: string; icon: any; description: string; color: string }> = [
    { 
      type: "color", 
      label: "Color Palette", 
      icon: Palette, 
      description: "Alternative color schemes",
      color: "from-purple-500 to-pink-500"
    },
    { 
      type: "layout", 
      label: "Layout", 
      icon: Layout, 
      description: "Different design patterns",
      color: "from-blue-500 to-cyan-500"
    },
    { 
      type: "typography", 
      label: "Typography", 
      icon: Type, 
      description: "Alternative font sizes",
      color: "from-green-500 to-emerald-500"
    },
    { 
      type: "minimal", 
      label: "Minimal", 
      icon: Minimize2, 
      description: "Simplified content",
      color: "from-orange-500 to-red-500"
    }
  ];

  const handleGenerateAll = async () => {
    setGenerating(true);
    const newVariants: Array<{ type: VariantType; slide: any }> = [];

    for (const variantType of variantTypes) {
      try {
        const variant = await onGenerateVariant(variantType.type);
        if (variant) {
          newVariants.push({ type: variantType.type, slide: variant });
        }
      } catch (error) {
        console.error(`Failed to generate ${variantType.type} variant:`, error);
      }
    }

    setVariants(newVariants);
    setGenerating(false);
  };

  const handleApply = () => {
    if (selectedVariant !== null && variants[selectedVariant]) {
      onApplyVariant(variants[selectedVariant].slide);
    }
  };

  return (
    <div className="bg-white rounded-2xl shadow-xl border border-[var(--neutral-7)] p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className="p-3 bg-gradient-to-br from-indigo-500 to-purple-500 rounded-xl">
            <Shuffle className="w-6 h-6 text-white" />
          </div>
          <div>
            <h2 className="text-2xl font-bold text-[var(--neutral-1)]">A/B Variants</h2>
            <p className="text-sm text-[var(--neutral-3)]">Generate alternative designs</p>
          </div>
        </div>
        <button
          onClick={handleGenerateAll}
          disabled={generating}
          className="px-4 py-2 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white rounded-lg hover:shadow-lg transition-all disabled:opacity-50 flex items-center gap-2"
        >
          {generating ? (
            <>
              <Sparkles className="w-4 h-4 animate-spin" />
              Generating...
            </>
          ) : (
            <>
              <Sparkles className="w-4 h-4" />
              Generate All Variants
            </>
          )}
        </button>
      </div>

      {/* Variant Type Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {variantTypes.map((variantType) => {
          const Icon = variantType.icon;
          const variant = variants.find(v => v.type === variantType.type);
          const isSelected = selectedVariant === variants.findIndex(v => v.type === variantType.type);

          return (
            <div
              key={variantType.type}
              className={`p-4 rounded-xl border-2 transition-all cursor-pointer ${
                isSelected
                  ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5 shadow-lg"
                  : variant
                  ? "border-[var(--neutral-7)] hover:border-[var(--color-primary)] hover:shadow-md"
                  : "border-[var(--neutral-7)] opacity-50"
              }`}
              onClick={() => {
                if (variant) {
                  const variantIndex = variants.findIndex(v => v.type === variantType.type);
                  setSelectedVariant(variantIndex);
                }
              }}
            >
              <div className="flex items-start gap-3">
                <div className={`p-3 bg-gradient-to-br ${variantType.color} rounded-lg`}>
                  <Icon className="w-5 h-5 text-white" />
                </div>
                <div className="flex-1">
                  <h3 className="font-semibold text-[var(--neutral-1)] mb-1">
                    {variantType.label}
                  </h3>
                  <p className="text-sm text-[var(--neutral-3)] mb-3">
                    {variantType.description}
                  </p>
                  {variant ? (
                    <div className="flex items-center gap-2">
                      <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse" />
                      <span className="text-xs text-green-600 font-semibold">Ready</span>
                    </div>
                  ) : generating ? (
                    <div className="flex items-center gap-2">
                      <div className="w-2 h-2 bg-blue-500 rounded-full animate-pulse" />
                      <span className="text-xs text-blue-600 font-semibold">Generating...</span>
                    </div>
                  ) : (
                    <div className="flex items-center gap-2">
                      <div className="w-2 h-2 bg-[var(--neutral-5)] rounded-full" />
                      <span className="text-xs text-[var(--neutral-4)]">Not generated</span>
                    </div>
                  )}
                </div>
              </div>

              {/* Preview (simplified) */}
              {variant && (
                <div className="mt-4 p-3 bg-[var(--neutral-8)] rounded-lg">
                  <div className="text-xs text-[var(--neutral-3)] space-y-1">
                    {variantType.type === "color" && (
                      <div className="flex gap-2">
                        <div
                          className="w-6 h-6 rounded border border-[var(--neutral-7)]"
                          style={{ backgroundColor: variant.slide?.styleTokens?.palette?.primary }}
                        />
                        <div
                          className="w-6 h-6 rounded border border-[var(--neutral-7)]"
                          style={{ backgroundColor: variant.slide?.styleTokens?.palette?.accent }}
                        />
                      </div>
                    )}
                    {variantType.type === "typography" && (
                      <p>Title: {variant.slide?.styleTokens?.typography?.sizes?.step_3}px</p>
                    )}
                    {variantType.type === "minimal" && (
                      <p>Bullets: {variant.slide?.content?.bullets?.[0]?.items?.length || 0}</p>
                    )}
                  </div>
                </div>
              )}
            </div>
          );
        })}
      </div>

      {/* Apply Button */}
      {selectedVariant !== null && (
        <div className="flex gap-3 pt-4 border-t border-[var(--neutral-7)]">
          <button
            onClick={() => setSelectedVariant(null)}
            className="flex-1 px-6 py-3 border border-[var(--neutral-7)] text-[var(--neutral-2)] font-semibold rounded-xl hover:bg-[var(--neutral-8)] transition-all"
          >
            Cancel
          </button>
          <button
            onClick={handleApply}
            className="flex-1 px-6 py-3 bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transition-all"
          >
            Apply Selected Variant
          </button>
        </div>
      )}

      {/* Info */}
      {variants.length === 0 && !generating && (
        <div className="text-center py-8">
          <Shuffle className="w-16 h-16 text-[var(--neutral-5)] mx-auto mb-4" />
          <p className="text-[var(--neutral-3)]">No variants generated yet</p>
          <p className="text-sm text-[var(--neutral-4)] mt-2">
            Click "Generate All Variants" to create alternative designs
          </p>
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/TemplateSelector.tsx
=================================================================================
import { useState } from "react";
import { TEMPLATES, type Template } from "@/lib/templates";

interface TemplateSelectorProps {
  selectedTemplateId?: string;
  onSelectTemplate: (template: Template) => void;
}

export function TemplateSelector({ selectedTemplateId, onSelectTemplate }: TemplateSelectorProps) {
  const [selectedCategory, setSelectedCategory] = useState<Template["category"] | "all">("all");

  const categories: Array<{ id: Template["category"] | "all"; label: string; icon: string }> = [
    { id: "all", label: "All", icon: "üìã" },
    { id: "business", label: "Business", icon: "üíº" },
    { id: "education", label: "Education", icon: "üéì" },
    { id: "marketing", label: "Marketing", icon: "üìä" },
    { id: "creative", label: "Creative", icon: "üé®" },
    { id: "minimal", label: "Minimal", icon: "‚ö™" },
  ];

  const filteredTemplates =
    selectedCategory === "all"
      ? TEMPLATES
      : TEMPLATES.filter((t) => t.category === selectedCategory);

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-bold text-[var(--neutral-1)]">Choose a Template</h3>
        <button
          onClick={() => setSelectedCategory("all")}
          className="text-sm text-[var(--color-primary)] hover:underline"
        >
          View All
        </button>
      </div>

      {/* Category Filter */}
      <div className="flex gap-2 overflow-x-auto pb-2">
        {categories.map((cat) => (
          <button
            key={cat.id}
            onClick={() => setSelectedCategory(cat.id)}
            className={`flex items-center gap-2 px-4 py-2 rounded-lg whitespace-nowrap transition-all ${
              selectedCategory === cat.id
                ? "bg-[var(--color-primary)] text-white shadow-md"
                : "bg-white border border-[var(--neutral-7)] text-[var(--neutral-2)] hover:border-[var(--color-primary)]"
            }`}
          >
            <span>{cat.icon}</span>
            <span className="text-sm font-medium">{cat.label}</span>
          </button>
        ))}
      </div>

      {/* Template Grid */}
      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
        {filteredTemplates.map((template) => (
          <button
            key={template.id}
            onClick={() => onSelectTemplate(template)}
            className={`group relative p-4 rounded-xl border-2 transition-all hover:shadow-lg ${
              selectedTemplateId === template.id
                ? "border-[var(--color-primary)] bg-[var(--color-primary)]/5 shadow-md"
                : "border-[var(--neutral-7)] bg-white hover:border-[var(--color-primary)]"
            }`}
          >
            {/* Thumbnail */}
            <div className="aspect-video bg-gradient-to-br from-[var(--neutral-8)] to-[var(--neutral-9)] rounded-lg mb-3 flex items-center justify-center text-4xl">
              {template.thumbnail}
            </div>

            {/* Template Info */}
            <div className="text-left">
              <h4 className="text-sm font-semibold text-[var(--neutral-1)] mb-1 group-hover:text-[var(--color-primary)]">
                {template.name}
              </h4>
              <p className="text-xs text-[var(--neutral-4)] line-clamp-2">
                {template.description}
              </p>
            </div>

            {/* Selected Indicator */}
            {selectedTemplateId === template.id && (
              <div className="absolute top-2 right-2 w-6 h-6 bg-[var(--color-primary)] rounded-full flex items-center justify-center">
                <svg className="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
                  <path
                    fillRule="evenodd"
                    d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                    clipRule="evenodd"
                  />
                </svg>
              </div>
            )}

            {/* Color Preview */}
            <div className="flex gap-1 mt-2">
              <div
                className="w-4 h-4 rounded-full border border-[var(--neutral-7)]"
                style={{ backgroundColor: template.spec.styleTokens?.palette.primary }}
              />
              <div
                className="w-4 h-4 rounded-full border border-[var(--neutral-7)]"
                style={{ backgroundColor: template.spec.styleTokens?.palette.accent }}
              />
            </div>
          </button>
        ))}
      </div>

      {filteredTemplates.length === 0 && (
        <div className="text-center py-8 text-[var(--neutral-4)]">
          <p>No templates found in this category</p>
        </div>
      )}
    </div>
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/components/Toast.tsx
=================================================================================
import { useEffect, useState } from "react";

export type ToastType = "success" | "error" | "info" | "warning";

export interface ToastMessage {
  id: string;
  type: ToastType;
  message: string;
  duration?: number;
}

interface ToastProps {
  toast: ToastMessage;
  onClose: (id: string) => void;
}

function Toast({ toast, onClose }: ToastProps) {
  useEffect(() => {
    const timer = setTimeout(() => {
      onClose(toast.id);
    }, toast.duration || 5000);
    
    return () => clearTimeout(timer);
  }, [toast.id, toast.duration, onClose]);
  
  const bgColor = {
    success: "bg-green-500",
    error: "bg-red-500",
    info: "bg-blue-500",
    warning: "bg-yellow-500"
  }[toast.type];
  
  const icon = {
    success: "‚úì",
    error: "‚úï",
    info: "‚Ñπ",
    warning: "‚ö†"
  }[toast.type];
  
  return (
    <div className={`${bgColor} text-white px-4 py-3 rounded-[var(--radius-md)] shadow-[var(--shadow-lg)] flex items-center gap-3 min-w-[300px] max-w-[500px] animate-slide-in`}>
      <span className="text-xl font-bold">{icon}</span>
      <span className="flex-1">{toast.message}</span>
      <button 
        onClick={() => onClose(toast.id)}
        className="text-white/80 hover:text-white text-xl leading-none"
        aria-label="Close notification"
      >
        √ó
      </button>
    </div>
  );
}

interface ToastContainerProps {
  toasts: ToastMessage[];
  onClose: (id: string) => void;
}

export function ToastContainer({ toasts, onClose }: ToastContainerProps) {
  return (
    <div className="fixed top-4 right-4 z-50 flex flex-col gap-2">
      {toasts.map(toast => (
        <Toast key={toast.id} toast={toast} onClose={onClose} />
      ))}
    </div>
  );
}

// Hook for managing toasts
export function useToast() {
  const [toasts, setToasts] = useState<ToastMessage[]>([]);
  
  const showToast = (type: ToastType, message: string, duration?: number) => {
    const id = Math.random().toString(36).substring(7);
    setToasts(prev => [...prev, { id, type, message, duration }]);
  };
  
  const closeToast = (id: string) => {
    setToasts(prev => prev.filter(t => t.id !== id));
  };
  
  return {
    toasts,
    showToast,
    closeToast,
    success: (message: string, duration?: number) => showToast("success", message, duration),
    error: (message: string, duration?: number) => showToast("error", message, duration),
    info: (message: string, duration?: number) => showToast("info", message, duration),
    warning: (message: string, duration?: number) => showToast("warning", message, duration),
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/__tests__/usePresentation.test.ts
=================================================================================
import { describe, it, expect } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { usePresentation } from '../usePresentation';
import type { SlideSpecV1 } from '@/types/SlideSpecV1';

const mockSlideSpec: SlideSpecV1 = {
  meta: {
    version: '1.0',
    locale: 'en-US',
    theme: 'Test',
    aspectRatio: '16:9',
  },
  content: {
    title: { id: 'title', text: 'Test Slide' },
  },
  layout: {
    grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 24, r: 24, b: 24, l: 24 } },
    regions: [],
    anchors: [],
  },
  styleTokens: {
    palette: {
      primary: '#6366F1',
      accent: '#EC4899',
      neutral: ['#0F172A', '#1E293B', '#334155', '#64748B', '#94A3B8', '#CBD5E1', '#E2E8F0'],
    },
    typography: {
      fonts: { sans: 'Inter, Arial, sans-serif' },
      sizes: { 'step_-2': 12, 'step_-1': 14, step_0: 16, step_1: 20, step_2: 24, step_3: 32 },
      weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
      lineHeights: { compact: 1.2, standard: 1.5 },
    },
    spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32] },
    radii: { sm: 2, md: 6, lg: 12 },
    shadows: {
      sm: '0 1px 2px rgba(0,0,0,.06)',
      md: '0 4px 8px rgba(0,0,0,.12)',
      lg: '0 12px 24px rgba(0,0,0,.18)',
    },
    contrast: { minTextContrast: 4.5, minUiContrast: 3 },
  },
};

describe('usePresentation', () => {
  it('should initialize with default presentation', () => {
    const { result } = renderHook(() => usePresentation());

    expect(result.current.presentation).toBeDefined();
    expect(result.current.presentation.slides.length).toBe(0);
    expect(result.current.currentSlideIndex).toBe(0);
    expect(result.current.slideCount).toBe(0);
  });

  it('should add a slide', () => {
    const { result } = renderHook(() => usePresentation());

    act(() => {
      result.current.addSlide(mockSlideSpec, 'Test prompt');
    });

    expect(result.current.slideCount).toBe(1);
    expect(result.current.currentSlide?.spec).toEqual(mockSlideSpec);
  });

  it('should remove a slide', () => {
    const { result } = renderHook(() => usePresentation());

    let slideId: string | undefined;
    act(() => {
      slideId = result.current.addSlide(mockSlideSpec, 'Test prompt') || '';
    });

    act(() => {
      if (slideId) {
        result.current.removeSlide(slideId);
      }
    });

    expect(result.current.slideCount).toBe(0);
  });

  it('should navigate to next slide', () => {
    const { result } = renderHook(() => usePresentation());

    act(() => {
      result.current.addSlide(mockSlideSpec, 'Slide 1');
      result.current.addSlide(mockSlideSpec, 'Slide 2');
    });

    expect(result.current.currentSlideIndex).toBe(0);

    act(() => {
      result.current.nextSlide();
    });

    expect(result.current.currentSlideIndex).toBe(1);
  });

  it('should navigate to previous slide', () => {
    const { result } = renderHook(() => usePresentation());

    act(() => {
      result.current.addSlide(mockSlideSpec, 'Slide 1');
      result.current.addSlide(mockSlideSpec, 'Slide 2');
      result.current.goToSlide(1);
    });

    expect(result.current.currentSlideIndex).toBe(1);

    act(() => {
      result.current.previousSlide();
    });

    expect(result.current.currentSlideIndex).toBe(0);
  });

  it('should not navigate beyond bounds', () => {
    const { result } = renderHook(() => usePresentation());

    act(() => {
      result.current.addSlide(mockSlideSpec, 'Slide 1');
    });

    expect(result.current.canGoNext).toBe(false);
    expect(result.current.canGoPrevious).toBe(false);

    act(() => {
      result.current.nextSlide();
    });

    expect(result.current.currentSlideIndex).toBe(0);
  });

  it('should duplicate a slide', () => {
    const { result } = renderHook(() => usePresentation());

    let slideId: string;
    act(() => {
      slideId = result.current.addSlide(mockSlideSpec, 'Original');
    });

    act(() => {
      result.current.duplicateSlide(slideId!);
    });

    expect(result.current.slideCount).toBe(2);
  });

  it('should update a slide', () => {
    const { result } = renderHook(() => usePresentation());

    let slideId: string;
    act(() => {
      slideId = result.current.addSlide(mockSlideSpec, 'Original');
    });

    const updatedSpec = {
      ...mockSlideSpec,
      content: {
        ...mockSlideSpec.content,
        title: { id: 'title', text: 'Updated Title' },
      },
    };

    act(() => {
      result.current.updateSlide(slideId!, updatedSpec);
    });

    expect(result.current.currentSlide?.spec.content.title.text).toBe('Updated Title');
  });

  it('should reorder slides', () => {
    const { result } = renderHook(() => usePresentation());

    act(() => {
      result.current.addSlide(mockSlideSpec, 'Slide 1');
      result.current.addSlide(mockSlideSpec, 'Slide 2');
      result.current.addSlide(mockSlideSpec, 'Slide 3');
    });

    const slide1Id = result.current.presentation.slides[0].id;
    const slide3Id = result.current.presentation.slides[2].id;

    act(() => {
      result.current.reorderSlides(2, 0);
    });

    expect(result.current.presentation.slides[0].id).toBe(slide3Id);
    expect(result.current.presentation.slides[2].id).toBe(slide1Id);
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/usePDFExport.ts
=================================================================================
import { useState, useCallback } from "react";
import { downloadPDF, type PDFExportOptions } from "@/lib/pdfExport";
import type { Presentation } from "@/types/Presentation";
import { logger } from "@/lib/logger";

export function usePDFExport() {
  const [exporting, setExporting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [progress, setProgress] = useState(0);

  const exportToPDF = useCallback(
    async (
      presentation: Presentation,
      slideElements: HTMLElement[],
      filename?: string,
      options?: PDFExportOptions
    ) => {
      setError(null);
      setExporting(true);
      setProgress(0);

      logger.userAction("export_pdf", { 
        filename: filename || presentation.title,
        slideCount: presentation.slides.length 
      });

      try {
        // Simulate progress updates
        const progressInterval = setInterval(() => {
          setProgress((prev) => Math.min(prev + 10, 90));
        }, 200);

        await downloadPDF(presentation, slideElements, filename, options);

        clearInterval(progressInterval);
        setProgress(100);

        // Reset after a short delay
        setTimeout(() => {
          setProgress(0);
          setExporting(false);
        }, 1000);

        return true;
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to export PDF";
        setError(errorMessage);
        logger.error("PDF export failed", err);
        setExporting(false);
        setProgress(0);
        return false;
      }
    },
    []
  );

  return {
    exporting,
    error,
    progress,
    exportToPDF,
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/usePresentation.ts
=================================================================================
import { useState, useCallback } from "react";
import type { Presentation } from "@/types/Presentation";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";
import { createPresentation, createSlide } from "@/types/Presentation";
import { logger } from "@/lib/logger";

export function usePresentation(initialAspectRatio: "16:9" | "4:3" = "16:9") {
  const [presentation, setPresentation] = useState<Presentation>(() => 
    createPresentation("My Presentation", initialAspectRatio)
  );
  const [currentSlideIndex, setCurrentSlideIndex] = useState(0);

  const addSlide = useCallback((spec: SlideSpecV1, prompt?: string): string => {
    const slide = createSlide(spec, prompt);
    setPresentation(prev => ({
      ...prev,
      slides: [...prev.slides, slide],
      updatedAt: Date.now(),
    }));
    setCurrentSlideIndex(presentation.slides.length); // Navigate to new slide
    logger.info("Slide added to presentation", { slideId: slide.id, totalSlides: presentation.slides.length + 1 });
    return slide.id;
  }, [presentation.slides.length]);

  const removeSlide = useCallback((slideId: string) => {
    setPresentation(prev => {
      const newSlides = prev.slides.filter(s => s.id !== slideId);
      return {
        ...prev,
        slides: newSlides,
        updatedAt: Date.now(),
      };
    });
    
    // Adjust current index if needed
    setCurrentSlideIndex(prev => {
      const newLength = presentation.slides.length - 1;
      if (prev >= newLength) {
        return Math.max(0, newLength - 1);
      }
      return prev;
    });
    
    logger.info("Slide removed from presentation", { slideId });
  }, [presentation.slides.length]);

  const updateSlide = useCallback((slideId: string, spec: SlideSpecV1) => {
    setPresentation(prev => ({
      ...prev,
      slides: prev.slides.map(slide =>
        slide.id === slideId
          ? { ...slide, spec, updatedAt: Date.now() }
          : slide
      ),
      updatedAt: Date.now(),
    }));
    logger.info("Slide updated", { slideId });
  }, []);

  const duplicateSlide = useCallback((slideId: string) => {
    const slideIndex = presentation.slides.findIndex(s => s.id === slideId);
    if (slideIndex === -1) return;

    const originalSlide = presentation.slides[slideIndex];
    const newSlide = createSlide(originalSlide.spec, originalSlide.prompt);

    setPresentation(prev => {
      const newSlides = [...prev.slides];
      newSlides.splice(slideIndex + 1, 0, newSlide);
      return {
        ...prev,
        slides: newSlides,
        updatedAt: Date.now(),
      };
    });

    setCurrentSlideIndex(slideIndex + 1);
    logger.info("Slide duplicated", { originalId: slideId, newId: newSlide.id });
  }, [presentation.slides]);

  const reorderSlides = useCallback((fromIndex: number, toIndex: number) => {
    setPresentation(prev => {
      const newSlides = [...prev.slides];
      const [removed] = newSlides.splice(fromIndex, 1);
      newSlides.splice(toIndex, 0, removed);
      return {
        ...prev,
        slides: newSlides,
        updatedAt: Date.now(),
      };
    });
    
    // Update current index if the current slide was moved
    if (currentSlideIndex === fromIndex) {
      setCurrentSlideIndex(toIndex);
    } else if (currentSlideIndex > fromIndex && currentSlideIndex <= toIndex) {
      setCurrentSlideIndex(currentSlideIndex - 1);
    } else if (currentSlideIndex < fromIndex && currentSlideIndex >= toIndex) {
      setCurrentSlideIndex(currentSlideIndex + 1);
    }
    
    logger.info("Slides reordered", { fromIndex, toIndex });
  }, [currentSlideIndex]);

  const goToSlide = useCallback((index: number) => {
    if (index >= 0 && index < presentation.slides.length) {
      setCurrentSlideIndex(index);
    }
  }, [presentation.slides.length]);

  const nextSlide = useCallback(() => {
    setCurrentSlideIndex(prev => 
      prev < presentation.slides.length - 1 ? prev + 1 : prev
    );
  }, [presentation.slides.length]);

  const previousSlide = useCallback(() => {
    setCurrentSlideIndex(prev => prev > 0 ? prev - 1 : prev);
  }, []);

  const updateTitle = useCallback((title: string) => {
    setPresentation(prev => ({
      ...prev,
      title,
      updatedAt: Date.now(),
    }));
  }, []);

  const clearPresentation = useCallback(() => {
    setPresentation(createPresentation("My Presentation", presentation.aspectRatio));
    setCurrentSlideIndex(0);
    logger.info("Presentation cleared");
  }, [presentation.aspectRatio]);

  const currentSlide = presentation.slides[currentSlideIndex] || null;

  return {
    presentation,
    currentSlide,
    currentSlideIndex,
    addSlide,
    removeSlide,
    updateSlide,
    duplicateSlide,
    reorderSlides,
    goToSlide,
    nextSlide,
    previousSlide,
    updateTitle,
    clearPresentation,
    hasSlides: presentation.slides.length > 0,
    slideCount: presentation.slides.length,
    canGoNext: currentSlideIndex < presentation.slides.length - 1,
    canGoPrevious: currentSlideIndex > 0,
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/usePresentationExport.ts
=================================================================================
import { useState, useCallback } from "react";
import { apiExport, apiExportMultiple } from "@/lib/api";
import { logger } from "@/lib/logger";
import type { Presentation } from "@/types/Presentation";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export function usePresentationExport() {
  const [exporting, setExporting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const exportPresentation = useCallback(async (presentation: Presentation, filename?: string) => {
    setError(null);
    setExporting(true);

    const startTime = performance.now();
    const finalFilename = filename || `${presentation.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.pptx`;
    
    logger.userAction("export_presentation", { 
      filename: finalFilename, 
      slideCount: presentation.slides.length 
    });

    try {
      const specs = presentation.slides.map(slide => slide.spec);
      
      let blob: Blob;
      if (specs.length === 1) {
        // Single slide - use original API for backward compatibility
        blob = await apiExport(specs[0]);
      } else {
        // Multiple slides
        blob = await apiExportMultiple(specs);
      }

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = finalFilename;
      a.click();
      URL.revokeObjectURL(url);

      const duration = performance.now() - startTime;
      logger.performance("presentation_export", duration);
      logger.info("Presentation exported successfully", { 
        filename: finalFilename, 
        slideCount: specs.length,
        size: blob.size, 
        duration 
      });

      return true;
    } catch (e: unknown) {
      const errorMessage = e instanceof Error ? e.message : "Failed to export presentation";
      setError(errorMessage);
      logger.error("Failed to export presentation", e, { filename: finalFilename });
      return false;
    } finally {
      setExporting(false);
    }
  }, []);

  const exportSingleSlide = useCallback(async (spec: SlideSpecV1, filename = "slide.pptx") => {
    setError(null);
    setExporting(true);

    const startTime = performance.now();
    logger.userAction("export_single_slide", { filename });

    try {
      const blob = await apiExport(spec);
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);

      const duration = performance.now() - startTime;
      logger.performance("single_slide_export", duration);
      logger.info("Single slide exported successfully", { filename, size: blob.size, duration });

      return true;
    } catch (e: unknown) {
      const errorMessage = e instanceof Error ? e.message : "Failed to export slide";
      setError(errorMessage);
      logger.error("Failed to export slide", e, { filename });
      return false;
    } finally {
      setExporting(false);
    }
  }, []);

  return {
    exporting,
    error,
    exportPresentation,
    exportSingleSlide,
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/usePresentationGeneration.ts
=================================================================================
import { useState, useCallback } from "react";
import { logger } from "@/lib/logger";

interface PresentationRequest {
  topic: string;
  audience?: "executives" | "technical" | "sales" | "general" | "investors";
  tone?: "formal" | "casual" | "persuasive" | "educational" | "inspirational";
  slideCount?: number;
  industry?: "tech" | "finance" | "healthcare" | "marketing" | "corporate";
  includeAgenda?: boolean;
  includeSummary?: boolean;
}

interface PresentationResponse {
  slides: any[];
  structure: {
    title: string;
    slideCount: number;
    narrative: string[];
  };
  metadata: {
    audience: string;
    tone: string;
    industry: string;
  };
}

export function usePresentationGeneration() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [presentation, setPresentation] = useState<PresentationResponse | null>(null);
  const [progress, setProgress] = useState(0);

  const generatePresentation = useCallback(async (request: PresentationRequest) => {
    setLoading(true);
    setError(null);
    setProgress(0);

    try {
      logger.info("Generating presentation", { request });

      // Get the API endpoint from environment
      const apiUrl = import.meta.env.VITE_FIREBASE_FUNCTION_URL || 
                     "https://us-central1-pls-fix-thx.cloudfunctions.net";
      
      const endpoint = `${apiUrl}/generatePresentation`;

      // Simulate progress updates
      const progressInterval = setInterval(() => {
        setProgress(prev => Math.min(prev + 10, 90));
      }, 500);

      const response = await fetch(endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(request),
      });

      clearInterval(progressInterval);
      setProgress(100);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      logger.info("Presentation generated successfully", { 
        slideCount: data.slides?.length 
      });

      setPresentation(data);
      return data;

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to generate presentation";
      logger.error("Presentation generation failed", { error: errorMessage });
      setError(errorMessage);
      return null;
    } finally {
      setLoading(false);
      setProgress(0);
    }
  }, []);

  const reset = useCallback(() => {
    setPresentation(null);
    setError(null);
    setProgress(0);
  }, []);

  return {
    loading,
    error,
    presentation,
    progress,
    generatePresentation,
    reset
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/useSlideExport.ts
=================================================================================
import { useState, useCallback } from "react";
import { apiExport } from "@/lib/api";
import { logger } from "@/lib/logger";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export function useSlideExport() {
  const [exporting, setExporting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const exportSlide = useCallback(async (spec: SlideSpecV1, filename = "plzfixthx-slide.pptx") => {
    setError(null);
    setExporting(true);

    const startTime = performance.now();
    logger.userAction("export_slide", { filename });

    try {
      const blob = await apiExport(spec);
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);

      const duration = performance.now() - startTime;
      logger.performance("slide_export", duration);
      logger.info("Slide exported successfully", { filename, size: blob.size, duration });

      return true;
    } catch (e: unknown) {
      const errorMessage = e instanceof Error ? e.message : "Failed to export slide";
      setError(errorMessage);
      logger.error("Failed to export slide", e, { filename });
      return false;
    } finally {
      setExporting(false);
    }
  }, []);

  return {
    exporting,
    error,
    exportSlide
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/useSlideGeneration.ts
=================================================================================
import { useState, useCallback } from "react";
import { apiGenerate } from "@/lib/api";
import { normalizeOrFallback } from "@/lib/validation";
import { logger } from "@/lib/logger";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export function useSlideGeneration() {
  const [loading, setLoading] = useState(false);
  const [spec, setSpec] = useState<SlideSpecV1 | null>(null);
  const [error, setError] = useState<string | null>(null);

  const generate = useCallback(async (prompt: string) => {
    if (!prompt.trim()) {
      setError("Please enter a prompt");
      logger.warn("Generate called with empty prompt");
      return null;
    }

    setError(null);
    setLoading(true);

    const startTime = performance.now();
    logger.userAction("generate_slide", { promptLength: prompt.length });

    try {
      const data = await apiGenerate(prompt);
      const normalized = normalizeOrFallback(data?.spec ?? data);
      setSpec(normalized);

      const duration = performance.now() - startTime;
      logger.performance("slide_generation", duration);
      logger.info("Slide generated successfully", { duration });

      return normalized;
    } catch (e: unknown) {
      const errorMessage = e instanceof Error ? e.message : "Failed to generate slide";
      setError(errorMessage);
      logger.error("Failed to generate slide", e, { prompt: prompt.slice(0, 50) });

      // Still set a fallback spec so user sees something
      const fallback = normalizeOrFallback(null);
      setSpec(fallback);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const reset = useCallback(() => {
    setSpec(null);
    setError(null);
    setLoading(false);
  }, []);

  return {
    loading,
    spec,
    error,
    generate,
    reset
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/useSlideHistory.ts
=================================================================================
import { useState, useEffect, useCallback } from "react";
import type { Presentation } from "@/types/Presentation";
import { logger } from "@/lib/logger";

const STORAGE_KEY = "plzfixthx_presentations";
const MAX_HISTORY_ITEMS = 50;

interface HistoryItem {
  id: string;
  presentation: Presentation;
  savedAt: string;
}

export function useSlideHistory() {
  const [history, setHistory] = useState<HistoryItem[]>([]);
  const [loading, setLoading] = useState(true);

  // Load history from localStorage on mount
  useEffect(() => {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored) as HistoryItem[];
        setHistory(parsed);
        logger.info("Loaded presentation history", { count: parsed.length });
      }
    } catch (error) {
      logger.error("Failed to load presentation history", error);
    } finally {
      setLoading(false);
    }
  }, []);

  // Save presentation to history
  const savePresentation = useCallback((presentation: Presentation) => {
    try {
      const historyItem: HistoryItem = {
        id: presentation.id,
        presentation,
        savedAt: new Date().toISOString(),
      };

      setHistory((prev) => {
        // Remove existing entry with same ID if it exists
        const filtered = prev.filter((item) => item.id !== presentation.id);
        
        // Add new entry at the beginning
        const updated = [historyItem, ...filtered];
        
        // Limit to MAX_HISTORY_ITEMS
        const trimmed = updated.slice(0, MAX_HISTORY_ITEMS);
        
        // Save to localStorage
        localStorage.setItem(STORAGE_KEY, JSON.stringify(trimmed));
        
        logger.info("Saved presentation to history", { 
          id: presentation.id, 
          title: presentation.title 
        });
        
        return trimmed;
      });

      return true;
    } catch (error) {
      logger.error("Failed to save presentation to history", error);
      return false;
    }
  }, []);

  // Load presentation from history
  const loadPresentation = useCallback((id: string): Presentation | null => {
    const item = history.find((h) => h.id === id);
    if (item) {
      logger.info("Loaded presentation from history", { id, title: item.presentation.title });
      return item.presentation;
    }
    return null;
  }, [history]);

  // Delete presentation from history
  const deletePresentation = useCallback((id: string) => {
    try {
      setHistory((prev) => {
        const updated = prev.filter((item) => item.id !== id);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
        logger.info("Deleted presentation from history", { id });
        return updated;
      });
      return true;
    } catch (error) {
      logger.error("Failed to delete presentation from history", error);
      return false;
    }
  }, []);

  // Clear all history
  const clearHistory = useCallback(() => {
    try {
      setHistory([]);
      localStorage.removeItem(STORAGE_KEY);
      logger.info("Cleared presentation history");
      return true;
    } catch (error) {
      logger.error("Failed to clear presentation history", error);
      return false;
    }
  }, []);

  // Get recent presentations
  const getRecentPresentations = useCallback((limit = 10): HistoryItem[] => {
    return history.slice(0, limit);
  }, [history]);

  // Search presentations
  const searchPresentations = useCallback((query: string): HistoryItem[] => {
    const lowerQuery = query.toLowerCase();
    return history.filter((item) => 
      item.presentation.title.toLowerCase().includes(lowerQuery) ||
      item.presentation.slides.some((slide) => 
        slide.spec.content.title.text.toLowerCase().includes(lowerQuery)
      )
    );
  }, [history]);

  return {
    history,
    loading,
    savePresentation,
    loadPresentation,
    deletePresentation,
    clearHistory,
    getRecentPresentations,
    searchPresentations,
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/hooks/useSlideImages.ts
=================================================================================
import { useState, useCallback } from "react";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";
import { logger } from "@/lib/logger";

interface ImageData {
  id: string;
  dataUrl: string;
  filename: string;
  size: number;
  type: string;
}

export function useSlideImages() {
  const [images, setImages] = useState<Map<string, ImageData>>(new Map());

  const addImage = useCallback((placeholderId: string, imageData: string, file: File) => {
    const newImage: ImageData = {
      id: placeholderId,
      dataUrl: imageData,
      filename: file.name,
      size: file.size,
      type: file.type,
    };

    setImages((prev) => {
      const updated = new Map(prev);
      updated.set(placeholderId, newImage);
      logger.info("Image added to slide", { 
        placeholderId, 
        filename: file.name,
        size: file.size 
      });
      return updated;
    });
  }, []);

  const removeImage = useCallback((placeholderId: string) => {
    setImages((prev) => {
      const updated = new Map(prev);
      updated.delete(placeholderId);
      logger.info("Image removed from slide", { placeholderId });
      return updated;
    });
  }, []);

  const getImage = useCallback((placeholderId: string): ImageData | undefined => {
    return images.get(placeholderId);
  }, [images]);

  const hasImage = useCallback((placeholderId: string): boolean => {
    return images.has(placeholderId);
  }, [images]);

  const clearImages = useCallback(() => {
    setImages(new Map());
    logger.info("All images cleared");
  }, []);

  const updateSlideSpec = useCallback((spec: SlideSpecV1): SlideSpecV1 => {
    // Replace image placeholders with actual image data
    const updatedComponents = { ...spec.components };

    if (spec.content.imagePlaceholders) {
      spec.content.imagePlaceholders.forEach((placeholder) => {
        const image = images.get(placeholder.id);
        if (image) {
          // Update the placeholder with actual image data
          // This would be used when exporting to PPTX
          logger.info("Image placeholder updated", { 
            placeholderId: placeholder.id,
            filename: image.filename 
          });
        }
      });
    }

    return {
      ...spec,
      components: updatedComponents,
    };
  }, [images]);

  const getImageCount = useCallback((): number => {
    return images.size;
  }, [images]);

  const getAllImages = useCallback((): ImageData[] => {
    return Array.from(images.values());
  }, [images]);

  return {
    images,
    addImage,
    removeImage,
    getImage,
    hasImage,
    clearImages,
    updateSlideSpec,
    getImageCount,
    getAllImages,
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/__tests__/accessibility.test.ts
=================================================================================
import { describe, it, expect } from 'vitest';
import {
  getContrastRatio,
  meetsWCAGAA,
  meetsWCAGAAA,
  getAccessibleTextColor,
} from '../accessibility';

describe('accessibility utilities', () => {
  describe('getContrastRatio', () => {
    it('should calculate contrast ratio between black and white', () => {
      const ratio = getContrastRatio('#000000', '#FFFFFF');
      expect(ratio).toBe(21); // Maximum contrast ratio
    });

    it('should calculate contrast ratio between same colors', () => {
      const ratio = getContrastRatio('#6366F1', '#6366F1');
      expect(ratio).toBe(1); // Minimum contrast ratio
    });

    it('should handle lowercase hex colors', () => {
      const ratio = getContrastRatio('#ffffff', '#000000');
      expect(ratio).toBe(21);
    });

    it('should handle hex colors without # prefix', () => {
      const ratio = getContrastRatio('FFFFFF', '000000');
      expect(ratio).toBe(21);
    });
  });

  describe('meetsWCAGAA', () => {
    it('should pass for high contrast text', () => {
      expect(meetsWCAGAA('#000000', '#FFFFFF')).toBe(true);
    });

    it('should fail for low contrast text', () => {
      expect(meetsWCAGAA('#CCCCCC', '#FFFFFF')).toBe(false);
    });

    it('should use different threshold for large text', () => {
      // A contrast that passes for large text but not normal text
      const foreground = '#767676';
      const background = '#FFFFFF';
      
      expect(meetsWCAGAA(foreground, background, false)).toBe(false);
      expect(meetsWCAGAA(foreground, background, true)).toBe(true);
    });
  });

  describe('meetsWCAGAAA', () => {
    it('should pass for very high contrast', () => {
      expect(meetsWCAGAAA('#000000', '#FFFFFF')).toBe(true);
    });

    it('should fail for moderate contrast', () => {
      expect(meetsWCAGAAA('#595959', '#FFFFFF')).toBe(false);
    });

    it('should have stricter requirements than AA', () => {
      const foreground = '#595959';
      const background = '#FFFFFF';
      
      // This combination passes AA but not AAA
      expect(meetsWCAGAA(foreground, background)).toBe(true);
      expect(meetsWCAGAAA(foreground, background)).toBe(false);
    });
  });

  describe('getAccessibleTextColor', () => {
    it('should return white for dark backgrounds', () => {
      expect(getAccessibleTextColor('#000000')).toBe('#FFFFFF');
      expect(getAccessibleTextColor('#1E293B')).toBe('#FFFFFF');
    });

    it('should return black for light backgrounds', () => {
      expect(getAccessibleTextColor('#FFFFFF')).toBe('#000000');
      expect(getAccessibleTextColor('#F8FAFC')).toBe('#000000');
    });

    it('should return appropriate color for medium backgrounds', () => {
      const color = getAccessibleTextColor('#6366F1');
      expect(color).toMatch(/^#(000000|FFFFFF)$/);
    });
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/__tests__/designSystem.test.ts
=================================================================================
/**
 * Design System Tests
 * Comprehensive tests for design system libraries
 */

import { describe, it, expect } from "vitest";
import { PROFESSIONAL_PALETTES, calculateContrastRatio, validatePaletteContrast } from "../colorPalettes";
import { TYPOGRAPHY_PAIRS, validateTypographyPair } from "../typographyPairs";
import { LAYOUT_PATTERNS, validateLayoutPattern, calculateWhitespacePercentage } from "../layoutPatterns";
import { validateDesignQuality } from "../designQuality";

describe("Color Palettes", () => {
  it("should have at least 15 professional palettes", () => {
    const palettes = Object.keys(PROFESSIONAL_PALETTES);
    expect(palettes.length).toBeGreaterThanOrEqual(15);
  });

  it("should have valid hex colors in all palettes", () => {
    const hexPattern = /^#[0-9A-Fa-f]{6}$/;

    Object.values(PROFESSIONAL_PALETTES).forEach(palette => {
      expect(hexPattern.test(palette.primary)).toBe(true);
      expect(hexPattern.test(palette.accent)).toBe(true);
      palette.neutral.forEach(color => {
        expect(hexPattern.test(color)).toBe(true);
      });
    });
  });

  it("should calculate contrast ratio correctly", () => {
    const white = "#FFFFFF";
    const black = "#000000";
    const ratio = calculateContrastRatio(white, black);

    expect(ratio).toBeGreaterThan(20); // Should be 21:1
  });

  it("should validate palette contrast", () => {
    const palette = PROFESSIONAL_PALETTES.corporate;
    const isValid = validatePaletteContrast(palette);

    expect(isValid).toBe(true);
  });

  it("should have WCAG AA compliant contrast ratios", () => {
    Object.values(PROFESSIONAL_PALETTES).forEach(palette => {
      const ratio = calculateContrastRatio(palette.neutral[0], palette.neutral[6]);
      expect(ratio).toBeGreaterThanOrEqual(4.5); // WCAG AA minimum
    });
  });
});

describe("Typography Pairs", () => {
  it("should have at least 12 typography pairs", () => {
    const pairs = Object.keys(TYPOGRAPHY_PAIRS);
    expect(pairs.length).toBeGreaterThanOrEqual(12);
  });

  it("should have valid font specifications", () => {
    Object.values(TYPOGRAPHY_PAIRS).forEach(pair => {
      expect(pair.primary).toBeTruthy();
      expect(pair.secondary).toBeTruthy();
      expect(pair.sizes.title).toBeGreaterThan(0);
      expect(pair.sizes.body).toBeGreaterThan(0);
      expect(pair.sizes.title).toBeGreaterThan(pair.sizes.body);
    });
  });

  it("should validate typography pairs", () => {
    Object.values(TYPOGRAPHY_PAIRS).forEach(pair => {
      const isValid = validateTypographyPair(pair);
      expect(isValid).toBe(true);
    });
  });

  it("should have proper size hierarchy", () => {
    Object.values(TYPOGRAPHY_PAIRS).forEach(pair => {
      expect(pair.sizes.title).toBeGreaterThan(pair.sizes.subtitle);
      expect(pair.sizes.subtitle).toBeGreaterThan(pair.sizes.body);
      expect(pair.sizes.body).toBeGreaterThan(pair.sizes.caption);
    });
  });

  it("should have valid line heights", () => {
    Object.values(TYPOGRAPHY_PAIRS).forEach(pair => {
      Object.values(pair.lineHeights).forEach(lineHeight => {
        expect(lineHeight).toBeGreaterThanOrEqual(1.2);
        expect(lineHeight).toBeLessThanOrEqual(2);
      });
    });
  });
});

describe("Layout Patterns", () => {
  it("should have 6 layout patterns", () => {
    const patterns = Object.keys(LAYOUT_PATTERNS);
    expect(patterns.length).toBe(6);
  });

  it("should have valid pattern names", () => {
    const validNames = ["hero", "split", "asymmetric", "grid", "minimal", "data-focused"];
    const patterns = Object.keys(LAYOUT_PATTERNS);

    patterns.forEach(name => {
      expect(validNames).toContain(name);
    });
  });

  it("should validate all layout patterns", () => {
    Object.values(LAYOUT_PATTERNS).forEach(pattern => {
      const isValid = validateLayoutPattern(pattern);
      expect(isValid).toBe(true);
    });
  });

  it("should have regions within slide bounds", () => {
    const SLIDE_WIDTH = 10;
    const SLIDE_HEIGHT = 7.5;

    Object.values(LAYOUT_PATTERNS).forEach(pattern => {
      Object.values(pattern.regions).forEach(region => {
        expect(region.x).toBeGreaterThanOrEqual(0);
        expect(region.y).toBeGreaterThanOrEqual(0);
        expect(region.x + region.w).toBeLessThanOrEqual(SLIDE_WIDTH);
        expect(region.y + region.h).toBeLessThanOrEqual(SLIDE_HEIGHT);
      });
    });
  });

  it("should calculate white space percentage", () => {
    Object.values(LAYOUT_PATTERNS).forEach(pattern => {
      const whitespace = calculateWhitespacePercentage(pattern);
      expect(whitespace).toBeGreaterThan(0);
      expect(whitespace).toBeLessThan(100);
    });
  });

  it("should have appropriate white space for pattern type", () => {
    const minimalPattern = LAYOUT_PATTERNS.minimal;
    const dataFocusedPattern = LAYOUT_PATTERNS["data-focused"];

    const minimalWhitespace = calculateWhitespacePercentage(minimalPattern);
    const dataWhitespace = calculateWhitespacePercentage(dataFocusedPattern);

    // Minimal should have more white space than data-focused
    expect(minimalWhitespace).toBeGreaterThan(dataWhitespace);
  });
});

describe("Design Quality Validation", () => {
  it("should validate design quality", () => {
    const mockSpec = {
      design: {
        pattern: "split",
        whitespace: { strategy: "balanced", breathingRoom: 28 },
        typography: {
          hierarchy: {
            title: { size: 32, weight: 700, lineHeight: 1.2 },
            body: { size: 16, weight: 400, lineHeight: 1.5 }
          }
        }
      },
      styleTokens: {
        palette: {
          primary: "#1E40AF",
          accent: "#10B981",
          neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"]
        },
        typography: {
          sizes: { step_0: 16, step_3: 32 },
          lineHeights: { standard: 1.5 }
        }
      }
    } as any;

    const score = validateDesignQuality(mockSpec);
    expect(score.overall).toBeGreaterThan(0);
    expect(score.overall).toBeLessThanOrEqual(100);
  });

  it("should identify design issues", () => {
    const mockSpec = {
      design: {
        pattern: "split",
        whitespace: { strategy: "compact", breathingRoom: 10 },
        typography: {
          hierarchy: {
            title: { size: 14, weight: 400, lineHeight: 1 },
            body: { size: 12, weight: 400, lineHeight: 1 }
          }
        }
      },
      styleTokens: {
        palette: {
          primary: "#FFFFFF",
          accent: "#FFFFFF",
          neutral: ["#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF"]
        },
        typography: {
          sizes: { step_0: 12, step_3: 14 },
          lineHeights: { standard: 1 }
        }
      }
    } as any;

    const score = validateDesignQuality(mockSpec);
    expect(score.issues.length).toBeGreaterThan(0);
  });
});

describe("Design System Integration", () => {
  it("should have complementary palettes and typography", () => {
    Object.values(PROFESSIONAL_PALETTES).forEach(palette => {
      expect(palette.primary).toBeTruthy();
      expect(palette.accent).toBeTruthy();
      expect(palette.neutral.length).toBeGreaterThanOrEqual(5);
    });

    Object.values(TYPOGRAPHY_PAIRS).forEach(pair => {
      expect(pair.primary).toBeTruthy();
      expect(pair.secondary).toBeTruthy();
    });
  });

  it("should support all design patterns", () => {
    const patterns = Object.keys(LAYOUT_PATTERNS);
    expect(patterns).toContain("hero");
    expect(patterns).toContain("split");
    expect(patterns).toContain("asymmetric");
    expect(patterns).toContain("grid");
    expect(patterns).toContain("minimal");
    expect(patterns).toContain("data-focused");
  });
});



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/accessibility.ts
=================================================================================
/**
 * Accessibility utilities for WCAG compliance
 */

/**
 * Calculate relative luminance of a color
 * https://www.w3.org/TR/WCAG20/#relativeluminancedef
 */
function getLuminance(r: number, g: number, b: number): number {
  const [rs, gs, bs] = [r, g, b].map((c) => {
    const sRGB = c / 255;
    return sRGB <= 0.03928 ? sRGB / 12.92 : Math.pow((sRGB + 0.055) / 1.055, 2.4);
  });
  return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
}

/**
 * Parse hex color to RGB
 */
function hexToRgb(hex: string): { r: number; g: number; b: number } | null {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
      }
    : null;
}

/**
 * Calculate contrast ratio between two colors
 * https://www.w3.org/TR/WCAG20/#contrast-ratiodef
 */
export function getContrastRatio(color1: string, color2: string): number {
  const rgb1 = hexToRgb(color1);
  const rgb2 = hexToRgb(color2);

  if (!rgb1 || !rgb2) {
    return 0;
  }

  const lum1 = getLuminance(rgb1.r, rgb1.g, rgb1.b);
  const lum2 = getLuminance(rgb2.r, rgb2.g, rgb2.b);

  const lighter = Math.max(lum1, lum2);
  const darker = Math.min(lum1, lum2);

  return (lighter + 0.05) / (darker + 0.05);
}

/**
 * Check if contrast ratio meets WCAG AA standards
 */
export function meetsWCAGAA(
  foreground: string,
  background: string,
  isLargeText = false
): boolean {
  const ratio = getContrastRatio(foreground, background);
  return isLargeText ? ratio >= 3 : ratio >= 4.5;
}

/**
 * Check if contrast ratio meets WCAG AAA standards
 */
export function meetsWCAGAAA(
  foreground: string,
  background: string,
  isLargeText = false
): boolean {
  const ratio = getContrastRatio(foreground, background);
  return isLargeText ? ratio >= 4.5 : ratio >= 7;
}

/**
 * Get accessible text color (black or white) for a background
 */
export function getAccessibleTextColor(backgroundColor: string): string {
  const whiteContrast = getContrastRatio("#FFFFFF", backgroundColor);
  const blackContrast = getContrastRatio("#000000", backgroundColor);
  return whiteContrast > blackContrast ? "#FFFFFF" : "#000000";
}

/**
 * Announce message to screen readers
 */
export function announceToScreenReader(message: string, priority: "polite" | "assertive" = "polite") {
  const announcement = document.createElement("div");
  announcement.setAttribute("role", "status");
  announcement.setAttribute("aria-live", priority);
  announcement.setAttribute("aria-atomic", "true");
  announcement.className = "sr-only";
  announcement.textContent = message;

  document.body.appendChild(announcement);

  // Remove after announcement
  setTimeout(() => {
    document.body.removeChild(announcement);
  }, 1000);
}

/**
 * Trap focus within an element (for modals, dialogs)
 */
export function trapFocus(element: HTMLElement) {
  const focusableElements = element.querySelectorAll<HTMLElement>(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );

  const firstFocusable = focusableElements[0];
  const lastFocusable = focusableElements[focusableElements.length - 1];

  const handleTabKey = (e: KeyboardEvent) => {
    if (e.key !== "Tab") return;

    if (e.shiftKey) {
      // Shift + Tab
      if (document.activeElement === firstFocusable) {
        lastFocusable.focus();
        e.preventDefault();
      }
    } else {
      // Tab
      if (document.activeElement === lastFocusable) {
        firstFocusable.focus();
        e.preventDefault();
      }
    }
  };

  element.addEventListener("keydown", handleTabKey);

  // Return cleanup function
  return () => {
    element.removeEventListener("keydown", handleTabKey);
  };
}

/**
 * Add keyboard navigation support
 */
export function addKeyboardNavigation(
  elements: HTMLElement[],
  options: {
    orientation?: "horizontal" | "vertical" | "both";
    loop?: boolean;
  } = {}
) {
  const { orientation = "both", loop = true } = options;

  const handleKeyDown = (e: KeyboardEvent, currentIndex: number) => {
    let nextIndex = currentIndex;

    switch (e.key) {
      case "ArrowRight":
        if (orientation === "horizontal" || orientation === "both") {
          nextIndex = currentIndex + 1;
          e.preventDefault();
        }
        break;
      case "ArrowLeft":
        if (orientation === "horizontal" || orientation === "both") {
          nextIndex = currentIndex - 1;
          e.preventDefault();
        }
        break;
      case "ArrowDown":
        if (orientation === "vertical" || orientation === "both") {
          nextIndex = currentIndex + 1;
          e.preventDefault();
        }
        break;
      case "ArrowUp":
        if (orientation === "vertical" || orientation === "both") {
          nextIndex = currentIndex - 1;
          e.preventDefault();
        }
        break;
      case "Home":
        nextIndex = 0;
        e.preventDefault();
        break;
      case "End":
        nextIndex = elements.length - 1;
        e.preventDefault();
        break;
      default:
        return;
    }

    // Handle looping
    if (loop) {
      if (nextIndex < 0) nextIndex = elements.length - 1;
      if (nextIndex >= elements.length) nextIndex = 0;
    } else {
      nextIndex = Math.max(0, Math.min(nextIndex, elements.length - 1));
    }

    if (nextIndex !== currentIndex && elements[nextIndex]) {
      elements[nextIndex].focus();
    }
  };

  elements.forEach((element, index) => {
    element.addEventListener("keydown", (e) => handleKeyDown(e, index));
  });
}

/**
 * Check if user prefers reduced motion
 */
export function prefersReducedMotion(): boolean {
  return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
}

/**
 * Get appropriate animation duration based on user preference
 */
export function getAnimationDuration(defaultMs: number): number {
  return prefersReducedMotion() ? 0 : defaultMs;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/api.ts
=================================================================================
const region = import.meta.env.VITE_FUNCTIONS_REGION || "us-central1";
const projectId = import.meta.env.VITE_FIREBASE_PROJECT_ID || "pls-fix-thx";

// Use local emulator in development, deployed functions in production
function baseUrl() {
  // Check if we're in development mode and should use emulator
  const isDev = import.meta.env.DEV;
  const useEmulator = isDev && !import.meta.env.VITE_USE_PRODUCTION_FUNCTIONS;

  if (useEmulator) {
    return "http://127.0.0.1:5001/pls-fix-thx/us-central1";
  }

  return `https://${region}-${projectId}.cloudfunctions.net`;
}

export async function apiGenerate(prompt: string) {
  const r = await fetch(`${baseUrl()}/generateSlideSpec`, {
    method: "POST",
    headers: { "Content-Type":"application/json" },
    body: JSON.stringify({ prompt })
  });
  if (!r.ok) throw new Error(await r.text());
  return r.json();
}

export async function apiExport(spec: unknown) {
  const r = await fetch(`${baseUrl()}/exportPPTX`, {
    method: "POST",
    headers: { "Content-Type":"application/json" },
    body: JSON.stringify({ spec })
  });
  if (!r.ok) throw new Error(await r.text());
  const blob = await r.blob();
  return blob;
}

export async function apiExportMultiple(specs: unknown[]) {
  const r = await fetch(`${baseUrl()}/exportPPTX`, {
    method: "POST",
    headers: { "Content-Type":"application/json" },
    body: JSON.stringify({ specs })
  });
  if (!r.ok) throw new Error(await r.text());
  const blob = await r.blob();
  return blob;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/colorPalettes.ts
=================================================================================
/**
 * Professional Color Palettes
 * 15 carefully curated palettes with WCAG AA/AAA validation
 */

export interface ColorPalette {
  name: string;
  primary: string;
  accent: string;
  neutral: string[];
  use: string;
  contrast: number;
  psychology: string;
}

export const PROFESSIONAL_PALETTES: Record<string, ColorPalette> = {
  corporate: {
    name: "Corporate Professional",
    primary: "#1E40AF",
    accent: "#10B981",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Business, finance, corporate presentations",
    contrast: 7.2,
    psychology: "Trust, stability, growth"
  },
  tech: {
    name: "Tech Innovation",
    primary: "#2563EB",
    accent: "#8B5CF6",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Technology, startups, innovation",
    contrast: 6.8,
    psychology: "Innovation, intelligence, creativity"
  },
  finance: {
    name: "Finance & Growth",
    primary: "#1E40AF",
    accent: "#F59E0B",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Financial services, growth metrics, investment",
    contrast: 7.1,
    psychology: "Trust, prosperity, opportunity"
  },
  healthcare: {
    name: "Healthcare & Wellness",
    primary: "#0D9488",
    accent: "#0EA5E9",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Healthcare, wellness, medical",
    contrast: 6.5,
    psychology: "Health, trust, calm"
  },
  creative: {
    name: "Creative & Marketing",
    primary: "#EC4899",
    accent: "#F97316",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Creative, marketing, design",
    contrast: 6.9,
    psychology: "Energy, creativity, passion"
  },
  minimal: {
    name: "Minimal & Modern",
    primary: "#1F2937",
    accent: "#6366F1",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Minimal, modern, clean design",
    contrast: 7.5,
    psychology: "Sophistication, clarity, focus"
  },
  eco: {
    name: "Eco & Sustainability",
    primary: "#059669",
    accent: "#84CC16",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Sustainability, environment, nature",
    contrast: 6.7,
    psychology: "Growth, nature, sustainability"
  },
  luxury: {
    name: "Luxury & Premium",
    primary: "#1E1B4B",
    accent: "#D97706",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Luxury, premium, high-end",
    contrast: 7.3,
    psychology: "Elegance, exclusivity, quality"
  },
  education: {
    name: "Education & Learning",
    primary: "#0369A1",
    accent: "#7C3AED",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Education, training, learning",
    contrast: 6.6,
    psychology: "Knowledge, growth, inspiration"
  },
  bold: {
    name: "Bold & Energetic",
    primary: "#DC2626",
    accent: "#EA580C",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Energy, action, urgency",
    contrast: 7.0,
    psychology: "Energy, passion, action"
  },
  cool: {
    name: "Cool & Calm",
    primary: "#0891B2",
    accent: "#06B6D4",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Calm, cool, professional",
    contrast: 6.4,
    psychology: "Calm, trust, clarity"
  },
  warm: {
    name: "Warm & Friendly",
    primary: "#EA580C",
    accent: "#F97316",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Friendly, approachable, warm",
    contrast: 6.8,
    psychology: "Warmth, friendliness, energy"
  },
  grayscale: {
    name: "Professional Grayscale",
    primary: "#1F2937",
    accent: "#6B7280",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Professional, neutral, corporate",
    contrast: 7.4,
    psychology: "Professionalism, neutrality, focus"
  },
  vibrant: {
    name: "Vibrant & Modern",
    primary: "#7C3AED",
    accent: "#06B6D4",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Modern, vibrant, contemporary",
    contrast: 6.9,
    psychology: "Innovation, modernity, creativity"
  },
  classic: {
    name: "Classic & Timeless",
    primary: "#1E3A8A",
    accent: "#7C2D12",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Classic, timeless, traditional",
    contrast: 7.2,
    psychology: "Tradition, stability, heritage"
  },
  sunset: {
    name: "Sunset & Warmth",
    primary: "#EA580C",
    accent: "#F97316",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Warm, inviting, energetic presentations",
    contrast: 6.9,
    psychology: "Warmth, energy, optimism"
  },
  ocean: {
    name: "Ocean & Depth",
    primary: "#0369A1",
    accent: "#0EA5E9",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Water, technology, depth, trust",
    contrast: 6.6,
    psychology: "Trust, depth, clarity"
  },
  forest: {
    name: "Forest & Nature",
    primary: "#15803D",
    accent: "#22C55E",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Nature, sustainability, growth",
    contrast: 6.8,
    psychology: "Growth, nature, renewal"
  },
  midnight: {
    name: "Midnight & Mystery",
    primary: "#1E1B4B",
    accent: "#818CF8",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Premium, sophisticated, modern",
    contrast: 7.1,
    psychology: "Sophistication, mystery, elegance"
  },
  rose: {
    name: "Rose & Elegance",
    primary: "#BE185D",
    accent: "#EC4899",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Fashion, beauty, elegance",
    contrast: 6.7,
    psychology: "Elegance, femininity, sophistication"
  },
  amber: {
    name: "Amber & Warmth",
    primary: "#B45309",
    accent: "#F59E0B",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Warmth, hospitality, comfort",
    contrast: 6.8,
    psychology: "Warmth, comfort, hospitality"
  },
  slate: {
    name: "Slate & Professional",
    primary: "#334155",
    accent: "#64748B",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Professional, neutral, corporate",
    contrast: 7.3,
    psychology: "Professionalism, stability, focus"
  },
  indigo: {
    name: "Indigo & Innovation",
    primary: "#4F46E5",
    accent: "#6366F1",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Technology, innovation, intelligence",
    contrast: 6.5,
    psychology: "Innovation, intelligence, creativity"
  },
  teal: {
    name: "Teal & Balance",
    primary: "#0D9488",
    accent: "#14B8A6",
    neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
    use: "Balance, wellness, modern",
    contrast: 6.7,
    psychology: "Balance, wellness, harmony"
  }
};

export function getPalette(name: string): ColorPalette | undefined {
  return PROFESSIONAL_PALETTES[name];
}

export function getAllPalettes(): ColorPalette[] {
  return Object.values(PROFESSIONAL_PALETTES);
}

export function getPaletteNames(): string[] {
  return Object.keys(PROFESSIONAL_PALETTES);
}

/**
 * Calculate contrast ratio between two colors
 * Returns WCAG contrast ratio (1-21)
 */
export function calculateContrastRatio(foreground: string, background: string): number {
  const fgLum = getRelativeLuminance(foreground);
  const bgLum = getRelativeLuminance(background);
  
  const lighter = Math.max(fgLum, bgLum);
  const darker = Math.min(fgLum, bgLum);
  
  return (lighter + 0.05) / (darker + 0.05);
}

/**
 * Get relative luminance of a color
 */
function getRelativeLuminance(hex: string): number {
  const rgb = hexToRgb(hex);
  if (!rgb) return 0;
  
  const [r, g, b] = rgb.map(val => {
    const v = val / 255;
    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  });
  
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

/**
 * Convert hex color to RGB
 */
function hexToRgb(hex: string): [number, number, number] | null {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? [
    parseInt(result[1], 16),
    parseInt(result[2], 16),
    parseInt(result[3], 16)
  ] : null;
}

/**
 * Validate palette contrast ratios
 */
export function validatePaletteContrast(palette: ColorPalette, minRatio: number = 4.5): boolean {
  const textColor = palette.neutral[0];
  const bgColor = palette.neutral[6];
  const ratio = calculateContrastRatio(textColor, bgColor);
  return ratio >= minRatio;
}

/**
 * Get palette by use case
 */
export function getPaletteByUseCase(useCase: string): ColorPalette | undefined {
  const lower = useCase.toLowerCase();
  
  if (lower.includes("business") || lower.includes("corporate") || lower.includes("finance")) {
    return PROFESSIONAL_PALETTES.corporate;
  }
  if (lower.includes("tech") || lower.includes("startup") || lower.includes("innovation")) {
    return PROFESSIONAL_PALETTES.tech;
  }
  if (lower.includes("health") || lower.includes("medical") || lower.includes("wellness")) {
    return PROFESSIONAL_PALETTES.healthcare;
  }
  if (lower.includes("creative") || lower.includes("marketing") || lower.includes("design")) {
    return PROFESSIONAL_PALETTES.creative;
  }
  if (lower.includes("education") || lower.includes("learning") || lower.includes("training")) {
    return PROFESSIONAL_PALETTES.education;
  }
  if (lower.includes("eco") || lower.includes("sustainability") || lower.includes("environment")) {
    return PROFESSIONAL_PALETTES.eco;
  }
  if (lower.includes("luxury") || lower.includes("premium") || lower.includes("high-end")) {
    return PROFESSIONAL_PALETTES.luxury;
  }
  if (lower.includes("minimal") || lower.includes("modern") || lower.includes("clean")) {
    return PROFESSIONAL_PALETTES.minimal;
  }
  
  return PROFESSIONAL_PALETTES.corporate; // default
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/designQuality.ts
=================================================================================
/**
 * Design Quality Validation & Metrics
 * Validates design quality against professional standards
 */

import type { SlideSpecV2 } from "@/types/SlideSpecV2";
import { calculateContrastRatio } from "./colorPalettes";

export interface DesignQualityScore {
  contrast: number; // 0-100
  hierarchy: number; // 0-100
  whitespace: number; // 0-100
  colorHarmony: number; // 0-100
  typography: number; // 0-100
  accessibility: number; // 0-100
  overall: number; // 0-100
  issues: string[];
  warnings: string[];
}

/**
 * Validate overall design quality
 */
export function validateDesignQuality(spec: SlideSpecV2): DesignQualityScore {
  const issues: string[] = [];
  const warnings: string[] = [];
  
  const contrast = validateContrast(spec, issues, warnings);
  const hierarchy = validateHierarchy(spec, issues, warnings);
  const whitespace = validateWhitespace(spec, issues, warnings);
  const colorHarmony = validateColorHarmony(spec, issues, warnings);
  const typography = validateTypography(spec, issues, warnings);
  const accessibility = validateAccessibility(spec, issues, warnings);
  
  const overall = Math.round(
    (contrast + hierarchy + whitespace + colorHarmony + typography + accessibility) / 6
  );
  
  return {
    contrast,
    hierarchy,
    whitespace,
    colorHarmony,
    typography,
    accessibility,
    overall,
    issues,
    warnings
  };
}

/**
 * Validate contrast ratios (WCAG AA minimum 4.5:1)
 */
function validateContrast(spec: SlideSpecV2, issues: string[], warnings: string[]): number {
  const palette = spec.styleTokens.palette;
  const textColor = palette.neutral[0];
  const bgColor = palette.neutral[6];
  
  const ratio = calculateContrastRatio(textColor, bgColor);
  
  if (ratio >= 7) {
    return 100; // WCAG AAA
  } else if (ratio >= 4.5) {
    return 85; // WCAG AA
  } else if (ratio >= 3) {
    warnings.push(`Contrast ratio ${ratio.toFixed(1)}:1 is below WCAG AA (4.5:1)`);
    return 50;
  } else {
    issues.push(`Contrast ratio ${ratio.toFixed(1)}:1 is critically low`);
    return 20;
  }
}

/**
 * Validate visual hierarchy
 */
function validateHierarchy(spec: SlideSpecV2, issues: string[], warnings: string[]): number {
  const sizes = spec.styleTokens.typography.sizes;
  const step0 = sizes.step_0;
  const step3 = sizes.step_3;
  
  const ratio = step3 / step0;
  
  if (ratio >= 2) {
    return 100; // Excellent hierarchy
  } else if (ratio >= 1.5) {
    return 80; // Good hierarchy
  } else if (ratio >= 1.2) {
    warnings.push("Typography hierarchy could be more pronounced");
    return 60;
  } else {
    issues.push("Typography hierarchy is too subtle");
    return 40;
  }
}

/**
 * Validate white space distribution
 */
function validateWhitespace(spec: SlideSpecV2, issues: string[], warnings: string[]): number {
  const strategy = spec.design.whitespace.strategy;
  const breathing = spec.design.whitespace.breathingRoom;
  
  if (strategy === "generous" && breathing >= 40) {
    return 100;
  } else if (strategy === "balanced" && breathing >= 25) {
    return 100;
  } else if (strategy === "compact" && breathing >= 15) {
    return 100;
  } else if (breathing >= 20) {
    warnings.push("White space could be optimized for better visual balance");
    return 75;
  } else {
    issues.push("Insufficient white space - slide appears cluttered");
    return 50;
  }
}

/**
 * Validate color harmony
 */
function validateColorHarmony(spec: SlideSpecV2, issues: string[], warnings: string[]): number {
  const distribution = spec.design.colorStrategy.distribution;
  const palette = spec.styleTokens.palette;
  
  // Check if colors are valid hex
  const hexPattern = /^#[0-9A-Fa-f]{6}$/;
  if (!hexPattern.test(palette.primary) || !hexPattern.test(palette.accent)) {
    issues.push("Invalid color format - must be hex (#RRGGBB)");
    return 40;
  }
  
  // Validate distribution
  const validDistributions = ["monochromatic", "complementary", "analogous", "triadic"];
  if (!validDistributions.includes(distribution)) {
    warnings.push("Unknown color distribution strategy");
    return 70;
  }
  
  return 90; // Good color harmony
}

/**
 * Validate typography consistency
 */
function validateTypography(spec: SlideSpecV2, issues: string[], warnings: string[]): number {
  const hierarchy = spec.design.typography.hierarchy;

  // Check if hierarchy is defined
  if (!hierarchy || Object.keys(hierarchy).length === 0) {
    warnings.push("Typography hierarchy not fully defined");
    return 70;
  }
  
  // Check font sizes are reasonable
  const minSize = 12;
  const maxSize = 72;
  
  for (const [key, config] of Object.entries(hierarchy)) {
    if (config.size < minSize || config.size > maxSize) {
      issues.push(`Typography size for ${key} (${config.size}px) is out of range`);
      return 50;
    }
    
    if (config.lineHeight < 1.2 || config.lineHeight > 2) {
      warnings.push(`Line height for ${key} (${config.lineHeight}) may be suboptimal`);
    }
  }
  
  return 85; // Good typography
}

/**
 * Validate accessibility compliance
 */
function validateAccessibility(spec: SlideSpecV2, issues: string[], warnings: string[]): number {
  let score = 100;
  
  // Check minimum font size
  const bodySize = spec.styleTokens.typography.sizes.step_0;
  if (bodySize < 16) {
    warnings.push(`Body font size (${bodySize}px) is below recommended 16px minimum`);
    score -= 15;
  }
  
  // Check contrast
  const contrast = calculateContrastRatio(
    spec.styleTokens.palette.neutral[0],
    spec.styleTokens.palette.neutral[6]
  );
  if (contrast < 4.5) {
    issues.push("Contrast ratio below WCAG AA minimum (4.5:1)");
    score -= 30;
  }
  
  // Check line height
  const lineHeight = spec.styleTokens.typography.lineHeights.standard;
  if (lineHeight < 1.5) {
    warnings.push("Line height below recommended 1.5 minimum");
    score -= 10;
  }
  
  return Math.max(0, score);
}

/**
 * Get quality score interpretation
 */
export function getQualityInterpretation(score: number): string {
  if (score >= 90) return "Excellent - Professional quality";
  if (score >= 80) return "Very Good - High quality";
  if (score >= 70) return "Good - Acceptable quality";
  if (score >= 60) return "Fair - Needs improvement";
  if (score >= 50) return "Poor - Significant issues";
  return "Critical - Major problems";
}

/**
 * Get quality color indicator
 */
export function getQualityColor(score: number): string {
  if (score >= 90) return "#10B981"; // Green
  if (score >= 80) return "#3B82F6"; // Blue
  if (score >= 70) return "#F59E0B"; // Amber
  if (score >= 60) return "#F97316"; // Orange
  if (score >= 50) return "#EF4444"; // Red
  return "#DC2626"; // Dark Red
}

/**
 * Format quality report
 */
export function formatQualityReport(score: DesignQualityScore): string {
  let report = `Design Quality Report\n`;
  report += `Overall Score: ${score.overall}/100 (${getQualityInterpretation(score.overall)})\n\n`;
  
  report += `Metrics:\n`;
  report += `  Contrast: ${score.contrast}/100\n`;
  report += `  Hierarchy: ${score.hierarchy}/100\n`;
  report += `  White Space: ${score.whitespace}/100\n`;
  report += `  Color Harmony: ${score.colorHarmony}/100\n`;
  report += `  Typography: ${score.typography}/100\n`;
  report += `  Accessibility: ${score.accessibility}/100\n\n`;
  
  if (score.issues.length > 0) {
    report += `Issues (${score.issues.length}):\n`;
    score.issues.forEach(issue => {
      report += `  ‚ùå ${issue}\n`;
    });
    report += `\n`;
  }
  
  if (score.warnings.length > 0) {
    report += `Warnings (${score.warnings.length}):\n`;
    score.warnings.forEach(warning => {
      report += `  ‚ö†Ô∏è  ${warning}\n`;
    });
  }
  
  return report;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/env.ts
=================================================================================
import { z } from "zod";

/** Environment variable schema */
const envSchema = z.object({
  // Firebase config is optional since it can be hardcoded in firebase.ts
  VITE_FIREBASE_API_KEY: z.string().optional(),
  VITE_FIREBASE_AUTH_DOMAIN: z.string().optional(),
  VITE_FIREBASE_PROJECT_ID: z.string().optional(),
  VITE_FIREBASE_STORAGE_BUCKET: z.string().optional(),
  VITE_FIREBASE_MESSAGING_SENDER_ID: z.string().optional(),
  VITE_FIREBASE_APP_ID: z.string().optional(),
  VITE_FIREBASE_MEASUREMENT_ID: z.string().optional(),
  VITE_FUNCTIONS_BASE_URL: z.string().url("Functions base URL must be a valid URL").optional(),
  VITE_FUNCTIONS_REGION: z.string().optional(),
  MODE: z.enum(["development", "production", "test"]).optional(),
  DEV: z.boolean().optional(),
  PROD: z.boolean().optional(),
});

type Env = z.infer<typeof envSchema>;

/** Validated environment variables */
let validatedEnv: Env | null = null;

/** Validate environment variables at startup */
export function validateEnv(): Env {
  if (validatedEnv) {
    return validatedEnv;
  }

  try {
    validatedEnv = envSchema.parse(import.meta.env);
    console.log("‚úÖ Environment variables validated successfully");
    return validatedEnv;
  } catch (error) {
    if (error instanceof z.ZodError) {
      console.error("‚ùå Environment validation failed:");
      error.issues.forEach((err: any) => {
        console.error(`  - ${err.path.join(".")}: ${err.message}`);
      });

      // In development, show a helpful error message
      if (import.meta.env.DEV) {
        const missingVars = error.issues.map((e: any) => e.path.join(".")).join(", ");
        throw new Error(
          `Missing or invalid environment variables: ${missingVars}\n\n` +
          `Please check your .env file and ensure all required variables are set.\n` +
          `See .env.example for reference.`
        );
      }
    }
    throw error;
  }
}

/** Get validated environment variables */
export function getEnv(): Env {
  if (!validatedEnv) {
    return validateEnv();
  }
  return validatedEnv;
}

/** Check if running in development mode */
export function isDevelopment(): boolean {
  return import.meta.env.DEV === true;
}

/** Check if running in production mode */
export function isProduction(): boolean {
  return import.meta.env.PROD === true;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/firebase.ts
=================================================================================
import { initializeApp } from "firebase/app";
import { getAnalytics, isSupported } from "firebase/analytics";

/** Provided config (unchanged) */
const firebaseConfig = {
  apiKey: "AIzaSyAFFyRB7F7LHNVraB5xL7zSunVPa7zbq9E",
  authDomain: "pls-fix-thx.firebaseapp.com",
  projectId: "pls-fix-thx",
  storageBucket: "pls-fix-thx.firebasestorage.app",
  messagingSenderId: "684982102967",
  appId: "1:684982102967:web:ede742c0e2e5d497c61632",
  measurementId: "G-04FXJHYHCS"
};

export const app = initializeApp(firebaseConfig);

// Analytics optional; safe-check for SSR/emulator
export async function initAnalytics() {
  try {
    if (typeof window !== "undefined" && (await isSupported())) {
      return getAnalytics(app);
    }
  } catch {}
  return null;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/layoutPatterns.ts
=================================================================================
/**
 * Professional Layout Composition Patterns
 * 6 predefined patterns for professional slide layouts
 */

export type LayoutPatternName = "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused";

export interface RegionLayout {
  x: number; // left position (inches)
  y: number; // top position (inches)
  w: number; // width (inches)
  h: number; // height (inches)
}

export interface LayoutPattern {
  name: string;
  description: string;
  pattern: LayoutPatternName;
  regions: Record<string, RegionLayout>;
  whitespacePercentage: number;
  bestFor: string[];
}

// Standard slide dimensions: 10" x 7.5" (16:9)
const SLIDE_WIDTH = 10;
const SLIDE_HEIGHT = 7.5;
const MARGIN = 0.5;

export const LAYOUT_PATTERNS: Record<LayoutPatternName, LayoutPattern> = {
  hero: {
    name: "Hero Pattern",
    description: "Large title/image focus with supporting content",
    pattern: "hero",
    regions: {
      header: {
        x: MARGIN,
        y: MARGIN,
        w: SLIDE_WIDTH - 2 * MARGIN,
        h: SLIDE_HEIGHT * 0.6 - MARGIN
      },
      body: {
        x: MARGIN,
        y: SLIDE_HEIGHT * 0.6 + MARGIN,
        w: SLIDE_WIDTH - 2 * MARGIN,
        h: SLIDE_HEIGHT * 0.4 - 2 * MARGIN
      }
    },
    whitespacePercentage: 25,
    bestFor: ["Cover slides", "Announcements", "Key messages", "Hero images"]
  },
  split: {
    name: "Split Pattern",
    description: "50/50 left/right content division",
    pattern: "split",
    regions: {
      header: {
        x: MARGIN,
        y: MARGIN,
        w: SLIDE_WIDTH - 2 * MARGIN,
        h: 1.5
      },
      left: {
        x: MARGIN,
        y: 2,
        w: SLIDE_WIDTH / 2 - MARGIN - 0.25,
        h: SLIDE_HEIGHT - 2.5
      },
      right: {
        x: SLIDE_WIDTH / 2 + 0.25,
        y: 2,
        w: SLIDE_WIDTH / 2 - MARGIN - 0.25,
        h: SLIDE_HEIGHT - 2.5
      }
    },
    whitespacePercentage: 20,
    bestFor: ["Comparisons", "Before/after", "Two-column content", "Pros/cons"]
  },
  asymmetric: {
    name: "Asymmetric Pattern",
    description: "Dynamic off-center layout with visual balance",
    pattern: "asymmetric",
    regions: {
      header: {
        x: MARGIN,
        y: MARGIN,
        w: SLIDE_WIDTH - 2 * MARGIN,
        h: 1.2
      },
      primary: {
        x: MARGIN,
        y: 1.8,
        w: SLIDE_WIDTH * 0.65 - MARGIN,
        h: SLIDE_HEIGHT - 2.3
      },
      secondary: {
        x: SLIDE_WIDTH * 0.65 + 0.25,
        y: 1.8,
        w: SLIDE_WIDTH * 0.35 - MARGIN - 0.25,
        h: SLIDE_HEIGHT - 2.3
      }
    },
    whitespacePercentage: 22,
    bestFor: ["Dynamic layouts", "Creative presentations", "Feature highlights"]
  },
  grid: {
    name: "Grid Pattern",
    description: "Structured multi-element layout",
    pattern: "grid",
    regions: {
      header: {
        x: MARGIN,
        y: MARGIN,
        w: SLIDE_WIDTH - 2 * MARGIN,
        h: 1.2
      },
      item1: {
        x: MARGIN,
        y: 1.8,
        w: (SLIDE_WIDTH - 2 * MARGIN - 0.25) / 2,
        h: (SLIDE_HEIGHT - 2.3) / 2
      },
      item2: {
        x: SLIDE_WIDTH / 2 + 0.25,
        y: 1.8,
        w: (SLIDE_WIDTH - 2 * MARGIN - 0.25) / 2,
        h: (SLIDE_HEIGHT - 2.3) / 2
      },
      item3: {
        x: MARGIN,
        y: SLIDE_HEIGHT / 2 + 0.8,
        w: (SLIDE_WIDTH - 2 * MARGIN - 0.25) / 2,
        h: (SLIDE_HEIGHT - 2.3) / 2
      },
      item4: {
        x: SLIDE_WIDTH / 2 + 0.25,
        y: SLIDE_HEIGHT / 2 + 0.8,
        w: (SLIDE_WIDTH - 2 * MARGIN - 0.25) / 2,
        h: (SLIDE_HEIGHT - 2.3) / 2
      }
    },
    whitespacePercentage: 18,
    bestFor: ["Multiple items", "Portfolio", "Process steps", "Features"]
  },
  minimal: {
    name: "Minimal Pattern",
    description: "Single focal point with generous white space",
    pattern: "minimal",
    regions: {
      content: {
        x: SLIDE_WIDTH * 0.2,
        y: SLIDE_HEIGHT * 0.25,
        w: SLIDE_WIDTH * 0.6,
        h: SLIDE_HEIGHT * 0.5
      }
    },
    whitespacePercentage: 45,
    bestFor: ["Key messages", "Quotes", "Emphasis", "Minimal design"]
  },
  "data-focused": {
    name: "Data-Focused Pattern",
    description: "Chart/data as primary focus with supporting text",
    pattern: "data-focused",
    regions: {
      header: {
        x: MARGIN,
        y: MARGIN,
        w: SLIDE_WIDTH - 2 * MARGIN,
        h: 0.8
      },
      chart: {
        x: MARGIN,
        y: 1.2,
        w: SLIDE_WIDTH * 0.65 - MARGIN,
        h: SLIDE_HEIGHT - 1.7
      },
      sidebar: {
        x: SLIDE_WIDTH * 0.65 + 0.25,
        y: 1.2,
        w: SLIDE_WIDTH * 0.35 - MARGIN - 0.25,
        h: SLIDE_HEIGHT - 1.7
      }
    },
    whitespacePercentage: 18,
    bestFor: ["Analytics", "Metrics", "Data visualization", "Charts"]
  }
};

export function getLayoutPattern(pattern: LayoutPatternName): LayoutPattern | undefined {
  return LAYOUT_PATTERNS[pattern];
}

export function getAllLayoutPatterns(): LayoutPattern[] {
  return Object.values(LAYOUT_PATTERNS);
}

export function getLayoutPatternNames(): LayoutPatternName[] {
  return Object.keys(LAYOUT_PATTERNS) as LayoutPatternName[];
}

/**
 * Get layout pattern by use case
 */
export function getLayoutByUseCase(useCase: string): LayoutPattern | undefined {
  const lower = useCase.toLowerCase();
  
  if (lower.includes("data") || lower.includes("chart") || lower.includes("metric")) {
    return LAYOUT_PATTERNS["data-focused"];
  }
  if (lower.includes("minimal") || lower.includes("quote") || lower.includes("message")) {
    return LAYOUT_PATTERNS.minimal;
  }
  if (lower.includes("compare") || lower.includes("before") || lower.includes("after")) {
    return LAYOUT_PATTERNS.split;
  }
  if (lower.includes("dynamic") || lower.includes("creative") || lower.includes("feature")) {
    return LAYOUT_PATTERNS.asymmetric;
  }
  if (lower.includes("multiple") || lower.includes("portfolio") || lower.includes("process")) {
    return LAYOUT_PATTERNS.grid;
  }
  if (lower.includes("cover") || lower.includes("announcement") || lower.includes("hero")) {
    return LAYOUT_PATTERNS.hero;
  }
  
  return LAYOUT_PATTERNS.split; // default
}

/**
 * Validate layout pattern
 */
export function validateLayoutPattern(pattern: LayoutPattern): boolean {
  const regions = Object.values(pattern.regions);
  
  return regions.every(region => 
    region.x >= 0 &&
    region.y >= 0 &&
    region.w > 0 &&
    region.h > 0 &&
    region.x + region.w <= SLIDE_WIDTH &&
    region.y + region.h <= SLIDE_HEIGHT
  );
}

/**
 * Get region by name from pattern
 */
export function getRegion(pattern: LayoutPattern, regionName: string): RegionLayout | undefined {
  return pattern.regions[regionName];
}

/**
 * Calculate total white space percentage
 */
export function calculateWhitespacePercentage(pattern: LayoutPattern): number {
  const totalArea = SLIDE_WIDTH * SLIDE_HEIGHT;
  const usedArea = Object.values(pattern.regions).reduce((sum, region) => 
    sum + (region.w * region.h), 0
  );
  const whiteSpace = totalArea - usedArea;
  return (whiteSpace / totalArea) * 100;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/logger.ts
=================================================================================
import { isDevelopment } from "./env";

const LogLevel = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
} as const;

type LogLevel = typeof LogLevel[keyof typeof LogLevel];

interface LogContext {
  [key: string]: any;
}

class Logger {
  private minLevel: LogLevel;

  constructor() {
    this.minLevel = isDevelopment() ? LogLevel.DEBUG : LogLevel.INFO;
  }

  private shouldLog(level: LogLevel): boolean {
    return level >= this.minLevel;
  }

  private formatMessage(level: string, message: string, context?: LogContext): string {
    const timestamp = new Date().toISOString();
    const contextStr = context ? ` ${JSON.stringify(context)}` : "";
    return `[${timestamp}] [${level}] ${message}${contextStr}`;
  }

  debug(message: string, context?: LogContext): void {
    if (this.shouldLog(LogLevel.DEBUG)) {
      console.debug(this.formatMessage("DEBUG", message, context));
    }
  }

  info(message: string, context?: LogContext): void {
    if (this.shouldLog(LogLevel.INFO)) {
      console.info(this.formatMessage("INFO", message, context));
    }
  }

  warn(message: string, context?: LogContext): void {
    if (this.shouldLog(LogLevel.WARN)) {
      console.warn(this.formatMessage("WARN", message, context));
    }
  }

  error(message: string, error?: Error | unknown, context?: LogContext): void {
    if (this.shouldLog(LogLevel.ERROR)) {
      const errorContext = {
        ...context,
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack,
        } : error,
      };
      console.error(this.formatMessage("ERROR", message, errorContext));
    }
  }

  /** Log API call */
  apiCall(method: string, url: string, context?: LogContext): void {
    this.debug(`API ${method} ${url}`, context);
  }

  /** Log API response */
  apiResponse(method: string, url: string, status: number, duration: number): void {
    const level = status >= 400 ? LogLevel.ERROR : status >= 300 ? LogLevel.WARN : LogLevel.DEBUG;
    const message = `API ${method} ${url} - ${status} (${duration}ms)`;
    
    if (level === LogLevel.ERROR) {
      this.error(message);
    } else if (level === LogLevel.WARN) {
      this.warn(message);
    } else {
      this.debug(message);
    }
  }

  /** Log user action */
  userAction(action: string, context?: LogContext): void {
    this.info(`User action: ${action}`, context);
  }

  /** Log performance metric */
  performance(metric: string, value: number, unit: string = "ms"): void {
    this.debug(`Performance: ${metric} = ${value}${unit}`);
  }
}

export const logger = new Logger();



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/pdfExport.ts
=================================================================================
import jsPDF from "jspdf";
import html2canvas from "html2canvas";
import type { Presentation } from "@/types/Presentation";
import { logger } from "./logger";

export interface PDFExportOptions {
  orientation?: "portrait" | "landscape";
  quality?: number;
  includeMetadata?: boolean;
}

export async function exportPresentationToPDF(
  presentation: Presentation,
  slideElements: HTMLElement[],
  options: PDFExportOptions = {}
): Promise<Blob> {
  const {
    orientation = "landscape",
    quality = 0.95,
    includeMetadata = true,
  } = options;

  const startTime = performance.now();
  logger.info("Starting PDF export", { 
    slideCount: presentation.slides.length,
    orientation 
  });

  try {
    // Create PDF document
    const pdf = new jsPDF({
      orientation,
      unit: "px",
      format: orientation === "landscape" ? [1920, 1080] : [1080, 1920],
      compress: true,
    });

    // Add metadata
    if (includeMetadata) {
      pdf.setProperties({
        title: presentation.title,
        subject: "Generated presentation",
        author: "plzfixthx",
        creator: "plzfixthx",
        keywords: "presentation, slides",
      });
    }

    // Process each slide
    for (let i = 0; i < slideElements.length; i++) {
      const element = slideElements[i];
      
      logger.info(`Rendering slide ${i + 1} to canvas`);
      
      // Convert slide to canvas
      const canvas = await html2canvas(element, {
        scale: 2, // Higher quality
        useCORS: true,
        logging: false,
        backgroundColor: "#ffffff",
      });

      // Convert canvas to image
      const imgData = canvas.toDataURL("image/jpeg", quality);
      const imgWidth = pdf.internal.pageSize.getWidth();
      const imgHeight = pdf.internal.pageSize.getHeight();

      // Add new page for slides after the first
      if (i > 0) {
        pdf.addPage();
      }

      // Add image to PDF
      pdf.addImage(imgData, "JPEG", 0, 0, imgWidth, imgHeight);
      
      logger.info(`Added slide ${i + 1} to PDF`);
    }

    // Generate blob
    const blob = pdf.output("blob");
    
    const duration = performance.now() - startTime;
    logger.performance("pdf_export", duration);
    logger.info("PDF export completed", { 
      slideCount: presentation.slides.length,
      size: blob.size,
      duration 
    });

    return blob;
  } catch (error) {
    logger.error("PDF export failed", error);
    throw new Error("Failed to export presentation to PDF");
  }
}

export async function downloadPDF(
  presentation: Presentation,
  slideElements: HTMLElement[],
  filename?: string,
  options?: PDFExportOptions
): Promise<void> {
  const blob = await exportPresentationToPDF(presentation, slideElements, options);
  
  const finalFilename = filename || 
    `${presentation.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.pdf`;
  
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = finalFilename;
  a.click();
  URL.revokeObjectURL(url);
  
  logger.info("PDF downloaded", { filename: finalFilename });
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/registerSW.ts
=================================================================================
import { logger } from "./logger";

export function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker
        .register('/sw.js')
        .then((registration) => {
          logger.info('Service Worker registered', { scope: registration.scope });

          // Check for updates periodically
          setInterval(() => {
            registration.update();
          }, 60 * 60 * 1000); // Check every hour

          // Listen for updates
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            if (newWorker) {
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New service worker available
                  logger.info('New service worker available');
                  
                  // Optionally show a notification to the user
                  if (confirm('A new version is available. Reload to update?')) {
                    window.location.reload();
                  }
                }
              });
            }
          });
        })
        .catch((error) => {
          logger.error('Service Worker registration failed', error);
        });
    });
  }
}

export function unregisterServiceWorker() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready
      .then((registration) => {
        registration.unregister();
        logger.info('Service Worker unregistered');
      })
      .catch((error) => {
        logger.error('Service Worker unregistration failed', error);
      });
  }
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/templates.ts
=================================================================================
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export interface Template {
  id: string;
  name: string;
  description: string;
  category: "business" | "education" | "marketing" | "creative" | "minimal";
  thumbnail: string;
  spec: Partial<SlideSpecV1>;
}

export const TEMPLATES: Template[] = [
  {
    id: "business-professional",
    name: "Business Professional",
    description: "Clean and professional design for corporate presentations",
    category: "business",
    thumbnail: "üíº",
    spec: {
      meta: {
        version: "1.0",
        locale: "en-US",
        theme: "Business Professional",
        aspectRatio: "16:9",
      },
      styleTokens: {
        palette: {
          primary: "#1E40AF",
          accent: "#10B981",
          neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
        },
        typography: {
          fonts: { sans: "Inter, Arial, sans-serif" },
          sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 32 },
          weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
          lineHeights: { compact: 1.2, standard: 1.5 },
        },
        spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32] },
        radii: { sm: 2, md: 6, lg: 12 },
        shadows: {
          sm: "0 1px 2px rgba(0,0,0,.06)",
          md: "0 4px 8px rgba(0,0,0,.12)",
          lg: "0 12px 24px rgba(0,0,0,.18)",
        },
        contrast: { minTextContrast: 4.5, minUiContrast: 3 },
      },
    },
  },
  {
    id: "education-bright",
    name: "Education Bright",
    description: "Colorful and engaging design for educational content",
    category: "education",
    thumbnail: "üéì",
    spec: {
      meta: {
        version: "1.0",
        locale: "en-US",
        theme: "Education Bright",
        aspectRatio: "16:9",
      },
      styleTokens: {
        palette: {
          primary: "#059669",
          accent: "#F59E0B",
          neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
        },
        typography: {
          fonts: { sans: "Inter, Arial, sans-serif" },
          sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 32 },
          weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
          lineHeights: { compact: 1.2, standard: 1.5 },
        },
        spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32] },
        radii: { sm: 4, md: 8, lg: 16 },
        shadows: {
          sm: "0 1px 2px rgba(0,0,0,.06)",
          md: "0 4px 8px rgba(0,0,0,.12)",
          lg: "0 12px 24px rgba(0,0,0,.18)",
        },
        contrast: { minTextContrast: 4.5, minUiContrast: 3 },
      },
    },
  },
  {
    id: "marketing-vibrant",
    name: "Marketing Vibrant",
    description: "Bold and eye-catching design for marketing presentations",
    category: "marketing",
    thumbnail: "üìä",
    spec: {
      meta: {
        version: "1.0",
        locale: "en-US",
        theme: "Marketing Vibrant",
        aspectRatio: "16:9",
      },
      styleTokens: {
        palette: {
          primary: "#EC4899",
          accent: "#F59E0B",
          neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
        },
        typography: {
          fonts: { sans: "Inter, Arial, sans-serif" },
          sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 36 },
          weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
          lineHeights: { compact: 1.2, standard: 1.5 },
        },
        spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32] },
        radii: { sm: 4, md: 8, lg: 16 },
        shadows: {
          sm: "0 1px 2px rgba(0,0,0,.06)",
          md: "0 4px 8px rgba(0,0,0,.12)",
          lg: "0 12px 24px rgba(0,0,0,.18)",
        },
        contrast: { minTextContrast: 4.5, minUiContrast: 3 },
      },
    },
  },
  {
    id: "creative-modern",
    name: "Creative Modern",
    description: "Contemporary design with bold typography and colors",
    category: "creative",
    thumbnail: "üé®",
    spec: {
      meta: {
        version: "1.0",
        locale: "en-US",
        theme: "Creative Modern",
        aspectRatio: "16:9",
      },
      styleTokens: {
        palette: {
          primary: "#8B5CF6",
          accent: "#06B6D4",
          neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
        },
        typography: {
          fonts: { sans: "Inter, Arial, sans-serif" },
          sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 28, step_3: 40 },
          weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
          lineHeights: { compact: 1.1, standard: 1.4 },
        },
        spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32] },
        radii: { sm: 8, md: 12, lg: 20 },
        shadows: {
          sm: "0 1px 2px rgba(0,0,0,.06)",
          md: "0 4px 8px rgba(0,0,0,.12)",
          lg: "0 12px 24px rgba(0,0,0,.18)",
        },
        contrast: { minTextContrast: 4.5, minUiContrast: 3 },
      },
    },
  },
  {
    id: "minimal-clean",
    name: "Minimal Clean",
    description: "Simple and elegant design with lots of white space",
    category: "minimal",
    thumbnail: "‚ö™",
    spec: {
      meta: {
        version: "1.0",
        locale: "en-US",
        theme: "Minimal Clean",
        aspectRatio: "16:9",
      },
      styleTokens: {
        palette: {
          primary: "#0F172A",
          accent: "#6366F1",
          neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0"],
        },
        typography: {
          fonts: { sans: "Inter, Arial, sans-serif" },
          sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 18, step_2: 22, step_3: 28 },
          weights: { regular: 300, medium: 400, semibold: 500, bold: 600 },
          lineHeights: { compact: 1.3, standard: 1.6 },
        },
        spacing: { base: 4, steps: [0, 8, 16, 24, 32, 48, 64] },
        radii: { sm: 0, md: 2, lg: 4 },
        shadows: {
          sm: "0 1px 2px rgba(0,0,0,.03)",
          md: "0 2px 4px rgba(0,0,0,.06)",
          lg: "0 4px 8px rgba(0,0,0,.09)",
        },
        contrast: { minTextContrast: 4.5, minUiContrast: 3 },
      },
    },
  },
];

export function getTemplateById(id: string): Template | undefined {
  return TEMPLATES.find((t) => t.id === id);
}

export function getTemplatesByCategory(category: Template["category"]): Template[] {
  return TEMPLATES.filter((t) => t.category === category);
}

export function applyTemplate(template: Template, content: SlideSpecV1["content"]): SlideSpecV1 {
  return {
    ...template.spec,
    content,
    meta: template.spec.meta!,
    layout: template.spec.layout || {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 24, r: 24, b: 24, l: 24 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 6, colSpan: 12 },
      ],
      anchors: [{ refId: "title", region: "header", order: 0 }],
    },
    styleTokens: template.spec.styleTokens!,
  } as SlideSpecV1;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/typographyPairs.ts
=================================================================================
/**
 * Professional Typography Pairings
 * 12 carefully curated font pairings with specifications
 */

export interface TypographyPair {
  name: string;
  strategy: string;
  primary: string; // heading font
  secondary: string; // body font
  sizes: {
    title: number;
    subtitle: number;
    body: number;
    caption: number;
  };
  weights: {
    title: number;
    subtitle: number;
    body: number;
    caption: number;
  };
  lineHeights: {
    title: number;
    subtitle: number;
    body: number;
    caption: number;
  };
  use: string;
}

export const TYPOGRAPHY_PAIRS: Record<string, TypographyPair> = {
  classic: {
    name: "Classic Elegance",
    strategy: "classic",
    primary: "Georgia, serif",
    secondary: "Inter, sans-serif",
    sizes: { title: 40, subtitle: 28, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.2, subtitle: 1.4, body: 1.6, caption: 1.5 },
    use: "Traditional, elegant, professional"
  },
  modern: {
    name: "Modern Minimalist",
    strategy: "modern",
    primary: "Poppins, sans-serif",
    secondary: "Inter, sans-serif",
    sizes: { title: 36, subtitle: 24, body: 16, caption: 14 },
    weights: { title: 600, subtitle: 500, body: 400, caption: 400 },
    lineHeights: { title: 1.4, subtitle: 1.5, body: 1.5, caption: 1.4 },
    use: "Modern, clean, contemporary"
  },
  bold: {
    name: "Bold & Impactful",
    strategy: "bold",
    primary: "Playfair Display, serif",
    secondary: "Montserrat, sans-serif",
    sizes: { title: 44, subtitle: 32, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.3, subtitle: 1.4, body: 1.5, caption: 1.4 },
    use: "Bold, impactful, creative"
  },
  minimal: {
    name: "Minimal & Refined",
    strategy: "minimal",
    primary: "Inter, sans-serif",
    secondary: "Inter, sans-serif",
    sizes: { title: 40, subtitle: 28, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.4, subtitle: 1.5, body: 1.5, caption: 1.4 },
    use: "Minimal, refined, focused"
  },
  elegant: {
    name: "Elegant & Sophisticated",
    strategy: "elegant",
    primary: "Cormorant, serif",
    secondary: "Lato, sans-serif",
    sizes: { title: 48, subtitle: 32, body: 16, caption: 14 },
    weights: { title: 600, subtitle: 500, body: 400, caption: 400 },
    lineHeights: { title: 1.5, subtitle: 1.6, body: 1.6, caption: 1.5 },
    use: "Elegant, sophisticated, luxury"
  },
  tech: {
    name: "Tech & Modern",
    strategy: "tech",
    primary: "Sora, sans-serif",
    secondary: "Sora, sans-serif",
    sizes: { title: 40, subtitle: 28, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.4, subtitle: 1.5, body: 1.5, caption: 1.4 },
    use: "Technology, modern, innovative"
  },
  friendly: {
    name: "Friendly & Approachable",
    strategy: "friendly",
    primary: "Quicksand, sans-serif",
    secondary: "Open Sans, sans-serif",
    sizes: { title: 36, subtitle: 24, body: 16, caption: 14 },
    weights: { title: 600, subtitle: 500, body: 400, caption: 400 },
    lineHeights: { title: 1.5, subtitle: 1.6, body: 1.6, caption: 1.5 },
    use: "Friendly, approachable, warm"
  },
  corporate: {
    name: "Professional & Corporate",
    strategy: "corporate",
    primary: "Roboto, sans-serif",
    secondary: "Roboto, sans-serif",
    sizes: { title: 40, subtitle: 28, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.4, subtitle: 1.5, body: 1.5, caption: 1.4 },
    use: "Professional, corporate, business"
  },
  creative: {
    name: "Creative & Artistic",
    strategy: "creative",
    primary: "Abril Fatface, serif",
    secondary: "Raleway, sans-serif",
    sizes: { title: 48, subtitle: 32, body: 16, caption: 14 },
    weights: { title: 400, subtitle: 400, body: 400, caption: 400 },
    lineHeights: { title: 1.5, subtitle: 1.6, body: 1.6, caption: 1.5 },
    use: "Creative, artistic, design-focused"
  },
  educational: {
    name: "Educational & Clear",
    strategy: "educational",
    primary: "Nunito, sans-serif",
    secondary: "Nunito, sans-serif",
    sizes: { title: 40, subtitle: 28, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.5, subtitle: 1.6, body: 1.6, caption: 1.5 },
    use: "Educational, clear, accessible"
  },
  premium: {
    name: "Luxury & Premium",
    strategy: "premium",
    primary: "Bodoni Moda, serif",
    secondary: "Lora, serif",
    sizes: { title: 48, subtitle: 32, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.6, subtitle: 1.7, body: 1.7, caption: 1.6 },
    use: "Luxury, premium, high-end"
  },
  energetic: {
    name: "Bold & Energetic",
    strategy: "energetic",
    primary: "Bebas Neue, sans-serif",
    secondary: "Lato, sans-serif",
    sizes: { title: 44, subtitle: 32, body: 16, caption: 14 },
    weights: { title: 700, subtitle: 600, body: 400, caption: 400 },
    lineHeights: { title: 1.3, subtitle: 1.5, body: 1.5, caption: 1.4 },
    use: "Bold, energetic, dynamic"
  }
};

export function getTypographyPair(strategy: string): TypographyPair | undefined {
  return TYPOGRAPHY_PAIRS[strategy];
}

export function getAllTypographyPairs(): TypographyPair[] {
  return Object.values(TYPOGRAPHY_PAIRS);
}

export function getTypographyPairNames(): string[] {
  return Object.keys(TYPOGRAPHY_PAIRS);
}

/**
 * Get typography pair by use case
 */
export function getTypographyByUseCase(useCase: string): TypographyPair | undefined {
  const lower = useCase.toLowerCase();
  
  if (lower.includes("business") || lower.includes("corporate")) {
    return TYPOGRAPHY_PAIRS.corporate;
  }
  if (lower.includes("tech") || lower.includes("modern")) {
    return TYPOGRAPHY_PAIRS.tech;
  }
  if (lower.includes("creative") || lower.includes("artistic")) {
    return TYPOGRAPHY_PAIRS.creative;
  }
  if (lower.includes("education") || lower.includes("learning")) {
    return TYPOGRAPHY_PAIRS.educational;
  }
  if (lower.includes("luxury") || lower.includes("premium")) {
    return TYPOGRAPHY_PAIRS.premium;
  }
  if (lower.includes("minimal") || lower.includes("clean")) {
    return TYPOGRAPHY_PAIRS.minimal;
  }
  if (lower.includes("elegant") || lower.includes("sophisticated")) {
    return TYPOGRAPHY_PAIRS.elegant;
  }
  if (lower.includes("friendly") || lower.includes("approachable")) {
    return TYPOGRAPHY_PAIRS.friendly;
  }
  if (lower.includes("bold") || lower.includes("energetic")) {
    return TYPOGRAPHY_PAIRS.energetic;
  }
  
  return TYPOGRAPHY_PAIRS.modern; // default
}

/**
 * Validate typography pair
 */
export function validateTypographyPair(pair: TypographyPair): boolean {
  return !!(
    pair.primary &&
    pair.secondary &&
    pair.sizes.title > pair.sizes.subtitle &&
    pair.sizes.subtitle > pair.sizes.body &&
    pair.sizes.body > pair.sizes.caption &&
    pair.lineHeights.title > 0 &&
    pair.lineHeights.body >= 1.5
  );
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/lib/validation.ts
=================================================================================
import { z } from "zod";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export const SlideSpecZ = z.object({
  meta: z.object({
    version: z.literal("1.0"),
    locale: z.string().default("en-US"),
    theme: z.string(),
    aspectRatio: z.enum(["16:9","4:3"]).default("16:9")
  }),
  content: z.object({
    title: z.object({ id: z.string(), text: z.string().min(1) }),
    subtitle: z.object({ id: z.string(), text: z.string().min(1) }).optional(),
    bullets: z.array(z.object({
      id: z.string(),
      items: z.array(z.object({ text: z.string().min(1), level: z.number().int().min(1).max(3) })).min(1).max(8)
    })).max(3).optional(),
    callouts: z.array(z.object({
      id: z.string(), title: z.string().optional(), text: z.string(), variant: z.enum(["note","success","warning","danger"])
    })).max(2).optional(),
    dataViz: z.object({
      id: z.string(),
      kind: z.enum(["bar","line","pie"]),
      title: z.string().optional(),
      labels: z.array(z.string()).min(2).max(10),
      series: z.array(z.object({ name: z.string(), values: z.array(z.number()) })).min(1).max(3),
      valueFormat: z.enum(["number","percent","currency","auto"]).default("auto")
    }).refine(d => d.series.every(s => s.values.length === d.labels.length), "series length mismatch")
      .optional(),
    imagePlaceholders: z.array(z.object({
      id: z.string(), role: z.enum(["hero","logo","illustration","icon"]), alt: z.string().min(1)
    })).max(2).optional()
  }),
  layout: z.object({
    grid: z.object({
      rows: z.number().int().min(3).max(12),
      cols: z.number().int().min(3).max(12),
      gutter: z.number().min(0),
      margin: z.object({ t: z.number(), r: z.number(), b: z.number(), l: z.number() })
    }),
    regions: z.array(z.object({
      name: z.enum(["header","body","footer","aside"]),
      rowStart: z.number().int().positive(), colStart: z.number().int().positive(),
      rowSpan: z.number().int().positive(),  colSpan: z.number().int().positive()
    })).min(1).max(4),
    anchors: z.array(z.object({
      refId: z.string(), region: z.enum(["header","body","footer","aside"]), order: z.number().int().min(0),
      span: z.object({ rows: z.number().int().positive(), cols: z.number().int().positive() }).optional()
    })).min(1).max(8)
  }),
  styleTokens: z.object({
    palette: z.object({ primary: z.string(), accent: z.string(), neutral: z.array(z.string()).min(5).max(9) }),
    typography: z.object({
      fonts: z.object({ sans: z.string(), serif: z.string().optional(), mono: z.string().optional() }),
      sizes: z.object({ "step_-2": z.number(), "step_-1": z.number(), step_0: z.number(), step_1: z.number(), step_2: z.number(), step_3: z.number() }),
      weights: z.object({ regular: z.number(), medium: z.number(), semibold: z.number(), bold: z.number() }),
      lineHeights: z.object({ compact: z.number(), standard: z.number() })
    }),
    spacing: z.object({ base: z.number(), steps: z.array(z.number()).min(5).max(10) }),
    radii: z.object({ sm: z.number(), md: z.number(), lg: z.number() }),
    shadows: z.object({ sm: z.string(), md: z.string(), lg: z.string() }),
    contrast: z.object({ minTextContrast: z.number(), minUiContrast: z.number() })
  }),
  components: z.object({
    bulletList: z.object({ variant: z.enum(["compact","spacious"]).optional() }).optional(),
    callout: z.object({ variant: z.enum(["flat","elevated"]).optional() }).optional(),
    chart: z.object({ legend: z.enum(["none","right","bottom"]).optional(), gridlines: z.boolean().optional() }).optional(),
    image: z.object({ fit: z.enum(["cover","contain"]).optional() }).optional(),
    title: z.object({ align: z.enum(["left","center","right"]).optional() }).optional()
  }).optional()
});
export type SlideSpec = z.infer<typeof SlideSpecZ>;

export function normalizeOrFallback(raw: unknown): SlideSpecV1 {
  const res = SlideSpecZ.safeParse(raw);
  if (res.success) return res.data as SlideSpecV1;
  return {
    meta: { version: "1.0", locale: "en-US", theme: "Clean", aspectRatio: "16:9" },
    content: { title: { id: "title", text: "Untitled Slide" } },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 24, r: 24, b: 24, l: 24 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 6, colSpan: 12 }
      ],
      anchors: [{ refId: "title", region: "header", order: 0 }]
    },
    styleTokens: {
      palette: { primary: "#2563EB", accent: "#F59E0B", neutral: ["#0F172A","#1E293B","#334155","#64748B","#94A3B8","#CBD5E1","#E2E8F0"] },
      typography: { fonts: { sans: "Inter, Arial, sans-serif" }, sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 32 }, weights: { regular: 400, medium: 500, semibold: 600, bold: 700 }, lineHeights: { compact: 1.2, standard: 1.5 } },
      spacing: { base: 4, steps: [0,4,8,12,16,24,32] },
      radii: { sm: 2, md: 6, lg: 12 },
      shadows: { sm: "0 1px 2px rgba(0,0,0,.06)", md: "0 4px 8px rgba(0,0,0,.12)", lg: "0 12px 24px rgba(0,0,0,.18)" },
      contrast: { minTextContrast: 4.5, minUiContrast: 3 }
    }
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/main.tsx
=================================================================================
import React from "react";
import ReactDOM from "react-dom/client";
import "@/styles/tailwind.css";
import App from "./App";
import { initAnalytics } from "./lib/firebase";
import { ErrorBoundary } from "./components/ErrorBoundary";
import { validateEnv } from "./lib/env";
import { logger } from "./lib/logger";
import { registerServiceWorker } from "./lib/registerSW";

// Validate environment variables at startup
try {
  validateEnv();
  logger.info("Application starting...");
} catch (error) {
  logger.error("Failed to validate environment", error);
  throw error;
}

initAnalytics();
registerServiceWorker();

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </React.StrictMode>
);


=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/test/setup.ts
=================================================================================
import { afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import '@testing-library/jest-dom';

// Cleanup after each test
afterEach(() => {
  cleanup();
});

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: (query: string) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: () => {}, // deprecated
    removeListener: () => {}, // deprecated
    addEventListener: () => {},
    removeEventListener: () => {},
    dispatchEvent: () => {},
  }),
});

// Mock IntersectionObserver
(globalThis as any).IntersectionObserver = class IntersectionObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  takeRecords() {
    return [];
  }
  unobserve() {}
} as any;

// Mock ResizeObserver
(globalThis as any).ResizeObserver = class ResizeObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
} as any;



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/types/Presentation.ts
=================================================================================
import type { SlideSpecV1 } from "./SlideSpecV1";

export interface Slide {
  id: string;
  spec: SlideSpecV1;
  createdAt: number;
  updatedAt: number;
  prompt?: string; // Original prompt used to generate this slide
}

export interface Presentation {
  id: string;
  title: string;
  slides: Slide[];
  createdAt: number;
  updatedAt: number;
  aspectRatio: "16:9" | "4:3";
}

export function createSlide(spec: SlideSpecV1, prompt?: string): Slide {
  const now = Date.now();
  return {
    id: `slide_${now}_${Math.random().toString(36).substr(2, 9)}`,
    spec,
    createdAt: now,
    updatedAt: now,
    prompt,
  };
}

export function createPresentation(title: string = "Untitled Presentation", aspectRatio: "16:9" | "4:3" = "16:9"): Presentation {
  const now = Date.now();
  return {
    id: `pres_${now}_${Math.random().toString(36).substr(2, 9)}`,
    title,
    slides: [],
    createdAt: now,
    updatedAt: now,
    aspectRatio,
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/types/SlideSpecV1.ts
=================================================================================
export type AspectRatio = "16:9" | "4:3";
export type RegionName = "header" | "body" | "footer" | "aside";
export type ChartKind = "bar" | "line" | "pie";

export interface SlideSpecV1 {
  meta: {
    version: "1.0";
    locale: string;
    theme: string;
    aspectRatio: AspectRatio;
  };
  content: {
    title: { id: string; text: string };
    subtitle?: { id: string; text: string };
    bullets?: { id: string; items: { text: string; level: 1 | 2 | 3 }[] }[];
    callouts?: { id: string; title?: string; text: string; variant: "note"|"success"|"warning"|"danger" }[];
    dataViz?: {
      id: string; kind: ChartKind; title?: string; labels: string[];
      series: { name: string; values: number[] }[]; valueFormat?: "number"|"percent"|"currency"|"auto";
    };
    imagePlaceholders?: { id: string; role: "hero" | "logo" | "illustration" | "icon"; alt: string }[];
  };
  layout: {
    grid: { rows: number; cols: number; gutter: number; margin: { t: number; r: number; b: number; l: number } };
    regions: { name: RegionName; rowStart: number; colStart: number; rowSpan: number; colSpan: number }[];
    anchors: { refId: string; region: RegionName; order: number; span?: { rows: number; cols: number } }[];
  };
  styleTokens: {
    palette: { primary: string; accent: string; neutral: string[] };
    typography: {
      fonts: { sans: string; serif?: string; mono?: string };
      sizes: { "step_-2": number; "step_-1": number; step_0: number; step_1: number; step_2: number; step_3: number };
      weights: { regular: number; medium: number; semibold: number; bold: number };
      lineHeights: { compact: number; standard: number };
    };
    spacing: { base: number; steps: number[] };
    radii: { sm: number; md: number; lg: number };
    shadows: { sm: string; md: string; lg: string };
    contrast: { minTextContrast: number; minUiContrast: number };
  };
  components?: {
    bulletList?: { variant?: "compact" | "spacious" };
    callout?: { variant?: "flat" | "elevated" };
    chart?: { legend?: "none" | "right" | "bottom"; gridlines?: boolean };
    image?: { fit?: "cover" | "contain" };
    title?: { align?: "left" | "center" | "right" };
  };
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/types/SlideSpecV2.ts
=================================================================================
import type { SlideSpecV1 } from "./SlideSpecV1";

export type DesignPattern = "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused";
export type WhitespaceStrategy = "generous" | "balanced" | "compact";
export type TypographyStrategy = "classic" | "modern" | "bold" | "minimal" | "elegant";
export type ColorDistribution = "monochromatic" | "complementary" | "analogous" | "triadic";
export type ContrastLevel = "high" | "medium" | "low";
export type AnimationType = "fade" | "slide" | "zoom" | "wipe" | "pulse" | "glow" | "scale";

export interface VisualHierarchy {
  primaryFocus: string; // element ID with highest emphasis
  secondaryFocus: string[]; // supporting element IDs
  emphasisLevels: Record<string, 1 | 2 | 3 | 4 | 5>; // 1=minimal, 5=maximum
}

export interface WhitespaceConfig {
  strategy: WhitespaceStrategy;
  breathingRoom: number; // 20-50 percentage
}

export interface TypographyConfig {
  strategy: TypographyStrategy;
  fontPairing: {
    primary: string; // heading font
    secondary: string; // body font
  };
  hierarchy: Record<string, {
    size: number;
    weight: 400 | 500 | 600 | 700;
    lineHeight: number;
  }>;
}

export interface ColorStrategyConfig {
  distribution: ColorDistribution;
  emphasis: string; // accent color usage
  contrast: ContrastLevel;
}

export interface AnimationConfig {
  type: AnimationType;
  duration: number; // milliseconds
  delay?: number;
}

export interface DesignConfig {
  pattern: DesignPattern;
  
  visualHierarchy: VisualHierarchy;
  
  whitespace: WhitespaceConfig;
  
  typography: TypographyConfig;
  
  colorStrategy: ColorStrategyConfig;
  
  animations?: {
    entrance?: AnimationConfig[];
    emphasis?: AnimationConfig[];
  };
}

export interface SlideSpecV2 extends SlideSpecV1 {
  design: DesignConfig;
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/src/utils/slideDebugger.ts
=================================================================================
/**
 * Slide Debugger - Diagnostic tool for slide rendering issues
 * Logs detailed information about spec structure and rendering
 */

import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export interface DiagnosticReport {
  specVersion: string;
  gridConfig: {
    rows: number;
    cols: number;
    gutter: number;
    margin: { t: number; r: number; b: number; l: number };
  };
  regions: Array<{
    name: string;
    position: { rowStart: number; colStart: number };
    span: { rowSpan: number; colSpan: number };
  }>;
  anchors: Array<{
    refId: string;
    region: string;
    order: number;
  }>;
  content: {
    title?: { id: string; text: string; length: number };
    subtitle?: { id: string; text: string; length: number };
    bullets?: Array<{ id: string; itemCount: number }>;
    callouts?: Array<{ id: string; text: string }>;
  };
  styleTokens: {
    palette: { primary: string; accent: string; neutralCount: number };
    typography: {
      fonts: { sans: string };
      sizes: Record<string, number>;
      weights: Record<string, number>;
    };
  };
  issues: string[];
}

export function generateDiagnosticReport(spec: SlideSpecV1): DiagnosticReport {
  const issues: string[] = [];

  // Validate grid config
  if (!spec.layout.grid) {
    issues.push("‚ùå Missing layout.grid configuration");
  }

  // Validate regions
  if (!spec.layout.regions || spec.layout.regions.length === 0) {
    issues.push("‚ùå No regions defined");
  }

  // Validate anchors
  if (!spec.layout.anchors || spec.layout.anchors.length === 0) {
    issues.push("‚ùå No anchors defined");
  }

  // Check for orphaned anchors (anchors without matching regions)
  const regionNames = new Set(spec.layout.regions?.map(r => r.name) || []);
  spec.layout.anchors?.forEach(anchor => {
    if (!regionNames.has(anchor.region)) {
      issues.push(`‚ö†Ô∏è  Anchor "${anchor.refId}" references non-existent region "${anchor.region}"`);
    }
  });

  // Check for content without anchors
  const anchorRefIds = new Set(spec.layout.anchors?.map(a => a.refId) || []);
  if (spec.content.title && !anchorRefIds.has(spec.content.title.id)) {
    issues.push(`‚ö†Ô∏è  Title has no anchor (id: ${spec.content.title.id})`);
  }
  if (spec.content.subtitle && !anchorRefIds.has(spec.content.subtitle.id)) {
    issues.push(`‚ö†Ô∏è  Subtitle has no anchor (id: ${spec.content.subtitle.id})`);
  }

  // Check for long text that might overflow
  if (spec.content.title?.text.length > 100) {
    issues.push(`‚ö†Ô∏è  Title text is very long (${spec.content.title.text.length} chars)`);
  }

  return {
    specVersion: spec.meta.version,
    gridConfig: spec.layout.grid,
    regions: spec.layout.regions.map(r => ({
      name: r.name,
      position: { rowStart: r.rowStart, colStart: r.colStart },
      span: { rowSpan: r.rowSpan, colSpan: r.colSpan },
    })),
    anchors: spec.layout.anchors.map(a => ({
      refId: a.refId,
      region: a.region,
      order: a.order,
    })),
    content: {
      title: spec.content.title ? {
        id: spec.content.title.id,
        text: spec.content.title.text.substring(0, 50),
        length: spec.content.title.text.length,
      } : undefined,
      subtitle: spec.content.subtitle ? {
        id: spec.content.subtitle.id,
        text: spec.content.subtitle.text.substring(0, 50),
        length: spec.content.subtitle.text.length,
      } : undefined,
      bullets: spec.content.bullets?.map(b => ({
        id: b.id,
        itemCount: b.items.length,
      })),
      callouts: spec.content.callouts?.map(c => ({
        id: c.id,
        text: c.text.substring(0, 30),
      })),
    },
    styleTokens: {
      palette: {
        primary: spec.styleTokens.palette.primary,
        accent: spec.styleTokens.palette.accent,
        neutralCount: spec.styleTokens.palette.neutral.length,
      },
      typography: {
        fonts: { sans: spec.styleTokens.typography.fonts.sans },
        sizes: spec.styleTokens.typography.sizes,
        weights: spec.styleTokens.typography.weights,
      },
    },
    issues,
  };
}

export function logDiagnostics(spec: SlideSpecV1): void {
  const report = generateDiagnosticReport(spec);
  
  console.group("üîç Slide Diagnostics Report");
  console.log("Spec Version:", report.specVersion);
  console.log("Grid Config:", report.gridConfig);
  console.log("Regions:", report.regions);
  console.log("Anchors:", report.anchors);
  console.log("Content:", report.content);
  console.log("Style Tokens:", report.styleTokens);
  
  if (report.issues.length > 0) {
    console.group("‚ö†Ô∏è  Issues Found");
    report.issues.forEach(issue => console.log(issue));
    console.groupEnd();
  } else {
    console.log("‚úÖ No issues detected");
  }
  
  console.groupEnd();
}

export function validateLayoutCalculations(spec: SlideSpecV1): void {
  const { rows, cols, gutter, margin } = spec.layout.grid;
  const SLIDE_WIDTH = 10; // inches
  const SLIDE_HEIGHT = 7.5; // inches

  const pxToIn = (px: number) => (px * 0.75) / 72;
  const marginTop = pxToIn(margin.t);
  const marginRight = pxToIn(margin.r);
  const marginBottom = pxToIn(margin.b);
  const marginLeft = pxToIn(margin.l);
  const gutterIn = pxToIn(gutter);

  const gridWidth = SLIDE_WIDTH - marginLeft - marginRight;
  const gridHeight = SLIDE_HEIGHT - marginTop - marginBottom;
  const cellWidth = (gridWidth - (cols - 1) * gutterIn) / cols;
  const cellHeight = (gridHeight - (rows - 1) * gutterIn) / rows;

  console.group("üìê Layout Calculations");
  console.log("Slide dimensions: 10in √ó 7.5in");
  console.log("Margins (in):", { top: marginTop.toFixed(2), right: marginRight.toFixed(2), bottom: marginBottom.toFixed(2), left: marginLeft.toFixed(2) });
  console.log("Grid dimensions (in):", { width: gridWidth.toFixed(2), height: gridHeight.toFixed(2) });
  console.log("Cell dimensions (in):", { width: cellWidth.toFixed(2), height: cellHeight.toFixed(2) });
  console.log("Gutter (in):", gutterIn.toFixed(2));
  console.groupEnd();
}



=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/package.json
=================================================================================
{
  "name": "functions",
  "scripts": {
    "build": "tsc",
    "serve": "npm run build && firebase emulators:start --only functions",
    "deploy": "npm run build && firebase deploy --only functions",
    "lint": "eslint --ext .ts src",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  },
  "engines": {
    "node": "20"
  },
  "main": "lib/index.js",
  "dependencies": {
    "@types/sharp": "^0.31.1",
    "cors": "^2.8.5",
    "firebase-admin": "^12.6.0",
    "firebase-functions": "^6.0.1",
    "pptxgenjs": "^4.0.1",
    "sharp": "^0.34.4",
    "undici": "^7.16.0",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^5.12.0",
    "@typescript-eslint/parser": "^5.12.0",
    "eslint": "^8.9.0",
    "eslint-config-google": "^0.14.0",
    "eslint-plugin-import": "^2.25.4",
    "firebase-functions-test": "^3.1.0",
    "typescript": "^5.7.3",
    "vitest": "^1.0.0"
  },
  "private": true
}


=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/functions/tsconfig.json
=================================================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "ES2022",
    "lib": ["ES2022", "DOM"],
    "outDir": "lib",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "compileOnSave": true,
  "exclude": ["node_modules", "lib"]
}


=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/package.json
=================================================================================
{
  "name": "web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  },
  "dependencies": {
    "firebase": "^12.4.0",
    "html2canvas": "^1.4.1",
    "jspdf": "^3.0.3",
    "lucide-react": "^0.546.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "recharts": "^3.3.0",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@tailwindcss/postcss": "^4.1.16",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^24.6.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^5.0.4",
    "@vitest/ui": "^4.0.1",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "jsdom": "^27.0.1",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.16",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7",
    "vitest": "^4.0.1"
  }
}


=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/tsconfig.json
=================================================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


=================================================================================
FILE: /Users/salscrudato/Projects/plzfixthx/web/vite.config.ts
=================================================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
})


