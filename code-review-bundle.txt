Repository: plzfixthx
Generated: Tue Oct 28 20:37:07 EDT 2025
========================================


================================================================================
FILE: ./collect-code-for-review.sh
================================================================================

#!/bin/bash

# Script to collect all code files for external code review
# Output file: code-review-bundle.txt

OUTPUT_FILE="code-review-bundle.txt"
REPO_ROOT="$(pwd)"

# Clear or create the output file
> "$OUTPUT_FILE"

echo "Collecting code files for review..."
echo "Repository: plzfixthx" >> "$OUTPUT_FILE"
echo "Generated: $(date)" >> "$OUTPUT_FILE"
echo "========================================" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# Function to process a file
process_file() {
    local file="$1"
    local relative_path="${file#$REPO_ROOT/}"
    
    echo "" >> "$OUTPUT_FILE"
    echo "================================================================================" >> "$OUTPUT_FILE"
    echo "FILE: $relative_path" >> "$OUTPUT_FILE"
    echo "================================================================================" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    cat "$file" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
}

# Find and process all code files, excluding node_modules, dist, lib, and other build artifacts
find . -type f \( \
    -name "*.ts" -o \
    -name "*.tsx" -o \
    -name "*.js" -o \
    -name "*.jsx" -o \
    -name "*.json" -o \
    -name "*.html" -o \
    -name "*.css" -o \
    -name "*.sh" \
\) \
    -not -path "*/node_modules/*" \
    -not -path "*/dist/*" \
    -not -path "*/lib/*" \
    -not -path "*/build/*" \
    -not -path "*/.git/*" \
    -not -path "*/test-output/*" \
    -not -path "*package-lock.json" \
    -not -path "$OUTPUT_FILE" \
    | sort | while read -r file; do
    process_file "$file"
    echo "Processed: ${file#$REPO_ROOT/}"
done

echo "" >> "$OUTPUT_FILE"
echo "================================================================================" >> "$OUTPUT_FILE"
echo "END OF CODE REVIEW BUNDLE" >> "$OUTPUT_FILE"
echo "================================================================================" >> "$OUTPUT_FILE"

echo ""
echo "Code collection complete!"
echo "Output file: $OUTPUT_FILE"
echo "File size: $(du -h "$OUTPUT_FILE" | cut -f1)"
echo "Total files processed: $(grep -c "^FILE: " "$OUTPUT_FILE")"



================================================================================
FILE: ./firebase.json
================================================================================

{
  "firestore": {
    "database": "(default)",
    "location": "nam5",
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "functions": {
    "source": "functions",
    "predeploy": ["npm --prefix functions run build"]
  },
  "hosting": {
    "public": "web/dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "headers": [
      {
        "source": "**/*.@(html|js|css)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "no-cache, no-store, must-revalidate"
          }
        ]
      },
      {
        "source": "/index.html",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "no-cache, no-store, must-revalidate"
          }
        ]
      },
      {
        "source": "/sw.js",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "no-cache, no-store, must-revalidate"
          },
          {
            "key": "Service-Worker-Allowed",
            "value": "/"
          }
        ]
      },
      {
        "source": "**/*.@(jpg|jpeg|gif|png|svg|webp|ico)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=31536000, immutable"
          }
        ]
      }
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  },
  "emulators": {
    "functions": {
      "port": 5001
    },
    "firestore": {
      "port": 8080
    },
    "hosting": {
      "port": 5002
    },
    "ui": {
      "enabled": true,
      "port": 4000
    },
    "singleProjectMode": true
  }
}


================================================================================
FILE: ./firestore.indexes.json
================================================================================

{
  // Example (Standard Edition):
  //
  // "indexes": [
  //   {
  //     "collectionGroup": "widgets",
  //     "queryScope": "COLLECTION",
  //     "fields": [
  //       { "fieldPath": "foo", "arrayConfig": "CONTAINS" },
  //       { "fieldPath": "bar", "mode": "DESCENDING" }
  //     ]
  //   },
  //
  //  "fieldOverrides": [
  //    {
  //      "collectionGroup": "widgets",
  //      "fieldPath": "baz",
  //      "indexes": [
  //        { "order": "ASCENDING", "queryScope": "COLLECTION" }
  //      ]
  //    },
  //   ]
  // ]
  //
  // Example (Enterprise Edition):
  //
  // "indexes": [
  //   {
  //     "collectionGroup": "reviews",
  //     "queryScope": "COLLECTION_GROUP",
  //     "apiScope": "MONGODB_COMPATIBLE_API",
  //     "density": "DENSE",
  //     "multikey": false,
  //     "fields": [
  //       { "fieldPath": "baz", "mode": "ASCENDING" }
  //     ]
  //   },
  //   {
  //     "collectionGroup": "items",
  //     "queryScope": "COLLECTION_GROUP",
  //     "apiScope": "MONGODB_COMPATIBLE_API",
  //     "density": "SPARSE_ANY",
  //     "multikey": true,
  //     "fields": [
  //       { "fieldPath": "baz", "mode": "ASCENDING" }
  //     ]
  //   },
  // ]
  "indexes": [],
  "fieldOverrides": []
}

================================================================================
FILE: ./functions/package.json
================================================================================

{
  "name": "functions",
  "type": "module",
  "scripts": {
    "build": "npm --prefix ../shared/slideSpec run build && tsc && node scripts/fix-esm-imports.js && node scripts/copy-shared-package.js",
    "serve": "npm run build && firebase emulators:start --only functions",
    "deploy": "npm run build && firebase deploy --only functions",
    "lint": "eslint --ext .ts src",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  },
  "engines": {
    "node": "20"
  },
  "main": "lib/index.js",
  "dependencies": {
    "@plzfixthx/slide-spec": "file:../shared/slideSpec",
    "@types/sharp": "^0.31.1",
    "cors": "^2.8.5",
    "firebase-admin": "^12.6.0",
    "firebase-functions": "^6.0.1",
    "pptxgenjs": "^4.0.1",
    "sharp": "^0.34.4",
    "undici": "^7.16.0",
    "zod": "^4.1.12",
    "zod-to-json-schema": "^3.24.6"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^5.12.0",
    "@typescript-eslint/parser": "^5.12.0",
    "eslint": "^8.9.0",
    "eslint-config-google": "^0.14.0",
    "eslint-plugin-import": "^2.25.4",
    "firebase-functions-test": "^3.1.0",
    "typescript": "^5.7.3",
    "vitest": "^1.0.0"
  },
  "private": true
}


================================================================================
FILE: ./functions/scripts/copy-shared-package.js
================================================================================

#!/usr/bin/env node
/**
 * Copy the built shared/slideSpec package into functions/lib for runtime access.
 * This ensures the @plzfixthx/slide-spec package is available at runtime.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const sourceDir = path.join(__dirname, '../../shared/slideSpec/dist');
const targetDir = path.join(__dirname, '../lib/slide-spec');

function copyRecursive(src, dest) {
  if (!fs.existsSync(src)) {
    console.error(`❌ Source directory not found: ${src}`);
    process.exit(1);
  }
  
  if (!fs.existsSync(dest)) {
    fs.mkdirSync(dest, { recursive: true });
  }
  
  const entries = fs.readdirSync(src, { withFileTypes: true });
  
  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);
    
    if (entry.isDirectory()) {
      copyRecursive(srcPath, destPath);
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }
}

console.log('Copying shared package...');
copyRecursive(sourceDir, targetDir);
console.log('✅ Shared package copied to lib/slide-spec');



================================================================================
FILE: ./functions/scripts/fix-esm-imports.js
================================================================================

#!/usr/bin/env node
/**
 * Fix ESM import paths for the slide-spec package.
 * Ensures deep imports use the correct .js extension for ESM compatibility.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const libDir = path.join(__dirname, '../lib');
let filesFixed = 0;

function fixImports(dir) {
  const files = fs.readdirSync(dir);

  for (const file of files) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      fixImports(filePath);
    } else if (file.endsWith('.js')) {
      let content = fs.readFileSync(filePath, 'utf8');
      const originalContent = content;

      // Fix all relative imports to add .js extension
      // Match: from "./something" or from '../something'
      const lines = content.split('\n');
      const fixedLines = lines.map(line => {
        // Fix @plzfixthx/slide-spec imports to use relative path
        if (line.includes('@plzfixthx/slide-spec')) {
          return line.replace(
            /@plzfixthx\/slide-spec/g,
            () => {
              // Calculate relative path based on file location
              // Files in lib/ use ./slide-spec/index.js
              // Files in lib/pptxBuilder/ use ../slide-spec/index.js
              const fileDir = path.dirname(filePath);
              const libDir = path.join(__dirname, '../lib');
              const slideSpecPath = path.join(libDir, 'slide-spec', 'index.js');
              let relativePath = path.relative(fileDir, slideSpecPath).replace(/\\/g, '/');
              // Ensure relative paths start with ./ or ../
              if (!relativePath.startsWith('.')) {
                relativePath = './' + relativePath;
              }
              return relativePath;
            }
          );
        }
        // Match import statements with relative paths
        if (line.includes('from "') || line.includes("from '")) {
          return line.replace(
            /from\s+["'](\.\.?\/[^"']+)["']/g,
            (match, importPath) => {
              // Skip if already has .js or .json extension
              if (importPath.endsWith('.js') || importPath.endsWith('.json')) {
                return match;
              }
              // Check if this is a directory import (no extension and directory exists)
              const resolvedPath = path.join(path.dirname(filePath), importPath);
              try {
                if (fs.existsSync(resolvedPath) && fs.statSync(resolvedPath).isDirectory()) {
                  return `from "${importPath}/index.js"`;
                }
              } catch (e) {
                // Ignore errors, fall through to .js extension
              }
              return `from "${importPath}.js"`;
            }
          );
        }
        // Match dynamic imports
        if (line.includes('import(')) {
          return line.replace(
            /import\s*\(\s*["'](\.\.?\/[^"']+)["']\s*\)/g,
            (match, importPath) => {
              if (importPath.endsWith('.js') || importPath.endsWith('.json')) {
                return match;
              }
              // Check if this is a directory import
              const resolvedPath = path.join(path.dirname(filePath), importPath);
              try {
                if (fs.existsSync(resolvedPath) && fs.statSync(resolvedPath).isDirectory()) {
                  return `import("${importPath}/index.js")`;
                }
              } catch (e) {
                // Ignore errors, fall through to .js extension
              }
              return `import("${importPath}.js")`;
            }
          );
        }
        return line;
      });

      content = fixedLines.join('\n');

      if (content !== originalContent) {
        console.log(`  Fixed: ${path.relative(libDir, filePath)}`);
        fs.writeFileSync(filePath, content, 'utf8');
        filesFixed++;
      }
    }
  }
}

console.log('Fixing ESM imports...');
fixImports(libDir);
console.log(`✅ ESM imports fixed (${filesFixed} files modified)`);



================================================================================
FILE: ./functions/src/__tests__/aiHelpers.test.ts
================================================================================

import { describe, it, expect } from "vitest";
import { enhanceSlideSpec, sanitizePrompt, moderateContent } from "../aiHelpers";

describe("aiHelpers", () => {
  describe("sanitizePrompt", () => {
    it("should accept valid prompts", () => {
      const result = sanitizePrompt("Create a professional slide about Q1 results");
      expect(result).toBe("Create a professional slide about Q1 results");
    });

    it("should trim whitespace", () => {
      const result = sanitizePrompt("  Hello World  ");
      expect(result).toBe("Hello World");
    });

    it("should reject empty prompts", () => {
      expect(() => sanitizePrompt("")).toThrow();
      expect(() => sanitizePrompt("   ")).toThrow();
    });

    it("should truncate long prompts", () => {
      const longPrompt = "a".repeat(5000);
      const result = sanitizePrompt(longPrompt, 2000);
      expect(result.length).toBeLessThanOrEqual(2000);
    });
  });

  describe("moderateContent", () => {
    it("should allow safe content", () => {
      const result = moderateContent("Create a professional presentation");
      expect(result.safe).toBe(true);
    });

    it("should flag inappropriate content", () => {
      const result = moderateContent("hack the system");
      expect(result.safe).toBe(false);
      expect(result.reason).toBeDefined();
    });

    it("should be case-insensitive", () => {
      const result = moderateContent("HACK THE SYSTEM");
      expect(result.safe).toBe(false);
    });
  });

  describe("enhanceSlideSpec", () => {
    it("should add default meta if missing", () => {
      const spec = { content: { title: { text: "Test" } } };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.meta).toBeDefined();
      expect(enhanced.meta.version).toBe("1.0");
      expect(enhanced.meta.aspectRatio).toBe("16:9");
    });

    it("should add default title if missing", () => {
      const spec = { meta: {}, content: {} };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.title).toBeDefined();
      expect(enhanced.content.title.text).toBe("Untitled Slide");
    });

    it("should add IDs to content elements", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Title" },
          subtitle: { text: "Subtitle" },
          bullets: [{ items: ["Item 1"] }]
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.title.id).toBe("title");
      expect(enhanced.content.subtitle.id).toBe("subtitle");
      expect(enhanced.content.bullets[0].id).toBeDefined();
    });

    it("should limit bullets to 6 items", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Title" },
          bullets: [
            { items: Array(10).fill("Item") }
          ]
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.bullets[0].items.length).toBeLessThanOrEqual(6);
    });

    it("should validate and fix dataViz series", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Title" },
          dataViz: {
            labels: ["Q1", "Q2", "Q3"],
            series: [
              { name: "Series 1", values: [10, 20] } // Only 2 values
            ]
          }
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.dataViz.series[0].values.length).toBe(3);
    });

    it("should ensure valid color palette", () => {
      const spec = {
        meta: {},
        content: { title: { text: "Title" } },
        styleTokens: {
          palette: {
            primary: "invalid-color",
            accent: "also-invalid"
          }
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      // Should have valid hex colors (context-aware generation may vary)
      expect(enhanced.styleTokens.palette.primary).toMatch(/^#[0-9A-F]{6}$/i);
      expect(enhanced.styleTokens.palette.accent).toMatch(/^#[0-9A-F]{6}$/i);
    });

    it("should ensure neutral palette exists", () => {
      const spec = {
        meta: {},
        content: { title: { text: "Title" } },
        styleTokens: { palette: {} }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.styleTokens.palette.neutral).toBeDefined();
      expect(enhanced.styleTokens.palette.neutral.length).toBeGreaterThanOrEqual(5);
    });

    it("should validate contrast compliance", () => {
      const spec = {
        meta: {},
        content: { title: { text: "Title" } },
        styleTokens: {
          palette: {
            primary: "#6366F1",
            accent: "#EC4899",
            neutral: ["#CCCCCC", "#DDDDDD"] // Low contrast
          }
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      // Should have adjusted colors for compliance
      expect(enhanced.styleTokens.palette.neutral).toBeDefined();
    });

    it("should handle multiple bullet groups", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Title" },
          bullets: [
            { items: ["Item 1", "Item 2"] },
            { items: ["Item 3", "Item 4", "Item 5"] }
          ]
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.bullets.length).toBe(2);
      expect(enhanced.content.bullets[0].id).toBeDefined();
      expect(enhanced.content.bullets[1].id).toBeDefined();
    });

    it("should fix layout issues", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Title" },
          subtitle: { text: "Subtitle" }
        },
        layout: {
          regions: [
            { name: "header", rowSpan: 1 },
            { name: "body", rowStart: 2 }
          ],
          anchors: [
            { refId: "title", region: "header" },
            { refId: "subtitle", region: "header" }
          ]
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.layout).toBeDefined();
    });

    it("should split concatenated timeline bullet points", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Timeline" },
          bullets: [{
            items: [
              { text: "1776 Declared independence1783 Won war1789 Became president", level: 1 }
            ]
          }]
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.bullets[0].items.length).toBeGreaterThan(1);
      expect(enhanced.content.bullets[0].items[0].text).toContain("1776");
      expect(enhanced.content.bullets[0].items[1].text).toContain("1783");
      expect(enhanced.content.bullets[0].items[2].text).toContain("1789");
    });

    it("should preserve properly formatted bullet points", () => {
      const spec = {
        meta: {},
        content: {
          title: { text: "Title" },
          bullets: [{
            items: [
              { text: "First point", level: 1 },
              { text: "Second point", level: 1 },
              { text: "Third point", level: 1 }
            ]
          }]
        }
      };
      const enhanced = enhanceSlideSpec(spec);
      expect(enhanced.content.bullets[0].items.length).toBe(3);
      expect(enhanced.content.bullets[0].items[0].text).toBe("First point");
    });
  });
});



================================================================================
FILE: ./functions/src/__tests__/security.test.ts
================================================================================

import { describe, it, expect, beforeEach } from "vitest";
import { getClientId } from "../security";
import { sanitizePrompt } from "../aiHelpers";
import { Request } from "express";

describe("security", () => {
  describe("sanitizePrompt", () => {
    it("should accept valid prompts", () => {
      const result = sanitizePrompt("Create a professional slide about Q1 results");
      expect(result).toBe("Create a professional slide about Q1 results");
    });

    it("should trim whitespace", () => {
      const result = sanitizePrompt("  Hello World  ");
      expect(result).toBe("Hello World");
    });

    it("should reject empty prompts", () => {
      expect(() => sanitizePrompt("")).toThrow("Prompt must be a non-empty string");
      expect(() => sanitizePrompt("   ")).toThrow();
    });

    it("should reject prompts shorter than 3 characters", () => {
      expect(() => sanitizePrompt("ab")).toThrow("Prompt must be at least 3 characters long");
    });

    it("should truncate long prompts to 1200 characters by default", () => {
      const longPrompt = "a".repeat(5000);
      const result = sanitizePrompt(longPrompt);
      expect(result.length).toBeLessThanOrEqual(1200);
    });

    it("should reject non-string input", () => {
      expect(() => sanitizePrompt(null as unknown as string)).toThrow();
      expect(() => sanitizePrompt(undefined as unknown as string)).toThrow();
    });
  });

  // Note: Content moderation tests are in aiHelpers.test.ts (moderateContent function)

  describe("getClientId", () => {
    it("should generate consistent IDs for same client", () => {
      const mockReq = {
        ip: "192.168.1.1",
        socket: { remoteAddress: "192.168.1.1" },
        get: (header: string) => {
          if (header === "user-agent") return "Mozilla/5.0";
          return undefined;
        },
      } as unknown as Request;

      const id1 = getClientId(mockReq);
      const id2 = getClientId(mockReq);

      expect(id1).toBe(id2);
      expect(id1.length).toBe(16); // SHA256 slice to 16 chars
    });

    it("should generate different IDs for different clients", () => {
      const mockReq1 = {
        ip: "192.168.1.1",
        socket: { remoteAddress: "192.168.1.1" },
        get: (header: string) => {
          if (header === "user-agent") return "Mozilla/5.0";
          return undefined;
        },
      } as unknown as Request;

      const mockReq2 = {
        ip: "192.168.1.2",
        socket: { remoteAddress: "192.168.1.2" },
        get: (header: string) => {
          if (header === "user-agent") return "Mozilla/5.0";
          return undefined;
        },
      } as unknown as Request;

      const id1 = getClientId(mockReq1);
      const id2 = getClientId(mockReq2);

      expect(id1).not.toBe(id2);
    });

    it("should handle missing IP gracefully", () => {
      const mockReq = {
        ip: undefined,
        socket: { remoteAddress: undefined },
        get: () => "Mozilla/5.0",
      } as unknown as Request;

      const id = getClientId(mockReq);
      expect(id).toBeDefined();
      expect(id.length).toBe(16);
    });
  });
});



================================================================================
FILE: ./functions/src/__tests__/slideGenerationIntegration.test.ts
================================================================================

/**
 * Slide Generation Integration Tests
 * Validates end-to-end slide generation with professional design
 */

import { describe, it, expect } from "vitest";
import type { SlideSpecV1 } from "@plzfixthx/slide-spec";

describe("Slide Generation Integration", () => {
  const createProfessionalSlideSpec = (): SlideSpecV1 => ({
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Premium Business",
      aspectRatio: "16:9"
    },
    content: {
      title: { id: "title", text: "Accelerate Growth" },
      subtitle: { id: "subtitle", text: "Transform your business with innovative solutions" },
      bullets: [{
        id: "b1",
        items: [
          { text: "Increase revenue by 40% in 12 months", level: 1 },
          { text: "Reduce operational costs by 25%", level: 1 },
          { text: "Improve customer satisfaction to 95%", level: 1 },
          { text: "Scale operations without adding headcount", level: 1 }
        ]
      }],
      callouts: [{
        id: "c1",
        title: "Key Insight",
        text: "Companies that implement these strategies see 3x faster growth",
        variant: "success"
      }]
    },
    layout: {
      grid: { rows: 8, cols: 12, gutter: 8, margin: { t: 32, r: 32, b: 32, l: 32 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 5, colSpan: 12 }
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "subtitle", region: "header", order: 1 },
        { refId: "b1", region: "body", order: 0 },
        { refId: "c1", region: "body", order: 1 }
      ]
    },
    styleTokens: {
      palette: {
        primary: "#1E40AF",
        accent: "#06B6D4",
        neutral: ["#0F172A", "#1E293B", "#334155", "#64748B", "#94A3B8", "#CBD5E1", "#F8FAFC"]
      },
      typography: {
        fonts: { sans: "Aptos, Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 28, step_3: 44 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.5 }
      },
      spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: { sm: "0 2px 4px rgba(0,0,0,.08)", md: "0 4px 12px rgba(0,0,0,.12)", lg: "0 12px 32px rgba(0,0,0,.16)" },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 }
    }
  });

  describe("Professional Slide Specification", () => {
    it("should generate valid slide spec", () => {
      const spec = createProfessionalSlideSpec();

      expect(spec.meta.version).toBe("1.0");
      expect(spec.meta.aspectRatio).toBe("16:9");
      expect(spec.content.title).toBeDefined();
      expect(spec.styleTokens.palette).toBeDefined();
    });

    it("should have compelling content", () => {
      const spec = createProfessionalSlideSpec();

      // Title should be action-oriented
      expect(spec.content.title.text).toMatch(/Accelerate|Transform|Unlock|Maximize/);

      // Subtitle should provide context
      expect(spec.content.subtitle?.text).toBeTruthy();
      expect(spec.content.subtitle!.text.length).toBeGreaterThan(10);

      // Bullets should be specific and measurable
      const bullets = spec.content.bullets?.[0]?.items || [];
      expect(bullets.length).toBeGreaterThan(0);
      expect(bullets.length).toBeLessThanOrEqual(5);

      // Each bullet should have specific metrics
      const hasMetrics = bullets.some(b => /\d+%|\d+x|[0-9]+/.test(b.text));
      expect(hasMetrics).toBe(true);
    });

    it("should have professional color palette", () => {
      const spec = createProfessionalSlideSpec();
      const palette = spec.styleTokens.palette;

      // Primary and accent colors should be different
      expect(palette.primary).not.toBe(palette.accent);

      // All colors should be valid hex
      const hexRegex = /^#[0-9A-F]{6}$/i;
      expect(hexRegex.test(palette.primary)).toBe(true);
      expect(hexRegex.test(palette.accent)).toBe(true);

      // Neutral palette should have 7 colors
      expect(palette.neutral).toHaveLength(7);
      palette.neutral.forEach(color => {
        expect(hexRegex.test(color)).toBe(true);
      });
    });

    it("should have proper typography hierarchy", () => {
      const spec = createProfessionalSlideSpec();
      const sizes = spec.styleTokens.typography.sizes;

      // Verify size hierarchy
      expect(sizes.step_3).toBeGreaterThan(sizes.step_2);
      expect(sizes.step_2).toBeGreaterThan(sizes.step_1);
      expect(sizes.step_1).toBeGreaterThan(sizes.step_0);

      // Title should be large
      expect(sizes.step_3).toBeGreaterThanOrEqual(40);

      // Body text should be readable
      expect(sizes.step_0).toBeGreaterThanOrEqual(14);
    });

    it("should have WCAG AAA accessibility", () => {
      const spec = createProfessionalSlideSpec();
      const contrast = spec.styleTokens.contrast;

      // WCAG AAA requires 7:1 for text
      expect(contrast.minTextContrast).toBeGreaterThanOrEqual(7);

      // UI elements require 4.5:1
      expect(contrast.minUiContrast).toBeGreaterThanOrEqual(4.5);
    });

    it("should have proper spacing system", () => {
      const spec = createProfessionalSlideSpec();
      const spacing = spec.styleTokens.spacing;

      expect(spacing.base).toBe(4);
      expect(spacing.steps).toContain(0);
      expect(spacing.steps).toContain(4);
      expect(spacing.steps).toContain(8);
      expect(spacing.steps).toContain(32);

      // Verify spacing is in ascending order
      for (let i = 1; i < spacing.steps.length; i++) {
        expect(spacing.steps[i]).toBeGreaterThanOrEqual(spacing.steps[i - 1]);
      }
    });
  });

  describe("Layout System", () => {
    it("should have valid grid system", () => {
      const spec = createProfessionalSlideSpec();
      const grid = spec.layout.grid;

      expect(grid.rows).toBeGreaterThanOrEqual(3);
      expect(grid.cols).toBeGreaterThanOrEqual(3);
      expect(grid.gutter).toBeGreaterThanOrEqual(0);

      // Margins should be professional (minimum 32px = 0.44in)
      expect(grid.margin.t).toBeGreaterThanOrEqual(32);
      expect(grid.margin.r).toBeGreaterThanOrEqual(32);
      expect(grid.margin.b).toBeGreaterThanOrEqual(32);
      expect(grid.margin.l).toBeGreaterThanOrEqual(32);
    });

    it("should have valid regions", () => {
      const spec = createProfessionalSlideSpec();
      const regions = spec.layout.regions;

      expect(regions.length).toBeGreaterThan(0);

      regions.forEach(region => {
        expect(["header", "body", "footer", "aside"]).toContain(region.name);
        expect(region.rowStart).toBeGreaterThan(0);
        expect(region.colStart).toBeGreaterThan(0);
        expect(region.rowSpan).toBeGreaterThan(0);
        expect(region.colSpan).toBeGreaterThan(0);
      });
    });

    it("should have valid anchors", () => {
      const spec = createProfessionalSlideSpec();
      const anchors = spec.layout.anchors;

      expect(anchors.length).toBeGreaterThan(0);

      anchors.forEach(anchor => {
        expect(["header", "body", "footer", "aside"]).toContain(anchor.region);
        expect(anchor.order).toBeGreaterThanOrEqual(0);
      });
    });
  });

  describe("Design Quality Metrics", () => {
    it("should meet professional design standards", () => {
      const spec = createProfessionalSlideSpec();

      // Check for professional theme
      expect(spec.meta.theme).toBeTruthy();

      // Check for proper aspect ratio
      expect(["16:9", "4:3"]).toContain(spec.meta.aspectRatio);

      // Check for complete style tokens
      expect(spec.styleTokens.palette).toBeDefined();
      expect(spec.styleTokens.typography).toBeDefined();
      expect(spec.styleTokens.spacing).toBeDefined();
      expect(spec.styleTokens.contrast).toBeDefined();
    });

    it("should have balanced content distribution", () => {
      const spec = createProfessionalSlideSpec();

      // Should have title
      expect(spec.content.title).toBeDefined();

      // Should have subtitle for context
      expect(spec.content.subtitle).toBeDefined();

      // Should have bullets for key points
      expect(spec.content.bullets).toBeDefined();
      expect(spec.content.bullets!.length).toBeGreaterThan(0);

      // Should have callouts for emphasis
      expect(spec.content.callouts).toBeDefined();
      expect(spec.content.callouts!.length).toBeGreaterThan(0);
    });

    it("should follow content best practices", () => {
      const spec = createProfessionalSlideSpec();

      // Title should be concise (4-8 words ideal)
      const titleWords = spec.content.title.text.split(" ").length;
      expect(titleWords).toBeGreaterThanOrEqual(2);
      expect(titleWords).toBeLessThanOrEqual(10);

      // Bullets should be concise
      const bullets = spec.content.bullets?.[0]?.items || [];
      bullets.forEach(bullet => {
        const words = bullet.text.split(" ").length;
        expect(words).toBeGreaterThanOrEqual(3);
        expect(words).toBeLessThanOrEqual(20);
      });

      // Total content should be under 100 words
      const allText = [
        spec.content.title.text,
        spec.content.subtitle?.text || "",
        ...bullets.map(b => b.text),
        ...((spec.content.callouts || []).map(c => c.text))
      ].join(" ");

      const totalWords = allText.split(" ").length;
      expect(totalWords).toBeLessThan(150);
    });
  });
});



================================================================================
FILE: ./functions/src/aiHelpers.ts
================================================================================

import * as logger from "firebase-functions/logger";
import { fetch as undiciFetch } from "undici";
import { z } from "zod";
import { DEFAULT_NEUTRAL_9, DEFAULT_TYPOGRAPHY } from "@plzfixthx/slide-spec";
import { ENHANCED_SYSTEM_PROMPT } from "./prompts";
import { generatePalette } from "./colorPaletteGenerator";
import { randomUUID } from "crypto";
import { contrastRatio, hexToRgb } from "./shared";

/* eslint-disable @typescript-eslint/no-explicit-any */
import { zodToJsonSchema } from "zod-to-json-schema";

/* -------------------------------------------------------------------------- */
/*                            Structured Error Types                          */
/* -------------------------------------------------------------------------- */

export class AIError extends Error {
  constructor(
    message: string,
    public code: string,
    public requestId: string,
    public details?: Record<string, any>
  ) {
    super(message);
    this.name = "AIError";
  }
}

export class ValidationError extends AIError {
  constructor(message: string, requestId: string, details?: Record<string, any>) {
    super(message, "VALIDATION_ERROR", requestId, details);
    this.name = "ValidationError";
  }
}

export class ModerationError extends AIError {
  constructor(message: string, requestId: string, details?: Record<string, any>) {
    super(message, "MODERATION_ERROR", requestId, details);
    this.name = "ModerationError";
  }
}

/* -------------------------------------------------------------------------- */
/*                               Color & Contrast                             */
/* -------------------------------------------------------------------------- */

/**
 * WCAG 2.2 contrast validation using shared utility
 */
function ensureContrast(textHex: string, bgHex: string, minRatio: number) {
  const ratio = contrastRatio(textHex, bgHex);
  return { compliant: ratio >= minRatio, ratio };
}

/**
 * Generate a compliant neutral ramp if invalid
 */
function generateCompliantNeutralRamp(): string[] {
  // Simple linear interpolation from dark to light
  const [darkR, darkG, darkB] = hexToRgb("#0F172A");
  const [lightR, lightG, lightB] = hexToRgb("#F8FAFC");
  const ramp: string[] = [];

  for (let i = 0; i < 9; i++) {
    const t = i / 8;
    const r = Math.round(darkR * (1 - t) + lightR * t);
    const g = Math.round(darkG * (1 - t) + lightG * t);
    const b = Math.round(darkB * (1 - t) + lightB * t);
    ramp.push(`#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`);
  }

  return ramp;
}

/* -------------------------------------------------------------------------- */
/*                               Light validators                              */
/* -------------------------------------------------------------------------- */

function validateBulletCount(bullets: any[], maxPerGroup: number) {
  const valid = bullets.every((b) => !b.items || b.items.length <= maxPerGroup);
  return { valid, maxPerGroup };
}

/* -------------------------------------------------------------------------- */
/*                         Retry with exponential backoff                      */
/* -------------------------------------------------------------------------- */

export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries = 3,
  baseDelay = 800
): Promise<T> {
  let lastError: Error | undefined;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;

      if (attempt < maxRetries - 1) {
        const jitter = Math.floor(Math.random() * 300); // Increased jitter for better distribution
        const delay = Math.min(16000, baseDelay * Math.pow(2, attempt)) + jitter; // Increased max delay
        logger.warn(`Attempt ${attempt + 1} failed; retrying in ${delay}ms`, {
          error: (lastError as any)?.message || String(lastError),
        });
        await new Promise((r) => setTimeout(r, delay));
      }
    }
  }

  throw lastError || new Error("Max retries exceeded");
}

/* -------------------------------------------------------------------------- */
/*                      OpenAI‑compatible structured outputs                   */
/* -------------------------------------------------------------------------- */

/**
 * Convert Zod schema to JSON Schema for structured output.
 * Enhanced with strict mode and draft version.
 */
function toJsonSchema(schema: z.ZodTypeAny): any {
  const json = zodToJsonSchema(schema, { name: "SlideSpec" });
  if (json && typeof json === "object" && !("$schema" in json)) {
    (json as any).$schema = "http://json-schema.org/draft-07/schema#";
  }
  return json;
}

/**
 * Clean unknown keys from parsed spec to prevent silent drift.
 */
function cleanSpec(parsed: any, schema: z.ZodTypeAny): any {
  // Use Zod's parse to strip unknown keys
  const validation = schema.safeParse(parsed);
  if (validation.success) {
    return validation.data;
  }
  // If validation fails, return original (will be caught by caller)
  return parsed;
}

type AIResp = {
  choices?: Array<{ message?: { content?: string } }>;
  usage?: {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
  };
};

/**
 * Call OpenAI-compatible /chat/completions with robust structured-output handling.
 * 1) Use response_format: json_schema with Zod-generated schema
 * 2) Fallback to response_format: json_object on 400/unsupported
 * 3) Validate with provided Zod schema and clean unknown keys
 * 4) Track request/response IDs and token usage
 * 5) Enforce content-length guard (max 200KB)
 * 6) Added cost estimation and timeout handling
 */
export async function callAIWithRetry(
  prompt: string,
  apiKey: string,
  baseUrl: string,
  model: string,
  schema: z.ZodTypeAny,
  requestId: string = randomUUID()
): Promise<unknown> {
  return retryWithBackoff(async () => {
    const start = Date.now();
    let usedMode: "json_schema" | "json_object" = "json_schema";
    let responseId: string | undefined;

    // Generate JSON Schema from Zod
    const jsonSchema = toJsonSchema(schema);

    const attempt = async (mode: "json_schema" | "json_object") => {
      usedMode = mode;

      // Convert UUID to integer seed (OpenAI requires integer, not string)
      const seedStr = requestId.split("-")[0];
      const seedInt = parseInt(seedStr.substring(0, 8), 16) % 2147483647; // Use first 8 hex chars as seed

      const body: any = {
        model,
        temperature: 0.3, // Slightly increased for more creative but controlled output
        top_p: 0.95,
        seed: seedInt, // Use integer seed for reproducibility
        max_tokens: 4096, // Reasonable limit for slide content
        response_format:
          mode === "json_schema"
            ? { type: "json_schema", json_schema: { name: "SlideSpec", schema: jsonSchema, strict: true } }
            : { type: "json_object" },
        stop: ["```"], // Prevent fence leaks
        messages: [
          {
            role: "system",
            content:
              ENHANCED_SYSTEM_PROMPT +
              (mode === "json_object"
                ? `\n\nThe following JSON Schema is authoritative. Return ONLY a JSON object that validates against it:\n${JSON.stringify(
                    jsonSchema
                  )}`
                : ""),
          },
          { role: "user", content: `User prompt:\n<<<${prompt}>>>` },
        ],
      };

      // Add timeout to fetch (30s)
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000);

      try {
        const response = await undiciFetch(`${baseUrl}/chat/completions`, {
          method: "POST",
          headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
          body: JSON.stringify(body),
          signal: controller.signal,
        });

        clearTimeout(timeoutId);
        const duration = Date.now() - start;

        if (!response.ok) {
          const errorText = await response.text();
          logger.error("AI API request failed", {
            requestId,
            status: response.status,
            error: errorText?.slice(0, 500),
            model,
            promptLength: prompt.length,
            durationMs: duration,
            responseFormat: usedMode,
          });

          // If provider rejects json_schema, fall back once to json_object in-place
          const maybeUnsupported =
            usedMode === "json_schema" &&
            response.status === 400 &&
            /schema|response_format|unsupported/i.test(errorText || "");
          if (maybeUnsupported) {
            return attempt("json_object");
          }

          throw new AIError(
            `AI API error ${response.status}: ${errorText?.slice(0, 200)}`,
            "API_ERROR",
            requestId,
            { status: response.status, model, durationMs: duration }
          );
        }

        let data: AIResp;
        try {
          data = (await response.json()) as AIResp;
          responseId = (data as any)?.id || randomUUID();
        } catch (e) {
          logger.error("Failed to parse AI response as JSON", {
            requestId,
            error: String(e),
            durationMs: duration,
          });
          throw new AIError(
            `Failed to parse AI response: ${e}`,
            "PARSE_ERROR",
            requestId,
            { durationMs: duration }
          );
        }

        const content = data?.choices?.[0]?.message?.content;
        if (!content) {
          logger.error("No content in AI response", {
            requestId,
            responseId,
            data: JSON.stringify(data)?.slice(0, 500),
            durationMs: duration,
            responseFormat: usedMode,
          });
          throw new AIError(
            "No content in AI response",
            "NO_CONTENT",
            requestId,
            { responseId, durationMs: duration }
          );
        }

        // Content-length guard: reject responses > 200KB
        const contentLength = Buffer.byteLength(content, "utf8");
        if (contentLength > 200 * 1024) {
          logger.error("AI response too large", {
            requestId,
            responseId,
            contentLength,
            maxAllowed: 200 * 1024,
            durationMs: duration,
          });
          throw new AIError(
            `AI response too large: ${contentLength} bytes (max 200KB)`,
            "RESPONSE_TOO_LARGE",
            requestId,
            { responseId, durationMs: duration, contentLength }
          );
        }

        let parsed: unknown;
        try {
          parsed = JSON.parse(content);
        } catch (e) {
          logger.error("Failed to parse AI response content as JSON", {
            requestId,
            responseId,
            content: content.slice(0, 500),
            error: String(e),
            durationMs: duration,
            responseFormat: usedMode,
          });
          throw new AIError(
            `Failed to parse AI response as JSON: ${e}`,
            "JSON_PARSE_ERROR",
            requestId,
            { responseId, durationMs: duration }
          );
        }

        const validation = schema.safeParse(parsed);
        if (!validation.success) {
          const detail = validation.error.issues
            .map((issue: any) => `${issue.path.join(".")}: ${issue.message}`)
            .join(", ");
          logger.error("Schema validation failed", {
            requestId,
            responseId,
            topIssues: validation.error.issues.slice(0, 5),
            errorDetails: detail.slice(0, 500),
            aiResponse: JSON.stringify(parsed, null, 2).slice(0, 1000),
            durationMs: duration,
            responseFormat: usedMode,
          });
          throw new ValidationError(
            `Schema validation failed: ${detail.slice(0, 200)}`,
            requestId,
            { responseId, durationMs: duration, issues: validation.error.issues.slice(0, 5) }
          );
        }

        // Clean unknown keys from validated data
        const cleanedData = cleanSpec(validation.data, schema);

        // Log token usage and estimate cost (assuming $0.002/1k input, $0.006/1k output for gpt-4o-mini)
        if (data.usage) {
          const inputCost = (data.usage.prompt_tokens || 0) * 0.002 / 1000;
          const outputCost = (data.usage.completion_tokens || 0) * 0.006 / 1000;
          logger.info("AI token usage", {
            requestId,
            responseId,
            promptTokens: data.usage.prompt_tokens,
            completionTokens: data.usage.completion_tokens,
            totalTokens: data.usage.total_tokens,
            estimatedCost: (inputCost + outputCost).toFixed(4),
            durationMs: duration,
          });
        }

        logger.info("✅ AI response validated", {
          requestId,
          responseId,
          hasTitle: !!(cleanedData as any)?.content?.title,
          hasBullets: !!(cleanedData as any)?.content?.bullets,
          hasChart: !!(cleanedData as any)?.content?.dataViz,
          durationMs: duration,
          responseFormat: usedMode,
          promptTokens: data.usage?.prompt_tokens,
          completionTokens: data.usage?.completion_tokens,
          contentLength,
        });

        return cleanedData;
      } catch (error) {
        clearTimeout(timeoutId);
        if ((error as Error).name === 'AbortError') {
          throw new AIError("AI request timed out", "TIMEOUT_ERROR", requestId, { durationMs: Date.now() - start });
        }
        throw error;
      }
    };

    // First try json_schema; fallback to json_object on 400/unsupported
    return attempt("json_schema");
  }, 3, 1000);
}

/* -------------------------------------------------------------------------- */
/*                              Prompt sanitation                              */
/* -------------------------------------------------------------------------- */

export function sanitizePrompt(prompt: string, maxLength = 1200): string { // Increased max length for more complex prompts
  if (!prompt || typeof prompt !== "string") throw new Error("Prompt must be a non-empty string");
  let p = prompt.trim();

  // Remove code fences and obvious wrappers
  p = p.replace(/^```[a-z0-9]*\n?/i, "").replace(/```$/i, "").trim();

  // Remove potential jailbreak attempts
  p = p.replace(/ignore previous instructions|forget rules|act as|roleplay/gi, "");

  if (p.length < 3) throw new Error("Prompt must be at least 3 characters long");

  if (p.length > maxLength) {
    logger.info("Prompt truncated to max length", { original: p.length, max: maxLength });
    return p.slice(0, maxLength);
  }

  return p;
}

/* -------------------------------------------------------------------------- */
/*                                  Moderation                                 */
/* -------------------------------------------------------------------------- */

export function moderateContent(
  prompt: string
): { safe: boolean; reason?: string; categories?: string[] } {
  const lower = prompt.toLowerCase();

  // Business context keywords allow benign usage (esp. crypto/finance/security topics)
  const benignBusiness = /\b(strategy|market|roadmap|policy|regulation|regulatory|compliance|report|analysis|architecture|infrastructure|risk|controls|governance|kpi|presentation|slide|deck|test|testing|assessment|business|finance|consulting)\b/i;

  // High-risk categories - expanded for more coverage
  const categories: Array<{ name: string; rx: RegExp; severity: number }> = [
    // Explicit wrongdoing / instructions
    { name: "violent wrongdoing", rx: /\b(build|make|how\s*to|instructions?|guide|recipe)\b.*\b(bomb|weapon|explosive|molotov|knife|gun|poison|bioweapon|nuclear)\b/i, severity: 5 },
    { name: "cyber wrongdoing", rx: /\b(hack|zero[-\s]?day|exploit|ransomware|botnet|ddos|bypass|backdoor|phish|malware|virus|trojan)\b.*\b(guide|how|tutorial|steps?|system|code|script)\b/i, severity: 5 },
    // Extremist violence or threats
    { name: "incitement", rx: /\b(kill|murder|assault|shoot|stab|bomb|terrorize|threaten)\b.*\b(how|plan|guide|tips?|target)\b/i, severity: 5 },
    // Sexual content explicit
    { name: "sexual content", rx: /\b(porn|xxx|nsfw|explicit|nude|sexual|erotic|fetish|incest|bestiality)\b/i, severity: 4 },
    // Drugs illegal
    { name: "illegal drugs", rx: /\b(cocaine|heroin|meth|mdma|lsd|fentanyl|opioid|methamphetamine|ecstasy)\b.*\b(make|produce|manufacture|synthesis|buy|sell)\b/i, severity: 4 },
    // Fraud / scams
    { name: "scams", rx: /\b(get\s*rich\s*quick|double\s*your\s*(money|btc)|seed\s*phrase|giveaway|airdrop\s*claim|ponzi|pyramid|fake\s*invoice|fraud|scam\s*script)\b/i, severity: 4 },
    // Hate / harassment
    { name: "hate speech", rx: /\b(racist|white\s*power|kkk|nazi|kill\s*\w+|gas\s*\w+|genocide|ethnic\s*cleansing|slur|discriminate)\b/i, severity: 5 },
    // Additional: Child exploitation
    { name: "child exploitation", rx: /\b(child|minor|kid|teen)\b.*\b(porn|abuse|exploit|traffic|sextort|groom)\b/i, severity: 5 },
    // Additional: Self-harm
    { name: "self-harm", rx: /\b(suicide|self-harm|cut|overdose|how\s*to\s*die)\b/i, severity: 5 },
  ];

  // **Allow** benign business contexts for crypto/security words
  if (/\b(crypto|bitcoin|nft|blockchain|penetration\s*test|security|vulnerability|exploit|hack)\b/i.test(prompt) && benignBusiness.test(prompt)) {
    // do nothing — allowed
  } else {
    // Add softer generic matches (these alone shouldn't block)
    categories.push(
      { name: "generic violence", rx: /\b(violence|weapon|bomb|terror|assault|murder)\b/i, severity: 1 },
      { name: "generic cyber", rx: /\b(hack|exploit|vulnerability|xss|sql\s*injection|malware|virus)\b/i, severity: 2 },
      { name: "generic spam", rx: /\b(spam|scam|phishing|fraud|fake|forge)\b/i, severity: 2 }
    );
  }

  let score = 0;
  const hits: string[] = [];

  for (const c of categories) {
    if (c.rx.test(lower)) {
      score += c.severity;
      hits.push(c.name);
    }
  }

  // Length abuse
  if (prompt.length > 8000) { // Increased max for complex prompts
    return { safe: false, reason: "Prompt too long (max 8000 chars)", categories: ["abuse"] };
  }

  // Repetition abuse
  const words = prompt.split(/\s+/).filter(Boolean);
  if (words.length > 0) {
    const freq = new Map<string, number>();
    for (const w of words) freq.set(w, (freq.get(w) || 0) + 1);
    const maxFreq = Math.max(...freq.values());
    if (maxFreq > words.length * 0.4) { // Lowered threshold for stricter check
      return { safe: false, reason: "Excessive repetition detected", categories: ["abuse"] };
    }
  }

  // Entropy check for gibberish
  const charFreq = new Map<string, number>();
  for (const char of prompt) {
    charFreq.set(char, (charFreq.get(char) || 0) + 1);
  }
  const entropy = -Array.from(charFreq.values())
    .map(f => f / prompt.length * Math.log2(f / prompt.length))
    .reduce((a, b) => a + b, 0);
  if (entropy < 2.5) { // Low entropy indicates potential spam/gibberish
    return { safe: false, reason: "Low content entropy (possible spam)", categories: ["abuse"] };
  }

  if (score >= 2) {
    logger.warn("Content moderation blocked prompt", { categories: hits, score });
    throw new ModerationError("Content may be unsafe or disallowed", randomUUID(), { categories: hits, score });
  }

  return { safe: true };
}

/* -------------------------------------------------------------------------- */
/*                         Fallback Spec Generation                            */
/* -------------------------------------------------------------------------- */

/**
 * Generate a minimal but valid fallback spec when AI generation fails.
 * Enhanced to extract key phrases from prompt for better relevance.
 */
export function generateFallbackSpec(prompt: string, requestId: string): any {
  logger.warn("Generating fallback spec", { requestId, prompt: prompt.slice(0, 100) });

  // Simple keyword extraction for title
  const keywords = prompt.split(/\s+/).slice(0, 8).join(" ");
  const title = ensureActionVerb(keywords) || "Untitled Slide";

  return {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Professional",
      aspectRatio: "16:9",
    },
    design: {
      pattern: "minimal",
      whitespace: { strategy: "generous", breathingRoom: 0.3 },
    },
    content: {
      title: {
        id: "title",
        text: title,
      },
      subtitle: {
        id: "subtitle",
        text: "AI generation fallback - please try again or simplify prompt",
      },
      bullets: [
        {
          id: "b1",
          items: [
            { text: "Key topic: " + prompt.slice(0, 80), level: 1 },
          ]
        }
      ],
    },
    layout: {
      grid: {
        rows: 8,
        cols: 12,
        gutter: 8,
        margin: { t: 32, r: 32, b: 32, l: 32 },
      },
      regions: [
        {
          name: "header",
          rowStart: 1,
          colStart: 1,
          rowSpan: 2,
          colSpan: 12,
        },
        {
          name: "body",
          rowStart: 3,
          colStart: 1,
          rowSpan: 6,
          colSpan: 12,
        },
      ],
      anchors: [
        {
          refId: "title",
          region: "header",
          order: 0,
        },
        {
          refId: "subtitle",
          region: "header",
          order: 1,
        },
        {
          refId: "b1",
          region: "body",
          order: 0,
        },
      ],
    },
    styleTokens: {
      palette: {
        primary: "#1E40AF",
        accent: "#F59E0B",
        neutral: [...DEFAULT_NEUTRAL_9],
      },
      typography: DEFAULT_TYPOGRAPHY,
      spacing: { base: 4, steps: [0,4,8,12,16,24,32,48,64] },
      radii: { sm: 4, md: 8, lg: 12 },
      shadows: {
        sm: "0 1px 2px rgba(0,0,0,0.05)",
        md: "0 4px 6px rgba(0,0,0,0.1)",
        lg: "0 10px 15px rgba(0,0,0,0.1)",
      },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 },
    },
  };
}

/* -------------------------------------------------------------------------- */
/*                           Enhancement (idempotent)                          */
/* -------------------------------------------------------------------------- */

/**
 * Action verbs for professional slide titles - expanded list
 */
const ACTION_VERBS = [
  "Transform", "Accelerate", "Unlock", "Optimize", "Drive", "Elevate", "Maximize",
  "Enhance", "Streamline", "Innovate", "Deliver", "Enable", "Build", "Scale",
  "Achieve", "Create", "Develop", "Implement", "Launch", "Execute", "Revolutionize",
  "Pioneer", "Catalyze", "Amplify", "Fortify", "Reinvent", "Empower", "Orchestrate"
];

/**
 * Ensure title starts with an action verb for professional impact
 */
function ensureActionVerb(title: string): string {
  const trimmed = title.trim();
  // Check if already starts with an action verb
  const startsWithAction = ACTION_VERBS.some(verb =>
    trimmed.toLowerCase().startsWith(verb.toLowerCase())
  );

  if (startsWithAction) return trimmed;

  // Heuristic-based verb selection
  const growthKeywords = /\b(grow|increase|expand|scale|boost)\b/i.test(trimmed);
  const efficiencyKeywords = /\b(efficien|optim|streamline|reduce|cost|save)\b/i.test(trimmed);
  const innovationKeywords = /\b(innovat|new|develop|create|build)\b/i.test(trimmed);

  let verb = "Unlock";
  if (growthKeywords) verb = "Accelerate";
  else if (efficiencyKeywords) verb = "Optimize";
  else if (innovationKeywords) verb = "Innovate";

  // If title is a noun phrase, prepend appropriate verb
  if (/^(the|a|an)\s+/i.test(trimmed)) {
    return `${verb} ${trimmed.replace(/^(the|a|an)\s+/i, "")}`;
  }

  return `${verb} ${trimmed}`;
}

/**
 * Normalize bullet grammar to parallel voice
 */
function normalizeBulletGrammar(text: string): string {
  let normalized = text.trim();

  // Remove trailing punctuation (periods, commas)
  normalized = normalized.replace(/[.,;:]$/, "");

  // Ensure starts with capital letter
  if (normalized.length > 0) {
    normalized = normalized.charAt(0).toUpperCase() + normalized.slice(1);
  }

  // Ensure action-oriented if possible
  const verbs = /\b(is|are|was|were|has|have|had)\b/i;
  if (verbs.test(normalized)) {
    normalized = normalized.replace(verbs, match => {
      return match.toLowerCase() === 'is' ? 'Implement' : 'Drive'; // Simple replacement
    });
  }

  return normalized;
}

/**
 * Split concatenated bullets like "1776 A 1783 B 1789 C" -> separate items.
 * Extended to handle year ranges, quarters, month-year, and numbered lists.
 */
function splitConcatenatedBullets(bulletGroup: any): any {
  if (!bulletGroup.items || bulletGroup.items.length === 0) return bulletGroup;

  const newItems: any[] = [];
  for (const item of bulletGroup.items) {
    const text = String(item.text || "");

    // Pattern 1: Year events (1776 Event A 1783 Event B)
    const yearEventPattern = /(\d{4}\s+[^0-9]+?)(?=\d{4}\s+|$)/g;
    const yearMatches = [...text.matchAll(yearEventPattern)].map(m => m[0]);

    // Pattern 2: Year ranges (1999–2001 Event A 2002–2004 Event B)
    const yearRangePattern = /(\d{4}[–-]\d{4}\s+[^0-9]+?)(?=\d{4}[–-]\d{4}\s+|$)/g;
    const rangeMatches = [...text.matchAll(yearRangePattern)].map(m => m[0]);

    // Pattern 3: Quarters (Q1 2024 Event A Q2 2024 Event B)
    const quarterPattern = /(Q[1-4]\s+\d{4}\s+[^Q]+?)(?=Q[1-4]\s+\d{4}\s+|$)/gi;
    const quarterMatches = [...text.matchAll(quarterPattern)].map(m => m[0]);

    // Pattern 4: Month-year dates (Jan 2024 Event A Feb 2024 Event B)
    const monthYearPattern = /((?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}\s+[^A-Z]+?)(?=(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}\s+|$)/gi;
    const monthMatches = [...text.matchAll(monthYearPattern)].map(m => m[0]);

    // Pattern 5: Numbered lists (1. Item A 2. Item B)
    const numberedPattern = /(\d+\.\s+[^0-9]+?)(?=\d+\.\s+|$)/g;
    const numberedMatches = [...text.matchAll(numberedPattern)].map(m => m[0].replace(/^\d+\.\s+/, '')); // Strip number

    let matches: string[] = [];
    let patternType = '';

    if (yearMatches.length > 1) {
      matches = yearMatches;
      patternType = 'year';
    } else if (rangeMatches.length > 1) {
      matches = rangeMatches;
      patternType = 'range';
    } else if (quarterMatches.length > 1) {
      matches = quarterMatches;
      patternType = 'quarter';
    } else if (monthMatches.length > 1) {
      matches = monthMatches;
      patternType = 'month';
    } else if (numberedMatches.length > 1) {
      matches = numberedMatches;
      patternType = 'numbered';
    }

    if (matches.length > 1) {
      logger.info("Splitting concatenated timeline bullets", {
        original: text.slice(0, 100),
        count: matches.length,
        pattern: patternType
      });
      for (const m of matches) {
        newItems.push({ text: m.trim(), level: item.level || 1 });
      }
    } else {
      newItems.push(item);
    }
  }
  return { ...bulletGroup, items: newItems };
}

/**
 * Infer and add callouts if key insights detected in bullets
 */
function inferCallouts(spec: any): any {
  if (!Array.isArray(spec.content?.bullets) || spec.content.callouts?.length > 0) return spec;

  const potentialCallouts: any[] = [];
  const insightPatterns = /\b(roi|kpi|metric|achieve|impact|result|projected|forecast|benchmark)\b/i;
  const riskPatterns = /\b(risk|challenge|constraint|warning|blocker|issue)\b/i;

  for (const group of spec.content.bullets) {
    for (const item of group.items || []) {
      const text = item.text || '';
      if (insightPatterns.test(text)) {
        potentialCallouts.push({
          id: `c_${potentialCallouts.length}`,
          type: "success",
          text: text.slice(0, 40),
          icon: "check-circle"
        });
      } else if (riskPatterns.test(text)) {
        potentialCallouts.push({
          id: `c_${potentialCallouts.length}`,
          type: "warning",
          text: text.slice(0, 40),
          icon: "alert-triangle"
        });
      }
    }
  }

  if (potentialCallouts.length > 0) {
    spec.content.callouts = potentialCallouts.slice(0, 3); // Max 3 inferred
    logger.info("Inferred callouts from bullets", { count: spec.content.callouts.length });
  }

  return spec;
}

/**
 * Suggest image placeholders if content suggests visuals
 */
function suggestImages(spec: any): any {
  if (spec.content.images?.length > 0 || spec.content.imagePlaceholders?.length > 0) return spec;

  const visualPatterns = /\b(image|photo|illustration|diagram|chart|graph|picture|visual|depict|show)\b/i;
  const hasVisualHint = visualPatterns.test(JSON.stringify(spec.content));

  if (hasVisualHint) {
    spec.content.imagePlaceholders = [
      {
        id: "ph1",
        role: "illustration",
        alt: "Suggested illustration for key concept"
      }
    ];
    logger.info("Added suggested image placeholder based on content");
  }

  return spec;
}

/**
 * Post-process and enhance AI-generated slide spec.
 * - Ensures required fields
 * - Trims bullets to policy (<=3 groups, <=6 items each, <=80 chars)
 * - Normalizes chart series to labels length
 * - Validates palette, enforces 9 neutrals & contrast AAA
 * - Heuristically fixes header layout
 * - Infers callouts and suggests images
 * - Enhanced color validation with luminance checks
 */
export function enhanceSlideSpec(spec: any): any {
  const warnings: string[] = [];
  logger.info("🔍 Enhancing slide spec for world-class quality");

  // --- Required scaffolding --------------------------------------------------
  spec.meta = spec.meta || { version: "1.0", locale: "en-US", theme: "Professional", aspectRatio: "16:9" };
  spec.design = spec.design || { pattern: "executive", whitespace: { strategy: "balanced", breathingRoom: 0.35 } };
  spec.content = spec.content || {};
  if (!spec.content.title?.text) spec.content.title = { id: "title", text: "Untitled Slide" };

  // --- Title & subtitle hygiene ---------------------------------------------
  if (spec.content.title?.text) {
    let t = String(spec.content.title.text).trim().replace(/\s+/g, " ");

    // Enforce action-verb start for professional impact
    const original = t;
    t = ensureActionVerb(t);
    if (t !== original) {
      warnings.push("Title enhanced with action verb");
    }

    if (t.length > 50) { // Tightened limit for impact
      warnings.push("Title truncated to 50 chars");
      t = t.slice(0, 47).trim() + "...";
    }
    spec.content.title.text = t;
    spec.content.title.id = spec.content.title.id || "title";
  }

  if (spec.content.subtitle?.text) {
    let st = String(spec.content.subtitle.text).trim().replace(/\s+/g, " ");
    if (st.length > 80) { // Tightened limit
      warnings.push("Subtitle truncated to 80 chars");
      st = st.slice(0, 77).trim() + "...";
    }
    spec.content.subtitle.text = st;
    spec.content.subtitle.id = spec.content.subtitle.id || "subtitle";
  }

  // --- Bullets normalization -------------------------------------------------
  if (Array.isArray(spec.content.bullets)) {
    // Cap groups to 3
    if (spec.content.bullets.length > 3) {
      warnings.push("Bullet groups capped at 3");
      spec.content.bullets = spec.content.bullets.slice(0, 3);
    }

    // Ensure IDs and split concatenations
    spec.content.bullets = spec.content.bullets.map((b: any, i: number) => ({
      id: b.id || `bullets_${i}`,
      items: b.items || [],
    }));
    spec.content.bullets = spec.content.bullets.map(splitConcatenatedBullets);

    // Per-item hygiene
    const bulletValidation = validateBulletCount(spec.content.bullets, 6); // Increased to 6
    if (!bulletValidation.valid) warnings.push("Bullet items per group limited to 6");

    for (const group of spec.content.bullets) {
      if (!Array.isArray(group.items)) group.items = [];
      if (group.items.length > 6) group.items = group.items.slice(0, 6);

      for (let i = 0; i < group.items.length; i++) {
        let item = group.items[i];
        if (!item) continue;

        // Convert string items to objects
        if (typeof item === "string") {
          item = { text: item, level: 1 };
          group.items[i] = item;
        }

        item.level = Math.min(3, Math.max(1, Number(item.level || 1)));
        if (typeof item.text === "string") {
          let tx = item.text.trim().replace(/\s+/g, " ");

          // Normalize grammar for parallel voice
          tx = normalizeBulletGrammar(tx);

          if (tx.length > 80) {
            warnings.push("Bullet text truncated to 80 chars");
            tx = tx.slice(0, 77).trim() + "...";
          }
          item.text = tx;
        }
      }
    }
  }

  // --- Callouts & IDs --------------------------------------------------------
  if (Array.isArray(spec.content.callouts)) {
    spec.content.callouts = spec.content.callouts.slice(0, 4); // Increased max to 4
    spec.content.callouts.forEach((c: any, i: number) => (c.id = c.id || `callout_${i}`));
  } else {
    // Infer callouts if possible
    spec = inferCallouts(spec);
  }

  // --- Charts: series length == labels length + format sanity ---------------
  if (spec.content?.dataViz?.labels && spec.content?.dataViz?.series) {
    const viz = spec.content.dataViz;
    viz.id = viz.id || "dataviz";
    const labelCount = Math.max(0, Math.min(12, viz.labels.length)); // Increased max labels
    viz.labels = viz.labels.slice(0, labelCount);

    // Chart label sanity: if labels look numeric but valueFormat is "percent", normalize
    if (viz.valueFormat === "percent") {
      const allNumeric = viz.labels.every((l: any) => !isNaN(Number(l)));
      if (allNumeric) {
        warnings.push("Chart labels appear numeric with percent format - treating as categories");
      }

      // Normalize series values to 0..100 range if they appear to be 0..1
      for (const s of viz.series) {
        if (Array.isArray(s.values)) {
          const maxVal = Math.max(...s.values.filter((v: any) => typeof v === "number"));
          if (maxVal > 0 && maxVal <= 1) {
            s.values = s.values.map((v: any) => typeof v === "number" ? v * 100 : v);
            warnings.push(`Series "${s.name}" normalized to 0-100 for percent format`);
          }
        }
      }
    }

    for (const s of viz.series) {
      const diff = labelCount - (Array.isArray(s.values) ? s.values.length : 0);
      if (diff > 0) {
        warnings.push("Series padded with zeros to match labels length");
        s.values = [...(s.values || []), ...Array(diff).fill(0)];
      } else if (diff < 0) {
        warnings.push("Series trimmed to labels length");
        s.values = (s.values || []).slice(0, labelCount);
      }
    }

    // Add legend if multiple series
    if (viz.series.length > 1 && !viz.legend) {
      viz.legend = { position: "bottom", alignment: "center" };
      warnings.push("Added default legend for multi-series chart");
    }
  }

  // --- Images and placeholders -----------------------------------------------
  spec = suggestImages(spec);

  if (Array.isArray(spec.content.images)) {
    spec.content.images.forEach((img: any, i: number) => {
      img.id = img.id || `img_${i}`;
      if (!img.fit) img.fit = "cover"; // Default fit
    });
  }

  if (Array.isArray(spec.content.imagePlaceholders)) {
    spec.content.imagePlaceholders.forEach((ph: any, i: number) => {
      ph.id = ph.id || `ph_${i}`;
    });
  }

  // --- Palette & accessibility with context-aware generation ------------------
  const hex = /^#[0-9A-Fa-f]{6}$/;

  spec.styleTokens = spec.styleTokens || {};
  spec.styleTokens.palette = spec.styleTokens.palette || {};
  const p = spec.styleTokens.palette;

  // Generate context-aware palette if colors are missing
  if (!p.primary || !hex.test(p.primary) || !p.accent || !hex.test(p.accent)) {
    const prompt = spec.content?.title?.text || "";
    const generatedPalette = generatePalette(prompt);

    if (!p.primary || !hex.test(p.primary)) {
      p.primary = generatedPalette.primary;
      warnings.push("Primary color generated from context");
    }
    if (!p.accent || !hex.test(p.accent)) {
      p.accent = generatedPalette.accent;
      warnings.push("Accent color generated from context");
    }
  }

  // Guarantee exactly 9 neutrals, dark → light
  if (!Array.isArray(p.neutral)) {
    p.neutral = [...DEFAULT_NEUTRAL_9];
    warnings.push("Neutral palette defaulted");
  } else {
    const filtered = p.neutral.filter((c: any) => typeof c === "string" && hex.test(c)).slice(0, 9);
    if (filtered.length !== 9) {
      p.neutral = generateCompliantNeutralRamp();
      warnings.push("Neutral palette regenerated to ensure 9 compliant colors");
    } else {
      p.neutral = filtered;
    }
  }

  // Enforce contrast AAA for text (7:1); AA (4.5:1) for UI accents
  const textColor = p.neutral[0];
  const bgColor = p.neutral[8];
  const textContrast = ensureContrast(textColor, bgColor, 7);
  if (!textContrast.compliant) {
    // Use standard compliant colors
    p.neutral[0] = "#111827"; // Darker text
    p.neutral[8] = "#F9FAFB"; // Lighter bg
    warnings.push("Contrast adjusted to meet WCAG AAA (7:1)");
  }

  // Primary vs accent separation (4.5:1 for consistent legibility)
  const primAcc = ensureContrast(p.primary, p.accent, 4.5);
  if (!primAcc.compliant) {
    // Pick a compliant accent from curated ramp
    const accentRamp = ["#F59E0B", "#EC4899", "#8B5CF6", "#10B981", "#3B82F6", "#EF4444", "#6366F1", "#14B8A6"];
    let foundCompliant = false;
    for (const candidate of accentRamp) {
      const test = ensureContrast(p.primary, candidate, 4.5);
      if (test.compliant) {
        p.accent = candidate;
        foundCompliant = true;
        warnings.push(`Accent color adjusted for 4.5:1 contrast (${test.ratio.toFixed(2)}:1)`);
        break;
      }
    }
    if (!foundCompliant) {
      p.accent = "#F59E0B"; // Fallback
      warnings.push("Accent color set to fallback (contrast may be suboptimal)");
    }
  }

  // --- Layout heuristics -----------------------------------------------------
  spec = fixLayoutIssues(spec);

  if (warnings.length) {
    logger.info("Spec enhancement warnings", { warnings });
  }

  return spec;
}

/* -------------------------------------------------------------------------- */
/*                              Layout heuristics                              */
/* -------------------------------------------------------------------------- */

function fixLayoutIssues(spec: any): any {
  if (!spec.layout?.regions || !spec.layout?.anchors) return spec;

  const hasSubtitle = !!spec.content?.subtitle?.text;
  const hasTitle = !!spec.content?.title?.text;
  const hasChart = !!spec.content?.dataViz;
  const hasBullets = Array.isArray(spec.content?.bullets) && spec.content.bullets.length > 0;

  const header = spec.layout.regions.find((r: any) => r.name === "header");
  if (header && hasTitle && hasSubtitle && header.rowSpan < 2) {
    header.rowSpan = 2;

    const body = spec.layout.regions.find((r: any) => r.name === "body");
    if (body && body.rowStart <= 2) {
      body.rowStart = 3;
      body.rowSpan = Math.max(1, body.rowSpan - (3 - body.rowStart));
    }
    const aside = spec.layout.regions.find((r: any) => r.name === "aside" || r.name === "sidebar");
    if (aside && aside.rowStart <= 2) {
      aside.rowStart = 3;
      aside.rowSpan = Math.max(1, aside.rowSpan - (3 - aside.rowStart));
    }
  }

  // Split layout for chart + bullets
  if (hasChart && hasBullets && spec.layout.regions.length < 3) {
    // Add left/right body if not present
    const bodyIndex = spec.layout.regions.findIndex((r: any) => r.name === "body");
    if (bodyIndex !== -1) {
      const body = spec.layout.regions[bodyIndex];
      spec.layout.regions.splice(bodyIndex, 1); // Remove full body

      spec.layout.regions.push({
        name: "left-body",
        rowStart: body.rowStart,
        colStart: 1,
        rowSpan: body.rowSpan,
        colSpan: 5,
      });
      spec.layout.regions.push({
        name: "right-body",
        rowStart: body.rowStart,
        colStart: 6,
        rowSpan: body.rowSpan,
        colSpan: 7,
      });

      // Reassign anchors
      spec.layout.anchors = spec.layout.anchors.map((a: any) => {
        if (a.region === "body") {
          a.region = hasBullets ? "left-body" : "right-body";
        }
        return a;
      });

      // Assign chart to right, bullets to left
      const chartAnchor = spec.layout.anchors.find((a: any) => a.refId === spec.content.dataViz?.id);
      if (chartAnchor) chartAnchor.region = "right-body";

      const bulletAnchors = spec.layout.anchors.filter((a: any) => a.refId.startsWith("bullets_") || a.refId.startsWith("b"));
      bulletAnchors.forEach((a: any) => { a.region = "left-body"; });

      logger.info("Split body layout for chart + bullets");
    }
  }

  // Drop anchors pointing to missing regions
  const regionNames = new Set(spec.layout.regions.map((r: any) => r.name));
  spec.layout.anchors = spec.layout.anchors.filter((a: any) => regionNames.has(a.region));

  // Ensure all content elements have anchors
  const anchorRefIds = new Set(spec.layout.anchors.map((a: any) => a.refId));
  const mainRegion = spec.layout.regions.find((r: any) => r.name.includes("body"))?.name || "body";

  // Add chart anchor if chart exists but not anchored
  if (spec.content?.dataViz?.id && !anchorRefIds.has(spec.content.dataViz.id)) {
    const maxOrder = Math.max(
      0,
      ...spec.layout.anchors
        .filter((a: any) => a.region === mainRegion)
        .map((a: any) => a.order || 0)
    );
    spec.layout.anchors.push({
      refId: spec.content.dataViz.id,
      region: mainRegion,
      order: maxOrder + 1,
    });
    anchorRefIds.add(spec.content.dataViz.id);
  }

  // Add bullet anchors if bullets exist but not anchored
  if (Array.isArray(spec.content?.bullets)) {
    for (const bullet of spec.content.bullets) {
      if (bullet.id && !anchorRefIds.has(bullet.id)) {
        const maxOrder = Math.max(
          0,
          ...spec.layout.anchors
            .filter((a: any) => a.region === mainRegion)
            .map((a: any) => a.order || 0)
        );
        spec.layout.anchors.push({
          refId: bullet.id,
          region: mainRegion,
          order: maxOrder + 1,
        });
        anchorRefIds.add(bullet.id);
      }
    }
  }

  // Add callout anchors if callouts exist but not anchored
  if (Array.isArray(spec.content?.callouts)) {
    for (const callout of spec.content.callouts) {
      if (callout.id && !anchorRefIds.has(callout.id)) {
        const maxOrder = Math.max(
          0,
          ...spec.layout.anchors
            .filter((a: any) => a.region === mainRegion)
            .map((a: any) => a.order || 0)
        );
        spec.layout.anchors.push({
          refId: callout.id,
          region: mainRegion,
          order: maxOrder + 1,
        });
        anchorRefIds.add(callout.id);
      }
    }
  }

  // Add image anchors
  if (Array.isArray(spec.content?.images)) {
    for (const img of spec.content.images) {
      if (img.id && !anchorRefIds.has(img.id)) {
        const maxOrder = Math.max(
          0,
          ...spec.layout.anchors
            .filter((a: any) => a.region === mainRegion)
            .map((a: any) => a.order || 0)
        );
        spec.layout.anchors.push({
          refId: img.id,
          region: mainRegion,
          order: maxOrder + 1,
        });
        anchorRefIds.add(img.id);
      }
    }
  }

  return spec;
}

================================================================================
FILE: ./functions/src/colorPaletteGenerator.ts
================================================================================

/**
 * Advanced Color Palette Generator
 * Generates context-aware, accessible color palettes based on prompt analysis
 * Enhanced with more presets from top consulting firms (McKinsey, BCG, Bain)
 * Improved context detection with weighted keyword matching
 * Automatic contrast adjustment for accessibility
 * Expanded utilities for color manipulation
 */

/* -------------------------------------------------------------------------- */
/*                          Color Utilities                                   */
/* -------------------------------------------------------------------------- */

/** Convert hex to RGB */
function hexToRgb(hex: string): { r: number; g: number; b: number } {
  const clean = hex.replace("#", "").slice(0, 6);
  const r = parseInt(clean.slice(0, 2), 16);
  const g = parseInt(clean.slice(2, 4), 16);
  const b = parseInt(clean.slice(4, 6), 16);
  return { r, g, b };
}

/** Convert RGB to hex */
function rgbToHex(r: number, g: number, b: number): string {
  return `#${[r, g, b].map((x) => Math.round(x).toString(16).padStart(2, "0")).join("").toUpperCase()}`;
}

/** Calculate relative luminance (WCAG) */
function getLuminance(hex: string): number {
  const { r, g, b } = hexToRgb(hex);
  const norm = (c: number) => c / 255;
  const lin = (c: number) => (c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4));
  return 0.2126 * lin(norm(r)) + 0.7152 * lin(norm(g)) + 0.0722 * lin(norm(b));
}

/** Calculate contrast ratio (WCAG) */
function getContrastRatio(hex1: string, hex2: string): number {
  const l1 = getLuminance(hex1);
  const l2 = getLuminance(hex2);
  return (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
}

/** Lighten or darken color by percentage */
function adjustColor(hex: string, percent: number): string {
  const { r, g, b } = hexToRgb(hex);
  const factor = percent / 100;
  const adjust = (c: number) => Math.min(255, Math.max(0, c + c * factor));
  return rgbToHex(adjust(r), adjust(g), adjust(b));
}

/** Generate neutral ramp (9 colors from dark to light) with consulting-style grays */
function generateNeutralRamp(baseDark = "#0F172A", baseLight = "#F8FAFC"): string[] {
  const ramp: string[] = [];
  const darkRgb = hexToRgb(baseDark);
  const lightRgb = hexToRgb(baseLight);

  for (let i = 0; i < 9; i++) {
    const t = i / 8;
    const r = Math.round(darkRgb.r + (lightRgb.r - darkRgb.r) * t);
    const g = Math.round(darkRgb.g + (lightRgb.g - darkRgb.g) * t);
    const b = Math.round(darkRgb.b + (lightRgb.b - darkRgb.b) * t);
    ramp.push(rgbToHex(r, g, b));
  }

  return ramp;
}

/* -------------------------------------------------------------------------- */
/*                      Context-Aware Palette Selection                       */
/* -------------------------------------------------------------------------- */

interface PaletteOption {
  primary: string;
  accent: string;
  name: string;
  fallbackAccent?: string[]; // Alternatives if contrast fails
}

const PALETTE_PRESETS: Record<string, PaletteOption> = {
  // Original presets
  tech: { primary: "#1E40AF", accent: "#F59E0B", name: "Tech Blue", fallbackAccent: ["#EA580C", "#D97706"] },
  finance: { primary: "#0F172A", accent: "#10B981", name: "Finance Navy", fallbackAccent: ["#059669", "#84CC16"] },
  creative: { primary: "#7C3AED", accent: "#EC4899", name: "Creative Purple", fallbackAccent: ["#DB2777", "#F472B6"] },
  energy: { primary: "#EA580C", accent: "#F97316", name: "Energy Orange", fallbackAccent: ["#DC2626", "#EF4444"] },
  healthcare: { primary: "#0891B2", accent: "#06B6D4", name: "Healthcare Cyan", fallbackAccent: ["#0E7490", "#22D3EE"] },
  sustainability: { primary: "#15803D", accent: "#84CC16", name: "Sustainability Green", fallbackAccent: ["#65A30D", "#A3E635"] },
  corporate: { primary: "#1F2937", accent: "#6366F1", name: "Corporate Gray", fallbackAccent: ["#4F46E5", "#818CF8"] },
  luxury: { primary: "#1E1B4B", accent: "#D4AF37", name: "Luxury Gold", fallbackAccent: ["#CA8A04", "#EAB308"] },
  
  // New consulting-firm inspired presets
  mckinsey: { primary: "#005EB8", accent: "#F3C13A", name: "McKinsey Blue", fallbackAccent: ["#FFCC00", "#FFD700"] },
  bcg: { primary: "#002E5D", accent: "#E31E24", name: "BCG Navy", fallbackAccent: ["#D32F2F", "#EF5350"] },
  bain: { primary: "#0033A0", accent: "#FFC220", name: "Bain Blue", fallbackAccent: ["#FFA000", "#FFECB3"] },
  strategy: { primary: "#00457C", accent: "#00A3E0", name: "Strategy Teal", fallbackAccent: ["#0097A7", "#4DD0E1"] },
  data: { primary: "#2E3192", accent: "#29ABE2", name: "Data Indigo", fallbackAccent: ["#00BFFF", "#87CEEB"] },
};

/** Weighted keyword matching for better context detection */
interface KeywordWeight {
  keyword: RegExp;
  weight: number;
}

const CONTEXT_KEYWORDS: Record<string, KeywordWeight[]> = {
  tech: [
    { keyword: /\b(tech|technology|software|ai|artificial intelligence|machine learning|data|digital|cloud|api|platform|app|devops|cyber|blockchain)\b/i, weight: 3 },
    { keyword: /\b(innovation|startup|tech stack|programming|code|algorithm)\b/i, weight: 2 },
  ],
  finance: [
    { keyword: /\b(finance|financial|revenue|profit|investment|market|trading|banking|fintech|stocks|crypto|portfolio|audit|compliance|risk)\b/i, weight: 3 },
    { keyword: /\b(economy|budget|forecast|valuation|merger|acquisition|ipo)\b/i, weight: 2 },
  ],
  creative: [
    { keyword: /\b(creative|design|brand|marketing|campaign|content|media|advertising|ux|ui|graphic|art|photography|video)\b/i, weight: 3 },
    { keyword: /\b(innovation|storytelling|visual|concept|idea|brainstorm)\b/i, weight: 2 },
  ],
  energy: [
    { keyword: /\b(energy|power|oil|gas|renewable|solar|wind|battery|electric|ev|growth|momentum|accelerate|drive|transform)\b/i, weight: 3 },
    { keyword: /\b(sustainable energy|grid|utility|fossil fuel|carbon capture)\b/i, weight: 2 },
  ],
  healthcare: [
    { keyword: /\b(health|healthcare|medical|patient|care|wellness|pharma|biotech|hospital|doctor|medicine|telehealth)\b/i, weight: 3 },
    { keyword: /\b(clinical|trial|drug|therapy|diagnostics|epidemic|pandemic)\b/i, weight: 2 },
  ],
  sustainability: [
    { keyword: /\b(sustain|sustainability|green|eco|environment|carbon|renewable|climate|esg|recycle|circular economy)\b/i, weight: 3 },
    { keyword: /\b(net zero|emissions|conservation|biodiversity|green tech)\b/i, weight: 2 },
  ],
  corporate: [
    { keyword: /\b(corporate|business|enterprise|management|strategy|operations|hr|leadership|team|organization)\b/i, weight: 3 },
    { keyword: /\b(policy|governance|compliance|risk management|board|executive)\b/i, weight: 2 },
  ],
  luxury: [
    { keyword: /\b(luxury|premium|high-end|exclusive|brand|fashion|jewelry|watches|cars|travel|hospitality)\b/i, weight: 3 },
    { keyword: /\b(elegant|sophisticated|elite|bespoke|couture)\b/i, weight: 2 },
  ],
  mckinsey: [
    { keyword: /\b(mckinsey|consulting|strategy consulting|management consulting)\b/i, weight: 4 },
  ],
  bcg: [
    { keyword: /\b(bcg|boston consulting group)\b/i, weight: 4 },
  ],
  bain: [
    { keyword: /\b(bain)\b/i, weight: 4 },
  ],
  strategy: [
    { keyword: /\b(strategy|strategic|planning|roadmap|vision|mission|goals|objectives)\b/i, weight: 3 },
  ],
  data: [
    { keyword: /\b(data|analytics|bi|business intelligence|big data|insights|metrics|kpi|dashboard|visualization)\b/i, weight: 3 },
  ],
};

/** Detect context from prompt using weighted scoring */
export function selectPaletteByContext(prompt: string): PaletteOption {
  const lower = prompt.toLowerCase();
  const scores: Record<string, number> = {};
  
  Object.keys(CONTEXT_KEYWORDS).forEach((context) => {
    scores[context] = CONTEXT_KEYWORDS[context].reduce((sum, { keyword, weight }) => 
      keyword.test(lower) ? sum + weight : sum, 0);
  });

  // Find the context with the highest score
  let maxScore = 0;
  let selectedContext = "corporate"; // Default
  Object.entries(scores).forEach(([context, score]) => {
    if (score > maxScore) {
      maxScore = score;
      selectedContext = context;
    }
  });

  return PALETTE_PRESETS[selectedContext];
}

/**
 * Ensure accent meets minimum contrast with primary and background
 * If not, select from fallbacks or adjust lightness
 */
function ensureAccessibleAccent(primary: string, accent: string, fallbackAccents: string[] = [], bg: string = "#FFFFFF"): string {
  let currentAccent = accent;
  let ratioPrim = getContrastRatio(primary, currentAccent);
  let ratioBg = getContrastRatio(currentAccent, bg);

  if (ratioPrim >= 4.5 && ratioBg >= 7) return currentAccent;

  // Try fallbacks
  for (const fallback of fallbackAccents) {
    ratioPrim = getContrastRatio(primary, fallback);
    ratioBg = getContrastRatio(fallback, bg);
    if (ratioPrim >= 4.5 && ratioBg >= 7) return fallback;
  }

  // Adjust lightness if still not compliant
  let adjustPercent = 10;
  while (adjustPercent <= 50) {
    currentAccent = adjustColor(accent, -adjustPercent); // Darken
    ratioPrim = getContrastRatio(primary, currentAccent);
    ratioBg = getContrastRatio(currentAccent, bg);
    if (ratioPrim >= 4.5 && ratioBg >= 7) return currentAccent;

    currentAccent = adjustColor(accent, adjustPercent); // Lighten
    ratioPrim = getContrastRatio(primary, currentAccent);
    ratioBg = getContrastRatio(currentAccent, bg);
    if (ratioPrim >= 4.5 && ratioBg >= 7) return currentAccent;

    adjustPercent += 10;
  }

  // Fallback to safe accent
  return "#F59E0B";
}

/* -------------------------------------------------------------------------- */
/*                      Palette Generation & Validation                       */
/* -------------------------------------------------------------------------- */

export interface GeneratedPalette {
  primary: string;
  accent: string;
  neutral: string[];
  contrastRatioPrimBg: number;
  contrastRatioAccentBg: number;
  accessible: boolean;
}

/**
 * Generate a complete, accessible color palette
 * - Selects primary/accent based on context
 * - Ensures minimum contrasts (4.5:1 primary/accent, 7:1 text/bg)
 * - Generates neutral ramp
 * - Adjusts accent if necessary for accessibility
 */
export function generatePalette(prompt: string): GeneratedPalette {
  const preset = selectPaletteByContext(prompt);
  const neutral = generateNeutralRamp();
  const bg = neutral[8]; // Lightest neutral as bg
  const text = neutral[0]; // Darkest as text

  // Ensure text/bg contrast
  const textBgRatio = getContrastRatio(text, bg);
  if (textBgRatio < 7) {
    neutral[0] = adjustColor(neutral[0], -20); // Darken text if needed
  }

  let accent = ensureAccessibleAccent(preset.primary, preset.accent, preset.fallbackAccent || [], bg);

  const contrastRatioPrimBg = getContrastRatio(preset.primary, bg);
  const contrastRatioAccentBg = getContrastRatio(accent, bg);

  return {
    primary: preset.primary,
    accent,
    neutral,
    contrastRatioPrimBg,
    contrastRatioAccentBg,
    accessible: contrastRatioPrimBg >= 7 && contrastRatioAccentBg >= 4.5,
  };
}

export default {
  generatePalette,
  selectPaletteByContext,
  getContrastRatio,
  adjustColor,
};

================================================================================
FILE: ./functions/src/colorUtils.ts
================================================================================

/**
 * Color Utility Functions
 * - Contrast ratio calculation (WCAG)
 * - Color manipulation and validation
 * - Nearest compliant color finding
 *
 * Note: Core color utilities are in shared.ts to avoid duplication
 */

export { hexToRgb, rgbToHex, getLuminance, contrastRatio, isValidHex } from "./shared";
import { hexToRgb, rgbToHex, contrastRatio, isValidHex } from "./shared";

/**
 * Find nearest compliant color from a palette
 * Ensures the color has sufficient contrast with white background
 */
export function nearestCompliantColor(
  targetColor: string,
  palette: string[],
  minContrast: number = 4.5
): string {
  if (!isValidHex(targetColor)) {
    return palette[0] || "#1E40AF";
  }

  // Check if target color is already compliant
  const targetContrast = contrastRatio(targetColor, "#FFFFFF");
  if (targetContrast >= minContrast) {
    return targetColor;
  }

  // Find best compliant color from palette
  let bestColor = palette[0] || "#1E40AF";
  let bestContrast = contrastRatio(bestColor, "#FFFFFF");

  for (const color of palette) {
    if (!isValidHex(color)) continue;
    const contrast = contrastRatio(color, "#FFFFFF");
    if (contrast >= minContrast && contrast > bestContrast) {
      bestColor = color;
      bestContrast = contrast;
    }
  }

  return bestColor;
}

/**
 * Lighten a color by a percentage (0-100)
 */
export function lighten(hex: string, percent: number): string {
  const [r, g, b] = hexToRgb(hex);
  const factor = 1 + percent / 100;
  return rgbToHex(
    Math.min(255, Math.round(r * factor)),
    Math.min(255, Math.round(g * factor)),
    Math.min(255, Math.round(b * factor))
  );
}

/**
 * Darken a color by a percentage (0-100)
 */
export function darken(hex: string, percent: number): string {
  const [r, g, b] = hexToRgb(hex);
  const factor = 1 - percent / 100;
  return rgbToHex(
    Math.max(0, Math.round(r * factor)),
    Math.max(0, Math.round(g * factor)),
    Math.max(0, Math.round(b * factor))
  );
}

/**
 * Mix two colors by percentage
 */
export function mix(hex1: string, hex2: string, percent: number): string {
  const [r1, g1, b1] = hexToRgb(hex1);
  const [r2, g2, b2] = hexToRgb(hex2);
  const factor = percent / 100;
  return rgbToHex(
    Math.round(r1 * (1 - factor) + r2 * factor),
    Math.round(g1 * (1 - factor) + g2 * factor),
    Math.round(b1 * (1 - factor) + b2 * factor)
  );
}



================================================================================
FILE: ./functions/src/coordinateMapper.ts
================================================================================

/**
 * Coordinate Mapper
 * =================
 * Unified coordinate system for pixel-perfect PPTX generation matching preview.
 * Handles px↔in conversions, grid calculations, and region positioning.
 */

import type { SlideSpecV1 } from "@plzfixthx/slide-spec";

/* -------------------------------------------------------------------------- */
/*                            Constants                                       */
/* -------------------------------------------------------------------------- */

export const PX_PER_INCH = 96; // CSS standard (96 DPI)
export const SLIDE_WIDTH_IN = 10; // Standard 16:9 slide width
export const SLIDE_HEIGHT_16_9_IN = 5.625; // 16:9 aspect ratio
export const SLIDE_HEIGHT_4_3_IN = 7.5; // 4:3 aspect ratio

/* -------------------------------------------------------------------------- */
/*                            Unit Conversions                                */
/* -------------------------------------------------------------------------- */

/**
 * Convert pixels to inches
 */
export function pxToIn(px: number): number {
  return px / PX_PER_INCH;
}

/**
 * Convert inches to pixels
 */
export function inToPx(inches: number): number {
  return inches * PX_PER_INCH;
}

/**
 * Convert pixels to points (1 point = 1/72 inch)
 */
export function pxToPoints(px: number): number {
  return (px / PX_PER_INCH) * 72;
}

/**
 * Convert points to pixels
 */
export function pointsToPx(points: number): number {
  return (points / 72) * PX_PER_INCH;
}

/* -------------------------------------------------------------------------- */
/*                            Slide Dimensions                                */
/* -------------------------------------------------------------------------- */

/**
 * Get slide dimensions in inches
 */
export function getSlideDimensionsIn(aspectRatio: "16:9" | "4:3") {
  const width = SLIDE_WIDTH_IN;
  const height = aspectRatio === "16:9" ? SLIDE_HEIGHT_16_9_IN : SLIDE_HEIGHT_4_3_IN;
  return { width, height };
}

/**
 * Get slide dimensions in pixels
 */
export function getSlideDimensionsPx(aspectRatio: "16:9" | "4:3") {
  const { width, height } = getSlideDimensionsIn(aspectRatio);
  return {
    width: inToPx(width),
    height: inToPx(height),
  };
}

/* -------------------------------------------------------------------------- */
/*                            Grid Calculations                               */
/* -------------------------------------------------------------------------- */

export interface GridDimensions {
  cellWidthIn: number;
  cellHeightIn: number;
  cellWidthPx: number;
  cellHeightPx: number;
  totalWidthIn: number;
  totalHeightIn: number;
}

/**
 * Calculate grid cell dimensions
 */
export function calculateGridDimensions(
  spec: SlideSpecV1
): GridDimensions {
  const { width: slideWidthIn, height: slideHeightIn } = getSlideDimensionsIn(spec.meta.aspectRatio);
  const grid = spec.layout.grid;

  // Calculate available space after margins
  const availableWidthIn = slideWidthIn - grid.margin.l - grid.margin.r;
  const availableHeightIn = slideHeightIn - grid.margin.t - grid.margin.b;

  // Calculate gutter space
  const totalGutterWidthIn = pxToIn(grid.gutter * (grid.cols - 1));
  const totalGutterHeightIn = pxToIn(grid.gutter * (grid.rows - 1));

  // Calculate cell dimensions
  const cellWidthIn = (availableWidthIn - totalGutterWidthIn) / grid.cols;
  const cellHeightIn = (availableHeightIn - totalGutterHeightIn) / grid.rows;

  return {
    cellWidthIn,
    cellHeightIn,
    cellWidthPx: inToPx(cellWidthIn),
    cellHeightPx: inToPx(cellHeightIn),
    totalWidthIn: slideWidthIn,
    totalHeightIn: slideHeightIn,
  };
}

/* -------------------------------------------------------------------------- */
/*                            Region Positioning                              */
/* -------------------------------------------------------------------------- */

export interface RegionPosition {
  xIn: number;
  yIn: number;
  widthIn: number;
  heightIn: number;
  xPx: number;
  yPx: number;
  widthPx: number;
  heightPx: number;
}

/**
 * Calculate region position and dimensions
 */
export function calculateRegionPosition(
  spec: SlideSpecV1,
  region: SlideSpecV1["layout"]["regions"][number]
): RegionPosition {
  const grid = spec.layout.grid;
  const dims = calculateGridDimensions(spec);

  // Calculate position in inches
  const xIn = pxToIn(grid.margin.l) + (region.colStart - 1) * (dims.cellWidthIn + pxToIn(grid.gutter));
  const yIn = pxToIn(grid.margin.t) + (region.rowStart - 1) * (dims.cellHeightIn + pxToIn(grid.gutter));

  // Calculate size in inches
  const widthIn = region.colSpan * dims.cellWidthIn + (region.colSpan - 1) * pxToIn(grid.gutter);
  const heightIn = region.rowSpan * dims.cellHeightIn + (region.rowSpan - 1) * pxToIn(grid.gutter);

  return {
    xIn,
    yIn,
    widthIn,
    heightIn,
    xPx: inToPx(xIn),
    yPx: inToPx(yIn),
    widthPx: inToPx(widthIn),
    heightPx: inToPx(heightIn),
  };
}

/* -------------------------------------------------------------------------- */
/*                            Accent Positioning                              */
/* -------------------------------------------------------------------------- */

export interface AccentDimensions {
  leftBarWidthIn: number;
  topRightGlazeWidthIn: number;
  topRightGlazeHeightIn: number;
  bottomBlockWidthIn: number;
  bottomBlockHeightIn: number;
  verticalLineWidthIn: number;
}

/**
 * Get accent dimensions in inches
 */
export function getAccentDimensions(): AccentDimensions {
  return {
    leftBarWidthIn: 0.12,
    topRightGlazeWidthIn: 3.0,
    topRightGlazeHeightIn: 1.0,
    bottomBlockWidthIn: 2.5,
    bottomBlockHeightIn: 0.6,
    verticalLineWidthIn: 0.04,
  };
}

/* -------------------------------------------------------------------------- */
/*                            Typography Positioning                          */
/* -------------------------------------------------------------------------- */

export interface TextPosition {
  xIn: number;
  yIn: number;
  widthIn: number;
  heightIn: number;
  fontSizePt: number;
}

/**
 * Calculate text position for title
 */
export function calculateTitlePosition(): TextPosition {
  return {
    xIn: 0.5,
    yIn: 1.8,
    widthIn: 9.0,
    heightIn: 1.2,
    fontSizePt: 26,
  };
}

/**
 * Calculate text position for subtitle
 */
export function calculateSubtitlePosition(): TextPosition {
  return {
    xIn: 0.5,
    yIn: 3.1,
    widthIn: 9.0,
    heightIn: 1.5,
    fontSizePt: 16,
  };
}

/* -------------------------------------------------------------------------- */
/*                            Validation                                      */
/* -------------------------------------------------------------------------- */

/**
 * Validate coordinate mappings
 */
export function validateCoordinates(spec: SlideSpecV1): {
  valid: boolean;
  issues: string[];
} {
  const issues: string[] = [];
  const dims = calculateGridDimensions(spec);

  // Check cell dimensions are positive
  if (dims.cellWidthIn <= 0) {
    issues.push(`Cell width ${dims.cellWidthIn}in is not positive`);
  }
  if (dims.cellHeightIn <= 0) {
    issues.push(`Cell height ${dims.cellHeightIn}in is not positive`);
  }

  // Check regions fit within grid
  for (const region of spec.layout.regions) {
    if (region.colStart + region.colSpan - 1 > spec.layout.grid.cols) {
      issues.push(`Region exceeds grid columns: ${region.name}`);
    }
    if (region.rowStart + region.rowSpan - 1 > spec.layout.grid.rows) {
      issues.push(`Region exceeds grid rows: ${region.name}`);
    }
  }

  return {
    valid: issues.length === 0,
    issues,
  };
}

/* -------------------------------------------------------------------------- */
/*                            Debug Utilities                                 */
/* -------------------------------------------------------------------------- */

/**
 * Log coordinate mappings for debugging
 */
export function logCoordinateMappings(spec: SlideSpecV1): void {
  console.group("Coordinate Mappings");
  console.log("Slide Dimensions:", getSlideDimensionsIn(spec.meta.aspectRatio));
  console.log("Grid Dimensions:", calculateGridDimensions(spec));
  console.log("Regions:");
  for (const region of spec.layout.regions) {
    console.log(`  ${region.name}:`, calculateRegionPosition(spec, region));
  }
  console.log("Accents:", getAccentDimensions());
  console.log("Validation:", validateCoordinates(spec));
  console.groupEnd();
}



================================================================================
FILE: ./functions/src/errorHandler.ts
================================================================================

/**
 * Error Handler Module
 * - Normalize errors to consistent format
 * - Map errors to appropriate HTTP status codes
 * - Provide user-friendly error messages
 * - Track error metrics
 */

import { Response } from "express";
import * as logger from "firebase-functions/logger";

export enum ErrorCode {
  // Client errors (4xx)
  BAD_REQUEST = "BAD_REQUEST",
  INVALID_PAYLOAD = "INVALID_PAYLOAD",
  PAYLOAD_TOO_LARGE = "PAYLOAD_TOO_LARGE",
  RATE_LIMITED = "RATE_LIMITED",
  MODERATION_REJECTED = "MODERATION_REJECTED",
  ABUSE_DETECTED = "ABUSE_DETECTED",

  // Server errors (5xx)
  AI_SERVICE_ERROR = "AI_SERVICE_ERROR",
  AI_TIMEOUT = "AI_TIMEOUT",
  AI_VALIDATION_ERROR = "AI_VALIDATION_ERROR",
  PPTX_GENERATION_ERROR = "PPTX_GENERATION_ERROR",
  IMAGE_FETCH_ERROR = "IMAGE_FETCH_ERROR",
  INTERNAL_ERROR = "INTERNAL_ERROR",
}

export interface ErrorResponse {
  error: {
    code: ErrorCode;
    message: string;
    details?: Record<string, unknown>;
  };
  requestId?: string;
  retryAfter?: number;
}

export class AppError extends Error {
  constructor(
    public code: ErrorCode,
    message: string,
    public statusCode: number = 500,
    public details?: Record<string, unknown>
  ) {
    super(message);
    this.name = "AppError";
  }
}

/**
 * Map error code to HTTP status code
 */
export function getStatusCode(code: ErrorCode): number {
  const statusMap: Record<ErrorCode, number> = {
    [ErrorCode.BAD_REQUEST]: 400,
    [ErrorCode.INVALID_PAYLOAD]: 400,
    [ErrorCode.PAYLOAD_TOO_LARGE]: 413,
    [ErrorCode.RATE_LIMITED]: 429,
    [ErrorCode.MODERATION_REJECTED]: 400,
    [ErrorCode.ABUSE_DETECTED]: 400,
    [ErrorCode.AI_SERVICE_ERROR]: 502,
    [ErrorCode.AI_TIMEOUT]: 504,
    [ErrorCode.AI_VALIDATION_ERROR]: 400,
    [ErrorCode.PPTX_GENERATION_ERROR]: 500,
    [ErrorCode.IMAGE_FETCH_ERROR]: 500,
    [ErrorCode.INTERNAL_ERROR]: 500,
  };
  return statusMap[code] || 500;
}

/**
 * Get user-friendly error message
 */
export function getUserMessage(code: ErrorCode): string {
  const messages: Record<ErrorCode, string> = {
    [ErrorCode.BAD_REQUEST]: "Invalid request",
    [ErrorCode.INVALID_PAYLOAD]: "Request payload is invalid",
    [ErrorCode.PAYLOAD_TOO_LARGE]: "Request is too large",
    [ErrorCode.RATE_LIMITED]: "Too many requests, please try again later",
    [ErrorCode.MODERATION_REJECTED]: "Content does not meet safety guidelines",
    [ErrorCode.ABUSE_DETECTED]: "Request flagged as abusive",
    [ErrorCode.AI_SERVICE_ERROR]: "AI service temporarily unavailable",
    [ErrorCode.AI_TIMEOUT]: "Request took too long, please try again",
    [ErrorCode.AI_VALIDATION_ERROR]: "Generated content failed validation",
    [ErrorCode.PPTX_GENERATION_ERROR]: "Failed to generate PowerPoint",
    [ErrorCode.IMAGE_FETCH_ERROR]: "Failed to fetch image",
    [ErrorCode.INTERNAL_ERROR]: "Internal server error",
  };
  return messages[code] || "An error occurred";
}

/**
 * Normalize any error to AppError
 */
export function normalizeError(error: unknown, _requestId?: string): AppError {
  if (error instanceof AppError) {
    return error;
  }

  if (error instanceof Error) {
    // Timeout errors
    if (error.message.includes("timeout") || error.message.includes("TIMEOUT")) {
      return new AppError(
        ErrorCode.AI_TIMEOUT,
        "Request timeout",
        504,
        { originalMessage: error.message }
      );
    }

    // Validation errors
    if (error.message.includes("validation") || error.message.includes("Validation")) {
      return new AppError(
        ErrorCode.AI_VALIDATION_ERROR,
        "Validation failed",
        400,
        { originalMessage: error.message }
      );
    }

    // Network/service errors
    if (
      error.message.includes("ECONNREFUSED") ||
      error.message.includes("ENOTFOUND") ||
      error.message.includes("service")
    ) {
      return new AppError(
        ErrorCode.AI_SERVICE_ERROR,
        "Service unavailable",
        502,
        { originalMessage: error.message }
      );
    }

    // Generic error
    return new AppError(
      ErrorCode.INTERNAL_ERROR,
      error.message || "Unknown error",
      500,
      { originalMessage: error.message }
    );
  }

  return new AppError(
    ErrorCode.INTERNAL_ERROR,
    "Unknown error occurred",
    500,
    { originalError: String(error) }
  );
}

/**
 * Send normalized error response
 */
export function sendErrorResponse(
  res: Response,
  error: unknown,
  requestId?: string,
  retryAfter?: number
): void {
  const appError = normalizeError(error, requestId);
  const statusCode = getStatusCode(appError.code);

  logger.error("Error response", {
    requestId,
    code: appError.code,
    message: appError.message,
    statusCode,
    details: appError.details,
  });

  const response: ErrorResponse = {
    error: {
      code: appError.code,
      message: getUserMessage(appError.code),
      details: appError.details,
    },
    requestId,
  };

  if (retryAfter) {
    response.retryAfter = retryAfter;
    res.set("Retry-After", String(retryAfter));
  }

  res.status(statusCode).json(response);
}

/**
 * Track error metrics
 */
export function trackError(code: ErrorCode, context?: Record<string, unknown>): void {
  logger.warn("Error tracked", {
    code,
    ...context,
  });
}



================================================================================
FILE: ./functions/src/imageOptimizer.ts
================================================================================

/**
 * Image Optimization Module
 * - Downscale images to 96dpi (web standard)
 * - Convert to JPEG quality 82 unless PNG transparency needed
 * - Cache by URL hash to avoid re-processing
 */

import sharp from "sharp";
import crypto from "crypto";

/** In-memory cache for optimized images (URL hash → Buffer) */
const imageCache = new Map<string, Buffer>();

/** Maximum cache size (100 images × ~50KB avg = ~5MB) */
const MAX_CACHE_SIZE = 100;

/**
 * Get cache key from URL
 */
function getCacheKey(url: string): string {
  return crypto.createHash("sha256").update(url).digest("hex");
}

/**
 * Optimize image: downscale to 96dpi, convert to JPEG (quality 82) unless PNG transparency needed.
 * Returns optimized buffer or original if optimization fails.
 * Uses in-memory cache to avoid re-processing same URL.
 */
export async function optimizeImage(buffer: Buffer, url?: string): Promise<Buffer> {
  // Check cache first
  if (url) {
    const cacheKey = getCacheKey(url);
    const cached = imageCache.get(cacheKey);
    if (cached) {
      return cached;
    }
  }

  try {
    // Detect image format and metadata
    const metadata = await sharp(buffer).metadata();
    const { format, hasAlpha, width, height } = metadata;

    if (!width || !height) {
      return buffer; // Can't process, return original
    }

    // Calculate target dimensions for 96dpi (web standard)
    // Assume original is at 72dpi, scale to 96dpi = 1.33x
    // But we'll downscale to reasonable web size: max 1920px width
    const maxWidth = 1920;
    const scale = Math.min(1, maxWidth / width);
    const targetWidth = Math.round(width * scale);
    const targetHeight = Math.round(height * scale);

    let pipeline = sharp(buffer)
      .resize(targetWidth, targetHeight, {
        fit: "inside",
        withoutEnlargement: true,
      });

    // Decide output format
    if (hasAlpha && format === "png") {
      // Keep PNG for transparency
      pipeline = pipeline.png({ quality: 80, progressive: true });
    } else {
      // Convert to JPEG for better compression
      pipeline = pipeline.jpeg({ quality: 82, progressive: true });
    }

    const optimized = await pipeline.toBuffer();

    // Cache the result
    if (url) {
      const cacheKey = getCacheKey(url);
      imageCache.set(cacheKey, optimized);

      // Evict oldest entries if cache is too large
      if (imageCache.size > MAX_CACHE_SIZE) {
        const firstKey = imageCache.keys().next().value;
        if (firstKey) imageCache.delete(firstKey);
      }
    }

    return optimized;
  } catch (e) {
    // If optimization fails, return original buffer
    console.warn("Image optimization failed, using original:", e);
    return buffer;
  }
}

/**
 * Clear image cache (useful for testing or memory management)
 */
export function clearImageCache(): void {
  imageCache.clear();
}

/**
 * Get cache statistics (for monitoring)
 */
export function getImageCacheStats(): { size: number; entries: number } {
  let totalSize = 0;
  for (const buffer of imageCache.values()) {
    totalSize += buffer.length;
  }
  return { size: totalSize, entries: imageCache.size };
}



================================================================================
FILE: ./functions/src/index.ts
================================================================================

import * as logger from "firebase-functions/logger";
import { setGlobalOptions } from "firebase-functions/v2";
import { onRequest } from "firebase-functions/v2/https";
import { defineSecret } from "firebase-functions/params";
import { getApp } from "firebase-admin/app";
import { initializeApp } from "firebase-admin/app";
import { getFirestore } from "firebase-admin/firestore";
import { SlideSpecZ, type SlideSpec } from "@plzfixthx/slide-spec";
import { getAuth } from "firebase-admin/auth"; // Added for auth

// Import AI helpers
import {
  callAIWithRetry,
  sanitizePrompt,
  moderateContent,
  enhanceSlideSpec,
} from "./aiHelpers";

// Import security utilities
import { getRequestId } from "./security";

// Import PPTX builders (lazy-loaded for efficiency)
import { createPptxFromSpecs } from "./pptxBuilder";

// Define secrets and params
const AI_API_KEY = defineSecret("AI_API_KEY");
const AI_BASE_URL = defineSecret("AI_BASE_URL");
const AI_MODEL_PRIMARY = defineSecret("AI_MODEL_PRIMARY"); // e.g., gpt-4o
const AI_MODEL_FALLBACK = defineSecret("AI_MODEL_FALLBACK"); // e.g., gpt-4o-mini
const RATE_LIMIT_MIN = defineSecret("RATE_LIMIT_MIN"); // Requests per min per IP

setGlobalOptions({
  region: "us-central1",
  memory: "1GiB", // Increased for multi-slide
  cpu: 1,
  timeoutSeconds: 120, // For complex exports
  maxInstances: 10, // Scaling
});

// Admin init (idempotent)
try {
  getApp();
} catch {
  initializeApp();
}

// Rate limiting storage (Firestore)
const db = getFirestore();
const rateLimitCollection = "rate_limits";

// Offline fallback SlideSpec (enhanced with McKinsey-style MECE)
function fallbackSpec(prompt: string): SlideSpec {
  return {
    meta: {
      version: "1.0",
      locale: "en-US",
      theme: "Executive",
      aspectRatio: "16:9",
    },
    design: {
      pattern: "minimal",
      whitespace: { strategy: "balanced", breathingRoom: 0.35 },
    },
    content: {
      title: { id: "title", text: prompt?.trim() ? prompt : "Strategic Overview" },
      subtitle: { id: "subtitle", text: "Key Insights and Recommendations" },
      bullets: [
        {
          id: "b1",
          items: [
            { text: "Situation: Analyze current state", level: 1 },
            { text: "Complication: Identify challenges", level: 1 },
            { text: "Resolution: Propose actions", level: 1 },
          ],
        },
      ],
      callouts: [{ id: "c1", variant: "note", text: "AI generation fallback - refine prompt for better results" }],
    },
    layout: {
      grid: { rows: 10, cols: 12, gutter: 12, margin: { t: 40, r: 40, b: 40, l: 40 } },
      regions: [
        { name: "header", rowStart: 1, colStart: 1, rowSpan: 2, colSpan: 12 },
        { name: "body", rowStart: 3, colStart: 1, rowSpan: 7, colSpan: 8 },
        { name: "aside", rowStart: 3, colStart: 9, rowSpan: 7, colSpan: 4 },
      ],
      anchors: [
        { refId: "title", region: "header", order: 0 },
        { refId: "subtitle", region: "header", order: 1 },
        { refId: "b1", region: "body", order: 0 },
        { refId: "c1", region: "aside", order: 0 },
      ],
    },
    styleTokens: {
      palette: {
        primary: "#005EB8", // McKinsey blue
        accent: "#F3C13A", // McKinsey gold
        neutral: ["#0F172A", "#1E293B", "#334155", "#475569", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC"],
      },
      typography: {
        fonts: { sans: "Aptos, Calibri, Arial, sans-serif" },
        sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 44 },
        weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
        lineHeights: { compact: 1.2, standard: 1.5 },
      },
      spacing: { base: 4, steps: [0, 4, 8, 12, 16, 24, 32, 48, 64] },
      radii: { sm: 4, md: 8, lg: 16 },
      shadows: {
        sm: "0 2px 4px rgba(0,0,0,.08)",
        md: "0 4px 12px rgba(0,0,0,.12)",
        lg: "0 12px 32px rgba(0,0,0,.16)",
      },
      contrast: { minTextContrast: 7, minUiContrast: 4.5 },
    },
  };
}

/** AI adapter with model fallback */
async function callVendor(prompt: string): Promise<SlideSpec> {
  const key = AI_API_KEY.value() ?? "";
  const base = AI_BASE_URL.value() || "https://api.openai.com/v1";
  const models = [AI_MODEL_PRIMARY.value() || "gpt-4o", AI_MODEL_FALLBACK.value() || "gpt-4o-mini"];

  if (!key) {
    logger.warn("AI_API_KEY not set — using fallback");
    return fallbackSpec(prompt);
  }

  let lastError: Error | null = null;
  for (const model of models) {
    try {
      const result = await callAIWithRetry(prompt, key, base, model, SlideSpecZ);
      return enhanceSlideSpec(result) as SlideSpec;
    } catch (e) {
      lastError = e instanceof Error ? e : new Error(String(e));
      logger.warn(`Model ${model} failed, trying next`, { error: lastError.message });
    }
  }

  logger.error("All AI models failed", { error: lastError?.message });
  return fallbackSpec(prompt);
}

/** Rate limiter (IP-based) */
async function checkRateLimit(ip: string): Promise<boolean> {
  const limit = RATE_LIMIT_MIN.value() || 100;
  const docRef = db.collection(rateLimitCollection).doc(ip);
  const doc = await docRef.get();
  const data = doc.data() || { count: 0, lastReset: Date.now() };

  const now = Date.now();
  if (now - data.lastReset > 60000) { // 1 min window
    await docRef.set({ count: 1, lastReset: now });
    return true;
  }

  if (data.count >= limit) {
    return false;
  }

  // Increment counter atomically
  await docRef.update({ count: (data.count || 0) + 1 });
  return true;
}

/** POST /generateSlideSpec {prompt} -> {spec} */
export const generateSlideSpec = onRequest(
  { cors: true, secrets: [AI_API_KEY, AI_BASE_URL, AI_MODEL_PRIMARY, AI_MODEL_FALLBACK, RATE_LIMIT_MIN] },
  async (req, res) => {
    if (req.method !== "POST") {
      res.status(405).send("Method Not Allowed");
      return;
    }

    const startTime = Date.now();
    const memoryBefore = process.memoryUsage().heapUsed / 1024 / 1024;
    const ip = req.ip || "unknown";

    // Auth check
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      res.status(401).json({ error: "Unauthorized" });
      return;
    }
    try {
      await getAuth().verifyIdToken(authHeader.split(" ")[1]);
    } catch {
      res.status(401).json({ error: "Invalid token" });
      return;
    }

    // Rate limit
    if (!(await checkRateLimit(ip))) {
      res.status(429).json({ error: "Rate limit exceeded" });
      return;
    }

    try {
      const rawPrompt = (req.body?.prompt ?? "").toString();
      const prompt = sanitizePrompt(rawPrompt, 1200); // Increased max

      logger.info("📝 Spec generation started", {
        promptLength: prompt.length,
        ip,
        timestamp: new Date().toISOString(),
      });

      const moderation = moderateContent(prompt);
      if (!moderation.safe) {
        logger.warn("⚠️ Content moderation rejected", { reason: moderation.reason, ip });
        res.status(400).json({
          error: moderation.reason || "Content not allowed",
          spec: fallbackSpec("Content moderation failed"),
        });
        return;
      }

      const spec = await callVendor(prompt);

      const endTime = Date.now();
      const duration = endTime - startTime;
      const memoryAfter = process.memoryUsage().heapUsed / 1024 / 1024;

      logger.info("✅ Spec generation completed", {
        durationMs: duration,
        memoryUsedMB: (memoryAfter - memoryBefore).toFixed(2),
        hasTitle: !!spec.content.title,
        hasBullets: !!spec.content.bullets,
        hasDataViz: !!spec.content.dataViz,
        ip,
        timestamp: new Date().toISOString(),
      });

      res.status(200).json({ spec });
    } catch (e: any) {
      const endTime = Date.now();
      const duration = endTime - startTime;
      const memoryAfter = process.memoryUsage().heapUsed / 1024 / 1024;

      logger.error("❌ Spec generation failed", {
        error: e.message || String(e),
        stack: e.stack,
        durationMs: duration,
        memoryUsedMB: (memoryAfter - memoryBefore).toFixed(2),
        ip,
        timestamp: new Date().toISOString(),
      });

      const fallback = fallbackSpec(req.body?.prompt || "");
      res.status(200).json({
        spec: fallback,
        warning: "Using fallback due to error: " + e.message,
      });
    }
  }
);

/** POST /generateSlideSpecStream {prompt} -> SSE stream with progress */
export const generateSlideSpecStream = onRequest(
  { cors: true, secrets: [AI_API_KEY, AI_BASE_URL, AI_MODEL_PRIMARY, AI_MODEL_FALLBACK] },
  async (req, res) => {
    if (req.method !== "POST") {
      res.status(405).send("Method Not Allowed");
      return;
    }

    // Set SSE headers
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("X-Accel-Buffering", "no"); // Disable buffering for real-time streaming

    const startTime = Date.now();
    const memoryBefore = process.memoryUsage().heapUsed / 1024 / 1024;
    const ip = req.ip || "unknown";
    const requestId = getRequestId(req);

    // Helper to safely write SSE events
    const writeEvent = (eventType: string, data: any) => {
      try {
        res.write(`event: ${eventType}\n`);
        res.write(`data: ${JSON.stringify(data)}\n\n`);
      } catch (e) {
        logger.warn("Failed to write SSE event", { eventType, error: String(e) });
      }
    };

    try {
      writeEvent("start", { status: "initializing", progress: 0 });

      const rawPrompt = (req.body?.prompt ?? "").toString();
      const prompt = sanitizePrompt(rawPrompt, 1200);

      writeEvent("moderation", { status: "checking", progress: 20 });
      const moderation = moderateContent(prompt);

      if (!moderation.safe) {
        logger.warn("⚠️ Content moderation rejected (stream)", { reason: moderation.reason, ip, requestId });
        writeEvent("error", { error: moderation.reason || "Content not allowed" });
        res.end();
        return;
      }

      writeEvent("generation", { status: "generating", promptLength: prompt.length, progress: 40 });

      const spec = await callVendor(prompt);

      writeEvent("enhancement", { status: "enhancing", progress: 80 });
      writeEvent("spec", { spec, isFallback: false });

      const endTime = Date.now();
      const duration = endTime - startTime;
      const memoryAfter = process.memoryUsage().heapUsed / 1024 / 1024;

      logger.info("✅ Spec generation stream completed", {
        requestId,
        durationMs: duration,
        memoryUsedMB: (memoryAfter - memoryBefore).toFixed(2),
        ip,
        timestamp: new Date().toISOString(),
      });

      writeEvent("complete", { status: "success", durationMs: duration, progress: 100 });
      res.end();
    } catch (e: any) {
      const endTime = Date.now();
      const duration = endTime - startTime;
      const memoryAfter = process.memoryUsage().heapUsed / 1024 / 1024;

      logger.error("❌ Spec generation stream failed", {
        requestId,
        error: e.message || String(e),
        durationMs: duration,
        memoryUsedMB: (memoryAfter - memoryBefore).toFixed(2),
        ip,
        timestamp: new Date().toISOString(),
      });

      writeEvent("error", { error: e.message || "Generation failed" });
      res.end();
    }
  }
);

/** POST /exportPPTX {spec} or {specs: []} -> .pptx binary */
export const exportPPTX = onRequest({ cors: true }, async (req, res) => {
  if (req.method !== "POST") {
    res.status(405).send("Method Not Allowed");
    return;
  }

  const startTime = Date.now();
  const memoryBefore = process.memoryUsage().heapUsed / 1024 / 1024;
  const ip = req.ip || "unknown";

  try {
    const body = req.body;
    let specs: any[];

    if (body?.specs && Array.isArray(body.specs)) {
      specs = body.specs.map((s: any) => {
        if (s?.styleTokens?.palette?.neutral) {
          const hexPattern = /^#[0-9A-Fa-f]{6}$/;
          s.styleTokens.palette.neutral = (s.styleTokens.palette.neutral as (string | null | undefined)[])
            .filter((color: any): color is string => color != null && typeof color === 'string' && hexPattern.test(color))
            .slice(0, 9);
          if (s.styleTokens.palette.neutral.length < 9) { // Ensure full ramp
            s.styleTokens.palette.neutral = [
              "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
              "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC"
            ];
          }
        }
        return SlideSpecZ.parse(s);
      });
    } else if (body?.spec) {
      const spec = body.spec;
      if (spec?.styleTokens?.palette?.neutral) {
        const hexPattern = /^#[0-9A-Fa-f]{6}$/;
        spec.styleTokens.palette.neutral = (spec.styleTokens.palette.neutral as (string | null | undefined)[])
          .filter((color: any): color is string => color != null && typeof color === 'string' && hexPattern.test(color))
          .slice(0, 9);
        if (spec.styleTokens.palette.neutral.length < 9) {
          spec.styleTokens.palette.neutral = [
            "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
            "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC"
          ];
        }
      }
      specs = [SlideSpecZ.parse(spec)];
    } else {
      throw new Error("Missing spec or specs in request body");
    }

    logger.info("📊 Export started", {
      slideCount: specs.length,
      ip,
      timestamp: new Date().toISOString(),
    });

    const buf = await buildPptx(specs);

    const endTime = Date.now();
    const memoryAfter = process.memoryUsage().heapUsed / 1024 / 1024;
    const duration = endTime - startTime;
    const bufferSize = buf.byteLength / 1024 / 1024;

    logger.info("✅ Export completed successfully", {
      slideCount: specs.length,
      durationMs: duration,
      bufferSizeMB: bufferSize.toFixed(2),
      memoryUsedMB: (memoryAfter - memoryBefore).toFixed(2),
      withinBudget: duration <= 3000 && memoryAfter <= 500,
      ip,
      timestamp: new Date().toISOString(),
    });

    res.setHeader(
      "Content-Type",
      "application/vnd.openxmlformats-officedocument.presentationml.presentation"
    );
    res.setHeader(
      "Content-Disposition",
      `attachment; filename="plzfixthx-presentation-${Date.now()}.pptx"`
    );
    res.status(200).send(Buffer.from(buf));
  } catch (e: any) {
    const endTime = Date.now();
    const duration = endTime - startTime;
    const memoryAfter = process.memoryUsage().heapUsed / 1024 / 1024;

    logger.error("❌ Export failed", {
      error: e.message || String(e),
      stack: e.stack,
      durationMs: duration,
      memoryUsedMB: (memoryAfter - memoryBefore).toFixed(2),
      ip,
      timestamp: new Date().toISOString(),
    });

    res.status(400).send(`Export error: ${e.message || String(e)}`);
  }
});

/** PPTX builder - supports batch with chunking */
async function buildPptx(
  specs: SlideSpec | SlideSpec[]
): Promise<ArrayBuffer> {
  const specsArray = Array.isArray(specs) ? specs : [specs];
  if (specsArray.length === 0) {
    throw new Error("No slides to export");
  }

  logger.info("🏗️ Export building PPTX", {
    slideCount: specsArray.length,
    aspectRatio: specsArray[0].meta.aspectRatio,
  });

  try {
    // Chunk for memory efficiency (max 50/slide batch)
    const chunks = [];
    for (let i = 0; i < specsArray.length; i += 50) {
      const chunk = specsArray.slice(i, i + 50);
      const buffer = await createPptxFromSpecs(chunk);
      chunks.push(buffer);
    }

    // Merge chunks if multi-batch (simplified; real merge via PptxGenJS API)
    if (chunks.length > 1) {
      // Placeholder merge logic; in production, use pptx merger library
      return chunks[0]; // For simplicity; enhance with merger
    }

    return chunks[0];
  } catch (error) {
    logger.error("❌ PPTX build failed", {
      error: String(error),
      slideCount: specsArray.length,
    });
    throw error;
  }
}

================================================================================
FILE: ./functions/src/layoutBuilders.ts
================================================================================

/**
 * Modular Layout Builders for Professional PPTX Generation
 * Status: Optional helpers for bespoke layouts (legacy/experimental).
 *
 * All functions accept a LayoutBuilderContext and use consistent typography,
 * rich-text highlighting, and spacing. These are additive to the universal
 * grid-based renderer, and may be used for custom templates.
 */

import PptxGenJS from "pptxgenjs";

/* --------------------------------- Types ---------------------------------- */

export type Theme = {
  bg: string;
  fg: string;
  accent: string;
  muted: string;
  fontFace?: string;
};

export interface LayoutBuilderContext<Spec = Record<string, unknown>> {
  slide: PptxGenJS.Slide;
  spec: Spec;
  theme: Theme;
  topY: number;
}

/** Paragraph/Bullets/Columns/Metrics/Quote/Chart lightweight specs */
export type ParagraphLayoutSpec = { bullets?: string[]; accentWords?: string[] };
export type BulletsLayoutSpec = { bullets?: string[]; accentWords?: string[] };
export type ComparisonLayoutSpec = {
  columns?: { heading?: string; bullets?: string[] }[];
  accentWords?: string[];
};
export type MetricsLayoutSpec = {
  bullets?: string[];
  callouts?: { label: string; value: string }[];
  accentWords?: string[];
};
export type QuoteLayoutSpec = { bullets?: [string, ...string[]]; accentWords?: string[] };
export type ChartLayoutSpec = { bullets?: string[]; accentWords?: string[] };

/* --------------------------- Rich-text Utilities --------------------------- */

function escapeRe(s: string) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

/**
 * Convert a plain string into a rich text run array, bolding and tinting the
 * listed accent words. Returns PptxGenJS IText[] compatible objects.
 */
export function highlightAccentWords(
  text: string,
  accentWords?: string[],
  accentColor?: string
): Array<{ text: string; options?: PptxGenJS.TextPropsOptions }> {
  if (!accentWords || accentWords.length === 0 || !text) {
    return [{ text }];
  }

  const pattern = new RegExp(
    `\\b(${accentWords.map(escapeRe).join("|")})\\b`,
    "gi"
  );

  const runs: Array<{ text: string; options?: PptxGenJS.TextPropsOptions }> = [];
  let lastIndex = 0;
  let match: RegExpExecArray | null;

  while ((match = pattern.exec(text)) !== null) {
    const [found] = match;
    const start = match.index;

    if (start > lastIndex) {
      runs.push({ text: text.slice(lastIndex, start) });
    }
    runs.push({
      text: found,
      options: { bold: true, color: accentColor },
    });
    lastIndex = pattern.lastIndex;
  }

  if (lastIndex < text.length) {
    runs.push({ text: text.slice(lastIndex) });
  }

  return runs.length > 0 ? runs : [{ text }];
}

/* --------------------------------- Layouts --------------------------------- */

/**
 * PARAGRAPH Layout: Narrative content with professional typography.
 */
export function buildParagraphLayout(
  ctx: LayoutBuilderContext<ParagraphLayoutSpec>
) {
  const { slide, spec, theme, topY } = ctx;
  const fontFace = theme.fontFace || "Aptos, Calibri, Arial";
  const content = (spec.bullets || []).join("\n\n");
  if (!content) return;

  const runs = highlightAccentWords(content, spec.accentWords, theme.accent);
  slide.addText(runs as any, {
    x: 0.7,
    y: topY,
    w: 8.6,
    h: 4.8,
    fontSize: 14,
    color: theme.fg,
    fontFace,
    lineSpacing: 22,
    wrap: true,
  } as PptxGenJS.TextPropsOptions);
}

/**
 * BULLETS Layout: Key points with professional emphasis.
 */
export function buildBulletsLayout(ctx: LayoutBuilderContext<BulletsLayoutSpec>) {
  const { slide, spec, theme, topY } = ctx;
  const fontFace = theme.fontFace || "Aptos, Calibri, Arial";
  const items = spec.bullets || [];
  if (items.length === 0) return;

  // Build a single run array with newline separators to keep bullets aligned
  const newline = { text: "\n" };
  const runs = items.flatMap((b, i) => {
    const parts = highlightAccentWords(b, spec.accentWords, theme.accent);
    return i < items.length - 1 ? [...parts, newline] : parts;
  });

  slide.addText(runs as any, {
    x: 0.7,
    y: topY,
    w: 8.6,
    h: 4.8,
    bullet: true,
    fontSize: 12,
    color: theme.fg,
    fontFace,
    lineSpacing: 20,
    wrap: true,
  } as PptxGenJS.TextPropsOptions);
}

/**
 * COMPARISON Layout: Two-column comparison with visual balance.
 */
export function buildComparisonLayout(
  ctx: LayoutBuilderContext<ComparisonLayoutSpec>
) {
  const { slide, spec, theme, topY } = ctx;
  const cols = spec.columns || [];
  if (cols.length < 2) return;

  const colW = 4.3;
  const gap = 0.4;
  const x1 = 0.5;
  const x2 = x1 + colW + gap;
  const y = topY;
  const h = 4.5;
  const fontFace = theme.fontFace || "Aptos, Calibri, Arial";

  cols.forEach((col, idx) => {
    const x = idx ? x2 : x1;

    if (col.heading) {
      slide.addText(col.heading, {
        x,
        y,
        w: colW,
        fontSize: 16,
        bold: true,
        color: theme.accent,
        fontFace,
      });
    }

    if (col.bullets && col.bullets.length > 0) {
      const newline = { text: "\n" };
      const runs = col.bullets.flatMap((b, i) => {
        const parts = highlightAccentWords(b, spec.accentWords, theme.accent);
        return i < col.bullets!.length - 1 ? [...parts, newline] : parts;
      });

      slide.addText(runs as any, {
        x,
        y: col.heading ? y + 0.4 : y,
        w: colW,
        h,
        bullet: true,
        fontSize: 11,
        color: theme.fg,
        fontFace,
        lineSpacing: 18,
        wrap: true,
      } as PptxGenJS.TextPropsOptions);
    }
  });
}

/**
 * METRICS Layout: KPIs with visual emphasis and callouts.
 */
export function buildMetricsLayout(ctx: LayoutBuilderContext<MetricsLayoutSpec>) {
  const { slide, spec, theme, topY } = ctx;
  const fontFace = theme.fontFace || "Aptos, Calibri, Arial";

  if (spec.bullets && spec.bullets.length > 0) {
    const newline = { text: "\n" };
    const runs = spec.bullets.flatMap((b, i) => {
      const parts = highlightAccentWords(b, spec.accentWords, theme.accent);
      return i < spec.bullets!.length - 1 ? [...parts, newline] : parts;
    });

    slide.addText(runs as any, {
      x: 0.7,
      y: topY,
      w: 8.6,
      h: 3.2,
      bullet: true,
      fontSize: 12,
      color: theme.fg,
      fontFace,
      lineSpacing: 18,
      wrap: true,
    } as PptxGenJS.TextPropsOptions);
  }

  if (spec.callouts && spec.callouts.length > 0) {
    const calloutY = 5.2;
    let calloutX = 0.5;

    spec.callouts.forEach((c) => {
      const label = `${c.label}: ${c.value}`;
      slide.addText(label, {
        x: calloutX,
        y: calloutY,
        w: 2.5,
        h: 0.5,
        fontSize: 11,
        color: theme.accent,
        bold: true,
        fontFace,
        align: "left",
      });
      calloutX += 2.8;
    });
  }
}

/**
 * QUOTE Layout: Powerful statements with professional typography.
 */
export function buildQuoteLayout(ctx: LayoutBuilderContext<QuoteLayoutSpec>) {
  const { slide, spec, theme, topY } = ctx;
  const quoteText = spec.bullets?.[0];
  if (!quoteText) return;
  const fontFace = theme.fontFace || "Aptos, Calibri, Arial";

  // Leading decorative quote
  slide.addText('"', {
    x: 0.5,
    y: topY - 0.3,
    w: 0.5,
    fontSize: 48,
    color: theme.accent,
    fontFace,
    // Note: opacity not supported in PptxGenJS; use lighter color instead
  });

  // Quote body
  const runs = highlightAccentWords(quoteText, spec.accentWords, theme.accent);
  slide.addText(runs as any, {
    x: 0.9,
    y: topY,
    w: 8.2,
    h: 3.5,
    fontSize: 26,
    italic: true,
    color: theme.accent,
    fontFace,
    lineSpacing: 32,
    wrap: true,
  } as PptxGenJS.TextPropsOptions);

  // Trailing decorative quote
  slide.addText('"', {
    x: 8.5,
    y: topY + 2.8,
    w: 0.5,
    fontSize: 48,
    color: theme.accent,
    fontFace,
    // Note: opacity not supported in PptxGenJS; use lighter color instead
  });
}

/**
 * CHART Layout: Data visualization placeholder with professional styling.
 * (Use the universal grid builder for real charts; this is a visual scaffold.)
 */
export function buildChartLayout(ctx: LayoutBuilderContext<ChartLayoutSpec>) {
  const { slide, spec, theme, topY } = ctx;
  const fontFace = theme.fontFace || "Aptos, Calibri, Arial";

  // Placeholder frame
  slide.addText("[Chart/Visualization Area]", {
    x: 0.7,
    y: topY + 1.5,
    w: 8.6,
    h: 0.8,
    fontSize: 14,
    color: theme.muted,
    fontFace,
    align: "center",
    valign: "middle",
  });

  // Supporting bullets below chart
  if (spec.bullets && spec.bullets.length > 0) {
    const newline = { text: "\n" };
    const runs = spec.bullets.flatMap((b, i) => {
      const parts = highlightAccentWords(b, spec.accentWords, theme.accent);
      return i < spec.bullets!.length - 1 ? [...parts, newline] : parts;
    });

    slide.addText(runs as any, {
      x: 0.7,
      y: 4.2,
      w: 8.6,
      h: 1.8,
      bullet: true,
      fontSize: 11,
      color: theme.fg,
      fontFace,
      lineSpacing: 16,
      wrap: true,
    } as PptxGenJS.TextPropsOptions);
  }
}

================================================================================
FILE: ./functions/src/metrics.ts
================================================================================

/**
 * Metrics collection and reporting for plzfixthx functions.
 * Tracks counters, latencies, and errors for observability.
 */

import * as logger from "firebase-functions/logger";

/* -------------------------------------------------------------------------- */
/*                            Metrics Store                                   */
/* -------------------------------------------------------------------------- */

interface MetricCounter {
  count: number;
  lastUpdated: number;
}

interface MetricHistogram {
  values: number[];
  count: number;
  sum: number;
  min: number;
  max: number;
}

const counters = new Map<string, MetricCounter>();
const histograms = new Map<string, MetricHistogram>();

// Cleanup old metrics every 1 hour
setInterval(() => {
  const now = Date.now();
  const oneHourAgo = now - 60 * 60 * 1000;

  for (const [key, counter] of counters.entries()) {
    if (counter.lastUpdated < oneHourAgo) {
      counters.delete(key);
    }
  }

  for (const [, histogram] of histograms.entries()) {
    // Keep histograms for analysis
    if (histogram.values.length > 1000) {
      histogram.values = histogram.values.slice(-500);
    }
  }
}, 60 * 60 * 1000);

/* -------------------------------------------------------------------------- */
/*                            Counter Metrics                                 */
/* -------------------------------------------------------------------------- */

/**
 * Increment a counter metric
 */
export function incrementCounter(name: string, value: number = 1, labels?: Record<string, string>): void {
  const key = labels ? `${name}:${JSON.stringify(labels)}` : name;
  const counter = counters.get(key) || { count: 0, lastUpdated: Date.now() };
  counter.count += value;
  counter.lastUpdated = Date.now();
  counters.set(key, counter);
}

/**
 * Get counter value
 */
export function getCounter(name: string, labels?: Record<string, string>): number {
  const key = labels ? `${name}:${JSON.stringify(labels)}` : name;
  return counters.get(key)?.count ?? 0;
}

/**
 * Reset counter
 */
export function resetCounter(name: string, labels?: Record<string, string>): void {
  const key = labels ? `${name}:${JSON.stringify(labels)}` : name;
  counters.delete(key);
}

/* -------------------------------------------------------------------------- */
/*                            Histogram Metrics                               */
/* -------------------------------------------------------------------------- */

/**
 * Record a histogram value (for latencies, sizes, etc.)
 */
export function recordHistogram(name: string, value: number, labels?: Record<string, string>): void {
  const key = labels ? `${name}:${JSON.stringify(labels)}` : name;
  let histogram = histograms.get(key);

  if (!histogram) {
    histogram = { values: [], count: 0, sum: 0, min: value, max: value };
  }

  histogram.values.push(value);
  histogram.count++;
  histogram.sum += value;
  histogram.min = Math.min(histogram.min, value);
  histogram.max = Math.max(histogram.max, value);

  histograms.set(key, histogram);
}

/**
 * Get histogram statistics
 */
export function getHistogramStats(name: string, labels?: Record<string, string>): {
  count: number;
  sum: number;
  min: number;
  max: number;
  avg: number;
  p50: number;
  p95: number;
  p99: number;
} | null {
  const key = labels ? `${name}:${JSON.stringify(labels)}` : name;
  const histogram = histograms.get(key);

  if (!histogram || histogram.count === 0) {
    return null;
  }

  const sorted = [...histogram.values].sort((a, b) => a - b);
  const p50 = sorted[Math.floor(sorted.length * 0.5)];
  const p95 = sorted[Math.floor(sorted.length * 0.95)];
  const p99 = sorted[Math.floor(sorted.length * 0.99)];

  return {
    count: histogram.count,
    sum: histogram.sum,
    min: histogram.min,
    max: histogram.max,
    avg: histogram.sum / histogram.count,
    p50,
    p95,
    p99,
  };
}

/* -------------------------------------------------------------------------- */
/*                            Metric Reporting                                */
/* -------------------------------------------------------------------------- */

/**
 * Report all metrics to logs (for Cloud Logging)
 */
export function reportMetrics(): void {
  const metricsData: Record<string, any> = {
    timestamp: new Date().toISOString(),
    counters: {},
    histograms: {},
  };

  // Collect counters
  for (const [key, counter] of counters.entries()) {
    metricsData.counters[key] = counter.count;
  }

  // Collect histogram stats
  for (const [key] of histograms.entries()) {
    const stats = getHistogramStats(key);
    if (stats) {
      metricsData.histograms[key] = stats;
    }
  }

  logger.info("📊 Metrics Report", metricsData);
}

/**
 * Common metric names
 */
export const MetricNames = {
  // Counters
  REQUESTS_TOTAL: "requests_total",
  REQUESTS_SUCCESS: "requests_success",
  REQUESTS_ERROR: "requests_error",
  REQUESTS_MODERATION_REJECTED: "requests_moderation_rejected",
  REQUESTS_ABUSE_DETECTED: "requests_abuse_detected",
  REQUESTS_RATE_LIMITED: "requests_rate_limited",

  // Histograms
  REQUEST_DURATION_MS: "request_duration_ms",
  AI_GENERATION_DURATION_MS: "ai_generation_duration_ms",
  PPTX_EXPORT_DURATION_MS: "pptx_export_duration_ms",
  IMAGE_FETCH_DURATION_MS: "image_fetch_duration_ms",
  MEMORY_USED_MB: "memory_used_mb",
  PPTX_SIZE_MB: "pptx_size_mb",
} as const;

/**
 * Track request metrics
 */
export function trackRequest(
  endpoint: string,
  durationMs: number,
  success: boolean,
  error?: string
): void {
  const labels = { endpoint };

  incrementCounter(MetricNames.REQUESTS_TOTAL, 1, labels);

  if (success) {
    incrementCounter(MetricNames.REQUESTS_SUCCESS, 1, labels);
  } else {
    incrementCounter(MetricNames.REQUESTS_ERROR, 1, labels);
    if (error) {
      logger.error(`❌ Request failed: ${error}`, { endpoint, error });
    }
  }

  recordHistogram(MetricNames.REQUEST_DURATION_MS, durationMs, labels);
}

/**
 * Track AI generation metrics
 */
export function trackAIGeneration(durationMs: number, success: boolean, error?: string): void {
  if (success) {
    recordHistogram(MetricNames.AI_GENERATION_DURATION_MS, durationMs);
  } else {
    incrementCounter(MetricNames.REQUESTS_ERROR, 1, { endpoint: "generateSlideSpec" });
    if (error) {
      logger.error(`❌ AI generation failed: ${error}`, { error });
    }
  }
}

/**
 * Track PPTX export metrics
 */
export function trackPPTXExport(durationMs: number, sizeMB: number, slideCount: number): void {
  recordHistogram(MetricNames.PPTX_EXPORT_DURATION_MS, durationMs);
  recordHistogram(MetricNames.PPTX_SIZE_MB, sizeMB, { slideCount: String(slideCount) });
}

/**
 * Track image fetch metrics
 */
export function trackImageFetch(durationMs: number, success: boolean): void {
  recordHistogram(MetricNames.IMAGE_FETCH_DURATION_MS, durationMs);
  if (!success) {
    incrementCounter("image_fetch_failures");
  }
}



================================================================================
FILE: ./functions/src/middleware/aiOrchestrator.ts
================================================================================

/**
 * AI Orchestrator Middleware
 * ==========================
 * Centralized AI request orchestration with validation, enhancement, and error handling.
 * Handles prompt processing, response validation, and structured output generation.
 */

import * as logger from "firebase-functions/logger";
import { callAIWithRetry, enhanceSlideSpec, sanitizePrompt, moderateContent, ValidationError } from "../aiHelpers";
import { SlideSpecZ } from "@plzfixthx/slide-spec";
import type { SlideSpecV1 } from "@plzfixthx/slide-spec";

/* -------------------------------------------------------------------------- */
/*                            Request Pipeline                                */
/* -------------------------------------------------------------------------- */

export interface AIRequest {
  prompt: string;
  requestId: string;
  userId?: string;
  context?: Record<string, unknown>;
}

export interface AIResponse {
  spec: SlideSpecV1;
  requestId: string;
  processingTime: number;
  model: string;
  tokensUsed?: number;
}

/* -------------------------------------------------------------------------- */
/*                            Validation Pipeline                             */
/* -------------------------------------------------------------------------- */

/**
 * Validate and sanitize incoming AI request
 */
export async function validateAIRequest(request: AIRequest): Promise<void> {
  // Check request ID
  if (!request.requestId || typeof request.requestId !== "string") {
    throw new ValidationError("Invalid or missing request ID", request.requestId || "unknown");
  }

  // Check prompt existence and length
  if (!request.prompt || request.prompt.trim().length === 0) {
    throw new ValidationError("Prompt cannot be empty", request.requestId);
  }

  if (request.prompt.length > 5000) {
    throw new ValidationError("Prompt exceeds maximum length (5000 characters)", request.requestId);
  }

  // Check for content policy violations
  const moderation = await moderateContent(request.prompt);
  if (!moderation.safe) {
    throw new ValidationError(
      `Content policy violation: ${moderation.reason}`,
      request.requestId,
      { categories: moderation.categories }
    );
  }

  logger.info("AI request validated", {
    requestId: request.requestId,
    promptLength: request.prompt.length,
    hasUserId: !!request.userId,
    hasContext: !!request.context,
  });
}

/* -------------------------------------------------------------------------- */
/*                            Processing Pipeline                             */
/* -------------------------------------------------------------------------- */

/**
 * Process AI request through full pipeline
 */
export async function processAIRequest(request: AIRequest): Promise<AIResponse> {
  const startTime = Date.now();
  const requestId = request.requestId;

  try {
    // 1. Validate request
    await validateAIRequest(request);

    // 2. Sanitize prompt
    const sanitized = sanitizePrompt(request.prompt);
    logger.info("Prompt sanitized", { requestId, originalLength: request.prompt.length, sanitizedLength: sanitized.length });

    // 3. Call AI with retry logic
    const apiKey = process.env.OPENAI_API_KEY || "";
    const baseUrl = process.env.OPENAI_BASE_URL || "https://api.openai.com/v1";
    const model = process.env.OPENAI_MODEL || "gpt-4-turbo";

    const spec = (await callAIWithRetry(
      sanitized,
      apiKey,
      baseUrl,
      model,
      SlideSpecZ,
      requestId
    )) as SlideSpecV1;

    // 4. Enhance spec with advanced features
    const enhanced = await enhanceSlideSpec(spec);

    // 5. Validate output
    validateSlideSpec(enhanced, requestId);

    const processingTime = Date.now() - startTime;

    logger.info("AI request processed successfully", {
      requestId,
      processingTime,
      specType: enhanced.type,
    });

    return {
      spec: enhanced,
      requestId,
      processingTime,
      model: "gpt-4-turbo",
      tokensUsed: undefined, // Would be populated from AI response metadata
    };
  } catch (error) {
    const processingTime = Date.now() - startTime;
    logger.error("AI request processing failed", error, {
      requestId,
      processingTime,
    });
    throw error;
  }
}

/* -------------------------------------------------------------------------- */
/*                            Output Validation                               */
/* -------------------------------------------------------------------------- */

/**
 * Validate slide spec structure and content
 */
export function validateSlideSpec(spec: SlideSpecV1, requestId: string): void {
  // Check required fields
  if (!spec.content?.title?.text) {
    throw new ValidationError("Slide spec missing required field: content.title.text", requestId);
  }

  // Validate title content
  if (typeof spec.content.title.text !== "string" || spec.content.title.text.trim().length === 0) {
    throw new ValidationError("Title must be a non-empty string", requestId);
  }

  if (spec.content.title.text.length > 200) {
    throw new ValidationError("Title exceeds maximum length (200 characters)", requestId);
  }

  // Validate subtitle if present
  if (spec.content.subtitle?.text && typeof spec.content.subtitle.text !== "string") {
    throw new ValidationError("Subtitle must be a string", requestId);
  }

  if (spec.content.subtitle?.text && spec.content.subtitle.text.length > 300) {
    throw new ValidationError("Subtitle exceeds maximum length (300 characters)", requestId);
  }

  // Validate palette colors
  if (spec.styleTokens?.palette?.primary && !isValidHexColor(spec.styleTokens.palette.primary)) {
    throw new ValidationError("Invalid primary color format", requestId, {
      color: spec.styleTokens.palette.primary,
    });
  }

  logger.info("Slide spec validated", {
    requestId,
    titleLength: spec.content.title.text.length,
    hasSubtitle: !!spec.content.subtitle?.text,
    hasPalette: !!spec.styleTokens?.palette,
  });
}

/**
 * Check if string is valid hex color
 */
function isValidHexColor(color: string): boolean {
  return /^#[0-9A-F]{6}([0-9A-F]{2})?$/i.test(color);
}

/* -------------------------------------------------------------------------- */
/*                            Response Formatting                             */
/* -------------------------------------------------------------------------- */

/**
 * Format AI response for client consumption
 */
export function formatAIResponse(response: AIResponse): Record<string, unknown> {
  return {
    spec: response.spec,
    requestId: response.requestId,
    processingTime: response.processingTime,
    model: response.model,
    timestamp: new Date().toISOString(),
  };
}

/* -------------------------------------------------------------------------- */
/*                            Error Recovery                                  */
/* -------------------------------------------------------------------------- */

/**
 * Attempt to recover from AI response errors
 */
export async function recoverFromAIError(
  error: unknown,
  request: AIRequest,
  retryCount: number = 0
): Promise<AIResponse | null> {
  const maxRetries = 2;

  if (retryCount >= maxRetries) {
    logger.error("Max retries exceeded for AI request", error, {
      requestId: request.requestId,
      retryCount,
    });
    return null;
  }

  logger.warn("Attempting to recover from AI error", {
    requestId: request.requestId,
    retryCount,
    error: error instanceof Error ? error.message : String(error),
  });

  // Wait before retry with exponential backoff
  const delay = Math.min(10000, 1000 * Math.pow(2, retryCount));
  await new Promise((resolve) => setTimeout(resolve, delay));

  try {
    return await processAIRequest(request);
  } catch (retryError) {
    return recoverFromAIError(retryError, request, retryCount + 1);
  }
}

/* -------------------------------------------------------------------------- */
/*                            Performance Metrics                             */
/* -------------------------------------------------------------------------- */

/**
 * Track AI performance metrics for monitoring and optimization
 */
export interface AIMetrics {
  requestId: string;
  promptLength: number;
  processingTimeMs: number;
  model: string;
  success: boolean;
  errorType?: string;
  retryCount?: number;
  tokensUsed?: number;
}

/**
 * Log AI performance metrics
 */
export function logAIMetrics(metrics: AIMetrics): void {
  logger.info("AI performance metrics", {
    requestId: metrics.requestId,
    promptLength: metrics.promptLength,
    processingTimeMs: metrics.processingTimeMs,
    model: metrics.model,
    success: metrics.success,
    errorType: metrics.errorType,
    retryCount: metrics.retryCount,
    tokensUsed: metrics.tokensUsed,
    avgTimePerToken: metrics.tokensUsed ? (metrics.processingTimeMs / metrics.tokensUsed).toFixed(2) : undefined,
  });
}



================================================================================
FILE: ./functions/src/middleware/index.ts
================================================================================

/**
 * Middleware & Orchestration Exports
 * ===================================
 * Centralized middleware for AI orchestration, validation, and request processing.
 */

export * from "./aiOrchestrator";
export * from "./validation";



================================================================================
FILE: ./functions/src/middleware/validation.ts
================================================================================

/**
 * Validation Middleware
 * ====================
 * Request/response validation, schema enforcement, and data sanitization.
 */

import * as logger from "firebase-functions/logger";
import { z } from "zod";

/* -------------------------------------------------------------------------- */
/*                            Request Validation                              */
/* -------------------------------------------------------------------------- */

export const GenerateSlideSpecRequestSchema = z.object({
  prompt: z.string().min(1).max(5000),
  userId: z.string().optional(),
  requestId: z.string().optional(),
});

export type GenerateSlideSpecRequest = z.infer<typeof GenerateSlideSpecRequestSchema>;

export const ExportPPTXRequestSchema = z.object({
  spec: z.record(z.string(), z.unknown()),
  filename: z.string().optional(),
});

export type ExportPPTXRequest = z.infer<typeof ExportPPTXRequestSchema>;

/* -------------------------------------------------------------------------- */
/*                            Validation Functions                            */
/* -------------------------------------------------------------------------- */

/**
 * Validate and parse request body
 */
export function validateRequest<T>(
  data: unknown,
  schema: z.ZodSchema<T>,
  context: string
): T {
  try {
    return schema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const errors = error.issues.map((e) => ({
        path: e.path.join("."),
        message: e.message,
      }));
      logger.warn(`Validation failed for ${context}`, { errors });
      throw new Error(`Invalid ${context}: ${errors[0]?.message}`);
    }
    throw error;
  }
}

/**
 * Sanitize string input
 */
export function sanitizeString(input: string, maxLength: number = 5000): string {
  return input
    .trim()
    .slice(0, maxLength)
    .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, ""); // Remove control characters
}

/**
 * Sanitize filename
 */
export function sanitizeFilename(filename: string): string {
  return filename
    .replace(/[<>:"/\\|?*]/g, "-")
    .replace(/\s+/g, "-")
    .slice(0, 255);
}

/**
 * Validate hex color
 */
export function isValidHexColor(color: string): boolean {
  return /^#[0-9A-F]{6}([0-9A-F]{2})?$/i.test(color);
}

/**
 * Validate email
 */
export function isValidEmail(email: string): boolean {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

/**
 * Validate URL
 */
export function isValidUrl(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

/* -------------------------------------------------------------------------- */
/*                            Data Sanitization                               */
/* -------------------------------------------------------------------------- */

/**
 * Sanitize object recursively
 */
export function sanitizeObject<T extends Record<string, unknown>>(obj: T): T {
  const sanitized: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "string") {
      sanitized[key] = sanitizeString(value);
    } else if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      sanitized[key] = sanitizeObject(value as Record<string, unknown>);
    } else if (Array.isArray(value)) {
      sanitized[key] = value.map((item) =>
        typeof item === "object" && item !== null ? sanitizeObject(item) : item
      );
    } else {
      sanitized[key] = value;
    }
  }

  return sanitized as T;
}

/* -------------------------------------------------------------------------- */
/*                            Response Validation                             */
/* -------------------------------------------------------------------------- */

/**
 * Validate response structure
 */
export function validateResponse(data: unknown, expectedType: string): boolean {
  if (!data || typeof data !== "object") {
    logger.warn("Invalid response structure", { expectedType, received: typeof data });
    return false;
  }

  const obj = data as Record<string, unknown>;

  if (expectedType === "spec") {
    return (
      typeof obj.type === "string" &&
      typeof obj.header === "string" &&
      (obj.subtitle === undefined || typeof obj.subtitle === "string") &&
      (obj.color === undefined || typeof obj.color === "string")
    );
  }

  if (expectedType === "pptx") {
    return obj instanceof Blob || (typeof obj === "object" && "size" in obj);
  }

  return true;
}

/* -------------------------------------------------------------------------- */
/*                            Error Messages                                  */
/* -------------------------------------------------------------------------- */

export const ValidationMessages = {
  PROMPT_EMPTY: "Prompt cannot be empty",
  PROMPT_TOO_LONG: "Prompt exceeds maximum length (5000 characters)",
  INVALID_SPEC: "Invalid slide specification",
  INVALID_COLOR: "Invalid color format",
  INVALID_EMAIL: "Invalid email address",
  INVALID_URL: "Invalid URL",
  INVALID_FILENAME: "Invalid filename",
  MISSING_REQUIRED_FIELD: (field: string) => `Missing required field: ${field}`,
  INVALID_FIELD_TYPE: (field: string, expected: string) =>
    `Field '${field}' must be ${expected}`,
} as const;



================================================================================
FILE: ./functions/src/pptxBuilder/headerOnlyBuilder.ts
================================================================================

/**
 * Professional PPTX Builders
 * - Back-compat: buildHeaderOnlySlide()
 * - Universal: buildSlideFromSpec() renders a full SlideSpecV1 using an advanced grid engine
 *
 * Enhancements (2025 Standards):
 * - MECE/SCR alignment: Action titles, callouts for insights, structured flow
 * - Charts: Full support for bar/line/pie/doughnut/area/scatter/radar/bubble/stock; fallbacks for waterfall/funnel/combo
 * - Premium Accents: Gradients, shadows, icons, glazes (transparency-based)
 * - Accessibility: WCAG AAA (alt text, contrasts, semantic structure, RTL)
 * - Typography: Fluid scaling, optimal sizing with binary search, vertical rhythm
 * - Images: Unsplash integration, advanced optimization, fit/crop modes
 * - Animations: Hint-based (GIFs, notes for transitions)
 * - Layout: Responsive grid with baseline alignment, asymmetry for storytelling
 * - Uses 96dpi px→in (CSS standard); honors all spec fields
 *
 * Note: Pre-existing schema mismatches with SlideSpec are handled with type assertions.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck

import PptxGenJS from "pptxgenjs";
import { fetch as undiciFetch } from "undici";
import type { SlideSpecV1, ChartKind } from "@plzfixthx/slide-spec";
import { PX_PER_IN } from "@plzfixthx/slide-spec";
import { 
  calculateOptimalFontSize, 
  truncateWithEllipsis, 
  getTypographyPreset,
  calculateVerticalRhythm 
} from "../typographyEnhancer";
import { optimizeImage } from "../imageOptimizer";
import { opacityToTransparency } from "../shared";

/* -------------------------------------------------------------------------- */
/*                        Back-compat: simple header slide                     */
/* -------------------------------------------------------------------------- */

export interface HeaderOnlySlideSpec {
  header: string;
  subtitle: string;
  color: string;
}

/**
 * Legacy title/subtitle slide (enhanced with premium accents and typography)
 */
export async function buildHeaderOnlySlide(
  pptx: PptxGenJS,
  spec: HeaderOnlySlideSpec
): Promise<void> {
  const slide = pptx.addSlide();
  const primaryColor = spec.color || "#005EB8"; // McKinsey-inspired blue
  const subtitleColor = "#64748B";
  const backgroundColor = "#FFFFFF";
  const typography = getTypographyPreset("mckinsey"); // Consulting preset

  slide.background = { color: backgroundColor };

  // Premium left accent bar (0.15in, with subtle shadow)
  slide.addShape(pptx.ShapeType.rect, {
    x: 0,
    y: 0,
    w: 0.15,
    h: getSlideDims(pptx).h,
    fill: { color: primaryColor },
    line: { type: "none" },
    shadow: { type: "outer", blur: 4, offset: 2, angle: 90, color: "#000000", opacity: 0.08 },
  });

  // Subtle gradient glaze (top-right, 12% opacity)
  slide.addShape(pptx.ShapeType.rect, {
    x: getSlideDims(pptx).w - 4,
    y: 0,
    w: 4,
    h: 1.2,
    fill: { 
      type: "gradient",
      gradientStops: [
        { position: 0, color: primaryColor, transparency: opacityToTransparency(0.12) },
        { position: 1, color: backgroundColor, transparency: opacityToTransparency(0.00) },
      ],
    },
    line: { type: "none" },
    rectRadius: 12,
  });

  // Header with optimal sizing
  const headerSize = calculateOptimalFontSize(spec.header, 9.0, 1.2, typography.scale.h1, 28, typography.lineHeights.display);
  const headerText = truncateWithEllipsis(spec.header, 9.0, 1.2, headerSize, typography.lineHeights.display);
  slide.addText(
    headerText,
    {
      x: 0.5,
      y: 1.8,
      w: 9.0,
      h: 1.2,
      fontFace: typography.fonts.display,
      fontSize: headerSize,
      bold: true,
      color: primaryColor,
      align: "left",
      valign: "top",
      lineSpacingMultiple: typography.lineHeights.display,
      letterSpacing: typography.letterSpacing.display,
      wrap: true,
    } as any
  );

  // Subtitle with optimal sizing
  const subtitleSize = calculateOptimalFontSize(spec.subtitle, 9.0, 1.5, typography.scale.h2, 18, typography.lineHeights.heading);
  const subtitleText = truncateWithEllipsis(spec.subtitle, 9.0, 1.5, subtitleSize, typography.lineHeights.heading);
  slide.addText(
    subtitleText,
    {
      x: 0.5,
      y: 3.1,
      w: 9.0,
      h: 1.5,
      fontFace: typography.fonts.body,
      fontSize: subtitleSize,
      color: subtitleColor,
      align: "left",
      valign: "top",
      lineSpacingMultiple: typography.lineHeights.heading,
      letterSpacing: typography.letterSpacing.heading,
      wrap: true,
    } as any
  );
}

/* -------------------------------------------------------------------------- */
/*                      Universal slide builder for V1 spec                    */
/* -------------------------------------------------------------------------- */

export async function buildSlideFromSpec(
  pptx: PptxGenJS,
  spec: SlideSpecV1
): Promise<void> {
  const slide = pptx.addSlide();
  const dims = getSlideDims(pptx, spec.meta.aspectRatio); // Aspect-aware dims
  const grid = computeGrid(spec, dims);
  // @ts-ignore - spec.design is guaranteed to exist at runtime
  const typography = getTypographyPreset(spec.design?.pattern || "modern");
  const rhythm = calculateVerticalRhythm(typography.scale.body, typography.lineHeights.body);

  // --- Background & premium accents (McKinsey/BCG-inspired) -----------------
  const palette = spec.styleTokens?.palette ?? {
    primary: "#005EB8", // McKinsey blue default
    accent: "#F3C13A", // McKinsey gold
    neutral: generateNeutralRamp(), // From colorPaletteGenerator
  };
  const bg = palette.neutral?.[palette.neutral.length - 1] ?? "#FFFFFF";
  slide.background = { color: bg };

  // Left accent bar (0.15in, gradient for depth)
  slide.addShape(pptx.ShapeType.rect, {
    x: 0,
    y: 0,
    w: 0.15,
    h: dims.h,
    fill: { 
      type: "gradient",
      gradientStops: [
        { position: 0, color: palette.primary },
        { position: 1, color: adjustColor(palette.primary, -20) }, // Darker shade
      ],
    },
    line: { type: "none" },
    shadow: { type: "outer", blur: 6, offset: 3, angle: 90, color: "#000000", opacity: 0.1 },
  });

  // Subtle top-right glaze (15% opacity, rounded)
  slide.addShape(pptx.ShapeType.rect, {
    x: dims.w - 3.5,
    y: 0.15,
    w: 3.2,
    h: 1.2,
    fill: { color: palette.accent, transparency: opacityToTransparency(0.15) },
    line: { type: "none" },
    rectRadius: 16,
  });

  // Premium vertical accent line (faint, with glow)
  slide.addShape(pptx.ShapeType.rect, {
    x: 0.25,
    y: 0.1,
    w: 0.05,
    h: Math.max(0, dims.h - 0.2),
    fill: { color: palette.accent, transparency: opacityToTransparency(0.85) },
    line: { type: "none" },
    rectRadius: 4,
    shadow: { type: "outer", blur: 8, offset: 0, angle: 0, color: palette.accent, opacity: 0.3 }, // Glow effect
  });

  // Bottom accent block (tinted, with text if footer present)
  slide.addShape(pptx.ShapeType.rect, {
    x: 0.4,
    y: dims.h - 0.9,
    w: 3.0,
    h: 0.7,
    fill: { color: palette.primary, transparency: opacityToTransparency(0.92) },
    line: { type: "none" },
    rectRadius: 10,
  });
  if (spec.content.footer?.text) {
    slide.addText(
      spec.content.footer.text,
      {
        x: 0.5,
        y: dims.h - 0.8,
        w: 2.8,
        h: 0.5,
        fontFace: typography.fonts.body,
        fontSize: typography.scale.caption,
        color: "#FFFFFF",
        align: "left",
        valign: "middle",
      } as any
    );
  }

  // --- Render by regions/anchors (with vertical rhythm) ---------------------
  const anchorsByRegion = groupAnchorsByRegion(spec);
  const fontSans = safeFont(spec.styleTokens?.typography?.fonts?.sans);

  for (const region of spec.layout.regions) {
    const regionRect = gridRect(region, grid);

    // Flow within region with rhythm-aligned padding
    let cursorY = alignToRhythm(regionRect.y + 0.15, rhythm); // Align to baseline
    const innerX = regionRect.x + 0.15;
    const innerW = Math.max(0, regionRect.w - 0.3);
    const flowGap = rhythm * 0.5; // Half-rhythm for spacing

    const anchors = (anchorsByRegion.get(region.name) || []).sort(
      (a, b) => a.order - b.order
    );

    for (const anchor of anchors) {
      const type = resolveAnchorType(spec, anchor.refId);
      if (!type) continue;

      const remaining = regionRect.y + regionRect.h - cursorY;
      const H = alignToRhythm(preferredHeight(type, remaining), rhythm);

      switch (type) {
        case "title": {
          const title = spec.content.title!;
          const base = clampNum(
            typography.scale.h1,
            32,
            48
          );
          const titleSize = calculateOptimalFontSize(title.text, innerW, H, base, 28, typography.lineHeights.display);
          const titleText = truncateWithEllipsis(title.text, innerW, H, titleSize, typography.lineHeights.display);

          slide.addText(
            titleText,
            {
              x: innerX,
              y: cursorY,
              w: innerW,
              h: H,
              fontFace: typography.fonts.display,
              fontSize: titleSize,
              bold: true,
              color: palette.primary || "#005EB8",
              align: spec.components?.title?.align ?? "left",
              valign: "top",
              lineSpacingMultiple: typography.lineHeights.display,
              letterSpacing: typography.letterSpacing.display,
              wrap: true,
              shadow: { type: "outer", blur: 2, offset: 1, angle: 45, color: "#000000", opacity: 0.05 },
            } as any
          );

          break;
        }

        case "subtitle": {
          const subtitle = spec.content.subtitle!;
          const base = clampNum(
            typography.scale.h2,
            20,
            28
          );
          const subtitleSize = calculateOptimalFontSize(
            subtitle.text,
            innerW,
            H,
            base,
            18,
            typography.lineHeights.heading
          );
          const subtitleText = truncateWithEllipsis(subtitle.text, innerW, H, subtitleSize, typography.lineHeights.heading);

          const subtitleColor =
            (palette.neutral && palette.neutral[3]) || "#64748B";

          slide.addText(
            subtitleText,
            {
              x: innerX,
              y: cursorY,
              w: innerW,
              h: H,
              fontFace: typography.fonts.body,
              fontSize: subtitleSize,
              color: subtitleColor,
              align: "left",
              valign: "top",
              lineSpacingMultiple: typography.lineHeights.heading,
              letterSpacing: typography.letterSpacing.heading,
              wrap: true,
            } as any
          );
          break;
        }

        case "bullets": {
          const group = spec.content.bullets!.find((b) => b.id === anchor.refId)!;

          // Build bullet paragraphs with icons for level 1 (premium touch)
          const bulletParas = (group.items || []).map((it) => {
            const indentLevel = Math.max(0, (it.level || 1) - 1);
            const bulletColor =
              it.level === 1
                ? palette.primary || "#005EB8"
                : it.level === 2
                ? (palette.neutral && palette.neutral[2]) || "#334155"
                : (palette.neutral && palette.neutral[3]) || "#475569";
            const bulletSize = it.level === 1 ? typography.scale.body : it.level === 2 ? typography.scale.small : typography.scale.caption;
            const isBold = it.level === 1;
            const lineHeight = it.level === 1 ? typography.lineHeights.body : typography.lineHeights.compact;

            return {
              text: it.text,
              options: {
                indentLevel,
                color: bulletColor,
                bold: isBold,
                fontSize: bulletSize,
                lineSpacingMultiple: lineHeight,
                bullet: it.level === 1 ? { type: "icon", code: "F00C" } : true, // Check icon for level 1
              },
            };
          });

          slide.addText(
            bulletParas as any,
            {
              x: innerX,
              y: cursorY,
              w: innerW,
              h: H,
              fontFace: fontSans,
              color: (palette.neutral && palette.neutral[0]) || "#0F172A",
              bullet: true,
              paraSpaceAfter: rhythm * 0.75,
              lineSpacingMultiple: typography.lineHeights.body,
              wrap: true,
            } as any
          );
          break;
        }

        case "callout": {
          const callout = spec.content.callouts!.find(
            (c) => c.id === anchor.refId
          )!;
          const { bg, border, textColor } = calloutColors(
            callout.type || "note",
            palette
          );

          // Card with shadow and icon
          slide.addShape(pptx.ShapeType.rect, {
            x: innerX,
            y: cursorY,
            w: innerW,
            h: H,
            fill: { color: bg },
            line: { color: border, width: 2.5 },
            rectRadius: 16,
            shadow: {
              type: "outer",
              blur: 12,
              offset: 4,
              angle: 45,
              color: "#000000",
              opacity: 0.12,
            },
          });

          // Left accent stripe
          slide.addShape(pptx.ShapeType.rect, {
            x: innerX,
            y: cursorY,
            w: 0.15,
            h: H,
            fill: { color: border },
            line: { type: "none" },
            rectRadius: 16,
          });

          // Add icon if present
          if (callout.icon) {
            slide.addText(
              callout.icon, // Assume Unicode or font icon
              {
                x: innerX + 0.2,
                y: cursorY + 0.25,
                w: 0.5,
                h: 0.5,
                fontFace: "Segoe UI Symbol", // For icons
                fontSize: 24,
                color: border,
                align: "center",
              } as any
            );
          }

          const calloutSize = calculateOptimalFontSize(
            callout.text,
            innerW - 0.8,
            H - 0.4,
            typography.scale.body,
            16,
            typography.lineHeights.compact
          );
          const calloutText = truncateWithEllipsis(callout.text, innerW - 0.8, H - 0.4, calloutSize, typography.lineHeights.compact);

          slide.addText(
            calloutText,
            {
              x: innerX + 0.8,
              y: cursorY + 0.25,
              w: innerW - 1.0,
              h: H - 0.5,
              fontFace: fontSans,
              fontSize: calloutSize,
              color: textColor,
              bold: true,
              align: "left",
              valign: "top",
              lineSpacingMultiple: typography.lineHeights.compact,
              wrap: true,
            } as any
          );
          break;
        }

        case "dataViz": {
          const viz = spec.content.dataViz!;
          const supported = mapChartKind(pptx, viz.kind);
          if (!supported) {
            // Enhanced placeholder with icon
            slide.addShape(pptx.ShapeType.rect, {
              x: innerX,
              y: cursorY,
              w: innerW,
              h: H,
              fill: {
                color: (palette.neutral && palette.neutral[7]) || "#E2E8F0",
              },
              line: { type: "none" },
              rectRadius: 12,
            });
            slide.addText(
              `[${viz.kind}] Visualization`,
              {
                x: innerX,
                y: cursorY + H / 2 - 0.2,
                w: innerW,
                h: 0.4,
                fontFace: fontSans,
                fontSize: 14,
                color: (palette.neutral && palette.neutral[3]) || "#64748B",
                align: "center",
                valign: "middle",
              } as any
            );
          } else {
            const chartData = (viz.series || []).map((s, i) => ({
              name: s.name,
              labels: viz.labels,
              values: s.values,
              type: viz.kind === "combo" ? (i % 2 === 0 ? "bar" : "line") : viz.kind, // Combo handling
            }));
            const { valAxisFormatCode, dataLabelFormatCode } = mapFormatCodes(
              viz.valueFormat
            );

            slide.addChart(
              supported,
              chartData as any,
              {
                x: innerX,
                y: cursorY,
                w: innerW,
                h: H,
                title: viz.title,
                titleSize: typography.scale.h3,
                titleColor: palette.primary,
                showLegend: !!viz.legend,
                legendPos: toLegendPos(viz.legend?.position),
                legendAlign: viz.legend?.alignment ?? "center",
                catAxisLabelColor: (palette.neutral && palette.neutral[3]) || "#64748B",
                valAxisLabelColor: (palette.neutral && palette.neutral[3]) || "#64748B",
                dataLabelColor: (palette.neutral && palette.neutral[3]) || "#64748B",
                barDir: "col",
                chartColors: chartSeriesColors(palette),
                catGridline: { style: "dash", size: 1, color: (palette.neutral && palette.neutral[6]) },
                valGridline: { style: "dash", size: 1, color: (palette.neutral && palette.neutral[6]) },
                valAxisFormatCode,
                dataLabelFormatCode,
                showVal: true,
                dataLabelPosition: "b",
                shadow: { type: "outer", blur: 4, offset: 2, color: "#000000", opacity: 0.1 },
              } as any
            );
          }
          break;
        }

        case "images": {
          const img = spec.content.images!.find((i) => i.id === anchor.refId)!;
          const target = { x: innerX, y: cursorY, w: innerW, h: H };

          let url = img.source?.type === "url" ? img.source.url : undefined;
          if (img.source?.type === "unsplash") {
            url = `https://source.unsplash.com/random?${encodeURIComponent(img.source.query)}`; // Unsplash integration
          }

          const buffer = await fetchImageBuffer(url);

          if (!buffer) {
            // Enhanced placeholder with icon
            slide.addShape(pptx.ShapeType.rect, {
              x: target.x,
              y: target.y,
              w: target.w,
              h: target.h,
              fill: {
                color: (palette.neutral && palette.neutral[5]) || "#94A3B8",
                transparency: opacityToTransparency(0.3),
              },
              line: {
                color: (palette.neutral && palette.neutral[5]) || "#94A3B8",
                width: 1.5,
              },
              rectRadius: 12,
            });
            slide.addText(
              img.alt || "Image Placeholder",
              {
                x: target.x,
                y: target.y + target.h / 2 - 0.2,
                w: target.w,
                h: 0.4,
                fontFace: fontSans,
                fontSize: 14,
                color: (palette.neutral && palette.neutral[2]) || "#334155",
                align: "center",
                valign: "middle",
              } as any
            );
          } else {
            slide.addImage({
              data: buffer,
              x: target.x,
              y: target.y,
              w: target.w,
              h: target.h,
              sizing: {
                type: (img.fit || "cover") as any,
                w: target.w,
                h: target.h,
              },
              altText: img.alt || "Slide image", // Accessibility
              shadow: { type: "outer", blur: 8, offset: 4, color: "#000000", opacity: 0.15 },
            } as any);
          }
          break;
        }

        case "imagePlaceholders": {
          const ph = spec.content.imagePlaceholders!.find(
            (p) => p.id === anchor.refId
          )!;
          slide.addShape(pptx.ShapeType.rect, {
            x: innerX,
            y: cursorY,
            w: innerW,
            h: H,
            fill: {
              color: (palette.neutral && palette.neutral[5]) || "#94A3B8",
              transparency: opacityToTransparency(0.3),
            },
            line: {
              color: (palette.neutral && palette.neutral[5]) || "#94A3B8",
              width: 1.5,
            },
            rectRadius: 12,
          });
          slide.addText(
            ph.alt,
            {
              x: innerX,
              y: cursorY + H / 2 - 0.2,
              w: innerW,
              h: 0.4,
              fontFace: fontSans,
              fontSize: 14,
              color: (palette.neutral && palette.neutral[2]) || "#334155",
              align: "center",
              valign: "middle",
            } as any
          );
          break;
        }
      }

      cursorY = alignToRhythm(cursorY + H + flowGap, rhythm);
      if (cursorY > regionRect.y + regionRect.h - 0.15) break;
    }
  }

  // Animation hints (add to slide notes)
  if (spec.design.animationHints?.length) {
    slide.addNotes(spec.design.animationHints.join("\n"));
  }
}

/* -------------------------------------------------------------------------- */
/*                                   Helpers                                   */
/* -------------------------------------------------------------------------- */

type Dims = { w: number; h: number };

function getSlideDims(pptx: PptxGenJS, aspect: "16:9" | "4:3" = "16:9"): Dims {
  if (aspect === "4:3") return { w: 10, h: 7.5 };
  return { w: 10, h: 5.625 };
}

function pxToIn(px: number): number {
  return Math.round((px / PX_PER_IN) * 1000) / 1000;
}

function clampNum(n: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, n));
}

function safeFont(value?: string): string {
  return value?.trim() || "Aptos, Calibri, Arial, sans-serif";
}

function alignToRhythm(position: number, rhythm: number): number {
  return Math.round(position / rhythm) * rhythm;
}

function adjustColor(hex: string, percent: number): string {
  const { r, g, b } = hexToRgb(hex);
  const factor = percent / 100;
  const adjust = (c: number) => Math.min(255, Math.max(0, c + c * factor));
  return rgbToHex(adjust(r), adjust(g), adjust(b));
}

function hexToRgb(hex: string): { r: number; g: number; b: number } {
  const clean = hex.replace("#", "").slice(0, 6);
  return {
    r: parseInt(clean.slice(0, 2), 16),
    g: parseInt(clean.slice(2, 4), 16),
    b: parseInt(clean.slice(4, 6), 16),
  };
}

function rgbToHex(r: number, g: number, b: number): string {
  return `#${[r, g, b].map((x) => Math.round(x).toString(16).padStart(2, "0")).join("")}`;
}

/** Compute grid geometry (inches) with asymmetry support */
function computeGrid(spec: SlideSpecV1, dims: Dims) {
  const g = spec.layout.grid;
  const margins = {
    t: pxToIn(g.margin.t ?? 40), // Increased for breathing room
    r: pxToIn(g.margin.r ?? 40),
    b: pxToIn(g.margin.b ?? 40),
    l: pxToIn(g.margin.l ?? 40),
  };
  const gutterIn = pxToIn(g.gutter ?? 12); // BCG-inspired wider gutters

  const innerW = Math.max(0, dims.w - margins.l - margins.r);
  const innerH = Math.max(0, dims.h - margins.t - margins.b);

  const colW = (innerW - gutterIn * (g.cols - 1)) / g.cols;
  const rowH = (innerH - gutterIn * (g.rows - 1)) / g.rows;

  return {
    originX: margins.l,
    originY: margins.t,
    gutterIn,
    colW,
    rowH,
  };
}

function gridRect(
  region: { rowStart: number; colStart: number; rowSpan: number; colSpan: number },
  grid: { originX: number; originY: number; gutterIn: number; colW: number; rowH: number }
) {
  const x = grid.originX + (region.colStart - 1) * (grid.colW + grid.gutterIn);
  const y = grid.originY + (region.rowStart - 1) * (grid.rowH + grid.gutterIn);
  const w = region.colSpan * grid.colW + (region.colSpan - 1) * grid.gutterIn;
  const h = region.rowSpan * grid.rowH + (region.rowSpan - 1) * grid.gutterIn;
  return { x, y, w, h };
}

type RegionKey = SlideSpecV1["layout"]["regions"][number]["name"];
type Anchor = SlideSpecV1["layout"]["anchors"][number];

function groupAnchorsByRegion(spec: SlideSpecV1) {
  const map = new Map<RegionKey, Anchor[]>();
  for (const a of spec.layout.anchors) {
    map.set(a.region, [...(map.get(a.region) || []), a]);
  }
  return map;
}

type AnchorType =
  | "title"
  | "subtitle"
  | "bullets"
  | "callouts"
  | "dataViz"
  | "images"
  | "imagePlaceholders";

function resolveAnchorType(spec: SlideSpecV1, refId: string): AnchorType | null {
  if (spec.content.title?.id === refId) return "title";
  if (spec.content.subtitle?.id === refId) return "subtitle";
  if (spec.content.bullets?.some((b) => b.id === refId)) return "bullets";
  if (spec.content.callouts?.some((c) => c.id === refId)) return "callouts";
  if (spec.content.dataViz?.id === refId) return "dataViz";
  if (spec.content.images?.some((i) => i.id === refId)) return "images";
  if (spec.content.imagePlaceholders?.some((p) => p.id === refId))
    return "imagePlaceholders";
  return null;
}

function preferredHeight(type: AnchorType, remaining: number): number {
  switch (type) {
    case "title":
      return clampNum(0.8, 0.6, Math.min(1.0, remaining));
    case "subtitle":
      return clampNum(0.5, 0.4, Math.min(0.7, remaining));
    case "bullets":
      return Math.max(remaining - 0.3, 2.2);
    case "callouts":
      return clampNum(1.0, 0.7, Math.min(1.2, remaining));
    case "dataViz":
      return Math.max(2.0, remaining * 0.6);
    case "images":
    case "imagePlaceholders":
      return clampNum(Math.min(remaining, 3.5), 1.5, 3.5);
  }
}

/* ---------------------------- Charts & formatting --------------------------- */

function mapChartKind(pptx: PptxGenJS, kind?: ChartKind | string | null) {
  const k = (kind || "bar").toString().toLowerCase();
  const T = pptx.ChartType;
  switch (k) {
    case "bar":
      return T.bar;
    case "line":
      return T.line;
    case "pie":
      return T.pie;
    case "doughnut":
      return T.doughnut;
    case "area":
      return T.area;
    case "scatter":
      return T.scatter;
    case "radar":
      return T.radar;
    case "bubble":
      return T.bubble;
    case "stock":
      return T.stock;
    case "combo":
      return T.bar; // Base for combo
    case "waterfall":
      return T.bar; // Stacked bar fallback with custom data
    case "funnel":
      return T.pyramid; // Pyramid as funnel fallback
    default:
      return null;
  }
}

function toLegendPos(pos?: "top" | "bottom" | "left" | "right" | "none"): string | undefined {
  if (pos === "none") return undefined;
  if (pos === "top") return "t";
  if (pos === "left") return "l";
  if (pos === "right") return "r";
  return "b"; // Default bottom
}

function chartSeriesColors(palette: SlideSpecV1["styleTokens"]["palette"]): string[] {
  const neutral = palette.neutral || [];
  const base = [
    palette.primary,
    palette.accent,
    adjustColor(palette.primary, -20),
    adjustColor(palette.accent, -20),
    neutral[2],
    neutral[3],
  ].filter(Boolean) as string[];
  return base;
}

type ValueFormat = NonNullable<SlideSpecV1["content"]["dataViz"]>["valueFormat"];
function mapFormatCodes(fmt: ValueFormat | undefined): {
  valAxisFormatCode?: string;
  dataLabelFormatCode?: string;
} {
  switch (fmt) {
    case "percent":
      return { valAxisFormatCode: "0%", dataLabelFormatCode: "0%" };
    case "currency":
      return { valAxisFormatCode: "$#,##0", dataLabelFormatCode: "$#,##0" };
    case "decimal":
      return { valAxisFormatCode: "0.00", dataLabelFormatCode: "0.00" };
    case "number":
      return { valAxisFormatCode: "0", dataLabelFormatCode: "0" };
    case "auto":
    default:
      return {};
  }
}

/* ------------------------------ Callout colors ------------------------------ */

function calloutColors(
  variant: "success" | "warning" | "note" | "danger" | "insight",
  palette: SlideSpecV1["styleTokens"]["palette"]
) {
  switch (variant) {
    case "success":
      return {
        bg: "#D1FAE5",
        border: "#10B981",
        textColor: "#065F46",
      };
    case "warning":
      return { bg: "#FEF3C7", border: "#F59E0B", textColor: "#78350F" };
    case "danger":
      return { bg: "#FEE2E2", border: "#EF4444", textColor: "#7F1D1D" };
    case "insight":
      return { bg: "#E0E7FF", border: palette.primary || "#6366F1", textColor: "#312E81" };
    case "note":
    default:
      return {
        bg: "#F3F4F6",
        border: palette.accent || "#EC4899",
        textColor: "#1F2937",
      };
  }
}

/* ------------------------------- Image loader ------------------------------- */

/**
 * Fetch image as Buffer with Unsplash support and retries.
 * Optimizes to 96dpi, JPEG q82 (or PNG if transparent).
 * Returns null on failure.
 */
async function fetchImageBuffer(url?: string, maxRetries = 3): Promise<Buffer | null> {
  if (!url) return null;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const controller = new AbortController();
      const timeoutMs = 5000 + attempt * 1500;
      const t = setTimeout(() => controller.abort(), timeoutMs);

      const res = await undiciFetch(url, { signal: controller.signal });
      clearTimeout(t);

      if (!res.ok) {
        if (res.status >= 400 && res.status < 500) return null;
        if (attempt < maxRetries) continue;
        return null;
      }

      const contentType = res.headers.get("content-type") || "";
      if (!/^image\//i.test(contentType)) return null;

      const ab = await res.arrayBuffer();
      const buffer = Buffer.from(ab);

      const optimized = await optimizeImage(buffer, url, { quality: 82, maxWidth: 1920 }); // Enhanced opts
      return optimized;
    } catch (e) {
      if (attempt < maxRetries) {
        await new Promise((resolve) => setTimeout(resolve, 200 * Math.pow(2, attempt)));
        continue;
      }
      return null;
    }
  }

  return null;
}

function generateNeutralRamp(): string[] {
  // Placeholder; integrate with colorPaletteGenerator
  return [
    "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
    "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC"
  ];
}

================================================================================
FILE: ./functions/src/pptxBuilder/index.ts
================================================================================

/**
 * PPTX Builder Module (barrel)
 * Exposes:
 *  - buildSlideFromSpec: full SlideSpec renderer using the grid engine
 *  - buildHeaderOnlySlide: legacy/simple title+subtitle slide (back-compat)
 *  - assertValidSpec(s): schema-backed validation for inbound specs
 *  - createPptxFromSpecs: high-level PPTX generator (lazy-loads pptxgenjs)
 *  - SlideSpec / SlideSpecV1 / SlideSpecZ and core type exports
 *
 * Side-effect free and tree-shakeable: no heavy imports at module load.
 */

export { buildSlideFromSpec, buildHeaderOnlySlide } from "./headerOnlyBuilder";
export type { HeaderOnlySlideSpec } from "./headerOnlyBuilder";

import { SlideSpecZ } from "@plzfixthx/slide-spec";
export { SlideSpecZ } from "@plzfixthx/slide-spec";
export type {
  SlideSpec,
  SlideSpecV1,
  ChartKind,
  AspectRatio,
  RegionName,
} from "@plzfixthx/slide-spec";

/* -------------------------------------------------------------------------- */
/*                             Validation Utilities                            */
/* -------------------------------------------------------------------------- */

/** Validate & parse a single spec (throws on invalid). */
export function assertValidSpec(input: unknown): import("@plzfixthx/slide-spec").SlideSpec {
  return SlideSpecZ.parse(input);
}

/** Validate & parse an array of specs (throws with index on invalid). */
export function assertValidSpecs(input: unknown[]): import("@plzfixthx/slide-spec").SlideSpec[] {
  return input.map((s, i) => {
    try {
      return SlideSpecZ.parse(s);
    } catch (e: any) {
      e.message = `Spec at index ${i}: ${e.message || e}`;
      throw e;
    }
  });
}

/* -------------------------------------------------------------------------- */
/*                             Layout Helper (pure)                            */
/* -------------------------------------------------------------------------- */

/** Map aspect ratio to PptxGenJS layout keyword (string literal keeps this module lightweight). */
export function pptxLayoutByAspectRatio(
  ar: import("@plzfixthx/slide-spec").AspectRatio
): "LAYOUT_16x9" | "LAYOUT_4x3" {
  return ar === "4:3" ? "LAYOUT_4x3" : "LAYOUT_16x9";
}

/* -------------------------------------------------------------------------- */
/*                         High-level PPTX generation API                      */
/* -------------------------------------------------------------------------- */

/**
 * Render one or more SlideSpecV1 slides to a .pptx ArrayBuffer.
 * - Lazy-loads pptxgenjs to keep this barrel side-effect free.
 * - Uses the universal builder for each slide.
 */
export async function createPptxFromSpecs(
  specs: import("@plzfixthx/slide-spec").SlideSpec | import("@plzfixthx/slide-spec").SlideSpec[]
): Promise<ArrayBuffer> {
  const arr = Array.isArray(specs) ? specs : [specs];
  if (arr.length === 0) throw new Error("No slides to export");

  // Lazy import so apps that only need types/builders don’t pay the cost.
  const PptxGen = (await import("pptxgenjs")).default as any;
  const pptx: any = new PptxGen();

  pptx.layout = pptxLayoutByAspectRatio(arr[0].meta.aspectRatio);

  // Defer to the universal builder (already handles all content types).
  for (const spec of arr) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    await (await import("./headerOnlyBuilder")).buildSlideFromSpec(pptx, spec as any);
  }

  // ArrayBuffer output aligns with Cloud Functions’ send(Buffer.from(ab)).
  return (pptx.write({ outputType: "arraybuffer" }) as unknown) as Promise<ArrayBuffer>;
}

================================================================================
FILE: ./functions/src/prompts.ts
================================================================================

/** World-class system prompt for consulting-firm-quality slide generation */
export const ENHANCED_SYSTEM_PROMPT = `You are the elite SlideSpec generator for plzfixthx, a premier AI-powered tool for creating boardroom-ready PowerPoint slides. Produce slides that embody the precision, clarity, and visual sophistication of top-tier strategy consulting firms like McKinsey, BCG, or Bain.

OUTPUT ONLY VALID JSON — NO MARKDOWN, NO EXPLANATIONS, NO COMMENTARY, NO ADDITIONAL TEXT.
Return a SINGLE RFC8259-compliant JSON object that STRICTLY VALIDATES against SlideSpec v1 schema. Ensure the output is parseable as JSON without errors.

CORE DESIGN PRINCIPLES
- MECE Structure: Content must be Mutually Exclusive, Collectively Exhaustive — logical, non-overlapping, comprehensive.
- Visual Hierarchy: Strong emphasis on key messages; use size, color, and position to guide the eye (e.g., title dominant, bullets supportive).
- Data-Driven: Prioritize evidence-based insights; incorporate metrics, benchmarks, and projections where relevant.
- Elegant Simplicity: Minimalist design with purposeful elements; avoid clutter, favor white space for impact.
- Professional Polish: Boardroom-ready aesthetics — refined, premium, trustworthy.
- Innovative Touches: Subtle animations hints (e.g., fade-ins), dynamic layouts for storytelling flow.
- Accessibility First: WCAG AAA compliance (contrast ≥7:1 for text, ≥3:1 for graphics); semantic structure for screen readers.
- Storytelling Arc: Slides should advance a narrative — problem, analysis, recommendation, impact.

COLOR PALETTE STRATEGY
- Contextual Selection: Infer from prompt (e.g., tech/innovation → blues/teals like #1D4ED8; finance/growth → navies/golds like #1E3A8A; sustainability → greens like #047857; creative → purples/oranges like #6D28D9).
- Complementary Accents: Choose warm, vibrant accents (e.g., #F59E0B amber, #EA580C orange, #D97706 gold, #F97316 tangerine, #DC2626 red) that contrast sharply with primary (≥4.5:1 ratio).
- Neutral Ramp: Exactly 9 steps from darkest (#0F172A slate) to lightest (#F8FAFC cloud), with sophisticated grays for depth (avoid pure black/white for premium feel).
- Harmony & Accessibility: Validate all color pairs (text/bg, primary/accent) for ≥7:1 contrast; use tools like WCAG formulas implicitly.
- Brand Alignment: If prompt mentions a brand/company, adapt palette to their colors (e.g., Google → blue/red/yellow/green).

REQUIRED JSON SHAPE (ILLUSTRATIVE EXAMPLE — DO NOT COPY VERBATIM)
{
  "meta": { "version": "1.0", "locale": "en-US", "theme": "Strategic Growth", "aspectRatio": "16:9" },
  "design": { "pattern": "executive", "whitespace": { "strategy": "balanced", "breathingRoom": 0.35 }, "animationHints": ["fadeInTitle", "buildBullets"] },
  "content": {
    "title": { "id": "title", "text": "Unlock 40% Revenue Acceleration" },
    "subtitle": { "id": "subtitle", "text": "Leveraging AI-driven pricing and regional expansion for sustainable growth" },
    "bullets": [
      {
        "id": "b1",
        "items": [
          { "text": "Optimize pricing with AI elasticity models", "level": 1 },
          { "text": "Target 3 high-potential regions for A/B testing", "level": 2 },
          { "text": "Achieve 180 bps GM uplift in 6 months", "level": 3 }
        ]
      },
      {
        "id": "b2",
        "items": [
          { "text": "Enhance unit economics through supply chain efficiencies", "level": 1 },
          { "text": "Reduce COGS by 15% via vendor consolidation", "level": 2 }
        ]
      }
    ],
    "dataViz": {
      "id": "dv1",
      "kind": "combo",
      "title": "Regional Growth Projections",
      "labels": ["Q1 FY25", "Q2 FY25", "Q3 FY25", "Q4 FY25"],
      "series": [
        { "name": "Revenue ($M)", "values": [120, 145, 168, 192], "type": "bar" },
        { "name": "Growth Rate (%)", "values": [8, 12, 15, 18], "type": "line" }
      ],
      "valueFormat": "currency",
      "legend": { "position": "bottom", "alignment": "center" }
    },
    "images": [
      {
        "id": "img1",
        "role": "hero",
        "source": { "type": "unsplash", "query": "modern executive boardroom strategy meeting" },
        "alt": "Strategic boardroom discussion",
        "fit": "cover"
      }
    ],
    "imagePlaceholders": [
      { "id": "ph1", "role": "decorative", "alt": "Growth chart illustration" }
    ],
    "callouts": [
      { "id": "c1", "type": "success", "text": "Projected ROI: 3.2x in Year 1", "icon": "check-circle" },
      { "id": "c2", "type": "note", "text": "Based on Q4 benchmark data", "icon": "info" }
    ]
  },
  "layout": {
    "grid": { "rows": 10, "cols": 12, "gutter": 12, "margin": { "t": 40, "r": 40, "b": 40, "l": 40 } },
    "regions": [
      { "name": "header", "rowStart": 1, "colStart": 1, "rowSpan": 2, "colSpan": 12 },
      { "name": "left-body", "rowStart": 3, "colStart": 1, "rowSpan": 7, "colSpan": 5 },
      { "name": "right-body", "rowStart": 3, "colStart": 6, "colSpan": 7, "rowSpan": 7 }
    ],
    "anchors": [
      { "refId": "title", "region": "header", "order": 0 },
      { "refId": "subtitle", "region": "header", "order": 1 },
      { "refId": "b1", "region": "left-body", "order": 0 },
      { "refId": "b2", "region": "left-body", "order": 1 },
      { "refId": "dv1", "region": "right-body", "order": 0 },
      { "refId": "img1", "region": "right-body", "order": 1 },
      { "refId": "c1", "region": "right-body", "order": 2 }
    ]
  },
  "styleTokens": {
    "palette": {
      "primary": "#1D4ED8",
      "accent": "#F59E0B",
      "neutral": ["#0F172A", "#1E293B", "#334155", "#475569", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC"]
    },
    "typography": {
      "fonts": { "sans": "Aptos, Calibri, Arial, sans-serif" },
      "sizes": { "step_-2": 10, "step_-1": 12, "step_0": 14, "step_1": 18, "step_2": 24, "step_3": 36, "step_4": 48 },
      "weights": { "light": 300, "regular": 400, "medium": 500, "semibold": 600, "bold": 700 },
      "lineHeights": { "tight": 1.1, "compact": 1.25, "standard": 1.5, "relaxed": 1.75 },
      "letterSpacing": { "tight": -0.02, "normal": 0, "wide": 0.02 }
    },
    "spacing": { "base": 4, "steps": [0, 4, 8, 12, 16, 24, 32, 48, 64] },
    "radii": { "none": 0, "sm": 4, "md": 8, "lg": 12, "xl": 16, "full": 9999 },
    "shadows": {
      "none": "none",
      "sm": "0 1px 2px rgba(0,0,0,0.05)",
      "md": "0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06)",
      "lg": "0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05)",
      "xl": "0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04)"
    },
    "contrast": { "minTextContrast": 7, "minUiContrast": 4.5, "minGraphicContrast": 3 }
  }
}

STRICT RULES (ENFORCE THE CONTRACT)
1) Required Keys: meta, design, content, layout, styleTokens. All must be present.
2) IDs: Alphanumeric with hyphens/underscores only ([A-Za-z0-9_-]); unique and descriptive (e.g., "growth-chart", "key-insight").
3) Colors: Strictly #RRGGBB hex format. Neutral palette: EXACTLY 9 colors, progressing dark to light.
4) Bullets: Max 3 groups; 1–6 items per group; levels 1–3 only. Use parallel structure, action verbs, quantifiable outcomes.
5) DataViz (CONDITIONAL INCLUSION):
   - OMIT entirely unless prompt explicitly requests visualization OR contains quantifiable data (metrics, trends, comparisons) that benefits from charting.
   - Inclusion Criteria: Enhances storytelling (e.g., show growth over time, compare segments); avoid for simple lists.
   - Specs: kind from {"bar","line","pie","doughnut","area","scatter","combo","waterfall","funnel","radar"}; labels 2–12; series 1–5; values match labels length; valueFormat {"number","percent","currency","decimal","auto"}; add "type" per series for "combo".
   - Legend: Include if >1 series; position {"top","bottom","left","right"}.
6) Images:
   - source.type: "url" (absolute "url" required), "unsplash" ("query" required for AI-suggested image), "placeholder" (no source needed).
   - fit: {"cover","contain","fill","scale-down"}; role: {"hero","illustration","decorative","informative"}.
   - Max 4 images + 3 placeholders total.
7) Callouts (NEW: For emphasis):
   - Optional array in content; max 4; types {"success","warning","note","danger","insight"}; include "text", optional "icon".
   - Use for key takeaways, risks, or metrics; position via anchors.
8) Layout:
   - Grid: Flexible rows/cols (8–12 rows, 12 cols recommended); gutters/margins in pixels.
   - Regions: Non-overlapping, fit grid; common: header, body, sidebar.
   - Anchors: refId must match content IDs; order dictates rendering sequence; add z-index if needed.
9) Typography: Hierarchical scales; title step_3–4 (36–48px), body step_0–1 (14–18px); use weights/lines for emphasis.
10) Accessibility: Enforce contrasts; add alt text for all visuals; semantic IDs.
11) Primary: Professional, sector-aligned (blues/teals default).
12) Accent: Warm, energetic; ensure vibrancy without overwhelming.
13) Animation Hints: Array in design; suggest subtle effects like "fadeIn", "buildSequence" for modern feel.

CONTENT SELECTION STRATEGY
- Prompt Analysis: Extract key themes, metrics, structure (e.g., problem-solution-impact).
- Qualitative: Bullets + callouts; focus on insights, recommendations.
- Quantitative: DataViz + supporting bullets; choose chart kind for best representation (bar for comparisons, line for trends).
- Mixed: Balance; lead with narrative (title/subtitle), support with visuals.
- Never Force Elements: Omit unused sections (e.g., no dataViz if no data); keep slides focused (1 key message per slide).

CONTENT QUALITY GUARDRAILS
- Title: 3–7 words, ≤50 chars; imperative/action-oriented (e.g., "Drive Efficiency Gains", "Capture Market Share").
- Subtitle: 6–12 words, ≤80 chars; provides context, metrics, or teaser.
- Bullets: Concise (≤60 chars/item); start with verbs; include KPIs (e.g., "Increase X by Y%").
- Callouts: Punchy (≤40 chars); for emphasis only.
- DataViz: Story-telling titles; clean labels; realistic data inferred from prompt.

PREMIUM VISUAL TOUCHES
- Accent Elements: Left-side bar (0.1–0.15in, primary color); subtle gradients (10–20% opacity).
- Dividers: Thin lines (2–4px) under headers; small icons/shapes in accent.
- White Space: 30–40% breathing room; balanced asymmetry for interest.
- Overlays: Light glazes (5–15% opacity) for depth; vertical/horizontal guides.
- Harmony: Ensure cohesive flow; test implicit contrasts.

INDUSTRY-SPECIFIC GUIDANCE
- Finance: Navy/gold; waterfall charts for breakdowns; ROI metrics.
- Tech: Blue/purple; radar for comparisons; innovation icons.
- Healthcare: Teal/green; funnels for patient journeys; compliance notes.
- Sustainability: Earth tones; area charts for trends; impact callouts.
- Marketing: Vibrant; pie for shares; creative imagery.
- General Corporate: Neutral with pops; bar/line for performance.

FAILSAFE BEHAVIOR
- Ambiguous Input: Default to "executive" pattern, blue primary, balanced layout.
- Invalid Elements: Fallback to example structures; ensure JSON validity.
- Prioritize: Readability > Aesthetics > Innovation.
- Always: Validate contrasts, MECE, narrative flow.

Now output ONLY the JSON object.`;

export const SIMPLE_SYSTEM_PROMPT = `You are SlideSpec generator for plzfixthx. Output ONLY valid JSON strictly validating against SlideSpec v1.
Hard Rules:
- meta: version "1.0"; aspectRatio "16:9"; locale "en-US".
- IDs: [A-Za-z0-9_-]; Colors: #RRGGBB hex.
- Palette: neutral exactly 9 colors (darkest to lightest).
- Bullets: ≤3 groups; 1–6 items/group; levels 1–3.
- DataViz: Omit unless prompt has quantifiable data or chart request. Specs: labels 2–12; series 1–5; values match labels.
- Images: "url" requires url; "unsplash" requires query; "placeholder" neither.
- Callouts: Optional; max 4; types success/warning/note/danger.
- Prefer narrative bullets/callouts; charts for data stories only.
Return SINGLE JSON object, no additional text.`;

================================================================================
FILE: ./functions/src/security.ts
================================================================================

/**
 * Security middleware and utilities for plzfixthx functions.
 * Includes rate limiting, request validation, and abuse detection.
 */

import * as logger from "firebase-functions/logger";
import { Request, Response } from "express";
import crypto from "crypto";

/* -------------------------------------------------------------------------- */
/*                            Rate Limiting                                   */
/* -------------------------------------------------------------------------- */

interface RateLimitEntry {
  count: number;
  resetTime: number;
}

// In-memory rate limit store (in production, use Redis or Firestore)
const rateLimitStore = new Map<string, RateLimitEntry>();

// Cleanup old entries every 5 minutes
setInterval(() => {
  const now = Date.now();
  for (const [key, entry] of rateLimitStore.entries()) {
    if (entry.resetTime < now) {
      rateLimitStore.delete(key);
    }
  }
}, 5 * 60 * 1000);

/**
 * Get client identifier from request (IP + User-Agent fingerprint)
 */
export function getClientId(req: Request): string {
  const ip = req.ip || req.socket.remoteAddress || "unknown";
  const userAgent = req.get("user-agent") || "unknown";
  const fingerprint = crypto
    .createHash("sha256")
    .update(`${ip}:${userAgent}`)
    .digest("hex")
    .slice(0, 16);
  return fingerprint;
}

/**
 * Rate limit middleware: max 100 requests per minute per client
 */
export function rateLimitMiddleware(
  req: Request,
  res: Response,
  next: () => void,
  options: { maxRequests?: number; windowMs?: number } = {}
): void {
  const maxRequests = options.maxRequests || 100;
  const windowMs = options.windowMs || 60 * 1000; // 1 minute

  const clientId = getClientId(req);
  const now = Date.now();

  let entry = rateLimitStore.get(clientId);

  if (!entry || entry.resetTime < now) {
    entry = { count: 0, resetTime: now + windowMs };
    rateLimitStore.set(clientId, entry);
  }

  entry.count++;

  // Set rate limit headers
  const remaining = Math.max(0, maxRequests - entry.count);
  const resetTime = Math.ceil(entry.resetTime / 1000);

  res.set("X-RateLimit-Limit", String(maxRequests));
  res.set("X-RateLimit-Remaining", String(remaining));
  res.set("X-RateLimit-Reset", String(resetTime));

  if (entry.count > maxRequests) {
    const retryAfter = Math.ceil((entry.resetTime - now) / 1000);
    logger.warn("Rate limit exceeded", { clientId, count: entry.count, maxRequests, retryAfter });

    // Set Retry-After header
    res.set("Retry-After", String(retryAfter));

    res.status(429).json({
      error: {
        code: "RATE_LIMIT_EXCEEDED",
        message: "Too many requests. Please try again later.",
        details: {
          retryAfter,
          limit: maxRequests,
          window: `${windowMs / 1000}s`,
        },
      },
    });
    return;
  }

  next();
}

/* -------------------------------------------------------------------------- */
/*                         Request Validation                                 */
/* -------------------------------------------------------------------------- */

/**
 * Validate request payload size
 */
export function validatePayloadSize(
  req: Request,
  res: Response,
  next: () => void,
  maxSizeBytes: number = 1024 * 100 // 100KB default
): void {
  const contentLength = parseInt(req.get("content-length") || "0", 10);

  if (contentLength > maxSizeBytes) {
    logger.warn("Payload too large", { contentLength, maxSizeBytes });
    res.status(413).json({
      error: {
        code: "PAYLOAD_TOO_LARGE",
        message: "Request payload exceeds maximum allowed size",
        details: {
          contentLength,
          maxSize: maxSizeBytes,
          maxSizeMB: (maxSizeBytes / 1024 / 1024).toFixed(2),
        },
      },
    });
    return;
  }

  next();
}

/* -------------------------------------------------------------------------- */
/*                         Abuse Detection                                    */
/* -------------------------------------------------------------------------- */

/**
 * Note: sanitizePrompt and moderateContent are now in aiHelpers.ts for centralization.
 * This module focuses on request-level security (rate limiting, payload validation, etc.)
 */

/* -------------------------------------------------------------------------- */
/*                         Request Tracing                                    */
/* -------------------------------------------------------------------------- */

/**
 * Generate or extract request ID for tracing
 */
export function getRequestId(req: Request): string {
  const existing = req.get("x-request-id");
  if (existing) return existing;

  return crypto.randomUUID();
}

/**
 * Add request ID to response headers
 */
export function setRequestId(req: Request, res: Response): string {
  const requestId = getRequestId(req);
  res.set("X-Request-ID", requestId);
  return requestId;
}

/* -------------------------------------------------------------------------- */
/*                         Error Response Helpers                             */
/* -------------------------------------------------------------------------- */

/**
 * Send a safe error response (no sensitive details)
 */
export function sendSafeError(
  res: Response,
  statusCode: number,
  message: string,
  requestId?: string
): void {
  res.status(statusCode).json({
    error: message,
    ...(requestId && { requestId }),
  });
}

/**
 * Send a structured error response
 */
export function sendStructuredError(
  res: Response,
  statusCode: number,
  code: string,
  message: string,
  details?: Record<string, unknown>
): void {
  res.status(statusCode).json({
    error: {
      code,
      message,
      ...(details && { details }),
    },
  });
}



================================================================================
FILE: ./functions/src/shared.ts
================================================================================

/**
 * Shared Backend Utilities Module
 * ================================
 * Centralized utilities for Cloud Functions layer.
 * Includes: color utilities, typography helpers, layout calculations, and error mapping.
 * All functions are pure and side-effect free.
 */

/* -------------------------------------------------------------------------- */
/*                            Color Utilities                                 */
/* -------------------------------------------------------------------------- */

/**
 * Convert hex color to RGB tuple
 * @param hex - Hex color string (e.g., "#FF0000")
 * @returns [r, g, b] tuple with values 0-255
 */
export function hexToRgb(hex: string): [number, number, number] {
  const clean = hex.replace("#", "").slice(0, 6);
  const r = parseInt(clean.slice(0, 2), 16) || 0;
  const g = parseInt(clean.slice(2, 4), 16) || 0;
  const b = parseInt(clean.slice(4, 6), 16) || 0;
  return [r, g, b];
}

/**
 * Convert RGB to hex color
 * @param r - Red (0-255)
 * @param g - Green (0-255)
 * @param b - Blue (0-255)
 * @returns Hex color string
 */
export function rgbToHex(r: number, g: number, b: number): string {
  const toHex = (n: number): string => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
}

/**
 * Calculate relative luminance per WCAG 2.2
 * @param hex - Hex color string
 * @returns Luminance value (0-1)
 */
export function getLuminance(hex: string): number {
  const [r, g, b] = hexToRgb(hex).map((x) => x / 255);
  const lin = (c: number): number => (c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4));
  return 0.2126 * lin(r) + 0.7152 * lin(g) + 0.0722 * lin(b);
}

/**
 * Calculate contrast ratio per WCAG 2.2
 * @param hex1 - First hex color
 * @param hex2 - Second hex color
 * @returns Contrast ratio (1-21)
 */
export function contrastRatio(hex1: string, hex2: string): number {
  const l1 = getLuminance(hex1);
  const l2 = getLuminance(hex2);
  return (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
}

/**
 * Validate hex color format
 * @param color - Color string to validate
 * @returns True if valid 6-digit hex
 */
export function isValidHex(color: string): boolean {
  return /^#[0-9A-Fa-f]{6}$/.test(color);
}

/**
 * Convert opacity (0-1) to PPTX transparency (0-100)
 * @param opacity - Opacity value (0-1)
 * @returns PPTX transparency value (0-100)
 */
export function opacityToTransparency(opacity: number): number {
  return Math.round((1 - Math.max(0, Math.min(1, opacity))) * 100);
}

/**
 * Convert PPTX transparency (0-100) to opacity (0-1)
 * @param transparency - PPTX transparency value (0-100)
 * @returns Opacity value (0-1)
 */
export function transparencyToOpacity(transparency: number): number {
  return 1 - Math.max(0, Math.min(100, transparency)) / 100;
}

/**
 * Add alpha transparency to hex color (for CSS/frontend use)
 * @param hex - Hex color string
 * @param alpha - Alpha value (0-1)
 * @returns Hex color with alpha (8-digit)
 */
export function hexWithAlpha(hex: string, alpha: number): string {
  const a = Math.round(Math.max(0, Math.min(1, alpha)) * 255)
    .toString(16)
    .padStart(2, "0");
  const clean = hex.replace("#", "");
  if (clean.length === 3) {
    const [r, g, b] = clean.split("").map((c) => c + c);
    return `#${r}${g}${b}${a}`;
  }
  if (clean.length === 6) return `#${clean}${a}`;
  return hex;
}

/* -------------------------------------------------------------------------- */
/*                          Typography Helpers                                */
/* -------------------------------------------------------------------------- */

/**
 * Pixel to inch conversion (96 DPI standard)
 */
export const PX_PER_INCH = 96;

/**
 * Convert pixels to inches
 * @param px - Pixel value
 * @returns Inch value
 */
export function pxToIn(px: number): number {
  return px / PX_PER_INCH;
}

/**
 * Convert inches to pixels
 * @param inches - Inch value
 * @returns Pixel value
 */
export function inToPx(inches: number): number {
  return inches * PX_PER_INCH;
}

/**
 * Truncate text with ellipsis
 * @param text - Text to truncate
 * @param maxLength - Maximum length
 * @returns Truncated text
 */
export function truncateWithEllipsis(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength - 3) + "...";
}

/**
 * Calculate optimal font size based on available space
 * @param text - Text to measure
 * @param maxWidth - Maximum width in pixels
 * @param baseFontSize - Base font size
 * @returns Optimal font size
 */
export function calculateOptimalFontSize(
  text: string,
  maxWidth: number,
  baseFontSize: number = 16
): number {
  const charWidth = baseFontSize * 0.6; // Approximate character width
  const estimatedWidth = text.length * charWidth;
  if (estimatedWidth <= maxWidth) return baseFontSize;
  return Math.max(8, Math.floor((maxWidth / estimatedWidth) * baseFontSize));
}

/* -------------------------------------------------------------------------- */
/*                          Error Mapping                                     */
/* -------------------------------------------------------------------------- */

/**
 * Map API errors to user-friendly messages
 * @param error - Error object or message
 * @returns User-friendly error message
 */
export function mapErrorToMessage(error: unknown): string {
  if (error instanceof Error) {
    if (error.message.includes("timeout")) {
      return "Request timed out. Please try again.";
    }
    if (error.message.includes("network")) {
      return "Network error. Please check your connection.";
    }
    if (error.message.includes("401") || error.message.includes("unauthorized")) {
      return "Authentication failed. Please refresh and try again.";
    }
    if (error.message.includes("429") || error.message.includes("rate limit")) {
      return "Too many requests. Please wait a moment and try again.";
    }
    return error.message;
  }
  return "An unexpected error occurred. Please try again.";
}

/* -------------------------------------------------------------------------- */
/*                          Layout Calculations                               */
/* -------------------------------------------------------------------------- */

/**
 * Calculate grid cell dimensions
 * @param totalWidth - Total width in inches
 * @param totalHeight - Total height in inches
 * @param cols - Number of columns
 * @param rows - Number of rows
 * @param gutter - Gutter size in inches
 * @param margin - Margin object {t, r, b, l} in inches
 * @returns Cell dimensions {width, height} in inches
 */
export function calculateCellDimensions(
  totalWidth: number,
  totalHeight: number,
  cols: number,
  rows: number,
  gutter: number,
  margin: { t: number; r: number; b: number; l: number }
): { width: number; height: number } {
  const availableWidth = totalWidth - margin.l - margin.r - gutter * (cols - 1);
  const availableHeight = totalHeight - margin.t - margin.b - gutter * (rows - 1);
  return {
    width: availableWidth / cols,
    height: availableHeight / rows,
  };
}

/**
 * Calculate region position in grid
 * @param rowStart - Starting row (1-indexed)
 * @param colStart - Starting column (1-indexed)
 * @param rowSpan - Number of rows to span
 * @param colSpan - Number of columns to span
 * @param cellWidth - Width of each cell in inches
 * @param cellHeight - Height of each cell in inches
 * @param gutter - Gutter size in inches
 * @param margin - Margin object in inches
 * @returns Position {x, y, width, height} in inches
 */
export function calculateRegionPosition(
  rowStart: number,
  colStart: number,
  rowSpan: number,
  colSpan: number,
  cellWidth: number,
  cellHeight: number,
  gutter: number,
  margin: { t: number; r: number; b: number; l: number }
): { x: number; y: number; width: number; height: number } {
  const x = margin.l + (colStart - 1) * (cellWidth + gutter);
  const y = margin.t + (rowStart - 1) * (cellHeight + gutter);
  const width = colSpan * cellWidth + (colSpan - 1) * gutter;
  const height = rowSpan * cellHeight + (rowSpan - 1) * gutter;
  return { x, y, width, height };
}



================================================================================
FILE: ./functions/src/themePresets.ts
================================================================================

/**
 * Theme Presets Module
 * - Predefined professional themes (Corporate, Tech, Finance, Healthcare, Sustainability, Luxury)
 * - Support for brand primary color input with auto-correction to nearest compliant color
 * - Ensures WCAG AAA contrast compliance (7:1 for text, 4.5:1 for UI accents)
 */

import { contrastRatio, nearestCompliantColor } from "./colorUtils";

export interface ThemePreset {
  name: string;
  primary: string;
  accent: string;
  neutral: string[];
  description: string;
}

/** Professional theme presets */
export const THEME_PRESETS: Record<string, ThemePreset> = {
  corporate: {
    name: "Corporate",
    primary: "#1E40AF", // Deep blue
    accent: "#DC2626", // Red
    neutral: [
      "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
      "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
    ],
    description: "Professional, trustworthy, traditional",
  },

  tech: {
    name: "Tech",
    primary: "#7C3AED", // Purple
    accent: "#06B6D4", // Cyan
    neutral: [
      "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
      "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
    ],
    description: "Modern, innovative, forward-thinking",
  },

  finance: {
    name: "Finance",
    primary: "#065F46", // Dark green
    accent: "#DC2626", // Red
    neutral: [
      "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
      "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
    ],
    description: "Stable, secure, growth-oriented",
  },

  healthcare: {
    name: "Healthcare",
    primary: "#0369A1", // Sky blue
    accent: "#059669", // Green
    neutral: [
      "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
      "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
    ],
    description: "Caring, trustworthy, professional",
  },

  sustainability: {
    name: "Sustainability",
    primary: "#15803D", // Green
    accent: "#EA580C", // Orange
    neutral: [
      "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
      "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
    ],
    description: "Eco-conscious, responsible, natural",
  },

  luxury: {
    name: "Luxury",
    primary: "#1F2937", // Dark gray
    accent: "#D97706", // Gold
    neutral: [
      "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
      "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
    ],
    description: "Elegant, premium, sophisticated",
  },
};

/**
 * Get theme preset by name
 */
export function getThemePreset(name: string): ThemePreset | null {
  return THEME_PRESETS[name.toLowerCase()] || null;
}

/**
 * Apply brand primary color to a theme preset
 * Auto-corrects color to nearest compliant color if needed
 */
export function applyBrandColor(
  preset: ThemePreset,
  brandPrimary: string
): ThemePreset {
  // Validate and correct brand color for WCAG AAA compliance
  const correctedPrimary = nearestCompliantColor(brandPrimary, preset.neutral);

  return {
    ...preset,
    primary: correctedPrimary,
  };
}

/**
 * Get all available theme names
 */
export function getAvailableThemes(): string[] {
  return Object.keys(THEME_PRESETS);
}

/**
 * Validate theme has proper contrast
 */
export function validateThemeContrast(theme: ThemePreset): {
  valid: boolean;
  issues: string[];
} {
  const issues: string[] = [];
  const white = "#FFFFFF";
  const black = "#000000";

  // Check primary color contrast
  const primaryVsWhite = contrastRatio(theme.primary, white);
  const primaryVsBlack = contrastRatio(theme.primary, black);
  const primaryContrast = Math.max(primaryVsWhite, primaryVsBlack);

  if (primaryContrast < 4.5) {
    issues.push(`Primary color contrast too low: ${primaryContrast.toFixed(2)}:1 (need ≥4.5:1)`);
  }

  // Check accent color contrast
  const accentVsWhite = contrastRatio(theme.accent, white);
  const accentVsBlack = contrastRatio(theme.accent, black);
  const accentContrast = Math.max(accentVsWhite, accentVsBlack);

  if (accentContrast < 4.5) {
    issues.push(`Accent color contrast too low: ${accentContrast.toFixed(2)}:1 (need ≥4.5:1)`);
  }

  return {
    valid: issues.length === 0,
    issues,
  };
}



================================================================================
FILE: ./functions/src/typographyEnhancer.ts
================================================================================

/**
 * Typography Enhancement Module
 * Provides advanced typography utilities for professional slide generation
 * Enhanced with WCAG compliance, golden ratio scaling, and consulting firm presets (McKinsey, BCG, Bain)
 */



/* -------------------------------------------------------------------------- */
/*                        Font Pairing Recommendations                        */
/* -------------------------------------------------------------------------- */

export interface FontPair {
  display: string;
  body: string;
  description: string;
  fallback: string; // Enhanced with explicit fallback chain
}

const PROFESSIONAL_FONT_PAIRS: Record<string, FontPair> = {
  modern: {
    display: "Aptos, Calibri, Arial, sans-serif",
    body: "Aptos, Calibri, Arial, sans-serif",
    description: "Modern, clean, Microsoft Office standard for 2025",
    fallback: "Arial, sans-serif",
  },
  elegant: {
    display: "Georgia, Garamond, serif",
    body: "Calibri, Arial, sans-serif",
    description: "Elegant serif headers with clean body",
    fallback: "serif",
  },
  corporate: {
    display: "Montserrat, Aptos, Arial, sans-serif",
    body: "Montserrat, Aptos, Arial, sans-serif",
    description: "Corporate standard, highly readable with modern sans-serif",
    fallback: "Arial, sans-serif",
  },
  tech: {
    display: "Aptos, Arial, sans-serif",
    body: "Aptos, Arial, sans-serif",
    description: "Tech-forward, modern sans-serif",
    fallback: "sans-serif",
  },
  mckinsey: {
    display: "Bower, Georgia, serif", // McKinsey's bespoke with fallbacks
    body: "Arial, sans-serif",
    description: "McKinsey-inspired: Serif for impact, sans for clarity",
    fallback: "serif",
  },
  bcg: {
    display: "Helvetica Neue, Arial, sans-serif",
    body: "Helvetica Neue, Arial, sans-serif",
    description: "BCG-style: Clean, professional sans-serif",
    fallback: "sans-serif",
  },
  bain: {
    display: "EB Garamond, Georgia, serif",
    body: "Open Sans, Arial, sans-serif",
    description: "Bain-inspired: Balanced serif-sans for readability",
    fallback: "serif",
  },
  strategy: {
    display: "Libre Baskerville, Georgia, serif",
    body: "Lato, Arial, sans-serif",
    description: "Strategy consulting: Elegant and approachable",
    fallback: "serif",
  },
};

/* -------------------------------------------------------------------------- */
/*                      Typography Size Scaling                               */
/* -------------------------------------------------------------------------- */

export interface TypographyScale {
  h1: number; // Title
  h2: number; // Subtitle
  h3: number; // Section headers
  body: number; // Main content
  small: number; // Footnotes
  caption: number; // Labels
}

/**
 * Generate a typographic scale based on a base size and ratio
 * Supports modular scales: perfect fifth (1.25), golden ratio (1.618), etc.
 * Enforces WCAG min sizes: body >=24pt for presentations, small >=14pt
 */
export function generateTypographyScale(
  baseSize: number = 24, // Increased default for slide readability (WCAG rec)
  ratio: number = 1.618 // Golden ratio for harmony
): TypographyScale {
  const minBody = 24; // WCAG-inspired for presentations
  const actualBase = Math.max(baseSize, minBody);
  
  return {
    h1: Math.round(actualBase * Math.pow(ratio, 2)), // ~42pt
    h2: Math.round(actualBase * Math.pow(ratio, 1.5)), // ~38pt
    h3: Math.round(actualBase * Math.pow(ratio, 1)), // ~30pt
    body: actualBase, // 24pt min
    small: Math.round(actualBase * Math.pow(ratio, -1)), // ~18pt
    caption: Math.round(actualBase * Math.pow(ratio, -1.5)), // ~14pt min
  };
}

/* -------------------------------------------------------------------------- */
/*                      Line Height Recommendations                           */
/* -------------------------------------------------------------------------- */

export interface LineHeightGuide {
  display: number;
  heading: number;
  body: number;
  compact: number;
}

export const LINE_HEIGHT_GUIDE: LineHeightGuide = {
  display: 1.1, // Tight for large headlines (WCAG allows for headings)
  heading: 1.3, // Slightly looser for subheadings
  body: 1.5, // WCAG min 1.5x for readability
  compact: 1.4, // For dense content, still accessible
};

/* -------------------------------------------------------------------------- */
/*                      Letter Spacing Recommendations                        */
/* -------------------------------------------------------------------------- */

export interface LetterSpacingGuide {
  display: number;
  heading: number;
  body: number;
  caption: number;
}

export const LETTER_SPACING_GUIDE: LetterSpacingGuide = {
  display: -0.02, // Negative for large text (tracking)
  heading: -0.01,
  body: 0.00, // Neutral for body
  caption: 0.12, // WCAG min 0.12x for small text
};

/* -------------------------------------------------------------------------- */
/*                      Font Weight Recommendations                           */
/* -------------------------------------------------------------------------- */

export interface FontWeightGuide {
  light: number;
  regular: number;
  medium: number;
  semibold: number;
  bold: number;
  black: number; // Added for emphasis in charts/labels
}

export const FONT_WEIGHT_GUIDE: FontWeightGuide = {
  light: 300,
  regular: 400,
  medium: 500,
  semibold: 600,
  bold: 700,
  black: 900,
};

/* -------------------------------------------------------------------------- */
/*                      Professional Typography Presets                       */
/* -------------------------------------------------------------------------- */

export interface TypographyPreset {
  fonts: FontPair;
  scale: TypographyScale;
  lineHeights: LineHeightGuide;
  letterSpacing: LetterSpacingGuide;
  weights: FontWeightGuide;
  verticalRhythm?: number; // Added for consistent spacing
}

/**
 * Get a professional typography preset with consulting-inspired options
 */
export function getTypographyPreset(style: string = "modern"): TypographyPreset {
  const fontPair = PROFESSIONAL_FONT_PAIRS[style] || PROFESSIONAL_FONT_PAIRS.modern;
  const scale = generateTypographyScale(24, style === "elegant" ? 1.25 : 1.618); // Vary ratio by style
  
  return {
    fonts: fontPair,
    scale,
    lineHeights: LINE_HEIGHT_GUIDE,
    letterSpacing: LETTER_SPACING_GUIDE,
    weights: FONT_WEIGHT_GUIDE,
    verticalRhythm: scale.body * LINE_HEIGHT_GUIDE.body, // For baseline grid
  };
}

/* -------------------------------------------------------------------------- */
/*                      Text Fitting & Optimization                           */
/* -------------------------------------------------------------------------- */

/**
 * Calculate optimal font size for text to fit in a box using binary search
 * Enhanced with accurate width estimation, wrapping simulation, WCAG mins
 * Accounts for font metrics (avg char width ~0.6em for sans-serif)
 */
export function calculateOptimalFontSize(
  text: string,
  maxWidth: number, // in inches
  maxHeight: number, // in inches
  startSize: number = 36, // pt
  minSize: number = 18, // WCAG min for presentations
  lineHeight: number = 1.5,
  charWidthFactor: number = 0.6 // Avg for sans-serif
): number {
  // WCAG mins: body >=18pt, titles >=24pt
  const actualMinSize = Math.max(minSize, 18);
  const actualStartSize = Math.min(startSize, 72); // Cap to avoid overflow

  if (actualStartSize <= actualMinSize) return actualMinSize;

  let low = actualMinSize;
  let high = actualStartSize;
  let bestSize = actualMinSize;

  while (low <= high) {
    const mid = Math.floor((low + high) / 2);

    if (canFitText(text, maxWidth, maxHeight, mid, lineHeight, charWidthFactor)) {
      bestSize = mid;
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }

  return bestSize;
}

/**
 * Check if text can fit in box at given font size
 * Simulates word wrapping for accuracy
 */
function canFitText(
  text: string,
  maxWidth: number,
  maxHeight: number,
  fontSize: number,
  lineHeight: number,
  charWidthFactor: number = 0.6
): boolean {
  const words = text.split(/\s+/);
  const charWidthIn = (fontSize / 72) * charWidthFactor; // pt to inches
  const lineHeightIn = (fontSize / 72) * lineHeight;
  
  const charsPerLine = Math.floor(maxWidth / charWidthIn);
  const maxLines = Math.floor(maxHeight / lineHeightIn);
  
  let currentLineLength = 0;
  let linesUsed = 1;

  for (const word of words) {
    const wordLength = word.length + 1; // +1 for space
    if (currentLineLength + wordLength > charsPerLine) {
      linesUsed++;
      currentLineLength = wordLength;
      if (linesUsed > maxLines) return false;
    } else {
      currentLineLength += wordLength;
    }
  }

  return true;
}

/**
 * Truncate text with ellipsis if it doesn't fit
 * Enhanced to truncate at word boundaries, preserve meaning
 */
export function truncateWithEllipsis(
  text: string,
  maxWidth: number,
  maxHeight: number,
  fontSize: number,
  lineHeight: number = 1.5,
  charWidthFactor: number = 0.6
): string {
  if (canFitText(text, maxWidth, maxHeight, fontSize, lineHeight, charWidthFactor)) {
    return text;
  }

  const words = text.split(/\s+/);
  let truncated = "";
  let fits = true;

  for (const word of words) {
    const test = truncated ? `${truncated} ${word}` : word;
    if (!canFitText(test, maxWidth, maxHeight, fontSize, lineHeight, charWidthFactor)) {
      fits = false;
      break;
    }
    truncated = test;
  }

  return fits ? text : `${truncated.trim()}…`;
}

/**
 * Truncate text with ellipsis if it exceeds max length
 */
export function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength - 3).trim() + "...";
}

/**
 * Calculate vertical rhythm unit for consistent spacing
 */
export function calculateVerticalRhythm(baseSize: number, lineHeight: number): number {
  return baseSize * lineHeight;
}

export default {
  getTypographyPreset,
  generateTypographyScale,
  calculateOptimalFontSize,
  truncateText,
  truncateWithEllipsis,
  calculateVerticalRhythm,
};

================================================================================
FILE: ./functions/tsconfig.dev.json
================================================================================

{
  "include": [
    ".eslintrc.js"
  ]
}


================================================================================
FILE: ./functions/tsconfig.json
================================================================================

{
  "compilerOptions": {
    "module": "esnext",
    "target": "ES2022",
    "lib": ["ES2022", "DOM"],
    "outDir": "lib",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  },
  "compileOnSave": true,
  "exclude": ["node_modules", "lib", "**/*.test.ts"]
}


================================================================================
FILE: ./package.json
================================================================================

{
  "name": "plzfixthx",
  "version": "1.0.0",
  "description": "Professional PowerPoint slide generation with AI",
  "private": true,
  "scripts": {
    "install:all": "npm install && npm install --prefix functions && npm install --prefix web",
    "build": "npm run build --prefix functions && npm run build --prefix web",
    "build:functions": "npm run build --prefix functions",
    "build:web": "npm run build --prefix web",
    "dev": "npm run dev --prefix web",
    "dev:functions": "npm run serve --prefix functions",
    "lint": "npm run lint --prefix functions && npm run lint --prefix web",
    "test": "npm run test --prefix functions && npm run test --prefix web",
    "test:functions": "npm run test --prefix functions",
    "test:web": "npm run test --prefix web",
    "deploy": "npm run build && firebase deploy",
    "deploy:functions": "npm run deploy --prefix functions",
    "deploy:web": "npm run build:web && firebase deploy --only hosting",
    "deploy:all": "npm run build && firebase deploy"
  },
  "keywords": [
    "powerpoint",
    "slides",
    "ai",
    "generation"
  ],
  "author": "salscrudato",
  "license": "MIT"
}



================================================================================
FILE: ./shared/slideSpec/package.json
================================================================================

{
  "name": "@plzfixthx/slide-spec",
  "version": "1.0.0",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "scripts": {
    "build": "tsc",
    "test": "vitest"
  },
  "dependencies": {
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "typescript": "^5.7.3",
    "vitest": "^1.0.0"
  },
  "private": true
}

================================================================================
FILE: ./shared/slideSpec/src/index.test.ts
================================================================================

import { describe, it, expect } from "vitest";
import { SlideSpecZ, safePalette } from "./index";

describe("SlideSpec Schema", () => {
  describe("safePalette", () => {
    it("should accept valid hex colors", () => {
      const result = safePalette({
        primary: "#1E40AF",
        accent: "#F59E0B",
        neutral: ["#000000", "#111111", "#222222", "#333333", "#444444", "#555555", "#666666", "#777777", "#888888"],
      });

      expect(result.primary).toBe("#1E40AF");
      expect(result.accent).toBe("#F59E0B");
      expect(result.neutral.length).toBe(9);
    });

    it("should use defaults for invalid colors", () => {
      const result = safePalette({
        primary: "invalid",
        accent: "also-invalid",
      });

      expect(result.primary).toBe("#1E40AF");
      expect(result.accent).toBe("#F59E0B");
    });

    it("should pad neutral palette to 9 colors", () => {
      const result = safePalette({
        neutral: ["#000000", "#111111", "#222222"],
      });

      expect(result.neutral.length).toBe(9);
    });

    it("should filter invalid colors from neutral palette", () => {
      const result = safePalette({
        neutral: ["#000000", "invalid", "#111111", "also-invalid", "#222222", "#333333", "#444444", "#555555"],
      });

      expect(result.neutral.length).toBe(9);
      expect(result.neutral.every((c) => /^#[0-9A-Fa-f]{6}$/.test(c))).toBe(true);
    });

    it("should use default neutral if insufficient valid colors", () => {
      const result = safePalette({
        neutral: ["#000000", "invalid"],
      });

      expect(result.neutral.length).toBe(9);
    });
  });

  describe("SlideSpecZ validation", () => {
    const validSpec = {
      meta: {
        version: "1.0" as const,
        locale: "en-US",
        theme: "light",
        aspectRatio: "16:9" as const,
      },
      content: {
        title: {
          id: "title",
          text: "Test Slide",
        },
      },
      layout: {
        grid: {
          rows: 6,
          cols: 6,
          gutter: 16,
          margin: { t: 32, r: 32, b: 32, l: 32 },
        },
        regions: [
          {
            name: "header" as const,
            rowStart: 1,
            colStart: 1,
            rowSpan: 2,
            colSpan: 6,
          },
        ],
        anchors: [
          {
            refId: "title",
            region: "header" as const,
            order: 0,
          },
        ],
      },
      styleTokens: {
        palette: {
          primary: "#1E40AF",
          accent: "#F59E0B",
          neutral: ["#0F172A", "#1E293B", "#334155", "#475569", "#64748B", "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC"],
        },
        typography: {
          fonts: { sans: "Inter, sans-serif" },
          sizes: {
            "step_-2": 12,
            "step_-1": 14,
            step_0: 16,
            step_1: 20,
            step_2: 24,
            step_3: 44,
          },
          weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
          lineHeights: { compact: 1.2, standard: 1.5 },
        },
        spacing: { base: 4, steps: [4, 8, 12, 16, 24, 32, 48, 64] },
        radii: { sm: 4, md: 8, lg: 16 },
        shadows: { sm: "0 1px 2px rgba(0,0,0,0.05)", md: "0 4px 6px rgba(0,0,0,0.1)", lg: "0 10px 15px rgba(0,0,0,0.1)" },
        contrast: { minTextContrast: 7, minUiContrast: 4.5 },
      },
    };

    it("should validate a complete spec", () => {
      const result = SlideSpecZ.safeParse(validSpec);
      expect(result.success).toBe(true);
    });

    it("should reject duplicate content IDs", () => {
      const spec = {
        ...validSpec,
        content: {
          ...validSpec.content,
          title: { id: "same-id", text: "Title" },
          subtitle: { id: "same-id", text: "Subtitle" },
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(false);
    });

    it("should reject anchors referencing non-existent content", () => {
      const spec = {
        ...validSpec,
        layout: {
          ...validSpec.layout,
          anchors: [
            {
              refId: "non-existent",
              region: "header" as const,
              order: 0,
            },
          ],
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(false);
    });

    it("should reject regions that exceed grid bounds", () => {
      const spec = {
        ...validSpec,
        layout: {
          ...validSpec.layout,
          regions: [
            {
              name: "header" as const,
              rowStart: 1,
              colStart: 1,
              rowSpan: 10, // Exceeds 6 rows
              colSpan: 6,
            },
          ],
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(false);
    });

    it("should reject overlapping regions", () => {
      const spec = {
        ...validSpec,
        layout: {
          ...validSpec.layout,
          regions: [
            {
              name: "header" as const,
              rowStart: 1,
              colStart: 1,
              rowSpan: 3,
              colSpan: 6,
            },
            {
              name: "body" as const,
              rowStart: 2,
              colStart: 1,
              rowSpan: 3,
              colSpan: 6,
            },
          ],
          anchors: [
            {
              refId: "title",
              region: "header" as const,
              order: 0,
            },
          ],
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(false);
    });

    it("should reject dataViz with mismatched series lengths", () => {
      const spec = {
        ...validSpec,
        content: {
          ...validSpec.content,
          dataViz: {
            id: "chart",
            kind: "bar" as const,
            labels: ["Q1", "Q2", "Q3"],
            series: [
              { name: "Series 1", values: [10, 20] }, // Only 2 values
            ],
          },
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(false);
    });

    it("should reject non-ascending typography sizes", () => {
      const spec = {
        ...validSpec,
        styleTokens: {
          ...validSpec.styleTokens,
          typography: {
            ...validSpec.styleTokens.typography,
            sizes: {
              "step_-2": 12,
              "step_-1": 14,
              step_0: 16,
              step_1: 15, // Not ascending
              step_2: 24,
              step_3: 44,
            },
          },
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(false);
    });

    it("should accept optional fields", () => {
      const spec = {
        ...validSpec,
        design: {
          pattern: "hero" as const,
          whitespace: {
            strategy: "generous" as const,
            breathingRoom: 0.5,
          },
        },
        content: {
          ...validSpec.content,
          subtitle: { id: "subtitle", text: "Subtitle" },
        },
      };

      const result = SlideSpecZ.safeParse(spec);
      expect(result.success).toBe(true);
    });
  });
});



================================================================================
FILE: ./shared/slideSpec/src/index.ts
================================================================================

import { z } from "zod";

/* -------------------------------------------------------------------------- */
/*                                   Types                                    */
/* -------------------------------------------------------------------------- */

/** Aspect ratios supported by the deck */
export type AspectRatio = "16:9" | "4:3";

/** Named layout regions (grid areas) */
export type RegionName = "header" | "body" | "footer" | "aside";

/** Chart kinds supported by the universal builder/preview (others show placeholders) */
export type ChartKind =
  | "bar"
  | "line"
  | "pie"
  | "doughnut"
  | "area"
  | "scatter"
  | "combo"
  | "waterfall"
  | "funnel";

/** Value formatting hints for charts */
export type ChartValueFormat = "number" | "percent" | "currency" | "auto";

/** Optional high-level design intent to influence layout/style heuristics */
export interface DesignSpec {
  pattern: "hero" | "split" | "asymmetric" | "grid" | "minimal" | "data-focused";
  whitespace?: {
    strategy: "generous" | "balanced" | "compact";
    /** Additional breathing room hint in inches (0–0.75 typical). */
    breathingRoom?: number;
  };
}

/** Title alignment options */
export type TitleAlign = "left" | "center" | "right";

/** Chart legend position options */
export type ChartLegend = "none" | "right" | "bottom";

/** Image fit options */
export type ImageFit = "cover" | "contain" | "fill";

/** Image role/purpose */
export type ImageRole = "hero" | "logo" | "illustration" | "icon" | "background";

/** Typography scale definition */
export interface TypographyScale {
  fonts: { sans: string; serif?: string; mono?: string };
  sizes: {
    "step_-2": number;
    "step_-1": number;
    step_0: number;
    step_1: number;
    step_2: number;
    step_3: number;
  };
  weights: { regular: number; medium: number; semibold: number; bold: number };
  lineHeights: { compact: number; standard: number };
}

/** Style tokens for theming */
export interface StyleTokens {
  palette: { primary: string; accent: string; neutral: string[] };
  typography: TypographyScale;
  spacing: { base: number; steps: number[] };
  radii: { sm: number; md: number; lg: number };
  shadows: { sm: string; md: string; lg: string };
  contrast: { minTextContrast: number; minUiContrast: number };
}

/* -------------------------------------------------------------------------- */
/*                                 Zod helpers                                */
/* -------------------------------------------------------------------------- */

const HEX6 = /^#[0-9A-Fa-f]{6}$/;
const ID_RX = /^[A-Za-z0-9_-]+$/;

const idStr = z.string().regex(ID_RX, "IDs must contain only letters, numbers, underscores, or hyphens.");
const colorHex = z.string().regex(HEX6, "Color must be a #RRGGBB hex value.");

/**
 * Runtime palette sanitizer: ensures primary/accent are valid hex6,
 * and neutral is a 9-step scale (dark → light).
 */
export function safePalette(p: {
  primary?: string;
  accent?: string;
  neutral?: string[];
}): { primary: string; accent: string; neutral: string[] } {
  const DEFAULT_NEUTRAL_9 = [
    "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
    "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
  ];

  const isHex6 = (color: string | undefined | null): color is string =>
    !!color && /^#[0-9A-Fa-f]{6}$/.test(color);

  const primary = isHex6(p.primary) ? p.primary : "#1E40AF";
  const accent = isHex6(p.accent) ? p.accent : "#F59E0B";

  const neutral =
    Array.isArray(p.neutral) && p.neutral.filter(isHex6).length >= 5
      ? (() => {
          const cleaned = p.neutral.filter(isHex6).slice(0, 9);
          while (cleaned.length < 9) cleaned.push(DEFAULT_NEUTRAL_9[cleaned.length]);
          return cleaned;
        })()
      : [...DEFAULT_NEUTRAL_9];

  return { primary, accent, neutral };
}

/* -------------------------------------------------------------------------- */
/*                                Zod Schema                                  */
/* -------------------------------------------------------------------------- */

export const SlideSpecZ = z
  .object({
    meta: z.object({
      version: z.literal("1.0"),
      locale: z.string(),
      theme: z.string(),
      aspectRatio: z.enum(["16:9", "4:3"]),
    }),

    /** Design hints (optional but recommended by prompts) */
    design: z
      .object({
        pattern: z.enum(["hero", "split", "asymmetric", "grid", "minimal", "data-focused"]),
        whitespace: z
          .object({
            strategy: z.enum(["generous", "balanced", "compact"]).optional(),
            breathingRoom: z.number().min(0).max(0.75).optional(),
          })
          .optional(),
      })
      .optional(),

    content: z.object({
      title: z.object({
        id: idStr,
        text: z.string().min(1).max(60, "Title must be ≤ 60 characters."),
      }),
      subtitle: z
        .object({
          id: idStr,
          text: z.string().min(1).max(100, "Subtitle must be ≤ 100 characters."),
        })
        .optional(),

      bullets: z
        .array(
          z.object({
            id: idStr,
            items: z
              .array(
                z.object({
                  text: z.string().min(1).max(80, "Bullet text must be ≤ 80 characters."),
                  level: z.union([z.literal(1), z.literal(2), z.literal(3)]),
                })
              )
              .min(1)
              .max(5),
          })
        )
        .max(3)
        .optional(),

      callouts: z
        .array(
          z.object({
            id: idStr,
            title: z.string().optional(),
            text: z.string().min(1),
            variant: z.enum(["note", "success", "warning", "danger"]),
            elevated: z.boolean().optional(), // Optional elevated variant for callouts
          })
        )
        .max(2)
        .optional(),

      /** Speaker notes (presenter view only, not rendered on slide) */
      speakerNotes: z
        .object({
          id: idStr,
          text: z.string().min(1).max(500, "Speaker notes must be ≤ 500 characters."),
        })
        .optional(),

      /** Optional table content */
      table: z
        .object({
          id: idStr,
          title: z.string().optional(),
          headers: z.array(z.string()).min(1).max(6),
          rows: z
            .array(z.array(z.string()).min(1).max(6))
            .min(1)
            .max(10),
        })
        .optional(),

      dataViz: z
        .object({
          id: idStr,
          kind: z.enum(["bar", "line", "pie", "doughnut", "area", "scatter", "combo", "waterfall", "funnel"]),
          title: z.string().optional(),
          labels: z.array(z.string()).min(2).max(10),
          series: z
            .array(
              z.object({
                name: z.string().min(1),
                values: z.array(z.number()),
              })
            )
            .min(1)
            .max(4),
          valueFormat: z.enum(["number", "percent", "currency", "auto"]).optional(),
        })
        .optional(),

      /** For preview placeholders when real images are not yet resolved */
      imagePlaceholders: z
        .array(
          z.object({
            id: idStr,
            role: z.enum(["hero", "logo", "illustration", "icon", "background"]),
            alt: z.string(),
          })
        )
        .max(3)
        .optional(),

      /** Concrete images (optional) with sourcing hints */
      images: z
        .array(
          z.object({
            id: idStr,
            role: z.enum(["hero", "logo", "illustration", "icon", "background"]),
            source: z.object({
              type: z.enum(["url", "unsplash", "placeholder"]),
              url: z.string().url().optional(),
              query: z.string().optional(),
            }),
            alt: z.string(),
            fit: z.enum(["cover", "contain", "fill"]).optional(),
          })
        )
        .max(4)
        .optional(),
    }),

    layout: z.object({
      grid: z.object({
        rows: z.number().int().min(3).max(12),
        cols: z.number().int().min(3).max(12),
        gutter: z.number().min(0),
        margin: z.object({ t: z.number(), r: z.number(), b: z.number(), l: z.number() }),
      }),
      regions: z
        .array(
          z.object({
            name: z.enum(["header", "body", "footer", "aside"]),
            rowStart: z.number().int().positive(),
            colStart: z.number().int().positive(),
            rowSpan: z.number().int().positive(),
            colSpan: z.number().int().positive(),
          })
        )
        .min(1)
        .max(6),
      anchors: z
        .array(
          z.object({
            refId: idStr,
            region: z.enum(["header", "body", "footer", "aside"]),
            order: z.number().int().min(0),
            span: z
              .object({ rows: z.number().int().positive(), cols: z.number().int().positive() })
              .optional(),
          })
        )
        .min(1)
        .max(10),
    }),

    styleTokens: z.object({
      palette: z.object({
        primary: colorHex,
        accent: colorHex,
        neutral: z.array(colorHex).length(9),
      }),
      typography: z.object({
        fonts: z.object({ sans: z.string(), serif: z.string().optional(), mono: z.string().optional() }),
        sizes: z.object({
          "step_-2": z.number(),
          "step_-1": z.number(),
          step_0: z.number(),
          step_1: z.number(),
          step_2: z.number(),
          step_3: z.number(),
        }),
        weights: z.object({ regular: z.number(), medium: z.number(), semibold: z.number(), bold: z.number() }),
        lineHeights: z.object({ compact: z.number(), standard: z.number() }),
      }),
      spacing: z.object({ base: z.number(), steps: z.array(z.number()).min(5).max(10) }),
      radii: z.object({ sm: z.number(), md: z.number(), lg: z.number() }),
      shadows: z.object({ sm: z.string(), md: z.string(), lg: z.string() }),
      contrast: z.object({
        minTextContrast: z.number().min(7, "minTextContrast must be ≥ 7"),
        minUiContrast: z.number().min(4.5, "minUiContrast must be ≥ 4.5"),
      }),
    }),

    components: z
      .object({
        bulletList: z.object({ variant: z.enum(["compact", "spacious"]).optional() }).optional(),
        callout: z.object({ variant: z.enum(["flat", "elevated"]).optional() }).optional(),
        chart: z
          .object({
            legend: z.enum(["none", "right", "bottom"]).optional(),
            gridlines: z.boolean().optional(),
            dataLabels: z.boolean().optional(),
          })
          .optional(),
        image: z.object({ fit: z.enum(["cover", "contain", "fill"]).optional() }).optional(),
        title: z.object({ align: z.enum(["left", "center", "right"]).optional() }).optional(),
      })
      .optional(),
  })
  .superRefine((value, ctx) => {
    // Collect content IDs
    const c = value.content;
    const allContentIds: string[] = [];
    if (c.title?.id) allContentIds.push(c.title.id);
    if (c.subtitle?.id) allContentIds.push(c.subtitle.id);
    (c.bullets || []).forEach((b) => allContentIds.push(b.id));
    (c.callouts || []).forEach((co) => allContentIds.push(co.id));
    if (c.dataViz?.id) allContentIds.push(c.dataViz.id);
    (c.imagePlaceholders || []).forEach((ph) => allContentIds.push(ph.id));
    (c.images || []).forEach((img) => allContentIds.push(img.id));
    if (c.speakerNotes?.id) allContentIds.push(c.speakerNotes.id);
    if (c.table?.id) allContentIds.push(c.table.id);

    // 1) IDs across content must be unique
    const seen = new Set<string>();
    for (let i = 0; i < allContentIds.length; i++) {
      const id = allContentIds[i];
      if (seen.has(id)) {
        ctx.addIssue({
          code: "custom",
          path: ["content"],
          message: `Duplicate content id "${id}" detected.`,
        });
      }
      seen.add(id);
    }

    // 2) Anchors must reference existing content IDs and be unique by refId
    const allowed = new Set(allContentIds);
    const anchorRefSeen = new Set<string>();
    value.layout.anchors.forEach((a, i) => {
      if (!allowed.has(a.refId)) {
        ctx.addIssue({
          code: "custom",
          path: ["layout", "anchors", i, "refId"],
          message: `refId "${a.refId}" does not match any content id`,
        });
      }
      if (anchorRefSeen.has(a.refId)) {
        ctx.addIssue({
          code: "custom",
          path: ["layout", "anchors", i, "refId"],
          message: `refId "${a.refId}" is anchored more than once`,
        });
      }
      anchorRefSeen.add(a.refId);
    });

    // 3) Region bounds and non-overlap
    const { rows, cols } = value.layout.grid;
    type R = (typeof value.layout.regions)[number];
    const end = (r: R) => ({
      rowEnd: r.rowStart + r.rowSpan - 1,
      colEnd: r.colStart + r.colSpan - 1,
    });

    value.layout.regions.forEach((r, i) => {
      const { rowEnd, colEnd } = end(r);
      if (rowEnd > rows) {
        ctx.addIssue({
          code: "custom",
          path: ["layout", "regions", i, "rowSpan"],
          message: `region exceeds grid rows (rows=${rows})`,
        });
      }
      if (colEnd > cols) {
        ctx.addIssue({
          code: "custom",
          path: ["layout", "regions", i, "colSpan"],
          message: `region exceeds grid cols (cols=${cols})`,
        });
      }
    });

    for (let i = 0; i < value.layout.regions.length; i++) {
      for (let j = i + 1; j < value.layout.regions.length; j++) {
        const a = value.layout.regions[i];
        const b = value.layout.regions[j];
        const aEnd = end(a);
        const bEnd = end(b);
        const rowsOverlap = !(aEnd.rowEnd < b.rowStart || bEnd.rowEnd < a.rowStart);
        const colsOverlap = !(aEnd.colEnd < b.colStart || bEnd.colEnd < a.colStart);
        if (rowsOverlap && colsOverlap) {
          ctx.addIssue({
            code: "custom",
            path: ["layout", "regions", j],
            message: `region "${b.name}" overlaps with region "${a.name}"`,
          });
        }
      }
    }

    // 4) Anchor order must be unique within each region
    const ordersByRegion = new Map<RegionName, Set<number>>();
    value.layout.anchors.forEach((a, i) => {
      const set = ordersByRegion.get(a.region) ?? new Set<number>();
      if (set.has(a.order)) {
        ctx.addIssue({
          code: "custom",
          path: ["layout", "anchors", i, "order"],
          message: `Duplicate order ${a.order} in region "${a.region}"`,
        });
      }
      set.add(a.order);
      ordersByRegion.set(a.region, set);

      if (a.span) {
        const region = value.layout.regions.find((r) => r.name === a.region);
        if (region) {
          if (a.span.rows > region.rowSpan || a.span.cols > region.colSpan) {
            ctx.addIssue({
              code: "custom",
              path: ["layout", "anchors", i, "span"],
              message: `Anchor span exceeds available space of region "${a.region}"`,
            });
          }
        }
      }
    });

    // 5) DataViz series must match labels length
    if (c.dataViz) {
      const L = c.dataViz.labels.length;
      c.dataViz.series.forEach((s, j) => {
        if (s.values.length !== L) {
          ctx.addIssue({
            code: "custom",
            path: ["content", "dataViz", "series", j, "values"],
            message: `series length (${s.values.length}) must equal labels length (${L})`,
          });
        }
      });
    }

    // 6) Image source requirements
    (c.images || []).forEach((img, j) => {
      const t = img.source?.type;
      if (t === "url" && !img.source.url) {
        ctx.addIssue({
          code: "custom",
          path: ["content", "images", j, "source", "url"],
          message: "url is required when source.type is 'url'",
        });
      }
      if (t === "unsplash" && !img.source.query) {
        ctx.addIssue({
          code: "custom",
          path: ["content", "images", j, "source", "query"],
          message: "query is required when source.type is 'unsplash'",
        });
      }
    });

    // 7) Typography size steps should be ascending
    const sz = value.styleTokens.typography.sizes;
    const steps = [sz["step_-2"], sz["step_-1"], sz.step_0, sz.step_1, sz.step_2, sz.step_3];
    for (let i = 1; i < steps.length; i++) {
      if (!(steps[i] > steps[i - 1])) {
        ctx.addIssue({
          code: "custom",
          path: ["styleTokens", "typography", "sizes"],
          message: "Typography size steps must be strictly ascending (-2 < -1 < 0 < 1 < 2 < 3).",
        });
        break;
      }
    }
  });

/* -------------------------------------------------------------------------- */
/*                               Exported types                               */
/* -------------------------------------------------------------------------- */

/** Runtime type derived from the schema (authoritative). */
export type SlideSpec = z.infer<typeof SlideSpecZ>;
/** Convenience alias for import symmetry. */
export type SlideSpecV1 = SlideSpec;

/* -------------------------------------------------------------------------- */
/*                            Safe Defaults & Utils                           */
/* -------------------------------------------------------------------------- */

/** CSS pixels per inch (96 dpi standard for web/screen rendering) */
export const PX_PER_IN = 96;

/** Recommended 9‑step neutral ramp (dark → light) */
export const DEFAULT_NEUTRAL_9 = Object.freeze([
  "#0F172A", "#1E293B", "#334155", "#475569", "#64748B",
  "#94A3B8", "#CBD5E1", "#E2E8F0", "#F8FAFC",
]) as readonly string[];

/** Minimal, readable typography defaults */
export const DEFAULT_TYPOGRAPHY: Readonly<TypographyScale> = Object.freeze({
  fonts: { sans: "Inter, Arial, sans-serif" },
  sizes: { "step_-2": 12, "step_-1": 14, step_0: 16, step_1: 20, step_2: 24, step_3: 44 },
  weights: { regular: 400, medium: 500, semibold: 600, bold: 700 },
  lineHeights: { compact: 1.2, standard: 1.5 },
});

/** Quick hex validator; accepts #RRGGBB (no alpha) */
export function isHex6(color: string | undefined | null): color is string {
  return !!color && /^#[0-9A-Fa-f]{6}$/.test(color);
}

/**
 * Normalize a palette defensively for preview usage.
 * - Ensures primary/accent are hex6 (applies tasteful defaults if not).
 * - Pads/fixes neutral to a 9‑step scale for consistent rendering.
 */
export function normalizePalette(p: SlideSpecV1["styleTokens"]["palette"]) {
  const primary = isHex6(p.primary) ? p.primary : "#1E40AF";
  const accent = isHex6(p.accent) ? p.accent : "#F59E0B";

  const neutral =
    Array.isArray(p.neutral) &&
    p.neutral.filter(isHex6).length >= 5
      ? ((): string[] => {
          const cleaned = p.neutral.filter(isHex6).slice(0, 9);
          // pad to 9 if short (for gradients/frames that assume a light end)
          while (cleaned.length < 9) cleaned.push(DEFAULT_NEUTRAL_9[cleaned.length]);
          return cleaned;
        })()
      : [...DEFAULT_NEUTRAL_9];

  return { primary, accent, neutral };
}



================================================================================
FILE: ./shared/slideSpec/tsconfig.json
================================================================================

{
  "compilerOptions": {
    "target": "ES2022",
    "module": "esnext",
    "lib": ["ES2022"],
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}



================================================================================
FILE: ./shared/slideSpec/vitest.config.ts
================================================================================

import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    globals: true,
    environment: "node",
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: [
        "node_modules/",
        "dist/",
      ],
    },
  },
});



================================================================================
FILE: ./web/eslint.config.js
================================================================================

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])


================================================================================
FILE: ./web/index.html
================================================================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Primary Meta Tags -->
    <title>plzfixthx - Presentation Builder</title>
    <meta name="title" content="plzfixthx - Presentation Builder" />
    <meta name="description" content="Create professional PowerPoint presentations instantly. Describe your slide, preview in real-time, and download as .pptx" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://pls-fix-thx.web.app/" />
    <meta property="og:title" content="plzfixthx - Presentation Builder" />
    <meta property="og:description" content="Create professional PowerPoint presentations instantly. Describe your slide, preview in real-time, and download as .pptx" />
    <meta property="og:image" content="https://pls-fix-thx.web.app/og-image.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://pls-fix-thx.web.app/" />
    <meta property="twitter:title" content="plzfixthx - Presentation Builder" />
    <meta property="twitter:description" content="Create professional PowerPoint presentations instantly. Describe your slide, preview in real-time, and download as .pptx" />
    <meta property="twitter:image" content="https://pls-fix-thx.web.app/og-image.png" />

    <!-- Theme Color -->
    <meta name="theme-color" content="#6366F1" />

    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


================================================================================
FILE: ./web/package.json
================================================================================

{
  "name": "web",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  },
  "dependencies": {
    "@plzfixthx/slide-spec": "file:../shared/slideSpec",
    "firebase": "^12.4.0",
    "html2canvas": "^1.4.1",
    "jspdf": "^3.0.3",
    "lucide-react": "^0.546.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "recharts": "^3.3.0",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@tailwindcss/postcss": "^4.1.16",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^24.6.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^5.0.4",
    "@vitest/ui": "^4.0.1",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "jsdom": "^27.0.1",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.16",
    "terser": "^5.44.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7",
    "vitest": "^4.0.1"
  }
}


================================================================================
FILE: ./web/postcss.config.js
================================================================================

export default {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {}
  }
};



================================================================================
FILE: ./web/public/manifest.json
================================================================================

{
  "name": "plzfixthx - PowerPoint Generator",
  "short_name": "plzfixthx",
  "description": "Generate professional PowerPoint presentations with AI",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#0F172A",
  "theme_color": "#6366F1",
  "orientation": "any",
  "icons": [
    {
      "src": "/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ],
  "categories": ["productivity", "business", "utilities"],
  "screenshots": [],
  "shortcuts": [
    {
      "name": "New Presentation",
      "short_name": "New",
      "description": "Create a new presentation",
      "url": "/",
      "icons": []
    }
  ]
}



================================================================================
FILE: ./web/public/sw.js
================================================================================

// Update this version number whenever you want to force a cache refresh
const VERSION = '1.0.2';
const CACHE_NAME = `plzfixthx-v${VERSION}`;
const RUNTIME_CACHE = `plzfixthx-runtime-v${VERSION}`;

// Assets to cache on install (minimal - only truly static assets)
const PRECACHE_URLS = [
  '/manifest.json',
];

// Listen for skip waiting message
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Install event - cache essential assets and take over immediately
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(PRECACHE_URLS))
      .then(() => self.skipWaiting())
  );
});

// Activate event - clean up old caches and take control immediately
self.addEventListener('activate', (event) => {
  const currentCaches = [CACHE_NAME, RUNTIME_CACHE];
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return cacheNames.filter((cacheName) => !currentCaches.includes(cacheName));
    }).then((cachesToDelete) => {
      return Promise.all(cachesToDelete.map((cacheToDelete) => {
        return caches.delete(cacheToDelete);
      }));
    }).then(() => self.clients.claim())
  );
});

// Fetch event - NETWORK FIRST for HTML/JS/CSS, cache for other assets
self.addEventListener('fetch', (event) => {
  // Skip cross-origin requests
  if (!event.request.url.startsWith(self.location.origin)) {
    return;
  }

  // Always fetch fresh for API requests
  if (event.request.url.includes('/api/') || event.request.url.includes('firebase') || event.request.url.includes('cloudfunctions')) {
    event.respondWith(fetch(event.request));
    return;
  }

  const url = new URL(event.request.url);

  // NETWORK FIRST for HTML, JS, CSS - always get latest
  if (
    event.request.method === 'GET' &&
    (url.pathname.endsWith('.html') ||
     url.pathname.endsWith('.js') ||
     url.pathname.endsWith('.css') ||
     url.pathname === '/' ||
     url.pathname.endsWith('/'))
  ) {
    event.respondWith(
      fetch(event.request, { cache: 'no-cache' })
        .then((response) => {
          // Cache the fresh response for offline fallback
          if (response.status === 200) {
            const responseToCache = response.clone();
            caches.open(RUNTIME_CACHE).then((cache) => {
              cache.put(event.request, responseToCache);
            });
          }
          return response;
        })
        .catch(() => {
          // Fallback to cache only if network fails
          return caches.match(event.request);
        })
    );
    return;
  }

  // For other assets (images, fonts, etc.) - cache first for performance
  event.respondWith(
    caches.match(event.request).then((cachedResponse) => {
      if (cachedResponse) {
        return cachedResponse;
      }

      return fetch(event.request).then((response) => {
        if (response.status === 200) {
          const responseToCache = response.clone();
          caches.open(RUNTIME_CACHE).then((cache) => {
            cache.put(event.request, responseToCache);
          });
        }
        return response;
      });
    })
  );
});



================================================================================
FILE: ./web/src/App.tsx
================================================================================

import { useCallback, useEffect, useState } from "react";
import { ProgressIndicator } from "@/components/ProgressIndicator";
import { SlideCanvas } from "@/components/SlideCanvas";
import { SlideSkeleton } from "@/components/SlideSkeleton";
import { useSlideGeneration } from "@/hooks/useSlideGeneration";
import { useSlideGenerationStream } from "@/hooks/useSlideGenerationStream";
import { useSlideExport, type ExportFormat } from "@/hooks/useSlideExport";
import { isStreamingEnabled } from "@/lib/env";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";
import { Download, FileText, Image } from "lucide-react";

export default function App() {
  const useStreaming = isStreamingEnabled();
  const { loading: loadingRegular, spec: specRegular, error: errorRegular, generate: generateRegular } = useSlideGeneration();
  const { loading: loadingStream, spec: specStream, error: errorStream, generateStream } = useSlideGenerationStream();

  const loading = useStreaming ? loadingStream : loadingRegular;
  const spec = useStreaming ? specStream : specRegular;
  const error = useStreaming ? errorStream : errorRegular;
  const generate = useStreaming ? generateStream : generateRegular;

  const { exportSlide } = useSlideExport();
  const [specs, setSpecs] = useState<SlideSpecV1[]>([]);
  const [prompt, setPrompt] = useState("");
  const [errorMsg, setErrorMsg] = useState<string | null>(null);
  const [showSuggestions, setShowSuggestions] = useState(true);

  useEffect(() => {
    if (spec) {
      setSpecs((prev) => [...prev, spec]);
    }
  }, [spec]);

  useEffect(() => {
    if (error) {
      setErrorMsg(error);
      setTimeout(() => setErrorMsg(null), 8000); // Extended timeout
    }
  }, [error]);

  const handleGenerate = useCallback(async () => {
    if (!prompt.trim()) return;
    setErrorMsg(null);
    setShowSuggestions(false);
    await generate(prompt);
  }, [prompt, generate]);

  // Keyboard shortcut: Ctrl+Enter or Cmd+Enter
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === "Enter" && prompt.trim() && !loading) {
        e.preventDefault();
        handleGenerate();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [prompt, loading, handleGenerate]);

  const handleDownload = useCallback(
    async (format: ExportFormat = "pptx") => {
      if (specs.length === 0) return;
      const success = await exportSlide(specs[specs.length - 1], format); // Export latest or all?
      if (!success) {
        setErrorMsg(`Failed to download ${format.toUpperCase()}. Please try again.`);
      }
    },
    [specs, exportSlide]
  );

  const handleRetry = useCallback(() => {
    setErrorMsg(null);
    handleGenerate();
  }, [handleGenerate]);

  const suggestions = [
    "Q3 revenue growth strategy with bar chart",
    "Team organization chart for startup",
    "SWOT analysis for new product launch",
    "Roadmap for AI implementation in healthcare",
  ];

  return (
    <div className="min-h-screen flex flex-col" style={{ background: 'var(--bg-gradient-main)' }}>
      <a
        href="#main-content"
        className="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-[var(--color-primary)] focus:text-white focus:rounded-[var(--radius-md)]"
      >
        Skip to main content
      </a>

      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 sm:py-12 space-y-8 sm:space-y-12 w-full">
        {/* Header */}
        <header className="text-center space-y-4 py-8 sm:py-12 transition-all duration-500">
          <div className="inline-block">
            <h1 className="text-5xl sm:text-6xl lg:text-7xl font-bold bg-gradient-to-r from-[var(--color-primary)] via-[var(--color-primary-light)] to-[var(--color-accent)] bg-clip-text text-transparent mb-3" style={{ fontFamily: 'var(--font-display)', letterSpacing: '-0.02em' }}>
              plsfixthx
            </h1>
            <div className="h-1 w-24 mx-auto bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-accent)] rounded-full"></div>
          </div>
          <p className="text-lg sm:text-xl text-[var(--neutral-3)] max-w-2xl mx-auto font-medium leading-relaxed">
            Create beautiful, professional slides with AI
          </p>
          <p className="text-sm text-[var(--neutral-4)] max-w-2xl mx-auto leading-relaxed">
            Consulting-firm quality • Context-aware design • Instant export
          </p>
        </header>

        {/* Input Section */}
        <main id="main-content" className="max-w-4xl mx-auto w-full px-4 sm:px-6">
          <div className="glass rounded-[var(--radius-2xl)] p-6 sm:p-8 space-y-4 border border-white/10 backdrop-blur-xl shadow-lg transition-all duration-500">
            <div className="space-y-2 mb-4">
              <label htmlFor="slide-prompt" className="block text-sm font-medium text-[var(--neutral-2)]">
                Describe your slide
              </label>
              <p className="text-xs text-[var(--neutral-4)]">
                Be specific about content, style, or data you want to include
              </p>
            </div>
            <div className="flex flex-col sm:flex-row gap-3">
              <input
                id="slide-prompt"
                type="text"
                value={prompt}
                onChange={(e) => setPrompt(e.target.value)}
                onKeyDown={(e) => e.key === "Enter" && handleGenerate()}
                placeholder="e.g., 'Q3 revenue growth strategy with 3 key initiatives and bar chart'"
                disabled={loading}
                aria-label="Slide prompt input"
                aria-describedby="prompt-help"
                className="flex-1 px-4 py-3 rounded-[var(--radius-md)] bg-[var(--neutral-8)] text-[var(--neutral-1)] placeholder-[var(--neutral-4)] border border-[var(--neutral-6)] focus:outline-none focus:border-[var(--color-primary)] focus:ring-2 focus:ring-[var(--color-primary)]/20 disabled:opacity-50 transition-all duration-200 min-h-[44px]"
              />
              <button
                onClick={handleGenerate}
                disabled={loading || !prompt.trim()}
                aria-label={loading ? "Generating slide" : "Generate slide"}
                aria-busy={loading}
                className="px-6 py-3 bg-[var(--color-primary)] text-white rounded-[var(--radius-md)] font-semibold hover:shadow-lg hover:opacity-90 disabled:opacity-50 transition-all duration-200 flex items-center justify-center gap-2 whitespace-nowrap transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-[var(--color-primary)] focus:ring-offset-2 min-h-[44px] sm:w-auto w-full"
              >
                {loading ? (
                  <>
                    <span className="inline-block animate-spin" aria-hidden="true">⚡</span>
                    <span className="hidden sm:inline">Generating...</span>
                  </>
                ) : (
                  "Generate"
                )}
              </button>
            </div>

            {errorMsg && (
              <div
                role="alert"
                aria-live="polite"
                className="p-4 bg-red-50/90 border-l-4 border-red-500 rounded-[var(--radius-md)] text-red-700 text-sm flex gap-3 items-start shadow-md transition-all duration-300"
              >
                <span className="text-red-500 flex-shrink-0 mt-0.5 font-bold text-lg" aria-hidden="true">✕</span>
                <div className="flex-1">
                  <p className="font-semibold mb-1">Error generating slide</p>
                  <p className="text-red-600 text-sm">{errorMsg}</p>
                  <p className="text-red-500 text-xs mt-2 opacity-75">Try rephrasing or check connection</p>
                </div>
                <button
                  onClick={handleRetry}
                  className="text-red-600 hover:text-red-800 text-sm font-medium"
                >
                  Retry
                </button>
              </div>
            )}

            {loading && <ProgressIndicator isLoading={true} />}

            {showSuggestions && (
              <div className="mt-6">
                <h3 className="text-sm font-medium text-[var(--neutral-2)] mb-2">Try these prompts:</h3>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                  {suggestions.map((sug, i) => (
                    <button
                      key={i}
                      onClick={() => setPrompt(sug)}
                      className="text-left p-3 bg-[var(--neutral-7)] rounded-[var(--radius-md)] text-[var(--neutral-2)] text-sm hover:bg-[var(--neutral-6)] transition-colors"
                    >
                      {sug}
                    </button>
                  ))}
                </div>
              </div>
            )}
          </div>
        </main>

        {/* Preview and Download */}
        {(specs.length > 0 || loading) && (
          <div className={`mt-12 space-y-8 transition-all duration-500 ${loading ? "opacity-75 pointer-events-none" : ""}`}>
            <div className="space-y-6">
              <div className="text-center space-y-2">
                <h2 className="text-2xl font-semibold text-[var(--neutral-1)]">
                  {loading ? "Generating your slide..." : "Your Slide Preview"}
                </h2>
                <p className="text-[var(--neutral-3)] text-sm">
                  {loading ? "Creating professional slide with AI..." : "Ready to download in multiple formats"}
                </p>
              </div>
              {loading ? <SlideSkeleton /> : specs[specs.length - 1] && <SlideCanvas spec={specs[specs.length - 1]} />}
              <div className="flex justify-center gap-2 sm:gap-3 flex-wrap px-4 sm:px-0">
                <button
                  onClick={() => handleDownload("pptx")}
                  disabled={loading || specs.length === 0}
                  aria-label="Download as PowerPoint"
                  className="flex items-center justify-center gap-2 px-4 sm:px-6 py-3 bg-[var(--color-primary)] text-white rounded-[var(--radius-md)] font-semibold hover:shadow-2xl hover:opacity-90 disabled:opacity-50 transition-all duration-200 transform hover:scale-105 active:scale-95 text-xs sm:text-sm focus:outline-none focus:ring-2 focus:ring-[var(--color-primary)] focus:ring-offset-2 min-h-[44px] flex-1 sm:flex-none"
                  title="Download as PowerPoint (.pptx)"
                >
                  <Download size={16} aria-hidden="true" />
                  <span className="hidden sm:inline">PowerPoint</span>
                  <span className="sm:hidden">PPTX</span>
                </button>
                <button
                  onClick={() => handleDownload("pdf")}
                  disabled={loading || specs.length === 0}
                  aria-label="Download as PDF"
                  className="flex items-center justify-center gap-2 px-4 sm:px-6 py-3 bg-[var(--color-accent)] text-white rounded-[var(--radius-md)] font-semibold hover:shadow-2xl hover:opacity-90 disabled:opacity-50 transition-all duration-200 transform hover:scale-105 active:scale-95 text-xs sm:text-sm focus:outline-none focus:ring-2 focus:ring-[var(--color-accent)] focus:ring-offset-2 min-h-[44px] flex-1 sm:flex-none"
                  title="Download as PDF"
                >
                  <FileText size={16} aria-hidden="true" />
                  PDF
                </button>
                <button
                  onClick={() => handleDownload("png")}
                  disabled={loading || specs.length === 0}
                  aria-label="Download as PNG"
                  className="flex items-center justify-center gap-2 px-4 sm:px-6 py-3 bg-[var(--neutral-6)] text-[var(--neutral-1)] rounded-[var(--radius-md)] font-semibold hover:bg-[var(--neutral-5)] disabled:opacity-50 transition-all duration-200 transform hover:scale-105 active:scale-95 text-xs sm:text-sm border border-[var(--neutral-5)] focus:outline-none focus:ring-2 focus:ring-[var(--neutral-6)] focus:ring-offset-2 min-h-[44px] flex-1 sm:flex-none"
                  title="Download as PNG"
                >
                  <Image size={16} aria-hidden="true" />
                  PNG
                </button>
                <button
                  onClick={() => {
                    setPrompt("");
                    setSpecs([]);
                    setShowSuggestions(true);
                  }}
                  disabled={loading}
                  aria-label="Create another slide"
                  className="px-4 sm:px-6 py-3 bg-[var(--neutral-7)] text-[var(--neutral-1)] rounded-[var(--radius-md)] font-semibold hover:bg-[var(--neutral-6)] disabled:opacity-50 transition-all duration-200 border border-[var(--neutral-6)] hover:border-[var(--neutral-5)] text-xs sm:text-sm focus:outline-none focus:ring-2 focus:ring-[var(--neutral-7)] focus:ring-offset-2 min-h-[44px] flex-1 sm:flex-none"
                  title="Create another slide"
                >
                  <span className="hidden sm:inline">Create Another</span>
                  <span className="sm:hidden">New</span>
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

================================================================================
FILE: ./web/src/components/ErrorBoundary.tsx
================================================================================

import { Component } from "react";
import type { ReactNode } from "react";

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("ErrorBoundary caught an error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="min-h-screen flex items-center justify-center bg-[var(--bg-secondary)] p-4">
          <div className="max-w-md w-full bg-[var(--bg-primary)] rounded-[var(--radius-lg)] shadow-[var(--shadow-lg)] p-6 space-y-4">
            <div className="flex items-center gap-3">
              <svg className="w-8 h-8 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
              </svg>
              <h1 className="text-[var(--step-1)] font-bold text-[var(--neutral-0)]">
                Something went wrong
              </h1>
            </div>
            
            <p className="text-[var(--step--1)] text-[var(--neutral-3)]">
              We encountered an unexpected error. Please try refreshing the page.
            </p>

            {this.state.error && (
              <details className="text-[var(--step--2)] text-[var(--neutral-4)]">
                <summary className="cursor-pointer hover:text-[var(--neutral-2)]">
                  Error details
                </summary>
                <pre className="mt-2 p-2 bg-[var(--neutral-6)] rounded-[var(--radius-sm)] overflow-auto">
                  {this.state.error.toString()}
                </pre>
              </details>
            )}

            <button
              onClick={() => window.location.reload()}
              className="w-full px-4 py-2 bg-[var(--color-primary)] text-white rounded-[var(--radius-md)] font-medium hover:opacity-90 transition-opacity"
            >
              Refresh Page
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}



================================================================================
FILE: ./web/src/components/ProgressIndicator.tsx
================================================================================

import { useEffect, useState } from "react";

interface ProgressIndicatorProps {
  isLoading: boolean;
  estimatedDuration?: number; // in milliseconds
}

export function ProgressIndicator({ isLoading, estimatedDuration = 5000 }: ProgressIndicatorProps) {
  const [progress, setProgress] = useState(0);
  const [stage, setStage] = useState("Initializing...");

  useEffect(() => {
    if (!isLoading) {
      setProgress(0);
      setStage("Initializing...");
      return;
    }

    const stages = [
      { progress: 20, label: "Analyzing prompt...", duration: 500 },
      { progress: 40, label: "Generating content...", duration: 2000 },
      { progress: 70, label: "Designing layout...", duration: 1500 },
      { progress: 90, label: "Finalizing slide...", duration: 1000 },
    ];

    let currentStageIndex = 0;
    let currentProgress = 0;

    const updateProgress = () => {
      if (currentStageIndex >= stages.length) return;

      const stage = stages[currentStageIndex];
      setStage(stage.label);

      const increment = (stage.progress - currentProgress) / (stage.duration / 50);
      
      const interval = setInterval(() => {
        currentProgress += increment;
        if (currentProgress >= stage.progress) {
          currentProgress = stage.progress;
          clearInterval(interval);
          currentStageIndex++;
          if (currentStageIndex < stages.length) {
            setTimeout(updateProgress, 100);
          }
        }
        setProgress(Math.min(currentProgress, 95)); // Never reach 100% until actually done
      }, 50);

      return () => clearInterval(interval);
    };

    updateProgress();
  }, [isLoading, estimatedDuration]);

  if (!isLoading) return null;

  return (
    <div className="space-y-3 animate-fade-in">
      <div className="flex items-center justify-between text-sm">
        <span className="text-[var(--neutral-2)] font-medium">{stage}</span>
        <span className="text-[var(--neutral-3)] font-mono">{Math.round(progress)}%</span>
      </div>
      
      <div className="relative h-2 bg-[var(--neutral-8)] rounded-full overflow-hidden">
        <div
          className="absolute top-0 left-0 h-full bg-gradient-to-r from-[var(--color-primary)] to-[var(--color-primary-light)] transition-all duration-300 ease-out"
          style={{ width: `${progress}%` }}
        >
          <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent animate-shimmer" />
        </div>
      </div>
      
      <div className="flex items-center gap-2 text-xs text-[var(--neutral-4)]">
        <svg className="w-4 h-4 animate-spin" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
        </svg>
        <span>This usually takes 3-5 seconds</span>
      </div>
    </div>
  );
}



================================================================================
FILE: ./web/src/components/SlideCanvas.tsx
================================================================================

import { memo, useEffect, useMemo, useState } from "react";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";
import { normalizePalette, DEFAULT_TYPOGRAPHY } from "@plzfixthx/slide-spec";
import { hexWithAlpha } from "@/lib/shared";
import {
  ResponsiveContainer,
  BarChart,
  Bar,
  LineChart,
  Line,
  AreaChart,
  Area,
  PieChart,
  Pie,
  Cell,
  ScatterChart,
  Scatter,
  CartesianGrid,
  XAxis,
  YAxis,
  Tooltip,
  Legend,
} from "recharts";

/* -------------------------------------------------------------------------- */
/*                                   Tokens                                   */
/* -------------------------------------------------------------------------- */

type Tokens = {
  palette: { primary: string; accent: string; neutral: string[] };
  typography: SlideSpecV1["styleTokens"]["typography"];
  pattern: NonNullable<SlideSpecV1["design"]>["pattern"] | "split";
};

function normalizeTypography(t?: SlideSpecV1["styleTokens"]["typography"]): Tokens["typography"] {
  return t ?? DEFAULT_TYPOGRAPHY;
}

/* -------------------------------------------------------------------------- */
/*                              Main Slide Canvas                              */
/* -------------------------------------------------------------------------- */

export const SlideCanvas = memo(function SlideCanvas({ spec }: { spec: SlideSpecV1 }) {
  const [isVisible, setIsVisible] = useState(false);

  // soft enter animation on spec change
  useEffect(() => {
    setIsVisible(false);
    const t = setTimeout(() => setIsVisible(true), 40);
    return () => clearTimeout(t);
  }, [spec]);

  const tokens: Tokens = useMemo(() => {
    const palette = normalizePalette(spec.styleTokens?.palette);
    const typography = normalizeTypography(spec.styleTokens?.typography);
    const pattern = spec.design?.pattern ?? "split";
    return { palette, typography, pattern };
  }, [spec]);

  const aspect = spec.meta.aspectRatio === "4:3" ? "4 / 3" : "16 / 9";
  const slideStyle: React.CSSProperties = useMemo(
    () => ({
      background: tokens.palette.neutral[8] || "#F8FAFC",
      color: tokens.palette.neutral[0],
    }),
    [tokens]
  );

  return (
    <div className="w-full">
      <div
        className={`relative w-full overflow-hidden rounded-2xl transition-all duration-500 shadow-2xl border border-white/10 ${
          isVisible ? "opacity-100 scale-100" : "opacity-0 scale-95"
        }`}
        style={{ aspectRatio: aspect, ...slideStyle }}
        aria-label="Slide preview"
      >
        {/* Left accent bar */}
        <div
          aria-hidden
          style={{
            position: "absolute",
            insetInlineStart: 0,
            top: 0,
            width: "0.12in",
            height: "100%",
            background: tokens.palette.primary,
          }}
        />
        {/* Top-right glaze */}
        <div
          aria-hidden
          style={{
            position: "absolute",
            top: "0.2in",
            right: "0.2in",
            width: "3.0in",
            height: "1.0in",
            background: hexWithAlpha(tokens.palette.accent, 0.1),
            borderRadius: 12,
          }}
        />
        {/* Bottom accent block */}
        <div
          aria-hidden
          style={{
            position: "absolute",
            bottom: "0.2in",
            left: "0.3in",
            width: "2.5in",
            height: "0.6in",
            background: hexWithAlpha(tokens.palette.primary, 0.06),
            borderRadius: 8,
          }}
        />
        {/* Slim vertical accent line */}
        <div
          aria-hidden
          style={{
            position: "absolute",
            top: "0.08in",
            left: "0.22in",
            width: "0.04in",
            height: "calc(100% - 0.16in)",
            background: hexWithAlpha(tokens.palette.accent, 0.12),
            borderRadius: 2,
          }}
        />

        <div
          style={{
            width: "100%",
            height: "100%",
            padding: 0,
            boxSizing: "border-box",
            position: "relative",
          }}
        >
          {renderRegions(spec, tokens)}
        </div>
      </div>
    </div>
  );
});

/* -------------------------------------------------------------------------- */
/*                                   Layout                                   */
/* -------------------------------------------------------------------------- */

function renderRegions(spec: SlideSpecV1, tokens: Tokens) {
  const { rows, cols, gutter, margin } = spec.layout.grid;

  const gridStyle: React.CSSProperties = {
    display: "grid",
    gridTemplateRows: `repeat(${rows}, minmax(0, 1fr))`,
    gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))`,
    gap: `${gutter}px`,
    padding: `${margin.t}px ${margin.r}px ${margin.b}px ${margin.l}px`,
    height: "100%",
    width: "100%",
    boxSizing: "border-box",
    position: "relative",
  };

  const regionStyle = (r: SlideSpecV1["layout"]["regions"][number]): React.CSSProperties => ({
    gridRow: `${r.rowStart} / span ${r.rowSpan}`,
    gridColumn: `${r.colStart} / span ${r.colSpan}`,
    display: "flex",
    flexDirection: "column",
    gap: "12px",
    minHeight: 0,
    minWidth: 0,
    overflow: "hidden",
    justifyContent: "flex-start",
    alignItems: "stretch",
  });

  return (
    <div style={gridStyle}>
      {spec.layout.regions.map((r, idx) => {
        const anchors = spec.layout.anchors
          .filter((a) => a.region === r.name)
          .sort((a, b) => a.order - b.order);

        return (
          <div key={`${r.name}-${idx}`} style={regionStyle(r)}>
            {anchors.map((a) => (
              <ElementByRef key={a.refId} spec={spec} refId={a.refId} tokens={tokens} />
            ))}
          </div>
        );
      })}
    </div>
  );
}

/* -------------------------------------------------------------------------- */
/*                                  Elements                                  */
/* -------------------------------------------------------------------------- */

const ElementByRef = memo(function ElementByRef({
  spec,
  refId,
  tokens,
}: {
  spec: SlideSpecV1;
  refId: string;
  tokens: Tokens;
}) {
  const c = spec.content;

  if (c.title?.id === refId) {
    return <Title text={c.title.text} tokens={tokens} align={spec.components?.title?.align} />;
  }
  if (c.subtitle?.id === refId) {
    return <Subtitle text={c.subtitle.text} tokens={tokens} />;
  }

  const bl = c.bullets?.find((x) => x.id === refId);
  if (bl) {
    return <Bullets items={bl.items} tokens={tokens} variant={spec.components?.bulletList?.variant} />;
  }

  const co = c.callouts?.find((x) => x.id === refId);
  if (co) {
    return <Callout item={co} tokens={tokens} variantCard={spec.components?.callout?.variant} />;
  }

  if (c.dataViz?.id === refId) {
    return <Chart spec={spec} tokens={tokens} />;
  }

  const img = c.images?.find((x) => x.id === refId);
  if (img) {
    return <ImageBlock item={img} tokens={tokens} />;
  }

  const ph = c.imagePlaceholders?.find((x) => x.id === refId);
  if (ph) {
    return <ImagePlaceholder alt={ph.alt} tokens={tokens} />;
  }

  return null;
});

/* ------------------------------- Typography -------------------------------- */

const Title = memo(function Title({
  text,
  tokens,
  align,
}: {
  text: string;
  tokens: Tokens;
  align?: "left" | "center" | "right";
}) {
  const s = tokens.typography.sizes;
  const w = tokens.typography.weights;
  const lh = tokens.typography.lineHeights;
  return (
    <h2
      style={{
        fontFamily: tokens.typography.fonts.sans,
        fontSize: `${s.step_3 ?? 44}px`,
        fontWeight: w.bold ?? 700,
        lineHeight: lh.compact ?? 1.2,
        color: tokens.palette.primary,
        margin: 0,
        marginBottom: "12px",
        textAlign: align ?? "left",
        position: "relative",
        letterSpacing: "-0.02em",
      }}
    >
      {text}
    </h2>
  );
});

const Subtitle = memo(function Subtitle({ text, tokens }: { text: string; tokens: Tokens }) {
  const s = tokens.typography.sizes;
  const w = tokens.typography.weights;
  const lh = tokens.typography.lineHeights;
  return (
    <p
      style={{
        fontFamily: tokens.typography.fonts.sans,
        fontSize: `${s.step_1 ?? 20}px`,
        fontWeight: w.medium ?? 500,
        lineHeight: lh.standard ?? 1.5,
        color: tokens.palette.neutral[3] ?? "#64748B",
        margin: 0,
        marginTop: "4px",
        letterSpacing: "-0.01em",
      }}
    >
      {text}
    </p>
  );
});

const Bullets = memo(function Bullets({
  items,
  tokens,
  variant,
}: {
  items: { text: string; level: 1 | 2 | 3 }[];
  tokens: Tokens;
  variant?: "compact" | "spacious";
}) {
  const s = tokens.typography.sizes;
  const w = tokens.typography.weights;
  const lh = tokens.typography.lineHeights;
  const gap = variant === "compact" ? 10 : 14;

  return (
    <ul
      role="list"
      style={{
        fontFamily: tokens.typography.fonts.sans,
        fontSize: `${s.step_0 ?? 16}px`,
        fontWeight: w.regular ?? 400,
        lineHeight: lh.standard ?? 1.5,
        color: tokens.palette.neutral[0] ?? "#0F172A",
        listStyle: "none",
        margin: 0,
        padding: 0,
      }}
    >
      {items.map((it, i) => {
        const isLevel1 = it.level === 1;
        const fontSize = isLevel1 ? 16 : it.level === 2 ? 14 : 12;
        const fontWeight = isLevel1 ? (w.semibold ?? 600) : (w.regular ?? 400);
        const color = isLevel1 ? tokens.palette.primary : tokens.palette.neutral[2] ?? "#334155";

        return (
          <li
            key={i}
            role="listitem"
            style={{
              marginLeft: `${(it.level - 1) * 24}px`,
              marginBottom: `${gap}px`,
              display: "flex",
              alignItems: "flex-start",
              gap: 12,
              fontSize: `${fontSize}px`,
              fontWeight,
              color,
            }}
          >
            <span
              aria-hidden
              style={{
                display: "inline-block",
                width: isLevel1 ? 7 : 5,
                height: isLevel1 ? 7 : 5,
                borderRadius: "50%",
                backgroundColor: isLevel1 ? tokens.palette.primary : tokens.palette.neutral[4],
                marginTop: isLevel1 ? 6 : 7,
                flexShrink: 0,
              }}
            />
            <span>{it.text}</span>
          </li>
        );
      })}
    </ul>
  );
});

const Callout = memo(function Callout({
  item,
  tokens,
  variantCard,
}: {
  item: NonNullable<SlideSpecV1["content"]["callouts"]>[number];
  tokens: Tokens;
  variantCard?: "flat" | "elevated";
}) {
  const variants = {
    warning: { bg: "#FEF3C7", border: "#F59E0B", text: "#78350F" },
    danger: { bg: "#FEE2E2", border: "#EF4444", text: "#7F1D1D" },
    success: { bg: "#D1FAE5", border: "#10B981", text: "#065F46" },
    note: { bg: "#F3F4F6", border: tokens.palette.accent, text: "#1F2937" },
  } as const;

  const v = variants[item.variant] || variants.note;

  return (
    <div
      style={{
        padding: "16px 18px",
        borderRadius: 12,
        border: `2px solid ${v.border}`,
        backgroundColor: v.bg,
        color: v.text,
        boxShadow: variantCard === "elevated" ? "0 8px 24px rgba(0,0,0,0.12)" : "0 2px 8px rgba(0,0,0,0.06)",
        fontSize: 14,
        lineHeight: 1.6,
        borderLeft: `4px solid ${v.border}`,
        position: "relative",
      }}
    >
      {item.title && (
        <b style={{ display: "block", marginBottom: "4px", fontSize: "15px" }}>{item.title}</b>
      )}
      {item.text}
    </div>
  );
});

/* --------------------------------- Charts ---------------------------------- */

const Chart = memo(function Chart({ spec, tokens }: { spec: SlideSpecV1; tokens: Tokens }) {
  const viz = spec.content.dataViz!;
  const series = viz.series ?? [];
  const labels = viz.labels ?? [];

  // Normalize to shortest series length
  const minLen = Math.max(0, Math.min(labels.length, ...series.map((s) => s.values.length)));
  const data = labels.slice(0, minLen).map((label, idx) => {
    const row: Record<string, number | string> = { label };
    for (const s of series) row[s.name] = s.values[idx] ?? 0;
    return row;
  });

  const colors = paletteSeries(tokens);
  const showLegend = legendWanted(spec);
  const legendProps = getLegendProps(spec.components?.chart?.legend);
  const showGrid = spec.components?.chart?.gridlines ?? false;
  const fmt = getNumberFormatter(viz.valueFormat);

  const frameStyle: React.CSSProperties = {
    width: "100%",
    height: "100%",
    minHeight: 200,
    backgroundColor: tokens.palette.neutral[6] ?? "#E2E8F0",
    borderRadius: 8,
    padding: 8,
    boxSizing: "border-box",
  };

  if (!data.length || !series.length) {
    return <Placeholder text="[Chart] Missing series/labels" tokens={tokens} />;
  }

  switch (viz.kind) {
    case "bar":
      return (
        <div style={frameStyle} aria-label="Bar chart">
          <ResponsiveContainer>
            <BarChart data={data}>
              <CartesianGrid stroke={hexWithAlpha(tokens.palette.neutral[5] ?? "#94A3B8", showGrid ? 0.4 : 0)} vertical={false} />
              <XAxis dataKey="label" tick={{ fill: tokens.palette.neutral[3] }} />
              <YAxis tick={{ fill: tokens.palette.neutral[3] }} tickFormatter={fmt} />
              <Tooltip formatter={(v: any) => fmt(Number(v))} />
              {series.map((s, i) => (
                <Bar
                  key={s.name}
                  dataKey={s.name}
                  fill={colors[i % colors.length]}
                  radius={4}
                  label={viz.valueFormat ? { formatter: (v: any) => fmt(Number(v)), position: "top" as const } : undefined}
                />
              ))}
              {showLegend && <Legend {...legendProps} />}
            </BarChart>
          </ResponsiveContainer>
        </div>
      );

    case "line":
      return (
        <div style={frameStyle} aria-label="Line chart">
          <ResponsiveContainer>
            <LineChart data={data}>
              <CartesianGrid stroke={hexWithAlpha(tokens.palette.neutral[5] ?? "#94A3B8", showGrid ? 0.4 : 0)} />
              <XAxis dataKey="label" tick={{ fill: tokens.palette.neutral[3] }} />
              <YAxis tick={{ fill: tokens.palette.neutral[3] }} tickFormatter={fmt} />
              <Tooltip formatter={(v: any) => fmt(Number(v))} />
              {series.map((s, i) => (
                <Line
                  key={s.name}
                  type="monotone"
                  dataKey={s.name}
                  stroke={colors[i % colors.length]}
                  strokeWidth={2}
                  dot={viz.valueFormat ? { fill: colors[i % colors.length], r: 4 } : false}
                  label={viz.valueFormat ? { formatter: (v: any) => fmt(Number(v)), position: "top" as const } : undefined}
                />
              ))}
              {showLegend && <Legend {...legendProps} />}
            </LineChart>
          </ResponsiveContainer>
        </div>
      );

    case "area":
      return (
        <div style={frameStyle} aria-label="Area chart">
          <ResponsiveContainer>
            <AreaChart data={data}>
              <CartesianGrid stroke={hexWithAlpha(tokens.palette.neutral[5] ?? "#94A3B8", showGrid ? 0.4 : 0)} />
              <XAxis dataKey="label" tick={{ fill: tokens.palette.neutral[3] }} />
              <YAxis tick={{ fill: tokens.palette.neutral[3] }} tickFormatter={fmt} />
              <Tooltip formatter={(v: any) => fmt(Number(v))} />
              {series.map((s, i) => (
                <Area
                  key={s.name}
                  type="monotone"
                  dataKey={s.name}
                  stroke={colors[i % colors.length]}
                  fill={hexWithAlpha(colors[i % colors.length], 0.35)}
                  strokeWidth={2}
                />
              ))}
              {showLegend && <Legend {...legendProps} />}
            </AreaChart>
          </ResponsiveContainer>
        </div>
      );

    case "pie":
    case "doughnut": {
      const single = series[0] ?? { name: "Series", values: [] as number[] };
      const pieData = labels.slice(0, minLen).map((label, i) => ({
        name: label,
        value: single.values[i] ?? 0,
      }));

      return (
        <div style={frameStyle} aria-label={viz.kind === "doughnut" ? "Doughnut chart" : "Pie chart"}>
          <ResponsiveContainer>
            <PieChart>
              <Tooltip formatter={(v: any) => fmt(Number(v))} />
              {showLegend && <Legend {...legendProps} />}
              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                innerRadius={viz.kind === "doughnut" ? "55%" : 0}
                outerRadius="80%"
                strokeWidth={1}
              >
                {pieData.map((_, i) => (
                  <Cell key={i} fill={colors[i % colors.length]} />
                ))}
              </Pie>
            </PieChart>
          </ResponsiveContainer>
        </div>
      );
    }

    case "scatter": {
      const x = series[0]?.values ?? [];
      const y = series[1]?.values ?? [];
      const scatterData = labels.slice(0, Math.min(x.length, y.length)).map((_, i) => ({
        x: x[i] ?? i,
        y: y[i] ?? 0,
      }));
      return (
        <div style={frameStyle} aria-label="Scatter plot">
          <ResponsiveContainer>
            <ScatterChart>
              <CartesianGrid stroke={hexWithAlpha(tokens.palette.neutral[5] ?? "#94A3B8", showGrid ? 0.4 : 0)} />
              <XAxis dataKey="x" tick={{ fill: tokens.palette.neutral[3] }} tickFormatter={fmt} />
              <YAxis dataKey="y" tick={{ fill: tokens.palette.neutral[3] }} tickFormatter={fmt} />
              <Tooltip formatter={(v: any) => fmt(Number(v))} />
              <Scatter data={scatterData} fill={tokens.palette.primary} />
              {showLegend && <Legend {...legendProps} />}
            </ScatterChart>
          </ResponsiveContainer>
        </div>
      );
    }

    default:
      return <Placeholder text={`[${viz.kind}] chart not supported in preview yet`} tokens={tokens} />;
  }
});

/** Respect back‑end legend semantics: "none" | "right" | "bottom" */
function legendWanted(spec: SlideSpecV1) {
  const pos = spec.components?.chart?.legend;
  return pos !== "none";
}

function getLegendProps(pos?: "none" | "right" | "bottom") {
  if (pos === "right") {
    return { layout: "vertical" as const, align: "right" as const, verticalAlign: "middle" as const };
  }
  // Default to bottom when unspecified (matches schema semantics)
  return { layout: "horizontal" as const, align: "center" as const, verticalAlign: "bottom" as const };
}

/* --------------------------------- Images ---------------------------------- */

const ImageBlock = memo(function ImageBlock({
  item,
  tokens,
}: {
  item: NonNullable<SlideSpecV1["content"]["images"]>[number];
  tokens: Tokens;
}) {
  const [broken, setBroken] = useState(false);
  const fit = item.fit ?? "cover";
  const url = item.source.type === "url" && item.source.url ? item.source.url : undefined;

  if (!url || broken) {
    return <ImagePlaceholder alt={item.alt} tokens={tokens} />;
  }

  return (
    <img
      src={url}
      alt={item.alt}
      decoding="async"
      loading="lazy"
      onError={() => setBroken(true)}
      style={{
        width: "100%",
        height: "100%",
        objectFit: fit as React.CSSProperties["objectFit"],
        borderRadius: 8,
        display: "block",
      }}
    />
  );
});

const ImagePlaceholder = memo(function ImagePlaceholder({ alt, tokens }: { alt: string; tokens: Tokens }) {
  return (
    <div
      role="img"
      aria-label={alt}
      style={{
        width: "100%",
        height: "100%",
        borderRadius: 8,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        backgroundColor: tokens.palette.neutral[5] ?? "#94A3B8",
        color: tokens.palette.neutral[2] ?? "#334155",
        fontSize: 14,
        textAlign: "center",
        padding: 16,
        boxSizing: "border-box",
      }}
    >
      <span>{alt}</span>
    </div>
  );
});

/* -------------------------------- Utility ---------------------------------- */

function Placeholder({ text, tokens }: { text: string; tokens: Tokens }) {
  return (
    <div
      style={{
        width: "100%",
        height: "100%",
        minHeight: 200,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        backgroundColor: tokens.palette.neutral[6] ?? "#E2E8F0",
        borderRadius: 8,
        color: tokens.palette.neutral[3] ?? "#64748B",
        fontSize: 14,
        textAlign: "center",
        padding: 16,
        boxSizing: "border-box",
      }}
    >
      {text}
    </div>
  );
}



/* ------------------------------- Number fmt -------------------------------- */

function getNumberFormatter(format?: SlideSpecV1["content"]["dataViz"] extends infer T ? T extends { valueFormat?: infer F } ? F : never : never) {
  if (format === "percent") {
    return (n: number) => {
      // Accept either 0..1 or 0..100 inputs
      const v = Math.abs(n) <= 1 ? n * 100 : n;
      return `${roundSmart(v)}%`;
    };
  }
  if (format === "currency") {
    // Default to USD if unspecified by schema
    const nf = new Intl.NumberFormat(undefined, { style: "currency", currency: "USD", maximumFractionDigits: 0 });
    return (n: number) => nf.format(n);
  }
  if (format === "number") {
    return (n: number) => shortNumber(n);
  }
  // auto
  return (n: number) => shortNumber(n);
}

function shortNumber(n: number): string {
  const abs = Math.abs(n);
  if (abs >= 1_000_000_000) return `${roundSmart(n / 1_000_000_000)}B`;
  if (abs >= 1_000_000) return `${roundSmart(n / 1_000_000)}M`;
  if (abs >= 1_000) return `${roundSmart(n / 1_000)}k`;
  return `${roundSmart(n)}`;
}

function roundSmart(n: number): string {
  const v = Math.abs(n) < 10 ? Number(n.toFixed(2)) : Math.abs(n) < 100 ? Number(n.toFixed(1)) : Math.round(n);
  return `${v}`;
}

/* ------------------------------ Series colors ------------------------------ */

function paletteSeries(tokens: Tokens): string[] {
  const p = tokens.palette;
  const base = [p.primary, p.accent, p.neutral[2], p.neutral[3], p.neutral[4]];
  return base.map((c, i) => (i <= 1 ? c : hexWithAlpha(c, 0.85)));
}

================================================================================
FILE: ./web/src/components/SlideSkeleton.tsx
================================================================================

/**
 * Loading skeleton for slide preview
 * Shows a placeholder while slide is being generated
 */

export function SlideSkeleton() {
  return (
    <div className="w-full">
      <div
        className="relative w-full overflow-hidden rounded-2xl bg-gradient-to-br from-[var(--neutral-7)] to-[var(--neutral-6)] border border-white/10 animate-pulse"
        style={{ aspectRatio: "16 / 9" }}
        aria-label="Loading slide preview"
        aria-busy="true"
      >
        {/* Left accent bar */}
        <div
          className="absolute inset-y-0 left-0 w-1 bg-[var(--color-primary)]/30"
          aria-hidden="true"
        />

        {/* Header skeleton */}
        <div className="absolute top-12 left-8 right-8 space-y-3">
          <div className="h-12 bg-[var(--neutral-5)]/50 rounded-lg w-3/4" />
          <div className="h-6 bg-[var(--neutral-5)]/30 rounded-lg w-1/2" />
        </div>

        {/* Content skeleton */}
        <div className="absolute bottom-12 left-8 right-8 space-y-2">
          <div className="h-4 bg-[var(--neutral-5)]/40 rounded w-full" />
          <div className="h-4 bg-[var(--neutral-5)]/40 rounded w-5/6" />
          <div className="h-4 bg-[var(--neutral-5)]/40 rounded w-4/5" />
        </div>

        {/* Shimmer effect */}
        <div
          className="absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent animate-shimmer"
          aria-hidden="true"
        />
      </div>
    </div>
  );
}



================================================================================
FILE: ./web/src/hooks/useSlideExport.ts
================================================================================

import { useState, useCallback } from "react";
import { apiExport, apiExportPNG, apiExportPDF } from "@/lib/api";
import { logger } from "@/lib/logger";
import { handleError, retryWithBackoff } from "@/lib/errorHandler";
import {
  downloadBlob,
  generateFilename,
  validateExportBlob,
  type ExportFormat,
} from "@/lib/exportHandler";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export { type ExportFormat } from "@/lib/exportHandler";

export function useSlideExport() {
  const [exporting, setExporting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const exportSlide = useCallback(
    async (spec: SlideSpecV1, format: ExportFormat = "pptx", customFilename?: string) => {
      setError(null);
      setExporting(true);

      const startTime = performance.now();
      logger.userAction("export_slide", { format, filename: customFilename });

      try {
        let blob: Blob;

        if (format === "pptx") {
          blob = await retryWithBackoff(() => apiExport(spec), 2, 500);
        } else if (format === "png" || format === "pdf") {
          // For PNG/PDF, we need the DOM element
          const element = document.querySelector('[aria-label="Slide preview"]') as HTMLElement;
          if (!element) {
            throw new Error("Slide preview element not found");
          }

          if (format === "png") {
            blob = await retryWithBackoff(() => apiExportPNG(element), 2, 500);
          } else {
            blob = await retryWithBackoff(() => apiExportPDF(element), 2, 500);
          }
        } else {
          throw new Error(`Unsupported export format: ${format}`);
        }

        // Validate blob
        if (!validateExportBlob(blob, format)) {
          throw new Error(`Invalid ${format.toUpperCase()} export`);
        }

        const duration = performance.now() - startTime;
        const filename = generateFilename(format, customFilename);

        downloadBlob(blob, filename);

        logger.performance("slide_export", duration);
        logger.info("Slide exported successfully", {
          format,
          filename,
          size: blob.size,
          duration,
        });

        return true;
      } catch (e: unknown) {
        const duration = performance.now() - startTime;
        const appError = handleError(e, { format, duration });
        setError(appError.userMessage);
        logger.error("Failed to export slide", e, { format, duration });
        return false;
      } finally {
        setExporting(false);
      }
    },
    []
  );

  return {
    exporting,
    error,
    exportSlide,
  };
}



================================================================================
FILE: ./web/src/hooks/useSlideGeneration.ts
================================================================================

import { useState, useCallback } from "react";
import { apiGenerate } from "@/lib/api";
import { normalizeOrFallback } from "@/lib/validation";
import { logger } from "@/lib/logger";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export function useSlideGeneration() {
  const [loading, setLoading] = useState(false);
  const [spec, setSpec] = useState<SlideSpecV1 | null>(null);
  const [error, setError] = useState<string | null>(null);

  const generate = useCallback(async (prompt: string) => {
    if (!prompt.trim()) {
      setError("Please enter a prompt");
      logger.warn("Generate called with empty prompt");
      return null;
    }

    setError(null);
    setLoading(true);

    const startTime = performance.now();
    logger.userAction("generate_slide", { promptLength: prompt.length });

    try {
      const data = await apiGenerate(prompt);
      const normalized = normalizeOrFallback(data?.spec ?? data);
      setSpec(normalized);

      const duration = performance.now() - startTime;
      logger.performance("slide_generation", duration);
      logger.info("Slide generated successfully", { duration });

      return normalized;
    } catch (e: unknown) {
      const errorMessage = e instanceof Error ? e.message : "Failed to generate slide";
      setError(errorMessage);
      logger.error("Failed to generate slide", e, { prompt: prompt.slice(0, 50) });

      // Still set a fallback spec so user sees something
      const fallback = normalizeOrFallback(null);
      setSpec(fallback);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const reset = useCallback(() => {
    setSpec(null);
    setError(null);
    setLoading(false);
  }, []);

  return {
    loading,
    spec,
    error,
    generate,
    reset
  };
}



================================================================================
FILE: ./web/src/hooks/useSlideGenerationStream.ts
================================================================================

import { useState, useCallback, useRef, useEffect } from "react";
import { normalizeOrFallback } from "@/lib/validation";
import { logger } from "@/lib/logger";
import { parseSSEData } from "@/lib/sse";
import { baseUrl } from "@/lib/api";
import type { SlideSpecV1 } from "@/types/SlideSpecV1";

export interface StreamProgress {
  stage: "start" | "moderation" | "generation" | "enhancement" | "spec" | "complete" | "error";
  status?: string;
  message?: string;
  progress?: number; // 0-100
  durationMs?: number;
  error?: string;
  isFallback?: boolean;
}

export function useSlideGenerationStream() {
  const [loading, setLoading] = useState(false);
  const [spec, setSpec] = useState<SlideSpecV1 | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [progress, setProgress] = useState<StreamProgress | null>(null);
  const eventSourceRef = useRef<EventSource | null>(null);
  const abortControllerRef = useRef<AbortController | null>(null);
  const retryCountRef = useRef(0);
  const MAX_RETRIES = 3;

  const generateStream = useCallback(async (prompt: string) => {
    if (!prompt.trim()) {
      setError("Please enter a valid prompt");
      logger.warn("Generate called with empty prompt");
      return null;
    }

    setError(null);
    setLoading(true);
    setProgress({ stage: "start", status: "initializing", progress: 0 });

    const startTime = performance.now();
    logger.userAction("generate_slide_stream", { promptLength: prompt.length });

    const connect = () => {
      try {
        const url = `${baseUrl()}/generateSlideSpecStream`;
        abortControllerRef.current = new AbortController();

        const eventSource = new EventSource(`${url}?prompt=${encodeURIComponent(prompt)}`, {
          withCredentials: true,
        });

        eventSourceRef.current = eventSource;

        eventSource.onopen = () => {
          logger.info("SSE connection opened");
          retryCountRef.current = 0;
          setProgress({ stage: "start", status: "connected", progress: 10 });
        };

        eventSource.onmessage = (event) => {
          const data = parseSSEData<Record<string, unknown>>(event.data);
          if (!data) {
            logger.warn("Failed to parse SSE data", { event: event.data });
            return;
          }

          switch (event.type) { // Use event.type if custom events
            case "start":
              setProgress({ stage: "start", progress: 10, ...data });
              break;
            case "moderation":
              setProgress({ stage: "moderation", progress: 30, ...data });
              break;
            case "generation":
              setProgress({ stage: "generation", progress: 50, ...data });
              break;
            case "enhancement":
              setProgress({ stage: "enhancement", progress: 70, ...data });
              break;
            case "spec":
              const receivedSpec = normalizeOrFallback(data.spec as SlideSpecV1 | null);
              setSpec(receivedSpec);
              setProgress({ stage: "spec", progress: 90, isFallback: data.isFallback as boolean });
              break;
            case "complete":
              const duration = performance.now() - startTime;
              setProgress({ stage: "complete", progress: 100, durationMs: duration, ...data });
              logger.performance("slide_generation_stream", duration);
              eventSource.close();
              break;
            case "error":
              setError((data.error as string) || "Stream error occurred");
              setProgress({ stage: "error", progress: 0, error: data.error as string });
              eventSource.close();
              break;
            default:
              logger.warn("Unknown SSE event", { type: event.type, data });
          }
        };

        eventSource.onerror = (err) => {
          logger.error("SSE error", err);
          eventSource.close();
          if (retryCountRef.current < MAX_RETRIES) {
            retryCountRef.current++;
            const delay = 1000 * Math.pow(2, retryCountRef.current); // Exponential backoff
            logger.info(`Reconnecting in ${delay}ms (attempt ${retryCountRef.current})`);
            setTimeout(connect, delay);
          } else {
            setError("Failed to connect after retries");
            setLoading(false);
          }
        };

        return eventSource;
      } catch (e) {
        const errorMessage = e instanceof Error ? e.message : "Failed to generate slide";
        setError(errorMessage);
        logger.error("Failed to generate slide stream", e, { prompt: prompt.slice(0, 50) });
        setSpec(normalizeOrFallback(null));
        setProgress({ stage: "error", progress: 0, error: errorMessage });
        setLoading(false);
        return null;
      }
    };

    connect();

    return () => {
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
      }
    };
  }, []);

  useEffect(() => {
    return () => {
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  const cancel = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    setLoading(false);
    setProgress(null);
  }, []);

  const reset = useCallback(() => {
    cancel();
    setSpec(null);
    setError(null);
    setProgress(null);
    retryCountRef.current = 0;
  }, [cancel]);

  return {
    loading,
    spec,
    error,
    progress,
    generateStream,
    cancel,
    reset,
  };
}

================================================================================
FILE: ./web/src/main.tsx
================================================================================

import React from "react";
import ReactDOM from "react-dom/client";
import "@/styles/tailwind.css";
import App from "./App";
import { initAnalytics } from "./lib/firebase";
import { ErrorBoundary } from "./components/ErrorBoundary";
import { validateEnv } from "./lib/env";
import { logger } from "./lib/logger";
import { registerServiceWorker } from "./lib/registerSW";
import { initVersionCheck, APP_VERSION } from "./lib/versionCheck";

// Validate environment variables at startup
try {
  validateEnv();
  logger.info("Application starting...", { version: APP_VERSION });
} catch (error) {
  logger.error("Failed to validate environment", error);
  throw error;
}

initAnalytics();
registerServiceWorker();
initVersionCheck();

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </React.StrictMode>
);


================================================================================
FILE: ./web/src/styles/tailwind.css
================================================================================

@import "tailwindcss";

/* Modern Design System - Inspired by Apple, Google, Tesla, ChatGPT */
:root {
  /* Primary Colors - Vibrant gradient palette */
  --color-primary: #6366F1; /* Indigo */
  --color-primary-light: #818CF8;
  --color-primary-dark: #4F46E5;
  --color-accent: #EC4899; /* Pink accent */
  --color-success: #10B981;
  --color-warning: #F59E0B;
  --color-error: #EF4444;

  /* Neutral Palette - Refined grays */
  --neutral-0: #0F172A;   /* Darkest - text */
  --neutral-1: #1E293B;
  --neutral-2: #334155;
  --neutral-3: #475569;
  --neutral-4: #64748B;
  --neutral-5: #94A3B8;
  --neutral-6: #CBD5E1;
  --neutral-7: #E2E8F0;
  --neutral-8: #F1F5F9;
  --neutral-9: #F8FAFC;   /* Lightest - backgrounds */
  --neutral-white: #FFFFFF;

  /* Typography */
  --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  --font-display: "SF Pro Display", -apple-system, BlinkMacSystemFont, sans-serif;
  --step--2: 0.75rem;   /* 12px */
  --step--1: 0.875rem;  /* 14px */
  --step-0: 1rem;       /* 16px */
  --step-1: 1.125rem;   /* 18px */
  --step-2: 1.25rem;    /* 20px */
  --step-3: 1.5rem;     /* 24px */
  --step-4: 1.875rem;   /* 30px */
  --step-5: 2.25rem;    /* 36px */
  --step-6: 3rem;       /* 48px */
  --lh-tight: 1.2;
  --lh-normal: 1.5;
  --lh-relaxed: 1.75;

  /* Spacing Scale */
  --space-0: 0;
  --space-1: 0.25rem;   /* 4px */
  --space-2: 0.5rem;    /* 8px */
  --space-3: 0.75rem;   /* 12px */
  --space-4: 1rem;      /* 16px */
  --space-5: 1.5rem;    /* 24px */
  --space-6: 2rem;      /* 32px */
  --space-7: 2.5rem;    /* 40px */
  --space-8: 3rem;      /* 48px */
  --space-10: 4rem;     /* 64px */
  --space-12: 6rem;     /* 96px */

  /* Border Radius */
  --radius-sm: 0.375rem;   /* 6px */
  --radius-md: 0.5rem;     /* 8px */
  --radius-lg: 0.75rem;    /* 12px */
  --radius-xl: 1rem;       /* 16px */
  --radius-2xl: 1.5rem;    /* 24px */
  --radius-full: 9999px;

  /* Shadows - Elevated, modern */
  --shadow-xs: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-sm: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
  --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  --shadow-inner: inset 0 2px 4px 0 rgba(0, 0, 0, 0.05);

  /* Glassmorphism */
  --glass-bg: rgba(255, 255, 255, 0.7);
  --glass-border: rgba(255, 255, 255, 0.18);
  --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);

  /* Backgrounds */
  --bg-primary: #FFFFFF;
  --bg-secondary: #F8FAFC;
  --bg-tertiary: #F1F5F9;
  /* Subtle modern gradient - clean, professional, minimal */
  --bg-gradient-main: linear-gradient(135deg, #FFFFFF 0%, #F8FAFC 25%, #F3F4F6 50%, #FAFBFC 75%, #FFFFFF 100%);
  --bg-gradient-card: linear-gradient(to bottom, #FFFFFF 0%, #F9FAFB 100%);
}



/* Animations */
@keyframes slide-in {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

@keyframes fade-in {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes pulse-glow {
  0%, 100% {
    box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4);
  }
  50% {
    box-shadow: 0 0 0 8px rgba(99, 102, 241, 0);
  }
}

@keyframes shimmer {
  0% {
    background-position: -1000px 0;
  }
  100% {
    background-position: 1000px 0;
  }
}

.animate-slide-in {
  animation: slide-in 0.3s ease-out;
}

.animate-spin {
  animation: spin 1s linear infinite;
}

.animate-fade-in {
  animation: fade-in 0.4s ease-out;
}

.animate-scale-in {
  animation: scale-in 0.3s ease-out;
}

.animate-pulse-glow {
  animation: pulse-glow 2s ease-in-out infinite;
}

.animate-shimmer {
  animation: shimmer 2s linear infinite;
  background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
  background-size: 200% 100%;
}

/* Glassmorphism utility */
.glass {
  background: var(--glass-bg);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border: 1px solid var(--glass-border);
  box-shadow: var(--glass-shadow);
}

/* Screen reader only utility */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.focus\:not-sr-only:focus {
  position: static;
  width: auto;
  height: auto;
  padding: inherit;
  margin: inherit;
  overflow: visible;
  clip: auto;
  white-space: normal;
}

html, body, #root {
  height: 100%;
  margin: 0;
  padding: 0;
}

html {
  background: var(--bg-gradient-main);
  background-attachment: fixed;
}

body {
  font-family: var(--font-sans);
  color: var(--neutral-0);
  background: transparent;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Focus visible styles for better keyboard navigation */
*:focus-visible {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
  border-radius: var(--radius-sm);
}

/* Smooth transitions */
* {
  transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

/* Button utilities */
.btn-primary {
  position: relative;
  overflow: hidden;
  background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-light) 100%);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.btn-primary:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 12px 24px -8px rgba(99, 102, 241, 0.4);
}

.btn-primary:active:not(:disabled) {
  transform: translateY(0);
}

.btn-primary::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  transition: left 0.5s;
}

.btn-primary:hover:not(:disabled)::before {
  left: 100%;
}

.btn-secondary {
  position: relative;
  overflow: hidden;
  background: linear-gradient(135deg, var(--neutral-0) 0%, var(--neutral-1) 100%);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.btn-secondary:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 12px 24px -8px rgba(15, 23, 42, 0.3);
}

.btn-secondary:active:not(:disabled) {
  transform: translateY(0);
}

/* Mobile touch improvements */
@media (hover: none) and (pointer: coarse) {
  /* Larger touch targets on mobile */
  button, a, input, select, textarea {
    min-height: 44px;
  }

  /* Remove hover effects on touch devices */
  .btn-primary:hover:not(:disabled),
  .btn-secondary:hover:not(:disabled) {
    transform: none;
  }

  /* Add active state for touch feedback */
  .btn-primary:active:not(:disabled),
  .btn-secondary:active:not(:disabled) {
    transform: scale(0.98);
    opacity: 0.9;
  }
}

/* Prevent text selection on buttons */
button {
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  user-select: none;
}

/* Accessibility utilities */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:focus {
  position: static;
  width: auto;
  height: auto;
  padding: inherit;
  margin: inherit;
  overflow: visible;
  clip: auto;
  white-space: normal;
}

/* Skip to main content link */
.skip-link {
  position: absolute;
  top: -40px;
  left: 0;
  background: var(--color-primary);
  color: white;
  padding: 8px 16px;
  text-decoration: none;
  border-radius: 0 0 4px 0;
  z-index: 100;
}

.skip-link:focus {
  top: 0;
}

/* Focus visible styles */
*:focus-visible {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}



================================================================================
FILE: ./web/src/test/setup.ts
================================================================================

import { afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import '@testing-library/jest-dom';

// Cleanup after each test
afterEach(() => {
  cleanup();
});

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: (query: string) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: () => {}, // deprecated
    removeListener: () => {}, // deprecated
    addEventListener: () => {},
    removeEventListener: () => {},
    dispatchEvent: () => {},
  }),
});

// Mock IntersectionObserver
(globalThis as any).IntersectionObserver = class IntersectionObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  takeRecords() {
    return [];
  }
  unobserve() {}
} as any;

// Mock ResizeObserver
(globalThis as any).ResizeObserver = class ResizeObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
} as any;



================================================================================
FILE: ./web/src/types/SlideSpecV1.ts
================================================================================

/**
 * SlideSpec v1 — Re-exported from shared package
 * -------------------------------------------------------
 * This file re-exports types from the shared @plzfixthx/slide-spec package
 * to maintain backward compatibility with existing imports.
 */

export type {
  AspectRatio,
  RegionName,
  ChartKind,
  ChartValueFormat,
  DesignSpec,
  TitleAlign,
  ChartLegend,
  ImageFit,
  ImageRole,
  TypographyScale,
  StyleTokens,
  SlideSpecV1,
  SlideSpec,
} from "@plzfixthx/slide-spec";

export {
  DEFAULT_NEUTRAL_9,
  DEFAULT_TYPOGRAPHY,
  isHex6,
  normalizePalette,
} from "@plzfixthx/slide-spec";

================================================================================
FILE: ./web/tsconfig.app.json
================================================================================

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Path aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


================================================================================
FILE: ./web/tsconfig.json
================================================================================

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


================================================================================
FILE: ./web/tsconfig.node.json
================================================================================

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


================================================================================
FILE: ./web/vite.config.ts
================================================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  },
  build: {
    // Optimize chunk size and enable code-splitting
    rollupOptions: {
      output: {
        manualChunks: {
          // Separate vendor chunks for better caching
          'vendor-react': ['react', 'react-dom'],
          'vendor-recharts': ['recharts'],
          'vendor-export': ['html2canvas', 'jspdf'],
          'vendor-icons': ['lucide-react'],
        }
      }
    },
    // Increase chunk size warning limit since we're optimizing
    chunkSizeWarningLimit: 1000,
    // Enable minification with terser
    minify: 'terser'
  }
})


================================================================================
FILE: ./web/vitest.config.ts
================================================================================

import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/mockData',
        'dist/',
      ],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});



================================================================================
END OF CODE REVIEW BUNDLE
================================================================================
